<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ColrC: colr.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="colrc-pixels.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ColrC
   </div>
   <div id="projectbrief">An easy to use C library for linux terminal colors/escape-codes.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('colr_8c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">colr.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implements everything in the <a class="el" href="colr_8h.html" title="Declarations for ColrC functions, enums, structs, etc. ">colr.h</a> header.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="colr_8h_source.html">colr.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a10030070daafdee7124638adfc5469d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a10030070daafdee7124638adfc5469d8">colr_append_reset</a> (char *s)</td></tr>
<tr class="memdesc:a10030070daafdee7124638adfc5469d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends CODE_RESET_ALL to a string (<code>char*</code>), but makes sure to do it before any newlines.  <a href="#a10030070daafdee7124638adfc5469d8">More...</a><br /></td></tr>
<tr class="separator:a10030070daafdee7124638adfc5469d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1ea562310969b7efa8711a843f103c"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a7f1ea562310969b7efa8711a843f103c">colr_char_escape_char</a> (const char c)</td></tr>
<tr class="memdesc:a7f1ea562310969b7efa8711a843f103c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the char needed to represent an escape sequence in C.  <a href="#a7f1ea562310969b7efa8711a843f103c">More...</a><br /></td></tr>
<tr class="separator:a7f1ea562310969b7efa8711a843f103c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2bef208b24ea5962b8e1af154772c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a7c2bef208b24ea5962b8e1af154772c1">colr_char_in_str</a> (const char c, const char *s)</td></tr>
<tr class="memdesc:a7c2bef208b24ea5962b8e1af154772c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a character exists in the given string (<code>char*</code>).  <a href="#a7c2bef208b24ea5962b8e1af154772c1">More...</a><br /></td></tr>
<tr class="separator:a7c2bef208b24ea5962b8e1af154772c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4fed7123927027262875834964b0a94"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ab4fed7123927027262875834964b0a94">colr_char_is_code_end</a> (const char c)</td></tr>
<tr class="memdesc:ab4fed7123927027262875834964b0a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a character is suitable for an escape code ending.  <a href="#ab4fed7123927027262875834964b0a94">More...</a><br /></td></tr>
<tr class="separator:ab4fed7123927027262875834964b0a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78a98cb101d4d5f18df0023b3109013"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#af78a98cb101d4d5f18df0023b3109013">colr_char_repr</a> (char c)</td></tr>
<tr class="memdesc:af78a98cb101d4d5f18df0023b3109013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation for a char.  <a href="#af78a98cb101d4d5f18df0023b3109013">More...</a><br /></td></tr>
<tr class="separator:af78a98cb101d4d5f18df0023b3109013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ef4700a46e78c2bed1132428a610fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a67ef4700a46e78c2bed1132428a610fb">colr_char_should_escape</a> (const char c)</td></tr>
<tr class="memdesc:a67ef4700a46e78c2bed1132428a610fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if an ascii character has an escape sequence in C.  <a href="#a67ef4700a46e78c2bed1132428a610fb">More...</a><br /></td></tr>
<tr class="separator:a67ef4700a46e78c2bed1132428a610fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330b20c743df488e74e70e6b0daef62a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a330b20c743df488e74e70e6b0daef62a">colr_check_marker</a> (unsigned int marker, void *p)</td></tr>
<tr class="memdesc:a330b20c743df488e74e70e6b0daef62a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks an unsigned int against the individual bytes behind a pointer's value.  <a href="#a330b20c743df488e74e70e6b0daef62a">More...</a><br /></td></tr>
<tr class="separator:a330b20c743df488e74e70e6b0daef62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8963c87ccb1c39bdd4481bb81810ba78"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a8963c87ccb1c39bdd4481bb81810ba78">colr_empty_str</a> (void)</td></tr>
<tr class="memdesc:a8963c87ccb1c39bdd4481bb81810ba78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates an empty string (<code>char*</code>).  <a href="#a8963c87ccb1c39bdd4481bb81810ba78">More...</a><br /></td></tr>
<tr class="separator:a8963c87ccb1c39bdd4481bb81810ba78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32382336586dbda9a7e205403de8a14"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ad32382336586dbda9a7e205403de8a14">colr_str_center</a> (const char *s, const char padchar, int width)</td></tr>
<tr class="memdesc:ad32382336586dbda9a7e205403de8a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Center-justifies a string (<code>char*</code>), ignoring escape codes when measuring the width.  <a href="#ad32382336586dbda9a7e205403de8a14">More...</a><br /></td></tr>
<tr class="separator:ad32382336586dbda9a7e205403de8a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e3ecc4a6c4bcaad1217df9200d271e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ad5e3ecc4a6c4bcaad1217df9200d271e">colr_str_char_count</a> (const char *s, const char c)</td></tr>
<tr class="memdesc:ad5e3ecc4a6c4bcaad1217df9200d271e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of characters (<code>c</code>) that are found in a string (<code>char*</code>) (<code>s</code>).  <a href="#ad5e3ecc4a6c4bcaad1217df9200d271e">More...</a><br /></td></tr>
<tr class="separator:ad5e3ecc4a6c4bcaad1217df9200d271e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578b0f213d7b24b3f3c00ff4d3f6e292"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a578b0f213d7b24b3f3c00ff4d3f6e292">colr_str_copy</a> (char *dest, const char *src, size_t length)</td></tr>
<tr class="memdesc:a578b0f213d7b24b3f3c00ff4d3f6e292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like strncopy, but ensures null-termination.  <a href="#a578b0f213d7b24b3f3c00ff4d3f6e292">More...</a><br /></td></tr>
<tr class="separator:a578b0f213d7b24b3f3c00ff4d3f6e292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3339c4d3f1d48ac335b8525f8248020"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ad3339c4d3f1d48ac335b8525f8248020">colr_str_ends_with</a> (const char *str, const char *suf)</td></tr>
<tr class="memdesc:ad3339c4d3f1d48ac335b8525f8248020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if one string (<code>char*</code>) ends with another.  <a href="#ad3339c4d3f1d48ac335b8525f8248020">More...</a><br /></td></tr>
<tr class="separator:ad3339c4d3f1d48ac335b8525f8248020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9f4cbe1e806316e063206dfb610476"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a8b9f4cbe1e806316e063206dfb610476">colr_str_has_codes</a> (const char *s)</td></tr>
<tr class="memdesc:a8b9f4cbe1e806316e063206dfb610476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a string (<code>char*</code>) has ANSI escape codes in it.  <a href="#a8b9f4cbe1e806316e063206dfb610476">More...</a><br /></td></tr>
<tr class="separator:a8b9f4cbe1e806316e063206dfb610476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc3f370843b64e92fb7d79e7989b5c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a3dc3f370843b64e92fb7d79e7989b5c3">colr_str_is_all</a> (const char *s, const char c)</td></tr>
<tr class="memdesc:a3dc3f370843b64e92fb7d79e7989b5c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a string (<code>char*</code>) consists of only one character, possibly repeated.  <a href="#a3dc3f370843b64e92fb7d79e7989b5c3">More...</a><br /></td></tr>
<tr class="separator:a3dc3f370843b64e92fb7d79e7989b5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b2971301b5247769b08f5ed08564fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a85b2971301b5247769b08f5ed08564fb">colr_str_is_codes</a> (const char *s)</td></tr>
<tr class="memdesc:a85b2971301b5247769b08f5ed08564fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a string (<code>char*</code>) is composed entirely of escape codes.  <a href="#a85b2971301b5247769b08f5ed08564fb">More...</a><br /></td></tr>
<tr class="separator:a85b2971301b5247769b08f5ed08564fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5492da225ade4fd8fe71989826348b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#af5492da225ade4fd8fe71989826348b4">colr_str_is_digits</a> (const char *s)</td></tr>
<tr class="memdesc:af5492da225ade4fd8fe71989826348b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all characters in a string (<code>char*</code>) are digits.  <a href="#af5492da225ade4fd8fe71989826348b4">More...</a><br /></td></tr>
<tr class="separator:af5492da225ade4fd8fe71989826348b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116ec26960e79456dbf9cf7f40ffe0d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a116ec26960e79456dbf9cf7f40ffe0d7">colr_str_lower</a> (char *s)</td></tr>
<tr class="memdesc:a116ec26960e79456dbf9cf7f40ffe0d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string (<code>char*</code>) into lower case in place.  <a href="#a116ec26960e79456dbf9cf7f40ffe0d7">More...</a><br /></td></tr>
<tr class="separator:a116ec26960e79456dbf9cf7f40ffe0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8be0d81828f73816a447b7440987d91"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ac8be0d81828f73816a447b7440987d91">colr_str_ljust</a> (const char *s, const char padchar, int width)</td></tr>
<tr class="memdesc:ac8be0d81828f73816a447b7440987d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-justifies a string (<code>char*</code>), ignoring escape codes when measuring the width.  <a href="#ac8be0d81828f73816a447b7440987d91">More...</a><br /></td></tr>
<tr class="separator:ac8be0d81828f73816a447b7440987d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab00c551514ec181b50628b8cc80e5527"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ab00c551514ec181b50628b8cc80e5527">colr_str_lstrip_chars</a> (const char *s, const char *chars)</td></tr>
<tr class="memdesc:ab00c551514ec181b50628b8cc80e5527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes certain characters from the start of a string (<code>char*</code>).  <a href="#ab00c551514ec181b50628b8cc80e5527">More...</a><br /></td></tr>
<tr class="separator:ab00c551514ec181b50628b8cc80e5527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab473f70278850994e1b7b9c8008353fa"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ab473f70278850994e1b7b9c8008353fa">colr_str_mb_len</a> (const char *s)</td></tr>
<tr class="memdesc:ab473f70278850994e1b7b9c8008353fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of characters in a string (<code>char*</code>), taking into account possibly multi-byte characters.  <a href="#ab473f70278850994e1b7b9c8008353fa">More...</a><br /></td></tr>
<tr class="separator:ab473f70278850994e1b7b9c8008353fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037a0245a39d7ff5cfba5f779d0eb251"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a037a0245a39d7ff5cfba5f779d0eb251">colr_str_noncode_len</a> (const char *s)</td></tr>
<tr class="memdesc:a037a0245a39d7ff5cfba5f779d0eb251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of string (<code>char*</code>), ignoring escape codes and the the null-terminator.  <a href="#a037a0245a39d7ff5cfba5f779d0eb251">More...</a><br /></td></tr>
<tr class="separator:a037a0245a39d7ff5cfba5f779d0eb251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29047496628c944048314c83f9415a5b"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a29047496628c944048314c83f9415a5b">colr_str_replace</a> (char *s, const char *target, const char *repl)</td></tr>
<tr class="memdesc:a29047496628c944048314c83f9415a5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces substrings in a string (<code>char*</code>).  <a href="#a29047496628c944048314c83f9415a5b">More...</a><br /></td></tr>
<tr class="separator:a29047496628c944048314c83f9415a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d236bca80dbce495c0f282c3a7d192"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a44d236bca80dbce495c0f282c3a7d192">colr_str_replace_ColorArg</a> (char *s, const char *target, const <a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *repl)</td></tr>
<tr class="memdesc:a44d236bca80dbce495c0f282c3a7d192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace substrings in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string result.  <a href="#a44d236bca80dbce495c0f282c3a7d192">More...</a><br /></td></tr>
<tr class="separator:a44d236bca80dbce495c0f282c3a7d192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec6d96305890148b019602f2301f989"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a7ec6d96305890148b019602f2301f989">colr_str_replace_ColorText</a> (char *s, const char *target, const <a class="el" href="colr_8h.html#structColorText">ColorText</a> *repl)</td></tr>
<tr class="memdesc:a7ec6d96305890148b019602f2301f989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace substrings in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string result.  <a href="#a7ec6d96305890148b019602f2301f989">More...</a><br /></td></tr>
<tr class="separator:a7ec6d96305890148b019602f2301f989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196ad91a69cfbeb27a5266ffc93ed353"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a196ad91a69cfbeb27a5266ffc93ed353">colr_str_repr</a> (const char *s)</td></tr>
<tr class="memdesc:a196ad91a69cfbeb27a5266ffc93ed353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string (<code>char*</code>) into a representation of a string, by wrapping it in quotes and escaping characters that need escaping.  <a href="#a196ad91a69cfbeb27a5266ffc93ed353">More...</a><br /></td></tr>
<tr class="separator:a196ad91a69cfbeb27a5266ffc93ed353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fbaa15923af761c5eb99224ef8089b4"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a8fbaa15923af761c5eb99224ef8089b4">colr_str_rjust</a> (const char *s, const char padchar, int width)</td></tr>
<tr class="memdesc:a8fbaa15923af761c5eb99224ef8089b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right-justifies a string (<code>char*</code>), ignoring escape codes when measuring the width.  <a href="#a8fbaa15923af761c5eb99224ef8089b4">More...</a><br /></td></tr>
<tr class="separator:a8fbaa15923af761c5eb99224ef8089b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f001f49e15a8c38e0dc3c6c6c1bb06c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a7f001f49e15a8c38e0dc3c6c6c1bb06c">colr_str_starts_with</a> (const char *s, const char *prefix)</td></tr>
<tr class="memdesc:a7f001f49e15a8c38e0dc3c6c6c1bb06c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a string (<code>char*</code>) for a certain prefix substring.  <a href="#a7f001f49e15a8c38e0dc3c6c6c1bb06c">More...</a><br /></td></tr>
<tr class="separator:a7f001f49e15a8c38e0dc3c6c6c1bb06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b13b04dc178d0990ab2ae403ee64e0"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ab0b13b04dc178d0990ab2ae403ee64e0">colr_str_strip_codes</a> (const char *s)</td></tr>
<tr class="memdesc:ab0b13b04dc178d0990ab2ae403ee64e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strips escape codes from a string (<code>char*</code>), resulting in a new allocated string.  <a href="#ab0b13b04dc178d0990ab2ae403ee64e0">More...</a><br /></td></tr>
<tr class="separator:ab0b13b04dc178d0990ab2ae403ee64e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b847e10db135f7ebc89031b3a7ad56"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ae9b847e10db135f7ebc89031b3a7ad56">colr_str_to_lower</a> (const char *s)</td></tr>
<tr class="memdesc:ae9b847e10db135f7ebc89031b3a7ad56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new lowercase version of a string (<code>char*</code>).  <a href="#ae9b847e10db135f7ebc89031b3a7ad56">More...</a><br /></td></tr>
<tr class="separator:ae9b847e10db135f7ebc89031b3a7ad56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ebdcd3c6e598a244292c7605452e9d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ab2ebdcd3c6e598a244292c7605452e9d">colr_supports_rgb</a> (void)</td></tr>
<tr class="memdesc:ab2ebdcd3c6e598a244292c7605452e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the current environment support <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> (True Colors).  <a href="#ab2ebdcd3c6e598a244292c7605452e9d">More...</a><br /></td></tr>
<tr class="separator:ab2ebdcd3c6e598a244292c7605452e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c11bb5b3b1bb2848bb16aee39763b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structTermSize">TermSize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ae4c11bb5b3b1bb2848bb16aee39763b2">colr_term_size</a> (void)</td></tr>
<tr class="memdesc:ae4c11bb5b3b1bb2848bb16aee39763b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to retrieve the row/column size of the terminal and returns a <a class="el" href="colr_8h.html#structTermSize" title="Holds a terminal size, usually retrieved with colr_term_size(). ">TermSize</a>.  <a href="#ae4c11bb5b3b1bb2848bb16aee39763b2">More...</a><br /></td></tr>
<tr class="separator:ae4c11bb5b3b1bb2848bb16aee39763b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d7b7bf1080742eeb588ba70ce9ea77"><td class="memItemLeft" align="right" valign="top">struct winsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ae7d7b7bf1080742eeb588ba70ce9ea77">colr_win_size</a> (void)</td></tr>
<tr class="memdesc:ae7d7b7bf1080742eeb588ba70ce9ea77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to retrieve a <code>winsize</code> struct from an <code>ioctl</code> call.  <a href="#ae7d7b7bf1080742eeb588ba70ce9ea77">More...</a><br /></td></tr>
<tr class="separator:ae7d7b7bf1080742eeb588ba70ce9ea77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2c53ebede7f97645f671401bfe356d"><td class="memItemLeft" align="right" valign="top">struct winsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#afc2c53ebede7f97645f671401bfe356d">colr_win_size_env</a> (void)</td></tr>
<tr class="memdesc:afc2c53ebede7f97645f671401bfe356d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get window/terminal size using the environment variables <code>LINES</code>, <code>COLUMNS</code>, or <code>COLS</code>.  <a href="#afc2c53ebede7f97645f671401bfe356d">More...</a><br /></td></tr>
<tr class="separator:afc2c53ebede7f97645f671401bfe356d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29032483aea8cb25d6b90750767ffc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ae29032483aea8cb25d6b90750767ffc1">format_bg</a> (char *out, <a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> value)</td></tr>
<tr class="memdesc:ae29032483aea8cb25d6b90750767ffc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for a background color.  <a href="#ae29032483aea8cb25d6b90750767ffc1">More...</a><br /></td></tr>
<tr class="separator:ae29032483aea8cb25d6b90750767ffc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4853b53fa18d26741ab7178606e5724"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#aa4853b53fa18d26741ab7178606e5724">format_bgx</a> (char *out, unsigned char num)</td></tr>
<tr class="memdesc:aa4853b53fa18d26741ab7178606e5724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for an extended background color.  <a href="#aa4853b53fa18d26741ab7178606e5724">More...</a><br /></td></tr>
<tr class="separator:aa4853b53fa18d26741ab7178606e5724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539627d29410dee484a6cd59198c72ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a539627d29410dee484a6cd59198c72ea">format_bg_rgb</a> (char *out, unsigned char redval, unsigned char greenval, unsigned char blueval)</td></tr>
<tr class="memdesc:a539627d29410dee484a6cd59198c72ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for a true color (rgb) background color.  <a href="#a539627d29410dee484a6cd59198c72ea">More...</a><br /></td></tr>
<tr class="separator:a539627d29410dee484a6cd59198c72ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97257ad40619df6a6c190890ff2873c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a97257ad40619df6a6c190890ff2873c4">format_bg_RGB</a> (char *out, <a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:a97257ad40619df6a6c190890ff2873c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for a true color (rgb) background color using values from an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct.  <a href="#a97257ad40619df6a6c190890ff2873c4">More...</a><br /></td></tr>
<tr class="separator:a97257ad40619df6a6c190890ff2873c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185cec167afe41b6401206659d2d406c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a185cec167afe41b6401206659d2d406c">format_bg_RGB_term</a> (char *out, <a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:a185cec167afe41b6401206659d2d406c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for a true color (rgb) fore color using an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct's values, approximating 256-color values.  <a href="#a185cec167afe41b6401206659d2d406c">More...</a><br /></td></tr>
<tr class="separator:a185cec167afe41b6401206659d2d406c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6027d93e8768f3c152edafd92e757801"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a6027d93e8768f3c152edafd92e757801">format_fg</a> (char *out, <a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> value)</td></tr>
<tr class="memdesc:a6027d93e8768f3c152edafd92e757801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for a fore color.  <a href="#a6027d93e8768f3c152edafd92e757801">More...</a><br /></td></tr>
<tr class="separator:a6027d93e8768f3c152edafd92e757801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd2cf68768c59fc3ed5c31b93590c53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#acfd2cf68768c59fc3ed5c31b93590c53">format_fgx</a> (char *out, unsigned char num)</td></tr>
<tr class="memdesc:acfd2cf68768c59fc3ed5c31b93590c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for an extended fore color.  <a href="#acfd2cf68768c59fc3ed5c31b93590c53">More...</a><br /></td></tr>
<tr class="separator:acfd2cf68768c59fc3ed5c31b93590c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63496434a5fc178504034514dc1e285c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a63496434a5fc178504034514dc1e285c">format_fg_rgb</a> (char *out, unsigned char redval, unsigned char greenval, unsigned char blueval)</td></tr>
<tr class="memdesc:a63496434a5fc178504034514dc1e285c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for a true color (rgb) fore color.  <a href="#a63496434a5fc178504034514dc1e285c">More...</a><br /></td></tr>
<tr class="separator:a63496434a5fc178504034514dc1e285c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3391a0cd6b6f73d9d39f8179fc0eb0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#aa3391a0cd6b6f73d9d39f8179fc0eb0b">format_fg_RGB</a> (char *out, <a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:aa3391a0cd6b6f73d9d39f8179fc0eb0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for a true color (rgb) fore color using an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct's values.  <a href="#aa3391a0cd6b6f73d9d39f8179fc0eb0b">More...</a><br /></td></tr>
<tr class="separator:aa3391a0cd6b6f73d9d39f8179fc0eb0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4661c576a4da879b8d4a2c525a42ad78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a4661c576a4da879b8d4a2c525a42ad78">format_fg_RGB_term</a> (char *out, <a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:a4661c576a4da879b8d4a2c525a42ad78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for a true color (rgb) fore color using an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct's values, approximating 256-color values.  <a href="#a4661c576a4da879b8d4a2c525a42ad78">More...</a><br /></td></tr>
<tr class="separator:a4661c576a4da879b8d4a2c525a42ad78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aec8e6a80b4ca158df2ad20e3e6a59e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a6aec8e6a80b4ca158df2ad20e3e6a59e">format_style</a> (char *out, <a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a> <a class="el" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662">style</a>)</td></tr>
<tr class="memdesc:a6aec8e6a80b4ca158df2ad20e3e6a59e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for a style.  <a href="#a6aec8e6a80b4ca158df2ad20e3e6a59e">More...</a><br /></td></tr>
<tr class="separator:a6aec8e6a80b4ca158df2ad20e3e6a59e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25670add558019fdb66a60d51f0ffbda"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a25670add558019fdb66a60d51f0ffbda">_colr</a> (void *p,...)</td></tr>
<tr class="memdesc:a25670add558019fdb66a60d51f0ffbda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joins ColorArgs, ColorTexts, and strings (<code>char*</code>) into one long string.  <a href="#a25670add558019fdb66a60d51f0ffbda">More...</a><br /></td></tr>
<tr class="separator:a25670add558019fdb66a60d51f0ffbda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64af11f4992c8143cb722772df98c98"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#af64af11f4992c8143cb722772df98c98">_colr_is_last_arg</a> (void *p)</td></tr>
<tr class="memdesc:af64af11f4992c8143cb722772df98c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a void pointer is _ColrLastArg (the last-arg-marker).  <a href="#af64af11f4992c8143cb722772df98c98">More...</a><br /></td></tr>
<tr class="separator:af64af11f4992c8143cb722772df98c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70e1c4f6da5a46e6fcf838aed07885b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ad70e1c4f6da5a46e6fcf838aed07885b">_colr_size</a> (void *p, va_list args)</td></tr>
<tr class="memdesc:ad70e1c4f6da5a46e6fcf838aed07885b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse arguments, just as in <a class="el" href="colr_8c.html#a25670add558019fdb66a60d51f0ffbda" title="Joins ColorArgs, ColorTexts, and strings (char*) into one long string. ">_colr()</a>, but only return the length needed to allocate the resulting string.  <a href="#ad70e1c4f6da5a46e6fcf838aed07885b">More...</a><br /></td></tr>
<tr class="separator:ad70e1c4f6da5a46e6fcf838aed07885b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4227a65824fdd699a25d3200706c9e9e"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join</a> (void *joinerp,...)</td></tr>
<tr class="memdesc:a4227a65824fdd699a25d3200706c9e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joins ColorArgs, ColorTexts, and strings (<code>char*</code>) into one long string separated by it's first argument.  <a href="#a4227a65824fdd699a25d3200706c9e9e">More...</a><br /></td></tr>
<tr class="separator:a4227a65824fdd699a25d3200706c9e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a051ef4cd2e7200a31f9de48766b4c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a91a051ef4cd2e7200a31f9de48766b4c">_colr_join_size</a> (void *joinerp, va_list args)</td></tr>
<tr class="memdesc:a91a051ef4cd2e7200a31f9de48766b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse arguments, just as in <a class="el" href="colr_8c.html#a4227a65824fdd699a25d3200706c9e9e" title="Joins ColorArgs, ColorTexts, and strings (char*) into one long string separated by it&#39;s first argumen...">_colr_join()</a>, but only return the size needed to allocate the resulting string.  <a href="#a91a051ef4cd2e7200a31f9de48766b4c">More...</a><br /></td></tr>
<tr class="separator:a91a051ef4cd2e7200a31f9de48766b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701126bd27c90fafa46152d9f9327b2f"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a701126bd27c90fafa46152d9f9327b2f">colr_join_array</a> (void *joinerp, void *ps)</td></tr>
<tr class="memdesc:a701126bd27c90fafa46152d9f9327b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join an array of strings (<code>char*</code>), ColorArgs, or ColorTexts by another string (<code>char*</code>), <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.  <a href="#a701126bd27c90fafa46152d9f9327b2f">More...</a><br /></td></tr>
<tr class="separator:a701126bd27c90fafa46152d9f9327b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71fcf08ad36d4424790e275d973445fc"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a71fcf08ad36d4424790e275d973445fc">colr_join_arrayn</a> (void *joinerp, void *ps, size_t count)</td></tr>
<tr class="memdesc:a71fcf08ad36d4424790e275d973445fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join an array of strings (<code>char*</code>), ColorArgs, or ColorTexts by another string (<code>char*</code>), <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.  <a href="#a71fcf08ad36d4424790e275d973445fc">More...</a><br /></td></tr>
<tr class="separator:a71fcf08ad36d4424790e275d973445fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49c3a33d328ebaf2b0564d5a9b1d4ec"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ac49c3a33d328ebaf2b0564d5a9b1d4ec">_colr_join_arrayn_size</a> (void *joinerp, void *ps, size_t count)</td></tr>
<tr class="memdesc:ac49c3a33d328ebaf2b0564d5a9b1d4ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size in bytes needed to join an array of strings (<code>char*</code>), ColorArgs, or ColorTexts by another string (<code>char*</code>), <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.  <a href="#ac49c3a33d328ebaf2b0564d5a9b1d4ec">More...</a><br /></td></tr>
<tr class="separator:ac49c3a33d328ebaf2b0564d5a9b1d4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d47ac6ee2a59e1c976cf2838545aa25"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a6d47ac6ee2a59e1c976cf2838545aa25">_colr_join_array_length</a> (void *ps)</td></tr>
<tr class="memdesc:a6d47ac6ee2a59e1c976cf2838545aa25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the length of a <code>NULL</code>-terminated array of strings (<code>char*</code>), ColorArgs, or ColorTexts.  <a href="#a6d47ac6ee2a59e1c976cf2838545aa25">More...</a><br /></td></tr>
<tr class="separator:a6d47ac6ee2a59e1c976cf2838545aa25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0be451277fc7e39aee0aa409c9d3f0c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ab0be451277fc7e39aee0aa409c9d3f0c">_colr_ptr_length</a> (void *p)</td></tr>
<tr class="memdesc:ab0be451277fc7e39aee0aa409c9d3f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size, in bytes, needed to convert a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, or string (<code>char*</code>) into a string.  <a href="#ab0be451277fc7e39aee0aa409c9d3f0c">More...</a><br /></td></tr>
<tr class="separator:ab0be451277fc7e39aee0aa409c9d3f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01ccaf04c71fc2474da94b050236572"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ad01ccaf04c71fc2474da94b050236572">ArgType_repr</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type)</td></tr>
<tr class="memdesc:ad01ccaf04c71fc2474da94b050236572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation of a ArgType.  <a href="#ad01ccaf04c71fc2474da94b050236572">More...</a><br /></td></tr>
<tr class="separator:ad01ccaf04c71fc2474da94b050236572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b270bebb1a01212b7e44e52f61f94be"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a2b270bebb1a01212b7e44e52f61f94be">ArgType_to_str</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type)</td></tr>
<tr class="memdesc:a2b270bebb1a01212b7e44e52f61f94be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) from an ArgType.  <a href="#a2b270bebb1a01212b7e44e52f61f94be">More...</a><br /></td></tr>
<tr class="separator:a2b270bebb1a01212b7e44e52f61f94be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af838f8479681d809beb868b2e1b547e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#af838f8479681d809beb868b2e1b547e7">ColorArg_empty</a> (void)</td></tr>
<tr class="memdesc:af838f8479681d809beb868b2e1b547e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> with ARGTYPE_NONE and ColorValue.type.TYPE_NONE.  <a href="#af838f8479681d809beb868b2e1b547e7">More...</a><br /></td></tr>
<tr class="separator:af838f8479681d809beb868b2e1b547e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb62efc0182d6f6107055eeda961a628"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#acb62efc0182d6f6107055eeda961a628">ColorArg_eq</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> a, <a class="el" href="colr_8h.html#structColorArg">ColorArg</a> b)</td></tr>
<tr class="memdesc:acb62efc0182d6f6107055eeda961a628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> structs.  <a href="#acb62efc0182d6f6107055eeda961a628">More...</a><br /></td></tr>
<tr class="separator:acb62efc0182d6f6107055eeda961a628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1163a9c866767fb7fcb734d3c0d9b7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#aa1163a9c866767fb7fcb734d3c0d9b7c">ColorArg_free</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *p)</td></tr>
<tr class="memdesc:aa1163a9c866767fb7fcb734d3c0d9b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free allocated memory for a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>.  <a href="#aa1163a9c866767fb7fcb734d3c0d9b7c">More...</a><br /></td></tr>
<tr class="separator:aa1163a9c866767fb7fcb734d3c0d9b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad49f4597388e6bdb896ff28334cd5e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#aad49f4597388e6bdb896ff28334cd5e6">ColorArg_from_BasicValue</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type, <a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> value)</td></tr>
<tr class="memdesc:aad49f4597388e6bdb896ff28334cd5e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit version of ColorArg_from_value that only handles BasicValues.  <a href="#aad49f4597388e6bdb896ff28334cd5e6">More...</a><br /></td></tr>
<tr class="separator:aad49f4597388e6bdb896ff28334cd5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed30e2a4b30ab5e3cf49608a3c410cc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#aed30e2a4b30ab5e3cf49608a3c410cc5">ColorArg_from_ExtendedValue</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type, <a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a> value)</td></tr>
<tr class="memdesc:aed30e2a4b30ab5e3cf49608a3c410cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit version of ColorArg_from_value that only handles ExtendedValues.  <a href="#aed30e2a4b30ab5e3cf49608a3c410cc5">More...</a><br /></td></tr>
<tr class="separator:aed30e2a4b30ab5e3cf49608a3c410cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa24bba74e99aa66ed41839576e57856"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#aaa24bba74e99aa66ed41839576e57856">ColorArg_from_RGB</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type, <a class="el" href="colr_8h.html#structRGB">RGB</a> value)</td></tr>
<tr class="memdesc:aaa24bba74e99aa66ed41839576e57856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit version of ColorArg_from_value that only handles <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> structs.  <a href="#aaa24bba74e99aa66ed41839576e57856">More...</a><br /></td></tr>
<tr class="separator:aaa24bba74e99aa66ed41839576e57856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d897499fca87d7902159f4ed7dbba3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ae8d897499fca87d7902159f4ed7dbba3">ColorArg_from_str</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type, char *colorname)</td></tr>
<tr class="memdesc:ae8d897499fca87d7902159f4ed7dbba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> (fore, back, or style value) from a known color name/style.  <a href="#ae8d897499fca87d7902159f4ed7dbba3">More...</a><br /></td></tr>
<tr class="separator:ae8d897499fca87d7902159f4ed7dbba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf63bcee395dca3ca29dc324e3d7c8f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#acf63bcee395dca3ca29dc324e3d7c8f2">ColorArg_from_StyleValue</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type, <a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a> value)</td></tr>
<tr class="memdesc:acf63bcee395dca3ca29dc324e3d7c8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit version of ColorArg_from_value that only handles StyleValues.  <a href="#acf63bcee395dca3ca29dc324e3d7c8f2">More...</a><br /></td></tr>
<tr class="separator:acf63bcee395dca3ca29dc324e3d7c8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a5aa762bd5802872faf571aa32ea35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a89a5aa762bd5802872faf571aa32ea35">ColorArg_from_value</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type, <a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> colrtype, void *p)</td></tr>
<tr class="memdesc:a89a5aa762bd5802872faf571aa32ea35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used with the color_arg macro to dynamically create a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> based on it's argument type.  <a href="#a89a5aa762bd5802872faf571aa32ea35">More...</a><br /></td></tr>
<tr class="separator:a89a5aa762bd5802872faf571aa32ea35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752355c2d96d35688d3756558f8421ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a752355c2d96d35688d3756558f8421ba">ColorArg_is_empty</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> carg)</td></tr>
<tr class="memdesc:a752355c2d96d35688d3756558f8421ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> is an empty placeholder.  <a href="#a752355c2d96d35688d3756558f8421ba">More...</a><br /></td></tr>
<tr class="separator:a752355c2d96d35688d3756558f8421ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b4906cfb08588005536db1250dc899"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a66b4906cfb08588005536db1250dc899">ColorArg_is_invalid</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> carg)</td></tr>
<tr class="memdesc:a66b4906cfb08588005536db1250dc899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> holds an invalid value.  <a href="#a66b4906cfb08588005536db1250dc899">More...</a><br /></td></tr>
<tr class="separator:a66b4906cfb08588005536db1250dc899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15f3a714a6383123d3fb24ade173e29"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ad15f3a714a6383123d3fb24ade173e29">ColorArg_is_ptr</a> (void *p)</td></tr>
<tr class="memdesc:ad15f3a714a6383123d3fb24ade173e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a void pointer to see if it contains a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct.  <a href="#ad15f3a714a6383123d3fb24ade173e29">More...</a><br /></td></tr>
<tr class="separator:ad15f3a714a6383123d3fb24ade173e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e446f65d6987d52522a1755c909d421"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a1e446f65d6987d52522a1755c909d421">ColorArg_is_valid</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> carg)</td></tr>
<tr class="memdesc:a1e446f65d6987d52522a1755c909d421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> holds a valid value.  <a href="#a1e446f65d6987d52522a1755c909d421">More...</a><br /></td></tr>
<tr class="separator:a1e446f65d6987d52522a1755c909d421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaff727006f4c057aab75e55bfb473c4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#adaff727006f4c057aab75e55bfb473c4">ColorArg_length</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> carg)</td></tr>
<tr class="memdesc:adaff727006f4c057aab75e55bfb473c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length in bytes needed to allocate a string (<code>char*</code>) built with <a class="el" href="colr_8c.html#a91fb398f6463553e576fc067f5a0a854" title="Converts a ColorArg into an escape code string (char*). ">ColorArg_to_str()</a>.  <a href="#adaff727006f4c057aab75e55bfb473c4">More...</a><br /></td></tr>
<tr class="separator:adaff727006f4c057aab75e55bfb473c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af692f2357d46b9cee45bb114f2a4a2"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a5af692f2357d46b9cee45bb114f2a4a2">ColorArg_repr</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> carg)</td></tr>
<tr class="memdesc:a5af692f2357d46b9cee45bb114f2a4a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation for a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>.  <a href="#a5af692f2357d46b9cee45bb114f2a4a2">More...</a><br /></td></tr>
<tr class="separator:a5af692f2357d46b9cee45bb114f2a4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5ac0bd012b8162cea125ad0d9e8bf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#afb5ac0bd012b8162cea125ad0d9e8bf0">ColorArg_to_ptr</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> carg)</td></tr>
<tr class="memdesc:afb5ac0bd012b8162cea125ad0d9e8bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> into memory and returns the pointer.  <a href="#afb5ac0bd012b8162cea125ad0d9e8bf0">More...</a><br /></td></tr>
<tr class="separator:afb5ac0bd012b8162cea125ad0d9e8bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91fb398f6463553e576fc067f5a0a854"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a91fb398f6463553e576fc067f5a0a854">ColorArg_to_str</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> carg)</td></tr>
<tr class="memdesc:a91fb398f6463553e576fc067f5a0a854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> into an escape code string (<code>char*</code>).  <a href="#a91fb398f6463553e576fc067f5a0a854">More...</a><br /></td></tr>
<tr class="separator:a91fb398f6463553e576fc067f5a0a854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11e9457ca4e8f5be0e29351b49b6844"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ae11e9457ca4e8f5be0e29351b49b6844">ColorJustify_empty</a> (void)</td></tr>
<tr class="memdesc:ae11e9457ca4e8f5be0e29351b49b6844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an "empty" <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a>, with JUST_NONE set.  <a href="#ae11e9457ca4e8f5be0e29351b49b6844">More...</a><br /></td></tr>
<tr class="separator:ae11e9457ca4e8f5be0e29351b49b6844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71656e616aef4bbb3c278d43c4a326e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ab71656e616aef4bbb3c278d43c4a326e">ColorJustify_eq</a> (<a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a> a, <a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a> b)</td></tr>
<tr class="memdesc:ab71656e616aef4bbb3c278d43c4a326e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> structs.  <a href="#ab71656e616aef4bbb3c278d43c4a326e">More...</a><br /></td></tr>
<tr class="separator:ab71656e616aef4bbb3c278d43c4a326e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f193b6e6a20c63caecc1d9b53c89fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a34f193b6e6a20c63caecc1d9b53c89fb">ColorJustify_is_empty</a> (<a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a> cjust)</td></tr>
<tr class="memdesc:a34f193b6e6a20c63caecc1d9b53c89fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> is "empty".  <a href="#a34f193b6e6a20c63caecc1d9b53c89fb">More...</a><br /></td></tr>
<tr class="separator:a34f193b6e6a20c63caecc1d9b53c89fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4a7a21151993343ef96a068c6d5018"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a7d4a7a21151993343ef96a068c6d5018">ColorJustify_new</a> (<a class="el" href="colr_8h.html#af1a3fe0b966f944fd659a98be170045f">ColorJustifyMethod</a> method, int width, char padchar)</td></tr>
<tr class="memdesc:a7d4a7a21151993343ef96a068c6d5018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a>.  <a href="#a7d4a7a21151993343ef96a068c6d5018">More...</a><br /></td></tr>
<tr class="separator:a7d4a7a21151993343ef96a068c6d5018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c35f6b47cc737744487d14d20241656"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a6c35f6b47cc737744487d14d20241656">ColorJustify_repr</a> (<a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a> cjust)</td></tr>
<tr class="memdesc:a6c35f6b47cc737744487d14d20241656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation for a <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a>.  <a href="#a6c35f6b47cc737744487d14d20241656">More...</a><br /></td></tr>
<tr class="separator:a6c35f6b47cc737744487d14d20241656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf78eeb364553d130055d93e9892cd9c"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#adf78eeb364553d130055d93e9892cd9c">ColorJustifyMethod_repr</a> (<a class="el" href="colr_8h.html#af1a3fe0b966f944fd659a98be170045f">ColorJustifyMethod</a> meth)</td></tr>
<tr class="memdesc:adf78eeb364553d130055d93e9892cd9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation for a ColorJustifyMethod.  <a href="#adf78eeb364553d130055d93e9892cd9c">More...</a><br /></td></tr>
<tr class="separator:adf78eeb364553d130055d93e9892cd9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341b4033c31c58e412ff15280185c6bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorText">ColorText</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a341b4033c31c58e412ff15280185c6bd">ColorText_empty</a> (void)</td></tr>
<tr class="memdesc:a341b4033c31c58e412ff15280185c6bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an "empty" <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> with pointers set to <code>NULL</code>.  <a href="#a341b4033c31c58e412ff15280185c6bd">More...</a><br /></td></tr>
<tr class="separator:a341b4033c31c58e412ff15280185c6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901e5738358a739629cc3aaccab3e73f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a901e5738358a739629cc3aaccab3e73f">ColorText_free</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> *p)</td></tr>
<tr class="memdesc:a901e5738358a739629cc3aaccab3e73f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> and it's ColorArgs.  <a href="#a901e5738358a739629cc3aaccab3e73f">More...</a><br /></td></tr>
<tr class="separator:a901e5738358a739629cc3aaccab3e73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4702d6ddc409a93a0b42c8f6141d2f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorText">ColorText</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ad4702d6ddc409a93a0b42c8f6141d2f2">ColorText_from_values</a> (char *text,...)</td></tr>
<tr class="memdesc:ad4702d6ddc409a93a0b42c8f6141d2f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> from 1 mandatory string (<code>char*</code>), and optional fore, back, and style args (pointers to ColorArgs).  <a href="#ad4702d6ddc409a93a0b42c8f6141d2f2">More...</a><br /></td></tr>
<tr class="separator:ad4702d6ddc409a93a0b42c8f6141d2f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f65430500d003575c547eb667330b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a93f65430500d003575c547eb667330b0">ColorText_has_arg</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> ctext, <a class="el" href="colr_8h.html#structColorArg">ColorArg</a> carg)</td></tr>
<tr class="memdesc:a93f65430500d003575c547eb667330b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> has a certain <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> value set.  <a href="#a93f65430500d003575c547eb667330b0">More...</a><br /></td></tr>
<tr class="separator:a93f65430500d003575c547eb667330b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b38987063bb127bb34761961d7f678"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a93b38987063bb127bb34761961d7f678">ColorText_has_args</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> ctext)</td></tr>
<tr class="memdesc:a93b38987063bb127bb34761961d7f678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> has any argument values set.  <a href="#a93b38987063bb127bb34761961d7f678">More...</a><br /></td></tr>
<tr class="separator:a93b38987063bb127bb34761961d7f678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac846e583415e832b9090270020320b9f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ac846e583415e832b9090270020320b9f">ColorText_is_empty</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> ctext)</td></tr>
<tr class="memdesc:ac846e583415e832b9090270020320b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> has no usable values.  <a href="#ac846e583415e832b9090270020320b9f">More...</a><br /></td></tr>
<tr class="separator:ac846e583415e832b9090270020320b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6eb8832110b943c3a3a17627a50288"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a1d6eb8832110b943c3a3a17627a50288">ColorText_is_ptr</a> (void *p)</td></tr>
<tr class="memdesc:a1d6eb8832110b943c3a3a17627a50288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a void pointer to see if it contains a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> struct.  <a href="#a1d6eb8832110b943c3a3a17627a50288">More...</a><br /></td></tr>
<tr class="separator:a1d6eb8832110b943c3a3a17627a50288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412833a097b050c8ee99874c733bd030"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a412833a097b050c8ee99874c733bd030">ColorText_length</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> ctext)</td></tr>
<tr class="memdesc:a412833a097b050c8ee99874c733bd030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length in bytes needed to allocate a string (<code>char*</code>) built with <a class="el" href="colr_8c.html#ae305b33e0a44b956ccf4123aa4f1a033" title="Stringifies a ColorText struct, creating a mix of escape codes and text. ">ColorText_to_str()</a> with the current <code>text</code>, <code>fore</code>, <code>back</code>, and <code>style</code> members.  <a href="#a412833a097b050c8ee99874c733bd030">More...</a><br /></td></tr>
<tr class="separator:a412833a097b050c8ee99874c733bd030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65363a3601cd9cfcdc7fc40722d5d3c3"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a65363a3601cd9cfcdc7fc40722d5d3c3">ColorText_repr</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> ctext)</td></tr>
<tr class="memdesc:a65363a3601cd9cfcdc7fc40722d5d3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a string (<code>char*</code>) representation for a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.  <a href="#a65363a3601cd9cfcdc7fc40722d5d3c3">More...</a><br /></td></tr>
<tr class="separator:a65363a3601cd9cfcdc7fc40722d5d3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab408d87cce896acccb75357acca8ade4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ab408d87cce896acccb75357acca8ade4">ColorText_set_just</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> *ctext, <a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a> cjust)</td></tr>
<tr class="memdesc:ab408d87cce896acccb75357acca8ade4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> method for a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, and return the <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.  <a href="#ab408d87cce896acccb75357acca8ade4">More...</a><br /></td></tr>
<tr class="separator:ab408d87cce896acccb75357acca8ade4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880b39cd2ce9b622dbe7790a162d88f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a880b39cd2ce9b622dbe7790a162d88f7">ColorText_set_values</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> *ctext, char *text,...)</td></tr>
<tr class="memdesc:a880b39cd2ce9b622dbe7790a162d88f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an existing <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> from 1 mandatory string (<code>char*</code>), and optional fore, back, and style args (pointers to ColorArgs).  <a href="#a880b39cd2ce9b622dbe7790a162d88f7">More...</a><br /></td></tr>
<tr class="separator:a880b39cd2ce9b622dbe7790a162d88f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e04de932a4cf712ac91e794bdc3f8db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a8e04de932a4cf712ac91e794bdc3f8db">ColorText_to_ptr</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> ctext)</td></tr>
<tr class="memdesc:a8e04de932a4cf712ac91e794bdc3f8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> into allocated memory and returns the pointer.  <a href="#a8e04de932a4cf712ac91e794bdc3f8db">More...</a><br /></td></tr>
<tr class="separator:a8e04de932a4cf712ac91e794bdc3f8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae305b33e0a44b956ccf4123aa4f1a033"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ae305b33e0a44b956ccf4123aa4f1a033">ColorText_to_str</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> ctext)</td></tr>
<tr class="memdesc:ae305b33e0a44b956ccf4123aa4f1a033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stringifies a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> struct, creating a mix of escape codes and text.  <a href="#ae305b33e0a44b956ccf4123aa4f1a033">More...</a><br /></td></tr>
<tr class="separator:ae305b33e0a44b956ccf4123aa4f1a033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e3483ae4add048424177fdc2b97b71"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a29e3483ae4add048424177fdc2b97b71">ColorType_eq</a> (<a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> a, <a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> b)</td></tr>
<tr class="memdesc:a29e3483ae4add048424177fdc2b97b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ColorTypes.  <a href="#a29e3483ae4add048424177fdc2b97b71">More...</a><br /></td></tr>
<tr class="separator:a29e3483ae4add048424177fdc2b97b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa75deef059c002134a88dbbdc18fd49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#afa75deef059c002134a88dbbdc18fd49">ColorType_from_str</a> (const char *arg)</td></tr>
<tr class="memdesc:afa75deef059c002134a88dbbdc18fd49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine which type of color value is desired by name.  <a href="#afa75deef059c002134a88dbbdc18fd49">More...</a><br /></td></tr>
<tr class="separator:afa75deef059c002134a88dbbdc18fd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc223f6fda6296396e9ecddcc68d4aec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#adc223f6fda6296396e9ecddcc68d4aec">ColorType_is_invalid</a> (<a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> type)</td></tr>
<tr class="memdesc:adc223f6fda6296396e9ecddcc68d4aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if a ColorType value is considered invalid.  <a href="#adc223f6fda6296396e9ecddcc68d4aec">More...</a><br /></td></tr>
<tr class="separator:adc223f6fda6296396e9ecddcc68d4aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5883d43e3206584ad048908720afb2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a5a5883d43e3206584ad048908720afb2">ColorType_is_valid</a> (<a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> type)</td></tr>
<tr class="memdesc:a5a5883d43e3206584ad048908720afb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if a ColorType value is considered valid.  <a href="#a5a5883d43e3206584ad048908720afb2">More...</a><br /></td></tr>
<tr class="separator:a5a5883d43e3206584ad048908720afb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a291ca6d28f9f430794413b76b7b094ed"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a291ca6d28f9f430794413b76b7b094ed">ColorType_repr</a> (<a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> type)</td></tr>
<tr class="memdesc:a291ca6d28f9f430794413b76b7b094ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation of a ColorType.  <a href="#a291ca6d28f9f430794413b76b7b094ed">More...</a><br /></td></tr>
<tr class="separator:a291ca6d28f9f430794413b76b7b094ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce7c54ad0e31ecf6d790c5770c2b66b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a5ce7c54ad0e31ecf6d790c5770c2b66b">ColorValue_empty</a> (void)</td></tr>
<tr class="memdesc:a5ce7c54ad0e31ecf6d790c5770c2b66b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an "empty" <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>.  <a href="#a5ce7c54ad0e31ecf6d790c5770c2b66b">More...</a><br /></td></tr>
<tr class="separator:a5ce7c54ad0e31ecf6d790c5770c2b66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf57e195301864cec80739e7e0f3000c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#adf57e195301864cec80739e7e0f3000c">ColorValue_eq</a> (<a class="el" href="colr_8h.html#structColorValue">ColorValue</a> a, <a class="el" href="colr_8h.html#structColorValue">ColorValue</a> b)</td></tr>
<tr class="memdesc:adf57e195301864cec80739e7e0f3000c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> structs.  <a href="#adf57e195301864cec80739e7e0f3000c">More...</a><br /></td></tr>
<tr class="separator:adf57e195301864cec80739e7e0f3000c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0cd3dca0ff796d69c1d6d02362079a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a4d0cd3dca0ff796d69c1d6d02362079a">ColorValue_from_str</a> (char *s)</td></tr>
<tr class="memdesc:a4d0cd3dca0ff796d69c1d6d02362079a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> from a known color name, or <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> string (<code>char*</code>).  <a href="#a4d0cd3dca0ff796d69c1d6d02362079a">More...</a><br /></td></tr>
<tr class="separator:a4d0cd3dca0ff796d69c1d6d02362079a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7fedbceb4f751d0d30034c0ef1dca8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#aca7fedbceb4f751d0d30034c0ef1dca8">ColorValue_from_value</a> (<a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> type, void *p)</td></tr>
<tr class="memdesc:aca7fedbceb4f751d0d30034c0ef1dca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used with the color_val macro to dynamically create a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> based on it's argument type.  <a href="#aca7fedbceb4f751d0d30034c0ef1dca8">More...</a><br /></td></tr>
<tr class="separator:aca7fedbceb4f751d0d30034c0ef1dca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711a955406cde9716797bf61ab43a7a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a711a955406cde9716797bf61ab43a7a7">ColorValue_has_BasicValue</a> (<a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval, <a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> bval)</td></tr>
<tr class="memdesc:a711a955406cde9716797bf61ab43a7a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has a BasicValue set.  <a href="#a711a955406cde9716797bf61ab43a7a7">More...</a><br /></td></tr>
<tr class="separator:a711a955406cde9716797bf61ab43a7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11dc047d1defc4de2239a45667b45f85"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a11dc047d1defc4de2239a45667b45f85">ColorValue_has_ExtendedValue</a> (<a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval, <a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a> eval)</td></tr>
<tr class="memdesc:a11dc047d1defc4de2239a45667b45f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has a ExtendedValue set.  <a href="#a11dc047d1defc4de2239a45667b45f85">More...</a><br /></td></tr>
<tr class="separator:a11dc047d1defc4de2239a45667b45f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fbfa502deb1f2bb920b74b9f4867fcf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a3fbfa502deb1f2bb920b74b9f4867fcf">ColorValue_has_StyleValue</a> (<a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval, <a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a> sval)</td></tr>
<tr class="memdesc:a3fbfa502deb1f2bb920b74b9f4867fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has a StyleValue set.  <a href="#a3fbfa502deb1f2bb920b74b9f4867fcf">More...</a><br /></td></tr>
<tr class="separator:a3fbfa502deb1f2bb920b74b9f4867fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8188a8a68463d6de08bf9ed2a4debad5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a8188a8a68463d6de08bf9ed2a4debad5">ColorValue_has_RGB</a> (<a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval, <a class="el" href="colr_8h.html#structRGB">RGB</a> rgbval)</td></tr>
<tr class="memdesc:a8188a8a68463d6de08bf9ed2a4debad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has a <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value set.  <a href="#a8188a8a68463d6de08bf9ed2a4debad5">More...</a><br /></td></tr>
<tr class="separator:a8188a8a68463d6de08bf9ed2a4debad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48005bb1589a7ebeef413ccee2a7c2a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a48005bb1589a7ebeef413ccee2a7c2a1">ColorValue_is_empty</a> (<a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval)</td></tr>
<tr class="memdesc:a48005bb1589a7ebeef413ccee2a7c2a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> is an empty placeholder.  <a href="#a48005bb1589a7ebeef413ccee2a7c2a1">More...</a><br /></td></tr>
<tr class="separator:a48005bb1589a7ebeef413ccee2a7c2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22fcf30338eb777592421543885f74e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a22fcf30338eb777592421543885f74e0">ColorValue_is_invalid</a> (<a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval)</td></tr>
<tr class="memdesc:a22fcf30338eb777592421543885f74e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> holds an invalid value.  <a href="#a22fcf30338eb777592421543885f74e0">More...</a><br /></td></tr>
<tr class="separator:a22fcf30338eb777592421543885f74e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7183410b61d12a99dda3f76c2705497"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ac7183410b61d12a99dda3f76c2705497">ColorValue_is_valid</a> (<a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval)</td></tr>
<tr class="memdesc:ac7183410b61d12a99dda3f76c2705497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> holds a valid value.  <a href="#ac7183410b61d12a99dda3f76c2705497">More...</a><br /></td></tr>
<tr class="separator:ac7183410b61d12a99dda3f76c2705497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af891527249f068cfcef057313c522a42"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#af891527249f068cfcef057313c522a42">ColorValue_length</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type, <a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval)</td></tr>
<tr class="memdesc:af891527249f068cfcef057313c522a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length in bytes needed to allocate a string (<code>char*</code>) built with <a class="el" href="colr_8c.html#a3d9ca6bef0b8e7eac4812349ab5562cb" title="Converts a ColorValue into an escape code string (char*). ">ColorValue_to_str()</a> with the specified ArgType and <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>.  <a href="#af891527249f068cfcef057313c522a42">More...</a><br /></td></tr>
<tr class="separator:af891527249f068cfcef057313c522a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95cf6ab7c565726eeb7c276d734193f6"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a95cf6ab7c565726eeb7c276d734193f6">ColorValue_repr</a> (<a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval)</td></tr>
<tr class="memdesc:a95cf6ab7c565726eeb7c276d734193f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation of a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>.  <a href="#a95cf6ab7c565726eeb7c276d734193f6">More...</a><br /></td></tr>
<tr class="separator:a95cf6ab7c565726eeb7c276d734193f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9ca6bef0b8e7eac4812349ab5562cb"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a3d9ca6bef0b8e7eac4812349ab5562cb">ColorValue_to_str</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type, <a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval)</td></tr>
<tr class="memdesc:a3d9ca6bef0b8e7eac4812349ab5562cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> into an escape code string (<code>char*</code>).  <a href="#a3d9ca6bef0b8e7eac4812349ab5562cb">More...</a><br /></td></tr>
<tr class="separator:a3d9ca6bef0b8e7eac4812349ab5562cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17bf46ac385e41b729d07a65dd506cba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a17bf46ac385e41b729d07a65dd506cba">BasicValue_eq</a> (<a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> a, <a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> b)</td></tr>
<tr class="memdesc:a17bf46ac385e41b729d07a65dd506cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two BasicValues.  <a href="#a17bf46ac385e41b729d07a65dd506cba">More...</a><br /></td></tr>
<tr class="separator:a17bf46ac385e41b729d07a65dd506cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4163ac65dca3e222525808b80a40b733"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a4163ac65dca3e222525808b80a40b733">BasicValue_from_str</a> (const char *arg)</td></tr>
<tr class="memdesc:a4163ac65dca3e222525808b80a40b733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert named argument to an actual BasicValue enum value.  <a href="#a4163ac65dca3e222525808b80a40b733">More...</a><br /></td></tr>
<tr class="separator:a4163ac65dca3e222525808b80a40b733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc0d9917621cab5b3efd162b7dc5a8c"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a1bc0d9917621cab5b3efd162b7dc5a8c">BasicValue_repr</a> (<a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> bval)</td></tr>
<tr class="memdesc:a1bc0d9917621cab5b3efd162b7dc5a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation of a BasicValue.  <a href="#a1bc0d9917621cab5b3efd162b7dc5a8c">More...</a><br /></td></tr>
<tr class="separator:a1bc0d9917621cab5b3efd162b7dc5a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a78ebb45cb53792d4c658bade99a70"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a71a78ebb45cb53792d4c658bade99a70">BasicValue_to_ansi</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type, <a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> bval)</td></tr>
<tr class="memdesc:a71a78ebb45cb53792d4c658bade99a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a fore/back BasicValue to the actual 4bit ansi code number.  <a href="#a71a78ebb45cb53792d4c658bade99a70">More...</a><br /></td></tr>
<tr class="separator:a71a78ebb45cb53792d4c658bade99a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac847d91a396ae6babc0bd46e6386a701"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ac847d91a396ae6babc0bd46e6386a701">ExtendedValue_eq</a> (<a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a> a, <a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a> b)</td></tr>
<tr class="memdesc:ac847d91a396ae6babc0bd46e6386a701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ExtendedValues.  <a href="#ac847d91a396ae6babc0bd46e6386a701">More...</a><br /></td></tr>
<tr class="separator:ac847d91a396ae6babc0bd46e6386a701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0632d78965000b1e50068a64e335133b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a0632d78965000b1e50068a64e335133b">ExtendedValue_from_hex</a> (const char *hexstr)</td></tr>
<tr class="memdesc:a0632d78965000b1e50068a64e335133b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an ExtendedValue from a hex string (<code>char*</code>).  <a href="#a0632d78965000b1e50068a64e335133b">More...</a><br /></td></tr>
<tr class="separator:a0632d78965000b1e50068a64e335133b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757be189530b4925c84df25742374485"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a757be189530b4925c84df25742374485">ExtendedValue_from_hex_default</a> (const char *hexstr, <a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a> default_value)</td></tr>
<tr class="memdesc:a757be189530b4925c84df25742374485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an ExtendedValue from a hex string (<code>char*</code>), but return a default value if the hex string is invalid.  <a href="#a757be189530b4925c84df25742374485">More...</a><br /></td></tr>
<tr class="separator:a757be189530b4925c84df25742374485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1548d9fc5f3e00a7b5d834eb1e12ff93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a1548d9fc5f3e00a7b5d834eb1e12ff93">ExtendedValue_from_RGB</a> (<a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:a1548d9fc5f3e00a7b5d834eb1e12ff93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value into the closest matching ExtendedValue.  <a href="#a1548d9fc5f3e00a7b5d834eb1e12ff93">More...</a><br /></td></tr>
<tr class="separator:a1548d9fc5f3e00a7b5d834eb1e12ff93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e859d542a8aa0939e4f76b1f33cb5f8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a2e859d542a8aa0939e4f76b1f33cb5f8">ExtendedValue_from_str</a> (const char *arg)</td></tr>
<tr class="memdesc:a2e859d542a8aa0939e4f76b1f33cb5f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a known name, integer string (0-255), or a hex string (<code>char*</code>), into an ExtendedValue suitable for the extended-value-based functions.  <a href="#a2e859d542a8aa0939e4f76b1f33cb5f8">More...</a><br /></td></tr>
<tr class="separator:a2e859d542a8aa0939e4f76b1f33cb5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa45baebc38756a40e7084f8198999902"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#aa45baebc38756a40e7084f8198999902">ExtendedValue_repr</a> (int eval)</td></tr>
<tr class="memdesc:aa45baebc38756a40e7084f8198999902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation of a ExtendedValue.  <a href="#aa45baebc38756a40e7084f8198999902">More...</a><br /></td></tr>
<tr class="separator:aa45baebc38756a40e7084f8198999902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e334d6b9145fca9717fe5a2aeb542fe"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a4e334d6b9145fca9717fe5a2aeb542fe">ExtendedValue_to_str</a> (<a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a> eval)</td></tr>
<tr class="memdesc:a4e334d6b9145fca9717fe5a2aeb542fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) from an ExtendedValue's actual value, suitable for use with <a class="el" href="colr_8c.html#a2e859d542a8aa0939e4f76b1f33cb5f8" title="Converts a known name, integer string (0-255), or a hex string (char*), into an ExtendedValue suitabl...">ExtendedValue_from_str()</a>.  <a href="#a4e334d6b9145fca9717fe5a2aeb542fe">More...</a><br /></td></tr>
<tr class="separator:a4e334d6b9145fca9717fe5a2aeb542fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b5f73b8aa9d72216d7386221418ae1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ad4b5f73b8aa9d72216d7386221418ae1">RGB_eq</a> (<a class="el" href="colr_8h.html#structRGB">RGB</a> a, <a class="el" href="colr_8h.html#structRGB">RGB</a> b)</td></tr>
<tr class="memdesc:ad4b5f73b8aa9d72216d7386221418ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> structs.  <a href="#ad4b5f73b8aa9d72216d7386221418ae1">More...</a><br /></td></tr>
<tr class="separator:ad4b5f73b8aa9d72216d7386221418ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e0c7cd639abdb4aafd4c592a3d79263"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a5e0c7cd639abdb4aafd4c592a3d79263">RGB_from_hex</a> (const char *hexstr, <a class="el" href="colr_8h.html#structRGB">RGB</a> *rgbval)</td></tr>
<tr class="memdesc:a5e0c7cd639abdb4aafd4c592a3d79263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a hex color into an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.  <a href="#a5e0c7cd639abdb4aafd4c592a3d79263">More...</a><br /></td></tr>
<tr class="separator:a5e0c7cd639abdb4aafd4c592a3d79263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6133112d9c73a8b56995e16e1af62d3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a6133112d9c73a8b56995e16e1af62d3b">RGB_from_hex_default</a> (const char *hexstr, <a class="el" href="colr_8h.html#structRGB">RGB</a> default_value)</td></tr>
<tr class="memdesc:a6133112d9c73a8b56995e16e1af62d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a hex color into an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value, but use a default value when errors occur.  <a href="#a6133112d9c73a8b56995e16e1af62d3b">More...</a><br /></td></tr>
<tr class="separator:a6133112d9c73a8b56995e16e1af62d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0943a956bc1491d6a6996ddc99a4d2dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a0943a956bc1491d6a6996ddc99a4d2dd">RGB_from_str</a> (const char *arg, <a class="el" href="colr_8h.html#structRGB">RGB</a> *rgbval)</td></tr>
<tr class="memdesc:a0943a956bc1491d6a6996ddc99a4d2dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> string (<code>char*</code>) into an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.  <a href="#a0943a956bc1491d6a6996ddc99a4d2dd">More...</a><br /></td></tr>
<tr class="separator:a0943a956bc1491d6a6996ddc99a4d2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e4feb89e009f00cfe7e74a55fab56f"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a95e4feb89e009f00cfe7e74a55fab56f">RGB_to_hex</a> (<a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:a95e4feb89e009f00cfe7e74a55fab56f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value into a hex string (<code>char*</code>).  <a href="#a95e4feb89e009f00cfe7e74a55fab56f">More...</a><br /></td></tr>
<tr class="separator:a95e4feb89e009f00cfe7e74a55fab56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d2f9a1133c8a955f0a551870d7ebe8"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a16d2f9a1133c8a955f0a551870d7ebe8">RGB_to_str</a> (<a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:a16d2f9a1133c8a955f0a551870d7ebe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value into an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> string (<code>char*</code>) suitable for input to <a class="el" href="colr_8c.html#a0943a956bc1491d6a6996ddc99a4d2dd" title="Convert an RGB string (char*) into an RGB value. ">RGB_from_str()</a>.  <a href="#a16d2f9a1133c8a955f0a551870d7ebe8">More...</a><br /></td></tr>
<tr class="separator:a16d2f9a1133c8a955f0a551870d7ebe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4576c531151e398b7ecede2e30df70d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ab4576c531151e398b7ecede2e30df70d">RGB_to_term_RGB</a> (<a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:ab4576c531151e398b7ecede2e30df70d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value into it's nearest terminal-friendly <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.  <a href="#ab4576c531151e398b7ecede2e30df70d">More...</a><br /></td></tr>
<tr class="separator:ab4576c531151e398b7ecede2e30df70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd28864afbcfa4a344e4596130645177"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#afd28864afbcfa4a344e4596130645177">RGB_repr</a> (<a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:afd28864afbcfa4a344e4596130645177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation for an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.  <a href="#afd28864afbcfa4a344e4596130645177">More...</a><br /></td></tr>
<tr class="separator:afd28864afbcfa4a344e4596130645177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32bf31475b0f6264b45438bd5c09ee7d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a32bf31475b0f6264b45438bd5c09ee7d">StyleValue_eq</a> (<a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a> a, <a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a> b)</td></tr>
<tr class="memdesc:a32bf31475b0f6264b45438bd5c09ee7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two StyleValues.  <a href="#a32bf31475b0f6264b45438bd5c09ee7d">More...</a><br /></td></tr>
<tr class="separator:a32bf31475b0f6264b45438bd5c09ee7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca63735ad2cbc6475d4af83dc7c1a9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a4ca63735ad2cbc6475d4af83dc7c1a9b">StyleValue_from_str</a> (const char *arg)</td></tr>
<tr class="memdesc:a4ca63735ad2cbc6475d4af83dc7c1a9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a named argument to actual StyleValue enum value.  <a href="#a4ca63735ad2cbc6475d4af83dc7c1a9b">More...</a><br /></td></tr>
<tr class="separator:a4ca63735ad2cbc6475d4af83dc7c1a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b74664587dd3c0e981603ee75c331b"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a24b74664587dd3c0e981603ee75c331b">StyleValue_repr</a> (<a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a> sval)</td></tr>
<tr class="memdesc:a24b74664587dd3c0e981603ee75c331b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation of a StyleValue.  <a href="#a24b74664587dd3c0e981603ee75c331b">More...</a><br /></td></tr>
<tr class="separator:a24b74664587dd3c0e981603ee75c331b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b4ed49acc5d806f161a3b31f5bf023"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a41b4ed49acc5d806f161a3b31f5bf023">TermSize_repr</a> (<a class="el" href="colr_8h.html#structTermSize">TermSize</a> ts)</td></tr>
<tr class="memdesc:a41b4ed49acc5d806f161a3b31f5bf023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a string (<code>char*</code>) representation for a <a class="el" href="colr_8h.html#structTermSize" title="Holds a terminal size, usually retrieved with colr_term_size(). ">TermSize</a>.  <a href="#a41b4ed49acc5d806f161a3b31f5bf023">More...</a><br /></td></tr>
<tr class="separator:a41b4ed49acc5d806f161a3b31f5bf023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69dd994da51a57fc3cedb5ade591d5c1"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a69dd994da51a57fc3cedb5ade591d5c1">rainbow_bg</a> (const char *s, double freq, size_t offset)</td></tr>
<tr class="memdesc:a69dd994da51a57fc3cedb5ade591d5c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rainbow-ize some text using rgb back colors, lolcat style.  <a href="#a69dd994da51a57fc3cedb5ade591d5c1">More...</a><br /></td></tr>
<tr class="separator:a69dd994da51a57fc3cedb5ade591d5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab261b60d6d790f5a3c91883a1b6646a7"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ab261b60d6d790f5a3c91883a1b6646a7">rainbow_bg_term</a> (const char *s, double freq, size_t offset)</td></tr>
<tr class="memdesc:ab261b60d6d790f5a3c91883a1b6646a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is exactly like <a class="el" href="colr_8c.html#a69dd994da51a57fc3cedb5ade591d5c1" title="Rainbow-ize some text using rgb back colors, lolcat style. ">rainbow_bg()</a>, except it uses colors that are closer to the standard 256-color values.  <a href="#ab261b60d6d790f5a3c91883a1b6646a7">More...</a><br /></td></tr>
<tr class="separator:ab261b60d6d790f5a3c91883a1b6646a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aed06cce3570d914738ce3f517e7ee9"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a7aed06cce3570d914738ce3f517e7ee9">rainbow_fg</a> (const char *s, double freq, size_t offset)</td></tr>
<tr class="memdesc:a7aed06cce3570d914738ce3f517e7ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rainbow-ize some text using rgb fore colors, lolcat style.  <a href="#a7aed06cce3570d914738ce3f517e7ee9">More...</a><br /></td></tr>
<tr class="separator:a7aed06cce3570d914738ce3f517e7ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa740f000c6d3ebe24734411e83125e37"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#aa740f000c6d3ebe24734411e83125e37">rainbow_fg_term</a> (const char *s, double freq, size_t offset)</td></tr>
<tr class="memdesc:aa740f000c6d3ebe24734411e83125e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is exactly like <a class="el" href="colr_8c.html#a7aed06cce3570d914738ce3f517e7ee9" title="Rainbow-ize some text using rgb fore colors, lolcat style. ">rainbow_fg()</a>, except it uses colors that are closer to the standard 256-color values.  <a href="#aa740f000c6d3ebe24734411e83125e37">More...</a><br /></td></tr>
<tr class="separator:aa740f000c6d3ebe24734411e83125e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d16a274fbb779576396457264453873"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a7d16a274fbb779576396457264453873">_rainbow</a> (<a class="el" href="colr_8h.html#adc966460db21ff6c35f23fcf6abe541e">RGB_fmter</a> fmter, const char *s, double freq, size_t offset)</td></tr>
<tr class="memdesc:a7d16a274fbb779576396457264453873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles multi-byte character string (<code>char*</code>) conversion and character iteration for all of the rainbow_ functions.  <a href="#a7d16a274fbb779576396457264453873">More...</a><br /></td></tr>
<tr class="separator:a7d16a274fbb779576396457264453873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3580f33d058571dffd8e5ff789c49296"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a3580f33d058571dffd8e5ff789c49296">rainbow_step</a> (double freq, size_t offset)</td></tr>
<tr class="memdesc:a3580f33d058571dffd8e5ff789c49296"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single step in rainbow-izing produces the next color in the "rainbow" as an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.  <a href="#a3580f33d058571dffd8e5ff789c49296">More...</a><br /></td></tr>
<tr class="separator:a3580f33d058571dffd8e5ff789c49296"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a3a3db0fb0c98d24ec072dfed5f88d717"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="colr_8h.html#structBasicInfo">BasicInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a3a3db0fb0c98d24ec072dfed5f88d717">basic_names</a> []</td></tr>
<tr class="memdesc:a3a3db0fb0c98d24ec072dfed5f88d717"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of <a class="el" href="colr_8h.html#structBasicInfo" title="Holds a known color name and it&#39;s BasicValue. ">BasicInfo</a> items, used with <a class="el" href="colr_8c.html#a4163ac65dca3e222525808b80a40b733" title="Convert named argument to an actual BasicValue enum value. ">BasicValue_from_str()</a>.  <a href="#a3a3db0fb0c98d24ec072dfed5f88d717">More...</a><br /></td></tr>
<tr class="separator:a3a3db0fb0c98d24ec072dfed5f88d717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e51bb70ff49bcce2b23c75a83f099a7"><td class="memItemLeft" align="right" valign="top"><a id="a9e51bb70ff49bcce2b23c75a83f099a7"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a9e51bb70ff49bcce2b23c75a83f099a7">basic_names_len</a> = sizeof(<a class="el" href="colr_8c.html#a3a3db0fb0c98d24ec072dfed5f88d717">basic_names</a>) / sizeof(<a class="el" href="colr_8c.html#a3a3db0fb0c98d24ec072dfed5f88d717">basic_names</a>[0])</td></tr>
<tr class="memdesc:a9e51bb70ff49bcce2b23c75a83f099a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of basic_names. <br /></td></tr>
<tr class="separator:a9e51bb70ff49bcce2b23c75a83f099a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abffaf3629342a2b3e9cb7ea53c12c4f0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="colr_8h.html#structExtendedInfo">ExtendedInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#abffaf3629342a2b3e9cb7ea53c12c4f0">extended_names</a> []</td></tr>
<tr class="memdesc:abffaf3629342a2b3e9cb7ea53c12c4f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of <a class="el" href="colr_8h.html#structExtendedInfo" title="Holds a known color name and it&#39;s ExtendedValue. ">ExtendedInfo</a>, used with <a class="el" href="colr_8c.html#a2e859d542a8aa0939e4f76b1f33cb5f8" title="Converts a known name, integer string (0-255), or a hex string (char*), into an ExtendedValue suitabl...">ExtendedValue_from_str()</a>.  <a href="#abffaf3629342a2b3e9cb7ea53c12c4f0">More...</a><br /></td></tr>
<tr class="separator:abffaf3629342a2b3e9cb7ea53c12c4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41163e87b52c4568025714dbc6ffcbfd"><td class="memItemLeft" align="right" valign="top"><a id="a41163e87b52c4568025714dbc6ffcbfd"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a41163e87b52c4568025714dbc6ffcbfd">extended_names_len</a> = sizeof(<a class="el" href="colr_8c.html#abffaf3629342a2b3e9cb7ea53c12c4f0">extended_names</a>) / sizeof(<a class="el" href="colr_8c.html#abffaf3629342a2b3e9cb7ea53c12c4f0">extended_names</a>[0])</td></tr>
<tr class="memdesc:a41163e87b52c4568025714dbc6ffcbfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of extended_names. <br /></td></tr>
<tr class="separator:a41163e87b52c4568025714dbc6ffcbfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9303c010fd45eab23c7903d1175ae20a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="colr_8h.html#structStyleInfo">StyleInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a9303c010fd45eab23c7903d1175ae20a">style_names</a> []</td></tr>
<tr class="memdesc:a9303c010fd45eab23c7903d1175ae20a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of <a class="el" href="colr_8h.html#structStyleInfo" title="Holds a known style name and it&#39;s StyleValue. ">StyleInfo</a> items, used with StyleName_from_str().  <a href="#a9303c010fd45eab23c7903d1175ae20a">More...</a><br /></td></tr>
<tr class="separator:a9303c010fd45eab23c7903d1175ae20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d274b3747f3ddd52d5e97cd7843388"><td class="memItemLeft" align="right" valign="top"><a id="a05d274b3747f3ddd52d5e97cd7843388"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a05d274b3747f3ddd52d5e97cd7843388">style_names_len</a> = sizeof(<a class="el" href="colr_8c.html#a9303c010fd45eab23c7903d1175ae20a">style_names</a>) / sizeof(<a class="el" href="colr_8c.html#a9303c010fd45eab23c7903d1175ae20a">style_names</a>[0])</td></tr>
<tr class="memdesc:a05d274b3747f3ddd52d5e97cd7843388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of style_names. <br /></td></tr>
<tr class="separator:a05d274b3747f3ddd52d5e97cd7843388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4b773fe2fc7907fdfcf5ef9b202758"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#afb4b773fe2fc7907fdfcf5ef9b202758">ext2rgb_map</a> []</td></tr>
<tr class="memdesc:afb4b773fe2fc7907fdfcf5ef9b202758"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map from ExtendedValue (256-color) to <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value, where the index is the is the ExtendedValue, and the value is the <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a>.  <a href="#afb4b773fe2fc7907fdfcf5ef9b202758">More...</a><br /></td></tr>
<tr class="separator:afb4b773fe2fc7907fdfcf5ef9b202758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8d8b99b472b84bccff92eab6277ce4"><td class="memItemLeft" align="right" valign="top"><a id="aea8d8b99b472b84bccff92eab6277ce4"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#aea8d8b99b472b84bccff92eab6277ce4">ext2rgb_map_len</a> = sizeof(<a class="el" href="colr_8c.html#afb4b773fe2fc7907fdfcf5ef9b202758">ext2rgb_map</a>) / sizeof(<a class="el" href="colr_8c.html#afb4b773fe2fc7907fdfcf5ef9b202758">ext2rgb_map</a>[0])</td></tr>
<tr class="memdesc:aea8d8b99b472b84bccff92eab6277ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of ext2rgb_map (should always be 256). <br /></td></tr>
<tr class="separator:aea8d8b99b472b84bccff92eab6277ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7295537f3f6be454d92f57ed54766d7"><td class="memItemLeft" align="right" valign="top"><a id="aa7295537f3f6be454d92f57ed54766d7"></a>
const <a class="el" href="colr_8h.html#structColorNameData">ColorNameData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#aa7295537f3f6be454d92f57ed54766d7">colr_name_data</a> []</td></tr>
<tr class="memdesc:aa7295537f3f6be454d92f57ed54766d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">An array that holds a known color name, it's ExtendedValue, and it's <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value. <br /></td></tr>
<tr class="separator:aa7295537f3f6be454d92f57ed54766d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5116a18af30d2256b8f465d2b35f4a01"><td class="memItemLeft" align="right" valign="top"><a id="a5116a18af30d2256b8f465d2b35f4a01"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a5116a18af30d2256b8f465d2b35f4a01">colr_name_data_len</a> = sizeof(<a class="el" href="colr_8c.html#aa7295537f3f6be454d92f57ed54766d7">colr_name_data</a>) / sizeof(<a class="el" href="colr_8c.html#aa7295537f3f6be454d92f57ed54766d7">colr_name_data</a>[0])</td></tr>
<tr class="memdesc:a5116a18af30d2256b8f465d2b35f4a01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of colr_name_data. <br /></td></tr>
<tr class="separator:a5116a18af30d2256b8f465d2b35f4a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implements everything in the <a class="el" href="colr_8h.html" title="Declarations for ColrC functions, enums, structs, etc. ">colr.h</a> header. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a25670add558019fdb66a60d51f0ffbda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25670add558019fdb66a60d51f0ffbda">&#9670;&nbsp;</a></span>_colr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* _colr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Joins ColorArgs, ColorTexts, and strings (<code>char*</code>) into one long string. </p>
<p>This will free() any ColorArgs and ColorTexts that are passed in. It is backing the <a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2" title="Join ColorArg pointers, ColorText pointers, and strings into one long string. ">colr()</a> macro, and enables easy throwaway color values.</p>
<p>Any plain strings that are passed in are left alone. It is up to the caller to free those. ColrC only manages the temporary Colr-based objects needed to build up these strings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The first of any ColorArgs, ColorTexts, or strings to join. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Zero or more ColorArgs, ColorTexts, or strings to join. The last argument must be a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointer that is equal to _ColrLastArgValue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string with mixed escape codes/strings.<br />
 CODE_RESET_ALL is appended to all the pieces that aren't plain strings. This allows easy part-colored messages, so there's no need to use CODE_RESET_ALL directly.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>. </dd></dl>

</div>
</div>
<a id="af64af11f4992c8143cb722772df98c98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af64af11f4992c8143cb722772df98c98">&#9670;&nbsp;</a></span>_colr_is_last_arg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool _colr_is_last_arg </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a void pointer is _ColrLastArg (the last-arg-marker). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The pointer to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the pointer is _ColrLastArg, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a4227a65824fdd699a25d3200706c9e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4227a65824fdd699a25d3200706c9e9e">&#9670;&nbsp;</a></span>_colr_join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* _colr_join </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>joinerp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Joins ColorArgs, ColorTexts, and strings (<code>char*</code>) into one long string separated by it's first argument. </p>
<p>This will free() any ColorArgs and ColorTexts that are passed in. It is backing the <a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2" title="Join ColorArg pointers, ColorText pointers, and strings into one long string. ">colr()</a> macro, and enables easy throwaway color values.</p>
<p>Any plain strings that are passed in are left alone. It is up to the caller to free those. ColrC only manages the temporary Colr-based objects needed to build up these strings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">joinerp</td><td>The joiner (any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, or string). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Zero or more ColorArgs, ColorTexts, or strings to join by the joiner. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string with mixed escape codes/strings.<br />
 CODE_RESET_ALL is appended to all <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> arguments. This allows easy part-colored messages.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>. </dd></dl>

</div>
</div>
<a id="a6d47ac6ee2a59e1c976cf2838545aa25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d47ac6ee2a59e1c976cf2838545aa25">&#9670;&nbsp;</a></span>_colr_join_array_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t _colr_join_array_length </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the length of a <code>NULL</code>-terminated array of strings (<code>char*</code>), ColorArgs, or ColorTexts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ps</td><td>A <code>NULL</code>-terminated array of ColorArgs, ColorTexts, or strings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of items (before <code>NULL</code>) in the array. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a701126bd27c90fafa46152d9f9327b2f">colr_join_array()</a>.</p>

</div>
</div>
<a id="ac49c3a33d328ebaf2b0564d5a9b1d4ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac49c3a33d328ebaf2b0564d5a9b1d4ec">&#9670;&nbsp;</a></span>_colr_join_arrayn_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t _colr_join_arrayn_size </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>joinerp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size in bytes needed to join an array of strings (<code>char*</code>), ColorArgs, or ColorTexts by another string (<code>char*</code>), <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>. </p>
<p>This is used to allocate memory in the _colr_join_array() function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">joinerp</td><td>The joiner (any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, or string). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ps</td><td>An array of pointers to ColorArgs, ColorTexts, or strings. The array must have <code>NULL</code> as the last item if <code>count</code> is greater than the total number of items. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Total number of items in the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string with the result.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2" title="Join ColorArg pointers, ColorText pointers, and strings into one long string. ">colr</a> <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join</a> <a class="el" href="colr_8c.html#a701126bd27c90fafa46152d9f9327b2f" title="Join an array of strings (char*), ColorArgs, or ColorTexts by another string (char*), ColorArg, or ColorText. ">colr_join_array</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a71fcf08ad36d4424790e275d973445fc">colr_join_arrayn()</a>.</p>

</div>
</div>
<a id="a91a051ef4cd2e7200a31f9de48766b4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a051ef4cd2e7200a31f9de48766b4c">&#9670;&nbsp;</a></span>_colr_join_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t _colr_join_size </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>joinerp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse arguments, just as in <a class="el" href="colr_8c.html#a4227a65824fdd699a25d3200706c9e9e" title="Joins ColorArgs, ColorTexts, and strings (char*) into one long string separated by it&#39;s first argumen...">_colr_join()</a>, but only return the size needed to allocate the resulting string. </p>
<p>This allows <a class="el" href="colr_8c.html#a4227a65824fdd699a25d3200706c9e9e" title="Joins ColorArgs, ColorTexts, and strings (char*) into one long string separated by it&#39;s first argumen...">_colr_join()</a> to allocate once, instead of reallocating for each argument that is passed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">joinerp</td><td>The joiner (any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, or string). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>A <code>va_list</code> with zero or more ColorArgs, ColorTexts, or strings to join.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length (in bytes) needed to allocate a string built with <a class="el" href="colr_8c.html#a25670add558019fdb66a60d51f0ffbda" title="Joins ColorArgs, ColorTexts, and strings (char*) into one long string. ">_colr()</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#a25670add558019fdb66a60d51f0ffbda" title="Joins ColorArgs, ColorTexts, and strings (char*) into one long string. ">_colr</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>.</p>

</div>
</div>
<a id="ab0be451277fc7e39aee0aa409c9d3f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0be451277fc7e39aee0aa409c9d3f0c">&#9670;&nbsp;</a></span>_colr_ptr_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t _colr_ptr_length </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size, in bytes, needed to convert a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, or string (<code>char*</code>) into a string. </p>
<p>This is used in the variadic _colr* functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointer, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointer, or string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length needed to convert the object into a string (<code>strlen() + 1</code> for strings). </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ac49c3a33d328ebaf2b0564d5a9b1d4ec">_colr_join_arrayn_size()</a>, <a class="el" href="colr_8h.html#a91a051ef4cd2e7200a31f9de48766b4c">_colr_join_size()</a>, and <a class="el" href="colr_8h.html#ad70e1c4f6da5a46e6fcf838aed07885b">_colr_size()</a>.</p>

</div>
</div>
<a id="ad70e1c4f6da5a46e6fcf838aed07885b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad70e1c4f6da5a46e6fcf838aed07885b">&#9670;&nbsp;</a></span>_colr_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t _colr_size </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse arguments, just as in <a class="el" href="colr_8c.html#a25670add558019fdb66a60d51f0ffbda" title="Joins ColorArgs, ColorTexts, and strings (char*) into one long string. ">_colr()</a>, but only return the length needed to allocate the resulting string. </p>
<p>This allows <a class="el" href="colr_8c.html#a25670add558019fdb66a60d51f0ffbda" title="Joins ColorArgs, ColorTexts, and strings (char*) into one long string. ">_colr()</a> to allocate once, instead of reallocating for each argument that is passed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The first of any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, or strings to join. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>A <code>va_list</code> with zero or more ColorArgs, ColorTexts, or strings to join.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length (in bytes) needed to allocate a string built with <a class="el" href="colr_8c.html#a25670add558019fdb66a60d51f0ffbda" title="Joins ColorArgs, ColorTexts, and strings (char*) into one long string. ">_colr()</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#a25670add558019fdb66a60d51f0ffbda" title="Joins ColorArgs, ColorTexts, and strings (char*) into one long string. ">_colr</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a25670add558019fdb66a60d51f0ffbda">_colr()</a>.</p>

</div>
</div>
<a id="a7d16a274fbb779576396457264453873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d16a274fbb779576396457264453873">&#9670;&nbsp;</a></span>_rainbow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* _rainbow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#adc966460db21ff6c35f23fcf6abe541e">RGB_fmter</a>&#160;</td>
          <td class="paramname"><em>fmter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles multi-byte character string (<code>char*</code>) conversion and character iteration for all of the rainbow_ functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fmter</td><td>A formatter function (RGB_fmter) that can create escape codes from <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to "rainbowize". Input <em>must be <code>null</code>-terminated</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freq</td><td>The "tightness" for colors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting offset into the rainbow.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string (<code>char*</code>) with the result.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a69dd994da51a57fc3cedb5ade591d5c1">rainbow_bg()</a>, <a class="el" href="colr_8h.html#ab261b60d6d790f5a3c91883a1b6646a7">rainbow_bg_term()</a>, <a class="el" href="colr_8h.html#a7aed06cce3570d914738ce3f517e7ee9">rainbow_fg()</a>, and <a class="el" href="colr_8h.html#aa740f000c6d3ebe24734411e83125e37">rainbow_fg_term()</a>.</p>

</div>
</div>
<a id="ad01ccaf04c71fc2474da94b050236572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01ccaf04c71fc2474da94b050236572">&#9670;&nbsp;</a></span>ArgType_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ArgType_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation of a ArgType. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>An ArgType to get the type from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an allocated string.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1" title="Argument types (fore, back, style). ">ArgType</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a5af692f2357d46b9cee45bb114f2a4a2">ColorArg_repr()</a>.</p>

</div>
</div>
<a id="a2b270bebb1a01212b7e44e52f61f94be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b270bebb1a01212b7e44e52f61f94be">&#9670;&nbsp;</a></span>ArgType_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ArgType_to_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) from an ArgType. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>An ArgType to get the type from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an allocated string.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1" title="Argument types (fore, back, style). ">ArgType</a> </dd></dl>

</div>
</div>
<a id="a17bf46ac385e41b729d07a65dd506cba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17bf46ac385e41b729d07a65dd506cba">&#9670;&nbsp;</a></span>BasicValue_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BasicValue_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two BasicValues. </p>
<p>This is used to implement <a class="el" href="colr_8h.html#a36af8aa0f01eaa780da182e856923faa" title="Calls the &lt;type&gt;_eq functions for the supported types. ">colr_eq()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first BasicValue to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second BasicValue to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if they are equal, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a4163ac65dca3e222525808b80a40b733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4163ac65dca3e222525808b80a40b733">&#9670;&nbsp;</a></span>BasicValue_from_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> BasicValue_from_str </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert named argument to an actual BasicValue enum value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Color name to find the BasicValue for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BasicValue value on success, or BASIC_INVALID on error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee" title="Basic color values, with a few convenience values for extended colors. ">BasicValue</a> </dd></dl>

</div>
</div>
<a id="a1bc0d9917621cab5b3efd162b7dc5a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc0d9917621cab5b3efd162b7dc5a8c">&#9670;&nbsp;</a></span>BasicValue_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* BasicValue_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>bval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation of a BasicValue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bval</td><td>A BasicValue to get the value from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an allocated string.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee" title="Basic color values, with a few convenience values for extended colors. ">BasicValue</a> </dd></dl>

</div>
</div>
<a id="a71a78ebb45cb53792d4c658bade99a70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71a78ebb45cb53792d4c658bade99a70">&#9670;&nbsp;</a></span>BasicValue_to_ansi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BasicValue_to_ansi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>bval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a fore/back BasicValue to the actual 4bit ansi code number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ArgType (FORE/BACK). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bval</td><td>BasicValue to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer usable with basic escape code fore/back colors.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee" title="Basic color values, with a few convenience values for extended colors. ">BasicValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ae29032483aea8cb25d6b90750767ffc1">format_bg()</a>, and <a class="el" href="colr_8h.html#a6027d93e8768f3c152edafd92e757801">format_fg()</a>.</p>

</div>
</div>
<a id="af838f8479681d809beb868b2e1b547e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af838f8479681d809beb868b2e1b547e7">&#9670;&nbsp;</a></span>ColorArg_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> ColorArg_empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> with ARGTYPE_NONE and ColorValue.type.TYPE_NONE. </p>
<p>This is used to pass "empty" fore/back/style args to the <a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2" title="Join ColorArg pointers, ColorText pointers, and strings into one long string. ">colr()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, and <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr() macro...">Colr()</a> macros, where <code>NULL</code> has a different meaning (end of argument list).</p>
<dl class="section return"><dt>Returns</dt><dd><code>(<a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>){.type=ARGTYPE_NONE, .value.type=TYPE_NONE}</code></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#a752355c2d96d35688d3756558f8421ba" title="Checks to see if a ColorArg is an empty placeholder. ">ColorArg_is_empty</a> <a class="el" href="colr_8c.html#a5ce7c54ad0e31ecf6d790c5770c2b66b" title="Create an &quot;empty&quot; ColorValue. ">ColorValue_empty</a> </dd></dl>

</div>
</div>
<a id="acb62efc0182d6f6107055eeda961a628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb62efc0182d6f6107055eeda961a628">&#9670;&nbsp;</a></span>ColorArg_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorArg_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> structs. </p>
<p>They are considered "equal" if their <code>.type</code> and <code>.value</code> match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if they are equal, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a93f65430500d003575c547eb667330b0">ColorText_has_arg()</a>.</p>

</div>
</div>
<a id="aa1163a9c866767fb7fcb734d3c0d9b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1163a9c866767fb7fcb734d3c0d9b7c">&#9670;&nbsp;</a></span>ColorArg_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ColorArg_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free allocated memory for a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>. </p>
<p>This has no advantage over <code>free(colorarg)</code> right now, it is used in debugging, and may be extended in the future. It's better just to use it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to free.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a25670add558019fdb66a60d51f0ffbda">_colr()</a>, <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>, and <a class="el" href="colr_8h.html#a901e5738358a739629cc3aaccab3e73f">ColorText_free()</a>.</p>

</div>
</div>
<a id="aad49f4597388e6bdb896ff28334cd5e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad49f4597388e6bdb896ff28334cd5e6">&#9670;&nbsp;</a></span>ColorArg_from_BasicValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> ColorArg_from_BasicValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicit version of ColorArg_from_value that only handles BasicValues. </p>
<p>This is used in some macros to aid in dynamic escape code creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ArgType (FORE, BACK, STYLE). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>BasicValue to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, with the <code>.value.type</code> member possibly set to <code>TYPE_INVALID</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

</div>
</div>
<a id="aed30e2a4b30ab5e3cf49608a3c410cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed30e2a4b30ab5e3cf49608a3c410cc5">&#9670;&nbsp;</a></span>ColorArg_from_ExtendedValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> ColorArg_from_ExtendedValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicit version of ColorArg_from_value that only handles ExtendedValues. </p>
<p>This is used in some macros to aid in dynamic escape code creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ArgType (FORE, BACK, STYLE). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>ExtendedValue to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, with the <code>.value.type</code> member possibly set to <code>TYPE_INVALID</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

</div>
</div>
<a id="aaa24bba74e99aa66ed41839576e57856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa24bba74e99aa66ed41839576e57856">&#9670;&nbsp;</a></span>ColorArg_from_RGB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> ColorArg_from_RGB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicit version of ColorArg_from_value that only handles <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> structs. </p>
<p>This is used in some macros to aid in dynamic escape code creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ArgType (FORE, BACK, STYLE). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, with the <code>.value.type</code> member possibly set to <code>TYPE_INVALID</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

</div>
</div>
<a id="ae8d897499fca87d7902159f4ed7dbba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8d897499fca87d7902159f4ed7dbba3">&#9670;&nbsp;</a></span>ColorArg_from_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> ColorArg_from_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>colorname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> (fore, back, or style value) from a known color name/style. </p>
<p>The <code>.value.type</code> attribute can be checked for an invalid type, or you can call ColorArg_is_invalid(x).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ArgType (FORE, BACK, STYLE). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">colorname</td><td>A known color name/style.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct with usable values.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

</div>
</div>
<a id="acf63bcee395dca3ca29dc324e3d7c8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf63bcee395dca3ca29dc324e3d7c8f2">&#9670;&nbsp;</a></span>ColorArg_from_StyleValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> ColorArg_from_StyleValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicit version of ColorArg_from_value that only handles StyleValues. </p>
<p>This is used in some macros to aid in dynamic escape code creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ArgType (FORE, BACK, STYLE). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>StyleValue to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, with the <code>.value.type</code> member possibly set to <code>TYPE_INVALID</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

</div>
</div>
<a id="a89a5aa762bd5802872faf571aa32ea35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a5aa762bd5802872faf571aa32ea35">&#9670;&nbsp;</a></span>ColorArg_from_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> ColorArg_from_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>&#160;</td>
          <td class="paramname"><em>colrtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used with the color_arg macro to dynamically create a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> based on it's argument type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ArgType value, to mark the type of <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">colrtype</td><td>ColorType value, to mark the type of <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A pointer to either a BasicValue, ExtendedValue, or a <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct with the appropriate <code>.value.type</code> member set for the value that was passed. For invalid types the <code>.value.type</code> member may be set to one of:<ul>
<li>TYPE_INVALID</li>
<li>TYPE_INVALID_EXTENDED_RANGE</li>
<li>TYPE_INVALID_RGB_RANGE</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

</div>
</div>
<a id="a752355c2d96d35688d3756558f8421ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a752355c2d96d35688d3756558f8421ba">&#9670;&nbsp;</a></span>ColorArg_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorArg_is_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>carg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> is an empty placeholder. </p>
<p>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> is empty if it's <code>.type</code> is set to <code>ARGTYPE_NONE</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">carg</td><td>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> is considered "empty", otherwise <code>false</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#adaff727006f4c057aab75e55bfb473c4">ColorArg_length()</a>, <a class="el" href="colr_8h.html#a91fb398f6463553e576fc067f5a0a854">ColorArg_to_str()</a>, <a class="el" href="colr_8h.html#a93b38987063bb127bb34761961d7f678">ColorText_has_args()</a>, and <a class="el" href="colr_8h.html#ae305b33e0a44b956ccf4123aa4f1a033">ColorText_to_str()</a>.</p>

</div>
</div>
<a id="a66b4906cfb08588005536db1250dc899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b4906cfb08588005536db1250dc899">&#9670;&nbsp;</a></span>ColorArg_is_invalid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorArg_is_invalid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>carg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> holds an invalid value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">carg</td><td><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is invalid, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

</div>
</div>
<a id="ad15f3a714a6383123d3fb24ade173e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad15f3a714a6383123d3fb24ade173e29">&#9670;&nbsp;</a></span>ColorArg_is_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorArg_is_ptr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks a void pointer to see if it contains a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct. </p>
<p>The first member of a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> is a marker.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A void pointer to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the pointer is a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a25670add558019fdb66a60d51f0ffbda">_colr()</a>, <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>, <a class="el" href="colr_8h.html#a6d47ac6ee2a59e1c976cf2838545aa25">_colr_join_array_length()</a>, <a class="el" href="colr_8h.html#ac49c3a33d328ebaf2b0564d5a9b1d4ec">_colr_join_arrayn_size()</a>, <a class="el" href="colr_8h.html#ab0be451277fc7e39aee0aa409c9d3f0c">_colr_ptr_length()</a>, <a class="el" href="colr_8h.html#ad70e1c4f6da5a46e6fcf838aed07885b">_colr_size()</a>, <a class="el" href="colr_8h.html#ad4702d6ddc409a93a0b42c8f6141d2f2">ColorText_from_values()</a>, <a class="el" href="colr_8h.html#a880b39cd2ce9b622dbe7790a162d88f7">ColorText_set_values()</a>, and <a class="el" href="colr_8h.html#a71fcf08ad36d4424790e275d973445fc">colr_join_arrayn()</a>.</p>

</div>
</div>
<a id="a1e446f65d6987d52522a1755c909d421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e446f65d6987d52522a1755c909d421">&#9670;&nbsp;</a></span>ColorArg_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorArg_is_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>carg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> holds a valid value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">carg</td><td><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is valid, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

</div>
</div>
<a id="adaff727006f4c057aab75e55bfb473c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaff727006f4c057aab75e55bfb473c4">&#9670;&nbsp;</a></span>ColorArg_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ColorArg_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>carg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length in bytes needed to allocate a string (<code>char*</code>) built with <a class="el" href="colr_8c.html#a91fb398f6463553e576fc067f5a0a854" title="Converts a ColorArg into an escape code string (char*). ">ColorArg_to_str()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">carg</td><td><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length (<code>size_t</code>) needed to allocate a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string, or <code>1</code> (size of an empty string) for invalid/empty arg types/values.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ac49c3a33d328ebaf2b0564d5a9b1d4ec">_colr_join_arrayn_size()</a>, <a class="el" href="colr_8h.html#ab0be451277fc7e39aee0aa409c9d3f0c">_colr_ptr_length()</a>, <a class="el" href="colr_8h.html#ad70e1c4f6da5a46e6fcf838aed07885b">_colr_size()</a>, and <a class="el" href="colr_8h.html#a412833a097b050c8ee99874c733bd030">ColorText_length()</a>.</p>

</div>
</div>
<a id="a5af692f2357d46b9cee45bb114f2a4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af692f2357d46b9cee45bb114f2a4a2">&#9670;&nbsp;</a></span>ColorArg_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorArg_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>carg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation for a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>. </p>
<p>Allocates memory for the string representation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">carg</td><td><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct to get the representation for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Allocated string for the representation.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a575a6cdc2f65cf1cd25227f847ae8d76">ColorText_repr()</a>.</p>

</div>
</div>
<a id="afb5ac0bd012b8162cea125ad0d9e8bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb5ac0bd012b8162cea125ad0d9e8bf0">&#9670;&nbsp;</a></span>ColorArg_to_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>* ColorArg_to_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>carg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> into memory and returns the pointer. </p>
<p>You must free() the memory if you call this directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">carg</td><td><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to copy/allocate for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a heap-allocated <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

</div>
</div>
<a id="a91fb398f6463553e576fc067f5a0a854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91fb398f6463553e576fc067f5a0a854">&#9670;&nbsp;</a></span>ColorArg_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorArg_to_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>carg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> into an escape code string (<code>char*</code>). </p>
<p>Allocates memory for the string.</p>
<p>If the <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> is empty (<code>ARGTYPE_NONE</code>), an empty string is returned.</p>
<p>If the <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> is invalid, an empty string is returned. You must still free the empty string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">carg</td><td><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to get the ArgType and <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Allocated string for the escape code.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a25670add558019fdb66a60d51f0ffbda">_colr()</a>, <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>, <a class="el" href="colr_8h.html#ae305b33e0a44b956ccf4123aa4f1a033">ColorText_to_str()</a>, <a class="el" href="colr_8h.html#a71fcf08ad36d4424790e275d973445fc">colr_join_arrayn()</a>, and <a class="el" href="colr_8h.html#a44d236bca80dbce495c0f282c3a7d192">colr_str_replace_ColorArg()</a>.</p>

</div>
</div>
<a id="ae11e9457ca4e8f5be0e29351b49b6844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae11e9457ca4e8f5be0e29351b49b6844">&#9670;&nbsp;</a></span>ColorJustify_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a> ColorJustify_empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an "empty" <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a>, with JUST_NONE set. </p>
<dl class="section return"><dt>Returns</dt><dd>An initialized <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a>, with no justification method set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a341b4033c31c58e412ff15280185c6bd">ColorText_empty()</a>.</p>

</div>
</div>
<a id="ab71656e616aef4bbb3c278d43c4a326e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab71656e616aef4bbb3c278d43c4a326e">&#9670;&nbsp;</a></span>ColorJustify_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorJustify_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> structs. </p>
<p>They are considered "equal" if their member values match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if they are equal, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> </dd></dl>

</div>
</div>
<a id="a34f193b6e6a20c63caecc1d9b53c89fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f193b6e6a20c63caecc1d9b53c89fb">&#9670;&nbsp;</a></span>ColorJustify_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorJustify_is_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a>&#160;</td>
          <td class="paramname"><em>cjust</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> is "empty". </p>
<p>A <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> is considered "empty" if the <code>.method</code> member is set to <code>JUST_NONE</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cjust</td><td>The <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> is empty, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> <a class="el" href="colr_8c.html#ae11e9457ca4e8f5be0e29351b49b6844" title="Creates an &quot;empty&quot; ColorJustify, with JUST_NONE set. ">ColorJustify_empty</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ac846e583415e832b9090270020320b9f">ColorText_is_empty()</a>, and <a class="el" href="colr_8h.html#a412833a097b050c8ee99874c733bd030">ColorText_length()</a>.</p>

</div>
</div>
<a id="a7d4a7a21151993343ef96a068c6d5018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4a7a21151993343ef96a068c6d5018">&#9670;&nbsp;</a></span>ColorJustify_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a> ColorJustify_new </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#af1a3fe0b966f944fd659a98be170045f">ColorJustifyMethod</a>&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>padchar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a>. </p>
<p>This is used to ensure every <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> has it's <code>.marker</code> member set correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>ColorJustifyMethod to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>Width for justification. If <code>0</code> is given, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> will use the width from colr_terminal_size(). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">padchar</td><td>Padding character to use. If <code>0</code> is given, the default, space (`' '`), is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An initialized <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a>. </dd></dl>

</div>
</div>
<a id="a6c35f6b47cc737744487d14d20241656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c35f6b47cc737744487d14d20241656">&#9670;&nbsp;</a></span>ColorJustify_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorJustify_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a>&#160;</td>
          <td class="paramname"><em>cjust</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation for a <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a>. </p>
<p>Allocates memory for the string representation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cjust</td><td><a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> struct to get the representation for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Allocated string for the representation.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a575a6cdc2f65cf1cd25227f847ae8d76">ColorText_repr()</a>.</p>

</div>
</div>
<a id="adf78eeb364553d130055d93e9892cd9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf78eeb364553d130055d93e9892cd9c">&#9670;&nbsp;</a></span>ColorJustifyMethod_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorJustifyMethod_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#af1a3fe0b966f944fd659a98be170045f">ColorJustifyMethod</a>&#160;</td>
          <td class="paramname"><em>meth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation for a ColorJustifyMethod. </p>
<p>Allocates memory for the string representation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meth</td><td>ColorJustifyMethod to get the representation for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Allocated string for the representation.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#af1a3fe0b966f944fd659a98be170045f" title="Justification style for ColorTexts. ">ColorJustifyMethod</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a6c35f6b47cc737744487d14d20241656">ColorJustify_repr()</a>.</p>

</div>
</div>
<a id="a341b4033c31c58e412ff15280185c6bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a341b4033c31c58e412ff15280185c6bd">&#9670;&nbsp;</a></span>ColorText_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorText">ColorText</a> ColorText_empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an "empty" <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> with pointers set to <code>NULL</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>An initialized <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ad4702d6ddc409a93a0b42c8f6141d2f2">ColorText_from_values()</a>, and <a class="el" href="colr_8h.html#a880b39cd2ce9b622dbe7790a162d88f7">ColorText_set_values()</a>.</p>

</div>
</div>
<a id="a901e5738358a739629cc3aaccab3e73f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a901e5738358a739629cc3aaccab3e73f">&#9670;&nbsp;</a></span>ColorText_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ColorText_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> and it's ColorArgs. </p>
<p>The text member is left alone, because it wasn't created by ColrC.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Pointer to <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to free, along with it's Colr-based members.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="colr_join_example_8c-example.html#a9">colr_join_example.c</a>.</dd>
</dl>
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a25670add558019fdb66a60d51f0ffbda">_colr()</a>, and <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>.</p>

</div>
</div>
<a id="ad4702d6ddc409a93a0b42c8f6141d2f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4702d6ddc409a93a0b42c8f6141d2f2">&#9670;&nbsp;</a></span>ColorText_from_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorText">ColorText</a> ColorText_from_values </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> from 1 mandatory string (<code>char*</code>), and optional fore, back, and style args (pointers to ColorArgs). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>Text to colorize (a regular string). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>ColorArgs for fore, back, and style, in any order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An initialized <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> struct.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

</div>
</div>
<a id="a93f65430500d003575c547eb667330b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f65430500d003575c547eb667330b0">&#9670;&nbsp;</a></span>ColorText_has_arg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorText_has_arg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a>&#160;</td>
          <td class="paramname"><em>ctext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>carg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> has a certain <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> value set. </p>
<p>Uses <a class="el" href="colr_8c.html#acb62efc0182d6f6107055eeda961a628" title="Compares two ColorArg structs. ">ColorArg_eq()</a> to inspect the <code>fore</code>, <code>back</code>, and <code>style</code> members.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctext</td><td>The <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to inspect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">carg</td><td>The <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <code>fore</code>, <code>back</code>, or <code>style</code> arg matches <code>carg</code>, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a93b38987063bb127bb34761961d7f678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93b38987063bb127bb34761961d7f678">&#9670;&nbsp;</a></span>ColorText_has_args()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorText_has_args </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a>&#160;</td>
          <td class="paramname"><em>ctext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> has any argument values set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctext</td><td>A <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>.fore</code>, <code>.back</code>, or .<code>style</code> is set to a non-empty <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, otherwise <code>false</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a25670add558019fdb66a60d51f0ffbda">_colr()</a>, <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>, and <a class="el" href="colr_8h.html#ad70e1c4f6da5a46e6fcf838aed07885b">_colr_size()</a>.</p>

</div>
</div>
<a id="ac846e583415e832b9090270020320b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac846e583415e832b9090270020320b9f">&#9670;&nbsp;</a></span>ColorText_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorText_is_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a>&#160;</td>
          <td class="paramname"><em>ctext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> has no usable values. </p>
<p>A <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> is considered "empty" if the <code>.text</code>, <code>.fore</code>, <code>.back</code>, and <code>.style</code> pointers are <code>NULL</code>, and the <code>.just</code> member is set to an "empty" <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctext</td><td>The <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> is empty, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> <a class="el" href="colr_8c.html#a341b4033c31c58e412ff15280185c6bd" title="Creates an &quot;empty&quot; ColorText with pointers set to NULL. ">ColorText_empty</a> </dd></dl>

</div>
</div>
<a id="a1d6eb8832110b943c3a3a17627a50288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6eb8832110b943c3a3a17627a50288">&#9670;&nbsp;</a></span>ColorText_is_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorText_is_ptr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks a void pointer to see if it contains a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> struct. </p>
<p>The first member of a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> is a marker.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A void pointer to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the pointer is a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a25670add558019fdb66a60d51f0ffbda">_colr()</a>, <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>, <a class="el" href="colr_8h.html#a6d47ac6ee2a59e1c976cf2838545aa25">_colr_join_array_length()</a>, <a class="el" href="colr_8h.html#ac49c3a33d328ebaf2b0564d5a9b1d4ec">_colr_join_arrayn_size()</a>, <a class="el" href="colr_8h.html#ab0be451277fc7e39aee0aa409c9d3f0c">_colr_ptr_length()</a>, <a class="el" href="colr_8h.html#ad70e1c4f6da5a46e6fcf838aed07885b">_colr_size()</a>, and <a class="el" href="colr_8h.html#a71fcf08ad36d4424790e275d973445fc">colr_join_arrayn()</a>.</p>

</div>
</div>
<a id="a412833a097b050c8ee99874c733bd030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a412833a097b050c8ee99874c733bd030">&#9670;&nbsp;</a></span>ColorText_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ColorText_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a>&#160;</td>
          <td class="paramname"><em>ctext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length in bytes needed to allocate a string (<code>char*</code>) built with <a class="el" href="colr_8c.html#ae305b33e0a44b956ccf4123aa4f1a033" title="Stringifies a ColorText struct, creating a mix of escape codes and text. ">ColorText_to_str()</a> with the current <code>text</code>, <code>fore</code>, <code>back</code>, and <code>style</code> members. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctext</td><td><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length (<code>size_t</code>) needed to allocate a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string, or <code>1</code> (size of an empty string) for invalid/empty arg types/values.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ac49c3a33d328ebaf2b0564d5a9b1d4ec">_colr_join_arrayn_size()</a>, <a class="el" href="colr_8h.html#ab0be451277fc7e39aee0aa409c9d3f0c">_colr_ptr_length()</a>, <a class="el" href="colr_8h.html#ad70e1c4f6da5a46e6fcf838aed07885b">_colr_size()</a>, and <a class="el" href="colr_8h.html#ae305b33e0a44b956ccf4123aa4f1a033">ColorText_to_str()</a>.</p>

</div>
</div>
<a id="a65363a3601cd9cfcdc7fc40722d5d3c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65363a3601cd9cfcdc7fc40722d5d3c3">&#9670;&nbsp;</a></span>ColorText_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorText_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a>&#160;</td>
          <td class="paramname"><em>ctext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a string (<code>char*</code>) representation for a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctext</td><td><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to get the string representation for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Allocated string for the <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

</div>
</div>
<a id="ab408d87cce896acccb75357acca8ade4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab408d87cce896acccb75357acca8ade4">&#9670;&nbsp;</a></span>ColorText_set_just()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorText">ColorText</a>* ColorText_set_just </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td>
          <td class="paramname"><em>ctext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a>&#160;</td>
          <td class="paramname"><em>cjust</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> method for a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, and return the <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>. </p>
<p>This is to facilitate the justification macros. If you already have a pointer to a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, you can just do <code>ctext-&gt;just = just;</code>. The purpose of this is to allow <code>ColorText_set_just(ColorText_to_ptr(...), ...)</code> to work.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ctext</td><td>The <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to set the justification method for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cjust</td><td>The <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> struct to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The same pointer that was given as <code>ctext</code>. </dd></dl>

</div>
</div>
<a id="a880b39cd2ce9b622dbe7790a162d88f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a880b39cd2ce9b622dbe7790a162d88f7">&#9670;&nbsp;</a></span>ColorText_set_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ColorText_set_values </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td>
          <td class="paramname"><em>ctext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an existing <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> from 1 mandatory string (<code>char*</code>), and optional fore, back, and style args (pointers to ColorArgs). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ctext</td><td>A <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to initialize with values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>Text to colorize (a regular string). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>A <code>va_list</code> with ColorArgs pointers for fore, back, and style, in any order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An initialized <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> struct.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

</div>
</div>
<a id="a8e04de932a4cf712ac91e794bdc3f8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e04de932a4cf712ac91e794bdc3f8db">&#9670;&nbsp;</a></span>ColorText_to_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorText">ColorText</a>* ColorText_to_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a>&#160;</td>
          <td class="paramname"><em>ctext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> into allocated memory and returns the pointer. </p>
<p>You must free() the memory if you call this directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctext</td><td><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to copy/allocate for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a heap-allocated <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

</div>
</div>
<a id="ae305b33e0a44b956ccf4123aa4f1a033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae305b33e0a44b956ccf4123aa4f1a033">&#9670;&nbsp;</a></span>ColorText_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorText_to_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a>&#160;</td>
          <td class="paramname"><em>ctext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stringifies a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> struct, creating a mix of escape codes and text. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctext</td><td><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to stringify. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string with text/escape-codes.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a25670add558019fdb66a60d51f0ffbda">_colr()</a>, <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>, <a class="el" href="colr_8h.html#a71fcf08ad36d4424790e275d973445fc">colr_join_arrayn()</a>, and <a class="el" href="colr_8h.html#a7ec6d96305890148b019602f2301f989">colr_str_replace_ColorText()</a>.</p>

</div>
</div>
<a id="a29e3483ae4add048424177fdc2b97b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29e3483ae4add048424177fdc2b97b71">&#9670;&nbsp;</a></span>ColorType_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorType_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two ColorTypes. </p>
<p>This is used to implement <a class="el" href="colr_8h.html#a36af8aa0f01eaa780da182e856923faa" title="Calls the &lt;type&gt;_eq functions for the supported types. ">colr_eq()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first ColorType to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second ColorType to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if they are equal, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="afa75deef059c002134a88dbbdc18fd49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa75deef059c002134a88dbbdc18fd49">&#9670;&nbsp;</a></span>ColorType_from_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> ColorType_from_str </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine which type of color value is desired by name. </p>
<p>Example:</p><ul>
<li>"red" == TYPE_BASIC</li>
<li>"253" == TYPE_EXTENDED</li>
<li>"123,55,67" == TYPE_RGB</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Color name to get the ColorType for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ColorType</td><td>value on success. </td></tr>
    <tr><td class="paramname">TYPE_INVALID</td><td>for invalid color names/strings. </td></tr>
    <tr><td class="paramname">TYPE_INVALID_EXTENDED_RANGE</td><td>for ExtendedValues outside of 0-255. </td></tr>
    <tr><td class="paramname">TYPE_INVALID_RGB_RANGE</td><td>for rgb values outside of 0-255.</td></tr>
  </table>
  </dd>
</dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#ColorType_from_str-example" id="ColorType_from_str-example" class="diamond-bullet">&#160;</a> ColorType_from_str example: </div><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="colr_8h.html">colr.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div><div class="line">    <span class="keywordtype">char</span>* userarg;</div><div class="line">    <span class="keywordflow">if</span> (argc == 1) {</div><div class="line">        <span class="keywordflow">if</span> (asprintf(&amp;userarg, <span class="stringliteral">&quot;%s&quot;</span>, <span class="stringliteral">&quot;123,54,25&quot;</span>) &lt; 1) <span class="keywordflow">return</span> 1;</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">        <span class="keywordflow">if</span> (asprintf(&amp;userarg, <span class="stringliteral">&quot;%s&quot;</span>,  argv[1]) &lt; 1) <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">    <a class="code" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> type = <a class="code" href="colr_8c.html#afa75deef059c002134a88dbbdc18fd49">ColorType_from_str</a>(userarg);</div><div class="line">    <span class="keywordflow">if</span> (!<a class="code" href="colr_8c.html#adc223f6fda6296396e9ecddcc68d4aec">ColorType_is_invalid</a>(type)) {</div><div class="line">        <span class="keywordtype">char</span>* repr = <a class="code" href="colr_8h.html#ac1ef824dd213274fb239526269315543">colr_repr</a>(type);</div><div class="line">        printf(<span class="stringliteral">&quot;User passed in a %s, %s\n&quot;</span>, repr, userarg);</div><div class="line">        free(repr);</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">        printf(<span class="stringliteral">&quot;User passed in an invalid color name: %s\n&quot;</span>, userarg);</div><div class="line">    }</div><div class="line">    free(userarg);</div><div class="line">}</div></div><!-- fragment --> </div> <dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83" title="Color/Style code types. Used with ColorType_from_str() and ColorValue. ">ColorType</a> </dd></dl>

</div>
</div>
<a id="adc223f6fda6296396e9ecddcc68d4aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc223f6fda6296396e9ecddcc68d4aec">&#9670;&nbsp;</a></span>ColorType_is_invalid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorType_is_invalid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check to see if a ColorType value is considered invalid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ColorType value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is considered invalid, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83" title="Color/Style code types. Used with ColorType_from_str() and ColorValue. ">ColorType</a> </dd></dl>

</div>
</div>
<a id="a5a5883d43e3206584ad048908720afb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a5883d43e3206584ad048908720afb2">&#9670;&nbsp;</a></span>ColorType_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorType_is_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check to see if a ColorType value is considered valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ColorType value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is considered valid, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83" title="Color/Style code types. Used with ColorType_from_str() and ColorValue. ">ColorType</a> </dd></dl>

</div>
</div>
<a id="a291ca6d28f9f430794413b76b7b094ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a291ca6d28f9f430794413b76b7b094ed">&#9670;&nbsp;</a></span>ColorType_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorType_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation of a ColorType. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>A ColorType to get the type from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an allocated string. <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83" title="Color/Style code types. Used with ColorType_from_str() and ColorValue. ">ColorType</a> </dd></dl>

</div>
</div>
<a id="a5ce7c54ad0e31ecf6d790c5770c2b66b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce7c54ad0e31ecf6d790c5770c2b66b">&#9670;&nbsp;</a></span>ColorValue_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a> ColorValue_empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an "empty" <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>. </p>
<p>This is used with <a class="el" href="colr_8c.html#af838f8479681d809beb868b2e1b547e7" title="Create a ColorArg with ARGTYPE_NONE and ColorValue.type.TYPE_NONE. ">ColorArg_empty()</a> to build ColorArgs that don't do anything, where using <code>NULL</code> has a different meaning inside the <a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2" title="Join ColorArg pointers, ColorText pointers, and strings into one long string. ">colr()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, and <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr() macro...">Colr()</a> macros.</p>
<dl class="section return"><dt>Returns</dt><dd><code>(<a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>){.type=TYPE_NONE, .basic=0, .ext=0, .rgb=(<a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a>){0, 0, 0}}</code></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> <a class="el" href="colr_8c.html#af838f8479681d809beb868b2e1b547e7" title="Create a ColorArg with ARGTYPE_NONE and ColorValue.type.TYPE_NONE. ">ColorArg_empty</a> <a class="el" href="colr_8c.html#a752355c2d96d35688d3756558f8421ba" title="Checks to see if a ColorArg is an empty placeholder. ">ColorArg_is_empty</a> <a class="el" href="colr_8c.html#a48005bb1589a7ebeef413ccee2a7c2a1" title="Checks to see if a ColorValue is an empty placeholder. ">ColorValue_is_empty</a> </dd></dl>

</div>
</div>
<a id="adf57e195301864cec80739e7e0f3000c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf57e195301864cec80739e7e0f3000c">&#9670;&nbsp;</a></span>ColorValue_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorValue_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> structs. </p>
<p>They are considered "equal" if all of their members match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if they are equal, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#acb62efc0182d6f6107055eeda961a628">ColorArg_eq()</a>.</p>

</div>
</div>
<a id="a4d0cd3dca0ff796d69c1d6d02362079a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d0cd3dca0ff796d69c1d6d02362079a">&#9670;&nbsp;</a></span>ColorValue_from_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a> ColorValue_from_str </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> from a known color name, or <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> string (<code>char*</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>A string to parse the color name from (can be an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> string). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> (with no fore/back information, only the color type and value).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ae8d897499fca87d7902159f4ed7dbba3">ColorArg_from_str()</a>.</p>

</div>
</div>
<a id="aca7fedbceb4f751d0d30034c0ef1dca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca7fedbceb4f751d0d30034c0ef1dca8">&#9670;&nbsp;</a></span>ColorValue_from_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a> ColorValue_from_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used with the color_val macro to dynamically create a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> based on it's argument type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>A ColorType value, to mark the type of <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A pointer to either a BasicValue, ExtendedValue, or a <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> struct with the appropriate <code>.type</code> member set for the value that was passed. For invalid types the <code>.type</code> member may be set to one of:<ul>
<li>TYPE_INVALID</li>
<li>TYPE_INVALID_EXTENDED_RANGE</li>
<li>TYPE_INVALID_RGB_RANGE</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#aad49f4597388e6bdb896ff28334cd5e6">ColorArg_from_BasicValue()</a>, <a class="el" href="colr_8h.html#aed30e2a4b30ab5e3cf49608a3c410cc5">ColorArg_from_ExtendedValue()</a>, <a class="el" href="colr_8h.html#aaa24bba74e99aa66ed41839576e57856">ColorArg_from_RGB()</a>, <a class="el" href="colr_8h.html#acf63bcee395dca3ca29dc324e3d7c8f2">ColorArg_from_StyleValue()</a>, and <a class="el" href="colr_8h.html#a4d0cd3dca0ff796d69c1d6d02362079a">ColorValue_from_str()</a>.</p>

</div>
</div>
<a id="a711a955406cde9716797bf61ab43a7a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a711a955406cde9716797bf61ab43a7a7">&#9670;&nbsp;</a></span>ColorValue_has_BasicValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorValue_has_BasicValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>bval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has a BasicValue set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bval</td><td>BasicValue to look for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has the exact BasicValue set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

</div>
</div>
<a id="a11dc047d1defc4de2239a45667b45f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11dc047d1defc4de2239a45667b45f85">&#9670;&nbsp;</a></span>ColorValue_has_ExtendedValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorValue_has_ExtendedValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>&#160;</td>
          <td class="paramname"><em>eval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has a ExtendedValue set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eval</td><td>ExtendedValue to look for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has the exact ExtendedValue set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

</div>
</div>
<a id="a8188a8a68463d6de08bf9ed2a4debad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8188a8a68463d6de08bf9ed2a4debad5">&#9670;&nbsp;</a></span>ColorValue_has_RGB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorValue_has_RGB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgbval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has a <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rgbval</td><td><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value to look for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has the exact <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

</div>
</div>
<a id="a3fbfa502deb1f2bb920b74b9f4867fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fbfa502deb1f2bb920b74b9f4867fcf">&#9670;&nbsp;</a></span>ColorValue_has_StyleValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorValue_has_StyleValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>&#160;</td>
          <td class="paramname"><em>sval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has a StyleValue set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sval</td><td>StyleValue to look for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has the exact StyleValue set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

</div>
</div>
<a id="a48005bb1589a7ebeef413ccee2a7c2a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48005bb1589a7ebeef413ccee2a7c2a1">&#9670;&nbsp;</a></span>ColorValue_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorValue_is_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> is an empty placeholder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> is "empty", otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> <a class="el" href="colr_8c.html#a5ce7c54ad0e31ecf6d790c5770c2b66b" title="Create an &quot;empty&quot; ColorValue. ">ColorValue_empty</a> <a class="el" href="colr_8c.html#af838f8479681d809beb868b2e1b547e7" title="Create a ColorArg with ARGTYPE_NONE and ColorValue.type.TYPE_NONE. ">ColorArg_empty</a> <a class="el" href="colr_8c.html#a752355c2d96d35688d3756558f8421ba" title="Checks to see if a ColorArg is an empty placeholder. ">ColorArg_is_empty</a> </dd></dl>

</div>
</div>
<a id="a22fcf30338eb777592421543885f74e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22fcf30338eb777592421543885f74e0">&#9670;&nbsp;</a></span>ColorValue_is_invalid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorValue_is_invalid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> holds an invalid value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> struct to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is invalid, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

</div>
</div>
<a id="ac7183410b61d12a99dda3f76c2705497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7183410b61d12a99dda3f76c2705497">&#9670;&nbsp;</a></span>ColorValue_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorValue_is_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> holds a valid value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> struct to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is valid, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

</div>
</div>
<a id="af891527249f068cfcef057313c522a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af891527249f068cfcef057313c522a42">&#9670;&nbsp;</a></span>ColorValue_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ColorValue_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length in bytes needed to allocate a string (<code>char*</code>) built with <a class="el" href="colr_8c.html#a3d9ca6bef0b8e7eac4812349ab5562cb" title="Converts a ColorValue into an escape code string (char*). ">ColorValue_to_str()</a> with the specified ArgType and <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ArgType (<code>FORE</code>, <code>BACK</code>, <code>STYLE</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length (<code>size_t</code>) needed to allocate a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>'s string, or <code>1</code> (size of an empty string) for invalid/empty arg types/values.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#adaff727006f4c057aab75e55bfb473c4">ColorArg_length()</a>.</p>

</div>
</div>
<a id="a95cf6ab7c565726eeb7c276d734193f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95cf6ab7c565726eeb7c276d734193f6">&#9670;&nbsp;</a></span>ColorValue_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorValue_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation of a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td>A <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to get the type and value from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an allocated string.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a5af692f2357d46b9cee45bb114f2a4a2">ColorArg_repr()</a>.</p>

</div>
</div>
<a id="a3d9ca6bef0b8e7eac4812349ab5562cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d9ca6bef0b8e7eac4812349ab5562cb">&#9670;&nbsp;</a></span>ColorValue_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorValue_to_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> into an escape code string (<code>char*</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ArgType (FORE, BACK, STYLE) to build the escape code for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to get the color value from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string with the appropriate escape code. For invalid values, an empty string is returned.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a91fb398f6463553e576fc067f5a0a854">ColorArg_to_str()</a>.</p>

</div>
</div>
<a id="a10030070daafdee7124638adfc5469d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10030070daafdee7124638adfc5469d8">&#9670;&nbsp;</a></span>colr_append_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void colr_append_reset </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends CODE_RESET_ALL to a string (<code>char*</code>), but makes sure to do it before any newlines. </p>
<p>Input <em>must be <code>null</code>-terminated</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to append to. <em>Must have extra room for CODE_RESET_ALL</em>. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a25670add558019fdb66a60d51f0ffbda">_colr()</a>, <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>, <a class="el" href="colr_8h.html#ae305b33e0a44b956ccf4123aa4f1a033">ColorText_to_str()</a>, and <a class="el" href="colr_8h.html#a71fcf08ad36d4424790e275d973445fc">colr_join_arrayn()</a>.</p>

</div>
</div>
<a id="a7f1ea562310969b7efa8711a843f103c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f1ea562310969b7efa8711a843f103c">&#9670;&nbsp;</a></span>colr_char_escape_char()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char colr_char_escape_char </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the char needed to represent an escape sequence in C. </p>
<p>The following characters are supported: </p><table class="doxtable">
<tr>
<th align="right">Escape Sequence </th><th align="left">Description Representation  </th></tr>
<tr>
<td align="right">\ ' </td><td align="left">single quote </td></tr>
<tr>
<td align="right">\ " </td><td align="left">double quote </td></tr>
<tr>
<td align="right">\ ? </td><td align="left">question mark </td></tr>
<tr>
<td align="right">\ \ </td><td align="left">backslash </td></tr>
<tr>
<td align="right">\ a </td><td align="left">audible bell </td></tr>
<tr>
<td align="right">\ b </td><td align="left">backspace </td></tr>
<tr>
<td align="right">\ f </td><td align="left">form feed - new page </td></tr>
<tr>
<td align="right">\ n </td><td align="left">line feed - new line </td></tr>
<tr>
<td align="right">\ r </td><td align="left">carriage return </td></tr>
<tr>
<td align="right">\ t </td><td align="left">horizontal tab </td></tr>
<tr>
<td align="right">\ v </td><td align="left">vertical tab </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The character to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The letter, without a backslash, needed to create an escape sequence. If the char doesn't need an escape sequence, it is simply returned.</dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_char_escape_char-example" id="colr_char_escape_char-example" class="diamond-bullet">&#160;</a> colr_char_escape_char example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span> constantchar = <a class="code" href="colr_8c.html#a7f1ea562310969b7efa8711a843f103c">colr_char_escape_char</a>(<span class="charliteral">&#39;\n&#39;</span>);</div><div class="line">assert(constantchar == <span class="charliteral">&#39;n&#39;</span>);</div><div class="line"></div><div class="line"><span class="keywordtype">char</span> constantquote = <a class="code" href="colr_8c.html#a7f1ea562310969b7efa8711a843f103c">colr_char_escape_char</a>(<span class="charliteral">&#39;&quot;&#39;</span>);</div><div class="line">assert(constantquote == <span class="charliteral">&#39;&quot;&#39;</span>);</div><div class="line"></div><div class="line"><span class="comment">// The actual escape sequence would need the backslash added to it:</span></div><div class="line"><span class="keywordtype">char</span>* escaped;</div><div class="line">asprintf(&amp;escaped, <span class="stringliteral">&quot;\\%c&quot;</span>, <a class="code" href="colr_8c.html#a7f1ea562310969b7efa8711a843f103c">colr_char_escape_char</a>(<span class="charliteral">&#39;\t&#39;</span>));</div><div class="line">free(escaped);</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a196ad91a69cfbeb27a5266ffc93ed353">colr_str_repr()</a>.</p>

</div>
</div>
<a id="a7c2bef208b24ea5962b8e1af154772c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c2bef208b24ea5962b8e1af154772c1">&#9670;&nbsp;</a></span>colr_char_in_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_char_in_str </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a character exists in the given string (<code>char*</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Character to search for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>String to check. Input <em>must be <code>null</code>-terminated</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>c</code> is found in <code>s</code>, otherwise <code>false</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ab00c551514ec181b50628b8cc80e5527">colr_str_lstrip_chars()</a>.</p>

</div>
</div>
<a id="ab4fed7123927027262875834964b0a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4fed7123927027262875834964b0a94">&#9670;&nbsp;</a></span>colr_char_is_code_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_char_is_code_end </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a character is suitable for an escape code ending. </p>
<p><code>m</code> is used as the last character in color codes, but other characters can be used for escape sequences (such as "\x1b[2A", cursor up). Actual escape code endings can be in the range (<code>char</code>) 64-126 (inclusive).</p>
<p>Since ColrC only deals with color codes and maybe some cursor/erase codes, this function tests if the character is either <code>A-Z</code> or <code>a-z</code>.</p>
<p>For more information, see: <a href="https://en.wikipedia.org/wiki/ANSI_escape_code">https://en.wikipedia.org/wiki/ANSI_escape_code</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Character to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the character is a possible escape code ending, otherwise <code>false</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a85b2971301b5247769b08f5ed08564fb">colr_str_is_codes()</a>, <a class="el" href="colr_8h.html#a037a0245a39d7ff5cfba5f779d0eb251">colr_str_noncode_len()</a>, and <a class="el" href="colr_8h.html#ab0b13b04dc178d0990ab2ae403ee64e0">colr_str_strip_codes()</a>.</p>

</div>
</div>
<a id="af78a98cb101d4d5f18df0023b3109013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af78a98cb101d4d5f18df0023b3109013">&#9670;&nbsp;</a></span>colr_char_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_char_repr </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation for a char. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Value to create the representation for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a6c35f6b47cc737744487d14d20241656">ColorJustify_repr()</a>.</p>

</div>
</div>
<a id="a67ef4700a46e78c2bed1132428a610fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ef4700a46e78c2bed1132428a610fb">&#9670;&nbsp;</a></span>colr_char_should_escape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_char_should_escape </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if an ascii character has an escape sequence in C. </p>
<p>The following characters are supported: </p><table class="doxtable">
<tr>
<th align="right">Escape Sequence </th><th align="left">Description Representation  </th></tr>
<tr>
<td align="right">\ ' </td><td align="left">single quote </td></tr>
<tr>
<td align="right">\ " </td><td align="left">double quote </td></tr>
<tr>
<td align="right">\ ? </td><td align="left">question mark </td></tr>
<tr>
<td align="right">\ \ </td><td align="left">backslash </td></tr>
<tr>
<td align="right">\ a </td><td align="left">audible bell </td></tr>
<tr>
<td align="right">\ b </td><td align="left">backspace </td></tr>
<tr>
<td align="right">\ f </td><td align="left">form feed - new page </td></tr>
<tr>
<td align="right">\ n </td><td align="left">line feed - new line </td></tr>
<tr>
<td align="right">\ r </td><td align="left">carriage return </td></tr>
<tr>
<td align="right">\ t </td><td align="left">horizontal tab </td></tr>
<tr>
<td align="right">\ v </td><td align="left">vertical tab </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The character to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the character needs an escape sequence, otherwise <code>false</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a196ad91a69cfbeb27a5266ffc93ed353">colr_str_repr()</a>.</p>

</div>
</div>
<a id="a330b20c743df488e74e70e6b0daef62a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a330b20c743df488e74e70e6b0daef62a">&#9670;&nbsp;</a></span>colr_check_marker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_check_marker </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>marker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks an unsigned int against the individual bytes behind a pointer's value. </p>
<p>This helps to guard against overflows, because only a single byte is checked at a time. If any byte doesn't match the marker, <code>false</code> is immediately returned, instead of continuing past the pointer's bounds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">marker</td><td>A colr marker, like COLORARG_MARKER, COLORTEXT_MARKER, etc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A pointer to check, to see if it starts with the marker. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all bytes match the marker, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#ad15f3a714a6383123d3fb24ade173e29" title="Checks a void pointer to see if it contains a ColorArg struct. ">ColorArg_is_ptr</a> <a class="el" href="colr_8c.html#a1d6eb8832110b943c3a3a17627a50288" title="Checks a void pointer to see if it contains a ColorText struct. ">ColorText_is_ptr</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_check_marker-example" id="colr_check_marker-example" class="diamond-bullet">&#160;</a> colr_check_marker example: </div><div class="fragment"><div class="line"><span class="comment">// This is actually used with void pointer, where the type is not known.</span></div><div class="line"><span class="comment">// It&#39;s only known that the pointer will be 1 of 3 types.</span></div><div class="line"><a class="code" href="colr_8h.html#structColorArg">ColorArg</a>* cargp = <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(GREEN);</div><div class="line">assert(<a class="code" href="colr_8c.html#a330b20c743df488e74e70e6b0daef62a">colr_check_marker</a>(<a class="code" href="colr_8h.html#a22fa09afcaf087080075551d293a72fd">COLORARG_MARKER</a>, cargp));</div><div class="line"><a class="code" href="colr_8h.html#a76eae619668e01987653932a7492fd94">colr_free</a>(cargp);</div><div class="line"></div><div class="line"><span class="keywordtype">char</span>* s = <span class="stringliteral">&quot;Not a ColorText at all.&quot;</span>;</div><div class="line">assert(!<a class="code" href="colr_8c.html#a330b20c743df488e74e70e6b0daef62a">colr_check_marker</a>(<a class="code" href="colr_8h.html#afc3756a551f1f8e5dfb56f6ab41d9e07">COLORTEXT_MARKER</a>, s));</div><div class="line"></div><div class="line"><a class="code" href="colr_8h.html#structColorText">ColorText</a>* ctextp = <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;But this is a ColorText.&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(GREEN));</div><div class="line">assert(<a class="code" href="colr_8c.html#a330b20c743df488e74e70e6b0daef62a">colr_check_marker</a>(<a class="code" href="colr_8h.html#afc3756a551f1f8e5dfb56f6ab41d9e07">COLORTEXT_MARKER</a>, ctextp));</div><div class="line"><a class="code" href="colr_8h.html#a76eae619668e01987653932a7492fd94">colr_free</a>(ctextp);</div><div class="line"></div><div class="line">printf(<span class="stringliteral">&quot;colr_check_marker() assertions held up.\n&quot;</span>);</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#ad15f3a714a6383123d3fb24ade173e29">ColorArg_is_ptr()</a>, and <a class="el" href="colr_8h.html#a1d6eb8832110b943c3a3a17627a50288">ColorText_is_ptr()</a>.</p>

</div>
</div>
<a id="a8963c87ccb1c39bdd4481bb81810ba78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8963c87ccb1c39bdd4481bb81810ba78">&#9670;&nbsp;</a></span>colr_empty_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_empty_str </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates an empty string (<code>char*</code>). </p>
<p>This is for keeping the interface simple, so the return values from color functions with invalid values can be consistent.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to an allocated string consisting of '\0'. <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a25670add558019fdb66a60d51f0ffbda">_colr()</a>, <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>, <a class="el" href="colr_8h.html#a91fb398f6463553e576fc067f5a0a854">ColorArg_to_str()</a>, <a class="el" href="colr_8h.html#ae305b33e0a44b956ccf4123aa4f1a033">ColorText_to_str()</a>, <a class="el" href="colr_8h.html#a71fcf08ad36d4424790e275d973445fc">colr_join_arrayn()</a>, <a class="el" href="colr_8h.html#ad32382336586dbda9a7e205403de8a14">colr_str_center()</a>, <a class="el" href="colr_8h.html#ac8be0d81828f73816a447b7440987d91">colr_str_ljust()</a>, <a class="el" href="colr_8h.html#a8fbaa15923af761c5eb99224ef8089b4">colr_str_rjust()</a>, and <a class="el" href="colr_8h.html#ab0b13b04dc178d0990ab2ae403ee64e0">colr_str_strip_codes()</a>.</p>

</div>
</div>
<a id="a701126bd27c90fafa46152d9f9327b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a701126bd27c90fafa46152d9f9327b2f">&#9670;&nbsp;</a></span>colr_join_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_join_array </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>joinerp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join an array of strings (<code>char*</code>), ColorArgs, or ColorTexts by another string (<code>char*</code>), <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">joinerp</td><td>The joiner (any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, or string). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ps</td><td>An array of pointers to ColorArgs, ColorTexts, or strings. The array must have <code>NULL</code> as the last item. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string with the result.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_join_array-example" id="colr_join_array-example" class="diamond-bullet">&#160;</a> colr_join_array example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* joiner = <span class="stringliteral">&quot; [and] &quot;</span>;</div><div class="line"><a class="code" href="colr_8h.html#structColorText">ColorText</a>* words[] = {</div><div class="line">    <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;this&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED)),</div><div class="line">    <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;that&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(<a class="code" href="colr_8h.html#a8fe812f8e76e4baed394ee9adf46b3df">hex</a>(<span class="stringliteral">&quot;ff3599&quot;</span>))),</div><div class="line">    <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;the other&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(BLUE), <a class="code" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662">style</a>(UNDERLINE)),</div><div class="line">    NULL</div><div class="line">};</div><div class="line"><span class="keywordtype">char</span>* s = <a class="code" href="colr_8c.html#a701126bd27c90fafa46152d9f9327b2f">colr_join_array</a>(joiner, words);</div><div class="line">printf(<span class="stringliteral">&quot;%s\n&quot;</span>, s);</div><div class="line">free(s);</div><div class="line"></div><div class="line"><span class="comment">// Don&#39;t forget to free the ColorTexts/ColorArgs.</span></div><div class="line"><span class="keywordtype">size_t</span> i = 0;</div><div class="line"><span class="keywordflow">while</span> (words[i]) <a class="code" href="colr_8c.html#a901e5738358a739629cc3aaccab3e73f">ColorText_free</a>(words[i++]);</div></div><!-- fragment --> </div> <dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2" title="Join ColorArg pointers, ColorText pointers, and strings into one long string. ">colr</a> <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join</a> <a class="el" href="colr_8c.html#a71fcf08ad36d4424790e275d973445fc" title="Join an array of strings (char*), ColorArgs, or ColorTexts by another string (char*), ColorArg, or ColorText. ">colr_join_arrayn</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="colr_join_example_8c-example.html#a8">colr_join_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="a71fcf08ad36d4424790e275d973445fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71fcf08ad36d4424790e275d973445fc">&#9670;&nbsp;</a></span>colr_join_arrayn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_join_arrayn </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>joinerp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join an array of strings (<code>char*</code>), ColorArgs, or ColorTexts by another string (<code>char*</code>), <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">joinerp</td><td>The joiner (any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, or string). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ps</td><td>An array of pointers to ColorArgs, ColorTexts, or strings. The array must have at least a length of <code>count</code>, unless a <code>NULL</code> element is placed at the end. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The total number of items in the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string with the result.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_join_arrayn-example" id="colr_join_arrayn-example" class="diamond-bullet">&#160;</a> colr_join_arrayn example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* joiner = <span class="stringliteral">&quot; [and] &quot;</span>;</div><div class="line"><a class="code" href="colr_8h.html#structColorText">ColorText</a>* words[] = {</div><div class="line">    <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;this&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED)),</div><div class="line">    <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;that&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(<a class="code" href="colr_8h.html#a8fe812f8e76e4baed394ee9adf46b3df">hex</a>(<span class="stringliteral">&quot;ff3599&quot;</span>))),</div><div class="line">    <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;the other&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(BLUE), <a class="code" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662">style</a>(UNDERLINE))</div><div class="line">};</div><div class="line"><span class="comment">// This only works for actual arrays, not malloc&#39;d stuff.</span></div><div class="line"><span class="keywordtype">size_t</span> arr_length = <span class="keyword">sizeof</span>(words) / <span class="keyword">sizeof</span>(words[0]);</div><div class="line"><span class="keywordtype">char</span>* s = <a class="code" href="colr_8c.html#a71fcf08ad36d4424790e275d973445fc">colr_join_arrayn</a>(joiner, words, arr_length);</div><div class="line">printf(<span class="stringliteral">&quot;%s\n&quot;</span>, s);</div><div class="line">free(s);</div><div class="line"></div><div class="line"><span class="comment">// Don&#39;t forget to free the ColorTexts/ColorArgs.</span></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; arr_length; i++) <a class="code" href="colr_8c.html#a901e5738358a739629cc3aaccab3e73f">ColorText_free</a>(words[i]);</div></div><!-- fragment --> </div> <dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2" title="Join ColorArg pointers, ColorText pointers, and strings into one long string. ">colr</a> <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a701126bd27c90fafa46152d9f9327b2f">colr_join_array()</a>.</p>

</div>
</div>
<a id="ad32382336586dbda9a7e205403de8a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad32382336586dbda9a7e205403de8a14">&#9670;&nbsp;</a></span>colr_str_center()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_center </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>padchar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Center-justifies a string (<code>char*</code>), ignoring escape codes when measuring the width. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to justify.<br />
 Input <em>must be <code>null</code>-terminated</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">padchar</td><td>The character to pad with. If '0', then `' '` is used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The overall width for the resulting string.<br />
 If set to '0', the terminal width will be used from <a class="el" href="colr_8c.html#ae4c11bb5b3b1bb2848bb16aee39763b2" title="Attempts to retrieve the row/column size of the terminal and returns a TermSize. ">colr_term_size()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string with the result.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#ac8be0d81828f73816a447b7440987d91" title="Left-justifies a string (char*), ignoring escape codes when measuring the width. ">colr_str_ljust</a> <a class="el" href="colr_8c.html#a8fbaa15923af761c5eb99224ef8089b4" title="Right-justifies a string (char*), ignoring escape codes when measuring the width. ...">colr_str_rjust</a> <a class="el" href="colr_8c.html#ae4c11bb5b3b1bb2848bb16aee39763b2" title="Attempts to retrieve the row/column size of the terminal and returns a TermSize. ">colr_term_size</a> </dd></dl>

</div>
</div>
<a id="ad5e3ecc4a6c4bcaad1217df9200d271e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e3ecc4a6c4bcaad1217df9200d271e">&#9670;&nbsp;</a></span>colr_str_char_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t colr_str_char_count </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of characters (<code>c</code>) that are found in a string (<code>char*</code>) (<code>s</code>). </p>
<p>Returns <code>0</code> if <code>s</code> is <code>NULL</code>, or <code>c</code> is `'\0'`.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to examine. Input <em>must be <code>null</code>-terminated</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The character to count. <em>must not be <code>0</code></em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of times <code>c</code> occurs in <code>s</code>. </dd></dl>

</div>
</div>
<a id="a578b0f213d7b24b3f3c00ff4d3f6e292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a578b0f213d7b24b3f3c00ff4d3f6e292">&#9670;&nbsp;</a></span>colr_str_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_copy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like strncopy, but ensures null-termination. </p>
<p>If src is NULL, or dest is NULL, NULL is returned.</p>
<p>If src does not contain a null-terminator, <em>this function will truncate at <code>length</code> characters</em>.</p>
<p>A null-terminator is always appended to dest.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>Memory allocated for new string. <em>Must have room for <code>strlen(src)</code>.</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source string to copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Maximum characters to copy. <em>This does not include the null-terminator</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a pointer to dest is returned.</dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_copy-example" id="colr_str_copy-example" class="diamond-bullet">&#160;</a> colr_str_copy example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* s = <span class="stringliteral">&quot;testing&quot;</span>;</div><div class="line"><span class="keywordtype">size_t</span> length = strlen(s);</div><div class="line"><span class="keywordtype">char</span>* dest = malloc(length + 1);</div><div class="line"></div><div class="line"><span class="comment">// Copy the entire string:</span></div><div class="line"><a class="code" href="colr_8c.html#a578b0f213d7b24b3f3c00ff4d3f6e292">colr_str_copy</a>(dest, s, length);</div><div class="line">assert(strcmp(dest, <span class="stringliteral">&quot;testing&quot;</span>) == 0);</div><div class="line">printf(<span class="stringliteral">&quot;Copied: %s\n&quot;</span>, dest);</div><div class="line"></div><div class="line"><span class="comment">// Copy only 4 bytes:</span></div><div class="line"><a class="code" href="colr_8c.html#a578b0f213d7b24b3f3c00ff4d3f6e292">colr_str_copy</a>(dest, s, 4);</div><div class="line">assert(strcmp(dest, <span class="stringliteral">&quot;test&quot;</span>) == 0);</div><div class="line">printf(<span class="stringliteral">&quot;Truncated: %s\n&quot;</span>, dest);</div><div class="line">free(dest);</div></div><!-- fragment --> </div> 
</div>
</div>
<a id="ad3339c4d3f1d48ac335b8525f8248020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3339c4d3f1d48ac335b8525f8248020">&#9670;&nbsp;</a></span>colr_str_ends_with()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_str_ends_with </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>suf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if one string (<code>char*</code>) ends with another. </p>
<p><code>str</code> and <code>suf</code> <em>must be <code>null</code>-terminated</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>String to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">suf</td><td>Suffix to check for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <code>str</code> ends with <code>suf</code>. </dd>
<dd>
False if either is NULL, or the string doesn't end with the suffix. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a10030070daafdee7124638adfc5469d8">colr_append_reset()</a>.</p>

</div>
</div>
<a id="a8b9f4cbe1e806316e063206dfb610476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b9f4cbe1e806316e063206dfb610476">&#9670;&nbsp;</a></span>colr_str_has_codes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_str_has_codes </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a string (<code>char*</code>) has ANSI escape codes in it. </p>
<p>This will detect any ansi escape code, not just colors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to check. Can be <code>NULL</code>. Input <em>must be <code>null</code>-terminated</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the string has at least one escape code, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#a85b2971301b5247769b08f5ed08564fb" title="Determines if a string (char*) is composed entirely of escape codes. ">colr_str_is_codes</a> </dd></dl>

</div>
</div>
<a id="a3dc3f370843b64e92fb7d79e7989b5c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc3f370843b64e92fb7d79e7989b5c3">&#9670;&nbsp;</a></span>colr_str_is_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_str_is_all </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a string (<code>char*</code>) consists of only one character, possibly repeated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>String to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Character to test for. Must not be <code>0</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>s</code> contains only the character <code>c</code>, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a85b2971301b5247769b08f5ed08564fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b2971301b5247769b08f5ed08564fb">&#9670;&nbsp;</a></span>colr_str_is_codes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_str_is_codes </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a string (<code>char*</code>) is composed entirely of escape codes. </p>
<p>Returns <code>false</code> if the string is <code>NULL</code>, or empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to check. Input <em>must be <code>null</code>-terminated</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the string is escape-codes only, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#a8b9f4cbe1e806316e063206dfb610476" title="Determines if a string (char*) has ANSI escape codes in it. ">colr_str_has_codes</a> </dd></dl>

</div>
</div>
<a id="af5492da225ade4fd8fe71989826348b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5492da225ade4fd8fe71989826348b4">&#9670;&nbsp;</a></span>colr_str_is_digits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_str_is_digits </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether all characters in a string (<code>char*</code>) are digits. </p>
<p>If <code>s</code> is NULL or an empty string (<code>""</code>), <code>false</code> is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>String to check. Input <em>must be <code>null</code>-terminated</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all characters are digits (0-9), otherwise <code>false</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a2e859d542a8aa0939e4f76b1f33cb5f8">ExtendedValue_from_str()</a>.</p>

</div>
</div>
<a id="ac8be0d81828f73816a447b7440987d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8be0d81828f73816a447b7440987d91">&#9670;&nbsp;</a></span>colr_str_ljust()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_ljust </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>padchar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left-justifies a string (<code>char*</code>), ignoring escape codes when measuring the width. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to justify.<br />
 Input <em>must be <code>null</code>-terminated</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">padchar</td><td>The character to pad with. If '0', then `' '` is used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The overall width for the resulting string.<br />
 If set to '0', the terminal width will be used from <a class="el" href="colr_8c.html#ae4c11bb5b3b1bb2848bb16aee39763b2" title="Attempts to retrieve the row/column size of the terminal and returns a TermSize. ">colr_term_size()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#ad32382336586dbda9a7e205403de8a14" title="Center-justifies a string (char*), ignoring escape codes when measuring the width. ">colr_str_center</a> <a class="el" href="colr_8c.html#a8fbaa15923af761c5eb99224ef8089b4" title="Right-justifies a string (char*), ignoring escape codes when measuring the width. ...">colr_str_rjust</a> <a class="el" href="colr_8c.html#ae4c11bb5b3b1bb2848bb16aee39763b2" title="Attempts to retrieve the row/column size of the terminal and returns a TermSize. ">colr_term_size</a> </dd></dl>

</div>
</div>
<a id="a116ec26960e79456dbf9cf7f40ffe0d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116ec26960e79456dbf9cf7f40ffe0d7">&#9670;&nbsp;</a></span>colr_str_lower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void colr_str_lower </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a string (<code>char*</code>) into lower case in place. </p>
<p>Input <em>must be <code>null</code>-terminated</em>.</p>
<p>If <code>s</code> is <code>NULL</code>, nothing is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The input string to convert to lower case. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab00c551514ec181b50628b8cc80e5527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab00c551514ec181b50628b8cc80e5527">&#9670;&nbsp;</a></span>colr_str_lstrip_chars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_lstrip_chars </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>chars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes certain characters from the start of a string (<code>char*</code>). </p>
<p>The order of the characters in <code>chars</code> does not matter. If any of them are found at the start of a string, they will be removed.</p>
<p><code>colr_str_lstrip_chars("aabbccTEST", "bca") == "TEST"</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to strip. <code>s</code> <em>must be <code>null</code>-terminated</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">chars</td><td>A string of characters to remove. Each will be removed from the start of the string. <code>chars</code> <em>must be <code>null</code>-terminated</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string with the result. May return NULL if <code>s</code> or <code>chars</code> is NULL. <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>. </dd></dl>

</div>
</div>
<a id="ab473f70278850994e1b7b9c8008353fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab473f70278850994e1b7b9c8008353fa">&#9670;&nbsp;</a></span>colr_str_mb_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t colr_str_mb_len </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of characters in a string (<code>char*</code>), taking into account possibly multi-byte characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to get the length of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters, single and multi-byte, or <code>0</code> if <code>s</code> is <code>NULL</code>, empty, or has invalid multibyte sequences. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a7d16a274fbb779576396457264453873">_rainbow()</a>.</p>

</div>
</div>
<a id="a037a0245a39d7ff5cfba5f779d0eb251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037a0245a39d7ff5cfba5f779d0eb251">&#9670;&nbsp;</a></span>colr_str_noncode_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t colr_str_noncode_len </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length of string (<code>char*</code>), ignoring escape codes and the the null-terminator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>String to get the length for. Input <em>must be <code>null</code>-terminated</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the string, as if it didn't contain escape codes.<br />
 For non-escape-code strings, this is like <code>strlen()</code>.<br />
 For <code>NULL</code> or "empty" strings, <code>0</code> is returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#ab0b13b04dc178d0990ab2ae403ee64e0" title="Strips escape codes from a string (char*), resulting in a new allocated string. ">colr_str_strip_codes</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a412833a097b050c8ee99874c733bd030">ColorText_length()</a>, <a class="el" href="colr_8h.html#ad32382336586dbda9a7e205403de8a14">colr_str_center()</a>, <a class="el" href="colr_8h.html#ac8be0d81828f73816a447b7440987d91">colr_str_ljust()</a>, and <a class="el" href="colr_8h.html#a8fbaa15923af761c5eb99224ef8089b4">colr_str_rjust()</a>.</p>

</div>
</div>
<a id="a29047496628c944048314c83f9415a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29047496628c944048314c83f9415a5b">&#9670;&nbsp;</a></span>colr_str_replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces substrings in a string (<code>char*</code>). </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>The string to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The string to replace with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>target</code> is <code>NULL</code>/empty.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a44d236bca80dbce495c0f282c3a7d192">colr_str_replace_ColorArg()</a>, and <a class="el" href="colr_8h.html#a7ec6d96305890148b019602f2301f989">colr_str_replace_ColorText()</a>.</p>

</div>
</div>
<a id="a44d236bca80dbce495c0f282c3a7d192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d236bca80dbce495c0f282c3a7d192">&#9670;&nbsp;</a></span>colr_str_replace_ColorArg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_ColorArg </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace substrings in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>The string to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to produce escape-codes to replace with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>target</code> is <code>NULL</code>/empty.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>. </dd></dl>

</div>
</div>
<a id="a7ec6d96305890148b019602f2301f989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ec6d96305890148b019602f2301f989">&#9670;&nbsp;</a></span>colr_str_replace_ColorText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_ColorText </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace substrings in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>The string to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to produce text/escape-codes to replace with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>target</code> is <code>NULL</code>/empty.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>. </dd></dl>

</div>
</div>
<a id="a196ad91a69cfbeb27a5266ffc93ed353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a196ad91a69cfbeb27a5266ffc93ed353">&#9670;&nbsp;</a></span>colr_str_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_repr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string (<code>char*</code>) into a representation of a string, by wrapping it in quotes and escaping characters that need escaping. </p>
<p>If <code>s</code> is NULL, then an allocated string containing the string "NULL" is returned (without quotes).</p>
<p>Escape codes will be escaped, so the terminal will ignore them if the result is printed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to represent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string with the representation.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#a67ef4700a46e78c2bed1132428a610fb" title="Determines if an ascii character has an escape sequence in C. ">colr_char_should_escape</a> <a class="el" href="colr_8c.html#a7f1ea562310969b7efa8711a843f103c" title="Returns the char needed to represent an escape sequence in C. ">colr_char_escape_char</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_repr-example" id="colr_str_repr-example" class="diamond-bullet">&#160;</a> colr_str_repr example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* s = <a class="code" href="colr_8c.html#a196ad91a69cfbeb27a5266ffc93ed353">colr_str_repr</a>(<span class="stringliteral">&quot;This\nhas \bspecial\tchars.&quot;</span>);</div><div class="line"><span class="comment">// The string `s` contains an escaped string, it *looks like* the definition,</span></div><div class="line"><span class="comment">// but no real newlines, backspaces, or tabs are in it.</span></div><div class="line">assert(strcmp(s, <span class="stringliteral">&quot;\&quot;This\\nhas \\bspecial\\tchars.\&quot;&quot;</span>) == 0);</div><div class="line">free(s);</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a575a6cdc2f65cf1cd25227f847ae8d76">ColorText_repr()</a>.</p>

</div>
</div>
<a id="a8fbaa15923af761c5eb99224ef8089b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fbaa15923af761c5eb99224ef8089b4">&#9670;&nbsp;</a></span>colr_str_rjust()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_rjust </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>padchar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Right-justifies a string (<code>char*</code>), ignoring escape codes when measuring the width. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to justify.<br />
 Input <em>must be <code>null</code>-terminated</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">padchar</td><td>The character to pad with. If '0', then `' '` is used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The overall width for the resulting string.<br />
 If set to '0', the terminal width will be used from <a class="el" href="colr_8c.html#ae4c11bb5b3b1bb2848bb16aee39763b2" title="Attempts to retrieve the row/column size of the terminal and returns a TermSize. ">colr_term_size()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#ad32382336586dbda9a7e205403de8a14" title="Center-justifies a string (char*), ignoring escape codes when measuring the width. ">colr_str_center</a> <a class="el" href="colr_8c.html#ac8be0d81828f73816a447b7440987d91" title="Left-justifies a string (char*), ignoring escape codes when measuring the width. ">colr_str_ljust</a> <a class="el" href="colr_8c.html#ae4c11bb5b3b1bb2848bb16aee39763b2" title="Attempts to retrieve the row/column size of the terminal and returns a TermSize. ">colr_term_size</a> </dd></dl>

</div>
</div>
<a id="a7f001f49e15a8c38e0dc3c6c6c1bb06c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f001f49e15a8c38e0dc3c6c6c1bb06c">&#9670;&nbsp;</a></span>colr_str_starts_with()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_str_starts_with </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks a string (<code>char*</code>) for a certain prefix substring. </p>
<p><code>prefix</code> <em>must be <code>null</code>-terminated</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>The prefix string to look for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the string <code>s</code> starts with prefix. </dd>
<dd>
False if one of the strings is null, or the prefix isn't found. </dd></dl>

</div>
</div>
<a id="ab0b13b04dc178d0990ab2ae403ee64e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b13b04dc178d0990ab2ae403ee64e0">&#9670;&nbsp;</a></span>colr_str_strip_codes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_strip_codes </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Strips escape codes from a string (<code>char*</code>), resulting in a new allocated string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to strip escape codes from. Input <em>must be <code>null</code>-terminated</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string with the result.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#a037a0245a39d7ff5cfba5f779d0eb251" title="Returns the length of string (char*), ignoring escape codes and the the null-terminator. ">colr_str_noncode_len</a> </dd></dl>

</div>
</div>
<a id="ae9b847e10db135f7ebc89031b3a7ad56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b847e10db135f7ebc89031b3a7ad56">&#9670;&nbsp;</a></span>colr_str_to_lower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_to_lower </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new lowercase version of a string (<code>char*</code>). </p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The input string to convert to lower case.<br />
 <em>must be <code>null</code>-terminated</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The allocated string, or <code>NULL</code> if <code>s</code> is <code>NULL</code>.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a2e859d542a8aa0939e4f76b1f33cb5f8">ExtendedValue_from_str()</a>, and <a class="el" href="colr_8h.html#a98c9e50fe14ad0c82bcf1a62699c05de">RGB_from_str()</a>.</p>

</div>
</div>
<a id="ab2ebdcd3c6e598a244292c7605452e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ebdcd3c6e598a244292c7605452e9d">&#9670;&nbsp;</a></span>colr_supports_rgb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_supports_rgb </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether the current environment support <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> (True Colors). </p>
<p>This checks <code>$COLORTERM</code> for the appropriate value (<code>'truecolor'</code> or <code>'24bit'</code>). On "dumber" terminals, <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> codes are probably ignored or mistaken for a 256-color or even 8-color value.</p>
<p>For instance, <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> is supported in <code>konsole</code>, but not in <code>xterm</code> or <code>linux</code> ttys. Using <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> codes in <code>xterm</code> makes the colors appear as though a 256-color value was used (closest matching value, like <a class="el" href="colr_8c.html#ab4576c531151e398b7ecede2e30df70d" title="Convert an RGB value into it&#39;s nearest terminal-friendly RGB value. ">RGB_to_term_RGB()</a>). Using <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> codes in a simpler <code>linux</code> tty makes them appear as though an 8-color value was used. Very ugly, but not a disaster.</p>
<p>I haven't seen a <em>modern</em> linux terminal spew garbage across the screen from using <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> codes when they are not supported, but I could be wrong. I would like to see that terminal if you know of one.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if 24-bit (true color, or "rgb") support is detected, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="ae4c11bb5b3b1bb2848bb16aee39763b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c11bb5b3b1bb2848bb16aee39763b2">&#9670;&nbsp;</a></span>colr_term_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structTermSize">TermSize</a> colr_term_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to retrieve the row/column size of the terminal and returns a <a class="el" href="colr_8h.html#structTermSize" title="Holds a terminal size, usually retrieved with colr_term_size(). ">TermSize</a>. </p>
<p>If the call to <code>ioctl()</code> fails, a default <a class="el" href="colr_8h.html#structTermSize" title="Holds a terminal size, usually retrieved with colr_term_size(). ">TermSize</a> struct is returned: </p><div class="fragment"><div class="line">(<a class="code" href="colr_8h.html#structTermSize">TermSize</a>){.rows=35, .columns=80}</div></div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structTermSize" title="Holds a terminal size, usually retrieved with colr_term_size(). ">TermSize</a> struct with terminal size information. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a412833a097b050c8ee99874c733bd030">ColorText_length()</a>, <a class="el" href="colr_8h.html#ad32382336586dbda9a7e205403de8a14">colr_str_center()</a>, <a class="el" href="colr_8h.html#ac8be0d81828f73816a447b7440987d91">colr_str_ljust()</a>, and <a class="el" href="colr_8h.html#a8fbaa15923af761c5eb99224ef8089b4">colr_str_rjust()</a>.</p>

</div>
</div>
<a id="ae7d7b7bf1080742eeb588ba70ce9ea77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d7b7bf1080742eeb588ba70ce9ea77">&#9670;&nbsp;</a></span>colr_win_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct winsize colr_win_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to retrieve a <code>winsize</code> struct from an <code>ioctl</code> call. </p>
<p>If the call fails, the environment variables <code>LINES</code> and <code>COLUMNS</code> are checked. If that fails, a default <code>winsize</code> struct is returned: </p><div class="fragment"><div class="line">(<span class="keyword">struct </span>winsize){.ws_row=35, .ws_col=80, .ws_xpixel=0, .ws_ypixel=0}</div></div><!-- fragment --><p><code>man ioctl_tty</code> says that <code>.ws_xpixel</code> and <code>.ws_ypixel</code> are unused.</p>
<dl class="section return"><dt>Returns</dt><dd>A <code>winsize</code> struct (<code>sys/ioctl.h</code>) with window size information. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ae4c11bb5b3b1bb2848bb16aee39763b2">colr_term_size()</a>.</p>

</div>
</div>
<a id="afc2c53ebede7f97645f671401bfe356d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc2c53ebede7f97645f671401bfe356d">&#9670;&nbsp;</a></span>colr_win_size_env()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct winsize colr_win_size_env </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get window/terminal size using the environment variables <code>LINES</code>, <code>COLUMNS</code>, or <code>COLS</code>. </p>
<p>This is used as a fallback if the <code>ioctl()</code> call fails in <a class="el" href="colr_8c.html#ae7d7b7bf1080742eeb588ba70ce9ea77" title="Attempts to retrieve a winsize struct from an ioctl call. ">colr_win_size()</a>. If environment variables are not available, a default <code>winsize</code> struct is returned: </p><div class="fragment"><div class="line">(<span class="keyword">struct </span>winsize){.ws_row=35, .ws_col=80, .ws_xpixel=0, .ws_ypixel=0}</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>A <code>winsize</code> struct (<code>sys/ioctl.h</code>) with window size information. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ae7d7b7bf1080742eeb588ba70ce9ea77">colr_win_size()</a>.</p>

</div>
</div>
<a id="ac847d91a396ae6babc0bd46e6386a701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac847d91a396ae6babc0bd46e6386a701">&#9670;&nbsp;</a></span>ExtendedValue_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ExtendedValue_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two ExtendedValues. </p>
<p>This is used to implement <a class="el" href="colr_8h.html#a36af8aa0f01eaa780da182e856923faa" title="Calls the &lt;type&gt;_eq functions for the supported types. ">colr_eq()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first ExtendedValue to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second ExtendedValue to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if they are equal, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a0632d78965000b1e50068a64e335133b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0632d78965000b1e50068a64e335133b">&#9670;&nbsp;</a></span>ExtendedValue_from_hex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ExtendedValue_from_hex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hexstr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an ExtendedValue from a hex string (<code>char*</code>). </p>
<p>This is not a 1:1 translation of hex to rgb. Use <a class="el" href="colr_8c.html#a5e0c7cd639abdb4aafd4c592a3d79263" title="Convert a hex color into an RGB value. ">RGB_from_hex()</a> for that. This will convert the hex string to the closest matching ExtendedValue value.</p>
<p>The format for hex strings can be one of:</p><ul>
<li>"[#]ffffff" (Leading hash symbol is optional)</li>
<li>"[#]fff" (short-form)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hexstr</td><td>Hex string to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value between 0 and 255 on success. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">COLOR_INVALID</td><td>on error or bad values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94" title="Convenience typedef for clarity when dealing with extended (256) colors. ">ExtendedValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a757be189530b4925c84df25742374485">ExtendedValue_from_hex_default()</a>, and <a class="el" href="colr_8h.html#a2e859d542a8aa0939e4f76b1f33cb5f8">ExtendedValue_from_str()</a>.</p>

</div>
</div>
<a id="a757be189530b4925c84df25742374485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a757be189530b4925c84df25742374485">&#9670;&nbsp;</a></span>ExtendedValue_from_hex_default()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a> ExtendedValue_from_hex_default </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hexstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an ExtendedValue from a hex string (<code>char*</code>), but return a default value if the hex string is invalid. </p>
<p>This is not a 1:1 translation of hex to rgb. Use <a class="el" href="colr_8c.html#a6133112d9c73a8b56995e16e1af62d3b" title="Convert a hex color into an RGB value, but use a default value when errors occur. ...">RGB_from_hex_default()</a> for that. This will convert the hex string to the closest matching ExtendedValue value.</p>
<p>The format for hex strings can be one of:</p><ul>
<li>"[#]ffffff" (Leading hash symbol is optional)</li>
<li>"[#]fff" (short-form)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hexstr</td><td>Hex string to convert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_value</td><td>ExtendedValue to use for bad hex strings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ExtendedValue on success, or <code>default_value</code> on error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94" title="Convenience typedef for clarity when dealing with extended (256) colors. ">ExtendedValue</a> </dd>
<dd>
<a class="el" href="colr_8c.html#a0632d78965000b1e50068a64e335133b" title="Create an ExtendedValue from a hex string (char*). ">ExtendedValue_from_hex</a> </dd></dl>

</div>
</div>
<a id="a1548d9fc5f3e00a7b5d834eb1e12ff93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1548d9fc5f3e00a7b5d834eb1e12ff93">&#9670;&nbsp;</a></span>ExtendedValue_from_RGB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a> ExtendedValue_from_RGB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value into the closest matching ExtendedValue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ExtendedValue that closely matches the original <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94" title="Convenience typedef for clarity when dealing with extended (256) colors. ">ExtendedValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a0632d78965000b1e50068a64e335133b">ExtendedValue_from_hex()</a>, <a class="el" href="colr_8h.html#a185cec167afe41b6401206659d2d406c">format_bg_RGB_term()</a>, and <a class="el" href="colr_8h.html#a4661c576a4da879b8d4a2c525a42ad78">format_fg_RGB_term()</a>.</p>

</div>
</div>
<a id="a2e859d542a8aa0939e4f76b1f33cb5f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e859d542a8aa0939e4f76b1f33cb5f8">&#9670;&nbsp;</a></span>ExtendedValue_from_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ExtendedValue_from_str </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a known name, integer string (0-255), or a hex string (<code>char*</code>), into an ExtendedValue suitable for the extended-value-based functions. </p>
<p>Hex strings can be used:</p><ul>
<li>"#ffffff" (Leading hash symbol is <b>NOT</b> optional)</li>
<li>"#fff" (short-form)</li>
</ul>
<p>The `'#'` is not optional for hex strings because it is impossible to tell the difference between the hex value '111' and the extended value '111' without it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Color name to find the ExtendedValue for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value between 0 and 255 on success. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">COLOR_INVALID</td><td>on error or bad values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94" title="Convenience typedef for clarity when dealing with extended (256) colors. ">ExtendedValue</a> </dd></dl>

</div>
</div>
<a id="aa45baebc38756a40e7084f8198999902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa45baebc38756a40e7084f8198999902">&#9670;&nbsp;</a></span>ExtendedValue_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ExtendedValue_repr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation of a ExtendedValue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eval</td><td>A ExtendedValue to get the value from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an allocated string.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94" title="Convenience typedef for clarity when dealing with extended (256) colors. ">ExtendedValue</a> </dd></dl>

</div>
</div>
<a id="a4e334d6b9145fca9717fe5a2aeb542fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e334d6b9145fca9717fe5a2aeb542fe">&#9670;&nbsp;</a></span>ExtendedValue_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ExtendedValue_to_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>&#160;</td>
          <td class="paramname"><em>eval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) from an ExtendedValue's actual value, suitable for use with <a class="el" href="colr_8c.html#a2e859d542a8aa0939e4f76b1f33cb5f8" title="Converts a known name, integer string (0-255), or a hex string (char*), into an ExtendedValue suitabl...">ExtendedValue_from_str()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eval</td><td>A ExtendedValue to get the value from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an allocated string<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94" title="Convenience typedef for clarity when dealing with extended (256) colors. ">ExtendedValue</a> </dd></dl>

</div>
</div>
<a id="ae29032483aea8cb25d6b90750767ffc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae29032483aea8cb25d6b90750767ffc1">&#9670;&nbsp;</a></span>format_bg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_bg </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for a background color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. <em>Must have enough room for <code>CODEX_LEN</code>.</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>BasicValue value to use for background. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a539627d29410dee484a6cd59198c72ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a539627d29410dee484a6cd59198c72ea">&#9670;&nbsp;</a></span>format_bg_rgb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_bg_rgb </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>redval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>greenval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>blueval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for a true color (rgb) background color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. <em>Must have enough room for <code>CODE_RGB_LEN</code>.</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">redval</td><td>Value for red. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">greenval</td><td>Value for green. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blueval</td><td>Value for blue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97257ad40619df6a6c190890ff2873c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97257ad40619df6a6c190890ff2873c4">&#9670;&nbsp;</a></span>format_bg_RGB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_bg_RGB </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for a true color (rgb) background color using values from an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. <em>Must have enough room for <code>CODE_RGB_LEN</code>.</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct to get red, blue, and green values from. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a15a88e36717ca1e6a4892d2ffda1f4f3">format_bg_rgb()</a>, and <a class="el" href="colr_8h.html#a69dd994da51a57fc3cedb5ade591d5c1">rainbow_bg()</a>.</p>

</div>
</div>
<a id="a185cec167afe41b6401206659d2d406c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a185cec167afe41b6401206659d2d406c">&#9670;&nbsp;</a></span>format_bg_RGB_term()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_bg_RGB_term </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for a true color (rgb) fore color using an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct's values, approximating 256-color values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td>Pointer to an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ab261b60d6d790f5a3c91883a1b6646a7">rainbow_bg_term()</a>.</p>

</div>
</div>
<a id="aa4853b53fa18d26741ab7178606e5724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4853b53fa18d26741ab7178606e5724">&#9670;&nbsp;</a></span>format_bgx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_bgx </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for an extended background color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. <em>Must have enough room for <code>CODEX_LEN</code>.</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>Value to use for background. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a185cec167afe41b6401206659d2d406c">format_bg_RGB_term()</a>.</p>

</div>
</div>
<a id="a6027d93e8768f3c152edafd92e757801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6027d93e8768f3c152edafd92e757801">&#9670;&nbsp;</a></span>format_fg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_fg </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for a fore color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. <em>Must have enough room for <code>CODEX_LEN</code>.</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>BasicValue value to use for fore. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63496434a5fc178504034514dc1e285c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63496434a5fc178504034514dc1e285c">&#9670;&nbsp;</a></span>format_fg_rgb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_fg_rgb </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>redval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>greenval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>blueval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for a true color (rgb) fore color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. <em>Must have enough room for <code>CODE_RGB_LEN</code>.</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">redval</td><td>Value for red. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">greenval</td><td>Value for green. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blueval</td><td>Value for blue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3391a0cd6b6f73d9d39f8179fc0eb0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3391a0cd6b6f73d9d39f8179fc0eb0b">&#9670;&nbsp;</a></span>format_fg_RGB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_fg_RGB </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for a true color (rgb) fore color using an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct's values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td>Pointer to an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#aca1991134c0d649bdc57b86140b6c2b0">format_fg_rgb()</a>, and <a class="el" href="colr_8h.html#a7aed06cce3570d914738ce3f517e7ee9">rainbow_fg()</a>.</p>

</div>
</div>
<a id="a4661c576a4da879b8d4a2c525a42ad78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4661c576a4da879b8d4a2c525a42ad78">&#9670;&nbsp;</a></span>format_fg_RGB_term()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_fg_RGB_term </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for a true color (rgb) fore color using an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct's values, approximating 256-color values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td>Pointer to an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#aa740f000c6d3ebe24734411e83125e37">rainbow_fg_term()</a>.</p>

</div>
</div>
<a id="acfd2cf68768c59fc3ed5c31b93590c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfd2cf68768c59fc3ed5c31b93590c53">&#9670;&nbsp;</a></span>format_fgx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_fgx </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for an extended fore color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. <em>Must have enough room for <code>CODEX_LEN</code>.</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>Value to use for fore. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a4661c576a4da879b8d4a2c525a42ad78">format_fg_RGB_term()</a>.</p>

</div>
</div>
<a id="a6aec8e6a80b4ca158df2ad20e3e6a59e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aec8e6a80b4ca158df2ad20e3e6a59e">&#9670;&nbsp;</a></span>format_style()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_style </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>&#160;</td>
          <td class="paramname"><em>style</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for a style. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. <em>Must have enough room for <code>STYLE_LEN</code>.</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">style</td><td>StyleValue value to use for style. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69dd994da51a57fc3cedb5ade591d5c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69dd994da51a57fc3cedb5ade591d5c1">&#9670;&nbsp;</a></span>rainbow_bg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* rainbow_bg </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rainbow-ize some text using rgb back colors, lolcat style. </p>
<p>This prepends a color code to every character in the string. Multi-byte characters are handled properly by checking <code>mblen()</code>, and copying the bytes to the resulting string without codes between the multi-byte characters.</p>
<p>The <code>CODE_RESET_ALL</code> code is appended to the result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to colorize. Input <em>must be <code>null</code>-terminated</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freq</td><td>Frequency ("tightness") for the colors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Starting offset in the rainbow. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The allocated/formatted string on success.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>. </dd></dl>

</div>
</div>
<a id="ab261b60d6d790f5a3c91883a1b6646a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab261b60d6d790f5a3c91883a1b6646a7">&#9670;&nbsp;</a></span>rainbow_bg_term()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* rainbow_bg_term </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is exactly like <a class="el" href="colr_8c.html#a69dd994da51a57fc3cedb5ade591d5c1" title="Rainbow-ize some text using rgb back colors, lolcat style. ">rainbow_bg()</a>, except it uses colors that are closer to the standard 256-color values. </p>
<p>This prepends a color code to every character in the string. Multi-byte characters are handled properly by checking <code>mblen()</code>, and copying the bytes to the resulting string without codes between the multi-byte characters.</p>
<p>The <code>CODE_RESET_ALL</code> code is appended to the result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to colorize. Input <em>must be <code>null</code>-terminated</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freq</td><td>Frequency ("tightness") for the colors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Starting offset in the rainbow. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The allocated/formatted string on success.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>. </dd></dl>

</div>
</div>
<a id="a7aed06cce3570d914738ce3f517e7ee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aed06cce3570d914738ce3f517e7ee9">&#9670;&nbsp;</a></span>rainbow_fg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* rainbow_fg </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rainbow-ize some text using rgb fore colors, lolcat style. </p>
<p>This prepends a color code to every character in the string. Multi-byte characters are handled properly by checking <code>mblen()</code>, and copying the bytes to the resulting string without codes between the multi-byte characters.</p>
<p>The <code>CODE_RESET_ALL</code> code is appended to the result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to colorize. Input <em>must be <code>null</code>-terminated</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freq</td><td>Frequency ("tightness") for the colors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Starting offset in the rainbow. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The allocated/formatted string on success.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>. </dd></dl>

</div>
</div>
<a id="aa740f000c6d3ebe24734411e83125e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa740f000c6d3ebe24734411e83125e37">&#9670;&nbsp;</a></span>rainbow_fg_term()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* rainbow_fg_term </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is exactly like <a class="el" href="colr_8c.html#a7aed06cce3570d914738ce3f517e7ee9" title="Rainbow-ize some text using rgb fore colors, lolcat style. ">rainbow_fg()</a>, except it uses colors that are closer to the standard 256-color values. </p>
<p>This prepends a color code to every character in the string. Multi-byte characters are handled properly by checking <code>mblen()</code>, and copying the bytes to the resulting string without codes between the multi-byte characters.</p>
<p>The <code>CODE_RESET_ALL</code> code is appended to the result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to colorize. Input <em>must be <code>null</code>-terminated</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freq</td><td>Frequency ("tightness") for the colors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Starting offset in the rainbow. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The allocated/formatted string on success.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>. </dd></dl>

</div>
</div>
<a id="a3580f33d058571dffd8e5ff789c49296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3580f33d058571dffd8e5ff789c49296">&#9670;&nbsp;</a></span>rainbow_step()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structRGB">RGB</a> rainbow_step </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A single step in rainbow-izing produces the next color in the "rainbow" as an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">freq</td><td>Frequency ("tightness") of the colors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Starting offset in the rainbow.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value with the next "step" in the "rainbow". </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a7d16a274fbb779576396457264453873">_rainbow()</a>.</p>

</div>
</div>
<a id="ad4b5f73b8aa9d72216d7386221418ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b5f73b8aa9d72216d7386221418ae1">&#9670;&nbsp;</a></span>RGB_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RGB_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> structs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>a</code> and <code>b</code> have the same <code>r</code>, <code>g</code>, and <code>b</code> values, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#adf57e195301864cec80739e7e0f3000c">ColorValue_eq()</a>, and <a class="el" href="colr_8h.html#a1548d9fc5f3e00a7b5d834eb1e12ff93">ExtendedValue_from_RGB()</a>.</p>

</div>
</div>
<a id="a5e0c7cd639abdb4aafd4c592a3d79263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e0c7cd639abdb4aafd4c592a3d79263">&#9670;&nbsp;</a></span>RGB_from_hex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RGB_from_hex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hexstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a> *&#160;</td>
          <td class="paramname"><em>rgbval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a hex color into an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value. </p>
<p>The format for hex strings can be one of:</p><ul>
<li>"[#]ffffff" (Leading hash symbol is optional)</li>
<li>"[#]fff" (short-form)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hexstr</td><td>String to check for hex values. Input <em>must be <code>null</code>-terminated</em>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rgbval</td><td>Pointer to an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct to fill in the values for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success, with <code>rgbval</code> filled with the values. </td></tr>
    <tr><td class="paramname">COLOR_INVALID</td><td>for non-hex strings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a0632d78965000b1e50068a64e335133b">ExtendedValue_from_hex()</a>, <a class="el" href="colr_8h.html#a6133112d9c73a8b56995e16e1af62d3b">RGB_from_hex_default()</a>, and <a class="el" href="colr_8h.html#a98c9e50fe14ad0c82bcf1a62699c05de">RGB_from_str()</a>.</p>

</div>
</div>
<a id="a6133112d9c73a8b56995e16e1af62d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6133112d9c73a8b56995e16e1af62d3b">&#9670;&nbsp;</a></span>RGB_from_hex_default()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structRGB">RGB</a> RGB_from_hex_default </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hexstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a hex color into an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value, but use a default value when errors occur. </p>
<p>The format for hex strings can be one of:</p><ul>
<li>"[#]ffffff" (Leading hash symbol is optional)</li>
<li>"[#]fff" (short-form)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hexstr</td><td>String to check for <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> values. Input <em>must be <code>null</code>-terminated</em>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">default_value</td><td>An <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value to use when errors occur.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A valid <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value on success, or <code>default_value</code> on error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a8fe812f8e76e4baed394ee9adf46b3df" title="Use RGB_from_hex_default() to create an RGB value. ">hex</a> </dd></dl>

</div>
</div>
<a id="a0943a956bc1491d6a6996ddc99a4d2dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0943a956bc1491d6a6996ddc99a4d2dd">&#9670;&nbsp;</a></span>RGB_from_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RGB_from_str </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a> *&#160;</td>
          <td class="paramname"><em>rgbval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> string (<code>char*</code>) into an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value. </p>
<p>The format for <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> strings can be one of:</p><ul>
<li>"RED,GREEN,BLUE"</li>
<li>"RED GREEN BLUE"</li>
<li>"RED:GREEN:BLUE"</li>
<li>"RED;GREEN;BLUE" Or hex strings can be used:</li>
<li>"#ffffff" (Leading hash symbol is <b>NOT</b> optional)</li>
<li>"#fff" (short-form)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>String to check for <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> values. Input <em>must be <code>null</code>-terminated</em>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rgbval</td><td>Pointer to an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct to fill in the values for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success, with <code>rgbval</code> filled with the values. </td></tr>
    <tr><td class="paramname">COLOR_INVALID</td><td>for non-rgb strings. </td></tr>
    <tr><td class="paramname">COLOR_INVALID_RANGE</td><td>for rgb values outside of 0-255.</td></tr>
  </table>
  </dd>
</dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#RGB_from_str-example" id="RGB_from_str-example" class="diamond-bullet">&#160;</a> RGB_from_str example: </div><div class="fragment"><div class="line"><a class="code" href="colr_8h.html#structRGB">RGB</a> rgbval;</div><div class="line"><span class="keywordtype">int</span> ret = <a class="code" href="colr_8c.html#a0943a956bc1491d6a6996ddc99a4d2dd">RGB_from_str</a>(<span class="stringliteral">&quot;123,0,234&quot;</span>, &amp;rgbval);</div><div class="line"><span class="keywordflow">if</span> (ret != <a class="code" href="colr_8h.html#aaaddb0f34c1374c29a8b7629ac40ca8b">COLOR_INVALID</a>) {</div><div class="line">    <span class="keywordtype">char</span>* s = <a class="code" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2">colr</a>(<a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;Test&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(rgbval)));</div><div class="line">    printf(<span class="stringliteral">&quot;%s\n&quot;</span>, s);</div><div class="line">    free(s);</div><div class="line">}</div></div><!-- fragment --> </div> <dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

</div>
</div>
<a id="afd28864afbcfa4a344e4596130645177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd28864afbcfa4a344e4596130645177">&#9670;&nbsp;</a></span>RGB_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* RGB_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation for an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value. </p>
<p>Allocates memory for the string representation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct to get the representation for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Allocated string for the representation.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

</div>
</div>
<a id="a95e4feb89e009f00cfe7e74a55fab56f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e4feb89e009f00cfe7e74a55fab56f">&#9670;&nbsp;</a></span>RGB_to_hex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* RGB_to_hex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value into a hex string (<code>char*</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

</div>
</div>
<a id="a16d2f9a1133c8a955f0a551870d7ebe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16d2f9a1133c8a955f0a551870d7ebe8">&#9670;&nbsp;</a></span>RGB_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* RGB_to_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value into an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> string (<code>char*</code>) suitable for input to <a class="el" href="colr_8c.html#a0943a956bc1491d6a6996ddc99a4d2dd" title="Convert an RGB string (char*) into an RGB value. ">RGB_from_str()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string in the form <code>"red;green;blue"</code>.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>. </dd></dl>

</div>
</div>
<a id="ab4576c531151e398b7ecede2e30df70d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4576c531151e398b7ecede2e30df70d">&#9670;&nbsp;</a></span>RGB_to_term_RGB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structRGB">RGB</a> RGB_to_term_RGB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value into it's nearest terminal-friendly <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value. </p>
<p>This is a helper for the 'to_term' functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> with values close to a terminal code color.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a1548d9fc5f3e00a7b5d834eb1e12ff93">ExtendedValue_from_RGB()</a>.</p>

</div>
</div>
<a id="a32bf31475b0f6264b45438bd5c09ee7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32bf31475b0f6264b45438bd5c09ee7d">&#9670;&nbsp;</a></span>StyleValue_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool StyleValue_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two StyleValues. </p>
<p>This is used to implement <a class="el" href="colr_8h.html#a36af8aa0f01eaa780da182e856923faa" title="Calls the &lt;type&gt;_eq functions for the supported types. ">colr_eq()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first StyleValue to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second StyleValue to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if they are equal, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a4ca63735ad2cbc6475d4af83dc7c1a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ca63735ad2cbc6475d4af83dc7c1a9b">&#9670;&nbsp;</a></span>StyleValue_from_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a> StyleValue_from_str </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a named argument to actual StyleValue enum value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Style name to convert into a StyleValue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A usable StyleValue value on success, or STYLE_INVALID on error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6" title="Style values. ">StyleValue</a> </dd></dl>

</div>
</div>
<a id="a24b74664587dd3c0e981603ee75c331b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b74664587dd3c0e981603ee75c331b">&#9670;&nbsp;</a></span>StyleValue_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* StyleValue_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>&#160;</td>
          <td class="paramname"><em>sval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation of a StyleValue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sval</td><td>A StyleValue to get the value from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an allocated string.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6" title="Style values. ">StyleValue</a> </dd></dl>

</div>
</div>
<a id="a41b4ed49acc5d806f161a3b31f5bf023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b4ed49acc5d806f161a3b31f5bf023">&#9670;&nbsp;</a></span>TermSize_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* TermSize_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structTermSize">TermSize</a>&#160;</td>
          <td class="paramname"><em>ts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a string (<code>char*</code>) representation for a <a class="el" href="colr_8h.html#structTermSize" title="Holds a terminal size, usually retrieved with colr_term_size(). ">TermSize</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td><a class="el" href="colr_8h.html#structTermSize" title="Holds a terminal size, usually retrieved with colr_term_size(). ">TermSize</a> to get the representation for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string with the result.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a3a3db0fb0c98d24ec072dfed5f88d717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a3db0fb0c98d24ec072dfed5f88d717">&#9670;&nbsp;</a></span>basic_names</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="colr_8h.html#structBasicInfo">BasicInfo</a> basic_names[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">    {<span class="stringliteral">&quot;none&quot;</span>, RESET},</div><div class="line">    {<span class="stringliteral">&quot;reset&quot;</span>, RESET},</div><div class="line">    {<span class="stringliteral">&quot;black&quot;</span>, BLACK},</div><div class="line">    {<span class="stringliteral">&quot;blue&quot;</span>, BLUE},</div><div class="line">    {<span class="stringliteral">&quot;cyan&quot;</span>, CYAN},</div><div class="line">    {<span class="stringliteral">&quot;green&quot;</span>, GREEN},</div><div class="line">    {<span class="stringliteral">&quot;magenta&quot;</span>, MAGENTA},</div><div class="line">    {<span class="stringliteral">&quot;normal&quot;</span>, WHITE},</div><div class="line">    {<span class="stringliteral">&quot;red&quot;</span>, RED},</div><div class="line">    {<span class="stringliteral">&quot;white&quot;</span>, WHITE},</div><div class="line">    {<span class="stringliteral">&quot;yellow&quot;</span>, YELLOW},</div><div class="line">    {<span class="stringliteral">&quot;lightblack&quot;</span>, LIGHTBLACK},</div><div class="line">    {<span class="stringliteral">&quot;lightblue&quot;</span>, LIGHTBLUE},</div><div class="line">    {<span class="stringliteral">&quot;lightcyan&quot;</span>, LIGHTCYAN},</div><div class="line">    {<span class="stringliteral">&quot;lightgreen&quot;</span>, LIGHTGREEN},</div><div class="line">    {<span class="stringliteral">&quot;lightmagenta&quot;</span>, LIGHTMAGENTA},</div><div class="line">    {<span class="stringliteral">&quot;lightnormal&quot;</span>, LIGHTWHITE},</div><div class="line">    {<span class="stringliteral">&quot;lightred&quot;</span>, LIGHTRED},</div><div class="line">    {<span class="stringliteral">&quot;lightwhite&quot;</span>, LIGHTWHITE},</div><div class="line">    {<span class="stringliteral">&quot;lightyellow&quot;</span>, LIGHTYELLOW},</div><div class="line">}</div></div><!-- fragment -->
<p>A list of <a class="el" href="colr_8h.html#structBasicInfo" title="Holds a known color name and it&#39;s BasicValue. ">BasicInfo</a> items, used with <a class="el" href="colr_8c.html#a4163ac65dca3e222525808b80a40b733" title="Convert named argument to an actual BasicValue enum value. ">BasicValue_from_str()</a>. </p>

</div>
</div>
<a id="afb4b773fe2fc7907fdfcf5ef9b202758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4b773fe2fc7907fdfcf5ef9b202758">&#9670;&nbsp;</a></span>ext2rgb_map</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="colr_8h.html#structRGB">RGB</a> ext2rgb_map[]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A map from ExtendedValue (256-color) to <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value, where the index is the is the ExtendedValue, and the value is the <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a>. </p>
<p>This is used in several RGB/ExtendedValue functions.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#a1548d9fc5f3e00a7b5d834eb1e12ff93" title="Convert an RGB value into the closest matching ExtendedValue. ">ExtendedValue_from_RGB</a> <a class="el" href="colr_8c.html#ab4576c531151e398b7ecede2e30df70d" title="Convert an RGB value into it&#39;s nearest terminal-friendly RGB value. ">RGB_to_term_RGB</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#ext2rgb_map-example" id="ext2rgb_map-example" class="diamond-bullet">&#160;</a> ext2rgb_map example: </div><div class="fragment"><div class="line"><span class="comment">// Fast map an ExtendedValue to an RGB value.</span></div><div class="line"><a class="code" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a> eval = 9; <span class="comment">// 9 happens to be XRED (255;0;0 in RGB).</span></div><div class="line"><a class="code" href="colr_8h.html#structRGB">RGB</a> rgbval = <a class="code" href="colr_8c.html#afb4b773fe2fc7907fdfcf5ef9b202758">ext2rgb_map</a>[eval];</div><div class="line"></div><div class="line"><span class="comment">// The result from ExtendedValue_from_RGB should always match the map.</span></div><div class="line">assert(<a class="code" href="colr_8c.html#a1548d9fc5f3e00a7b5d834eb1e12ff93">ExtendedValue_from_RGB</a>(rgbval) == eval);</div><div class="line"></div><div class="line"><span class="comment">// Also, the result of RGB_to_term_RGB() should always be in the map.</span></div><div class="line">assert(<a class="code" href="colr_8c.html#ad4b5f73b8aa9d72216d7386221418ae1">RGB_eq</a>(<a class="code" href="colr_8c.html#afb4b773fe2fc7907fdfcf5ef9b202758">ext2rgb_map</a>[eval], <a class="code" href="colr_8c.html#ab4576c531151e398b7ecede2e30df70d">RGB_to_term_RGB</a>(<a class="code" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>(255, 47, 23))));</div></div><!-- fragment --> </div> 
</div>
</div>
<a id="abffaf3629342a2b3e9cb7ea53c12c4f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abffaf3629342a2b3e9cb7ea53c12c4f0">&#9670;&nbsp;</a></span>extended_names</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="colr_8h.html#structExtendedInfo">ExtendedInfo</a> extended_names[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">    {<span class="stringliteral">&quot;xred&quot;</span>, XRED},</div><div class="line">    {<span class="stringliteral">&quot;xgreen&quot;</span>, XGREEN},</div><div class="line">    {<span class="stringliteral">&quot;xyellow&quot;</span>, XYELLOW},</div><div class="line">    {<span class="stringliteral">&quot;xblue&quot;</span>, XBLUE},</div><div class="line">    {<span class="stringliteral">&quot;xmagenta&quot;</span>, XMAGENTA},</div><div class="line">    {<span class="stringliteral">&quot;xcyan&quot;</span>, XCYAN},</div><div class="line">    {<span class="stringliteral">&quot;xnormal&quot;</span>, XWHITE},</div><div class="line">    {<span class="stringliteral">&quot;xwhite&quot;</span>, XWHITE},</div><div class="line">    {<span class="stringliteral">&quot;xlightred&quot;</span>, XLIGHTRED},</div><div class="line">    {<span class="stringliteral">&quot;xlightgreen&quot;</span>, XLIGHTGREEN},</div><div class="line">    {<span class="stringliteral">&quot;xlightyellow&quot;</span>, XLIGHTYELLOW},</div><div class="line">    {<span class="stringliteral">&quot;xlightblack&quot;</span>, XLIGHTBLACK},</div><div class="line">    {<span class="stringliteral">&quot;xlightblue&quot;</span>, XLIGHTBLUE},</div><div class="line">    {<span class="stringliteral">&quot;xlightmagenta&quot;</span>, XLIGHTMAGENTA},</div><div class="line">    {<span class="stringliteral">&quot;xlightwhite&quot;</span>, XLIGHTWHITE},</div><div class="line">    {<span class="stringliteral">&quot;xlightcyan&quot;</span>, XLIGHTCYAN},</div><div class="line">    {<span class="stringliteral">&quot;xlightnormal&quot;</span>, XLIGHTWHITE},</div><div class="line">}</div></div><!-- fragment -->
<p>A list of <a class="el" href="colr_8h.html#structExtendedInfo" title="Holds a known color name and it&#39;s ExtendedValue. ">ExtendedInfo</a>, used with <a class="el" href="colr_8c.html#a2e859d542a8aa0939e4f76b1f33cb5f8" title="Converts a known name, integer string (0-255), or a hex string (char*), into an ExtendedValue suitabl...">ExtendedValue_from_str()</a>. </p>

</div>
</div>
<a id="a9303c010fd45eab23c7903d1175ae20a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9303c010fd45eab23c7903d1175ae20a">&#9670;&nbsp;</a></span>style_names</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="colr_8h.html#structStyleInfo">StyleInfo</a> style_names[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">    {<span class="stringliteral">&quot;none&quot;</span>, RESET_ALL},</div><div class="line">    {<span class="stringliteral">&quot;reset&quot;</span>, RESET_ALL},</div><div class="line">    {<span class="stringliteral">&quot;reset-all&quot;</span>, RESET_ALL},</div><div class="line">    {<span class="stringliteral">&quot;reset_all&quot;</span>, RESET_ALL},</div><div class="line">    {<span class="stringliteral">&quot;reset all&quot;</span>, RESET_ALL},</div><div class="line">    {<span class="stringliteral">&quot;bold&quot;</span>, BRIGHT},</div><div class="line">    {<span class="stringliteral">&quot;bright&quot;</span>, BRIGHT},</div><div class="line">    {<span class="stringliteral">&quot;dim&quot;</span>, DIM},</div><div class="line">    {<span class="stringliteral">&quot;italic&quot;</span>, ITALIC},</div><div class="line">    {<span class="stringliteral">&quot;underline&quot;</span>, UNDERLINE},</div><div class="line">    {<span class="stringliteral">&quot;flash&quot;</span>, FLASH},</div><div class="line">    {<span class="stringliteral">&quot;highlight&quot;</span>, HIGHLIGHT},</div><div class="line">    {<span class="stringliteral">&quot;normal&quot;</span>, NORMAL},</div><div class="line">    {<span class="stringliteral">&quot;strikethru&quot;</span>, STRIKETHRU},</div><div class="line">    {<span class="stringliteral">&quot;strike&quot;</span>, STRIKETHRU},</div><div class="line">    {<span class="stringliteral">&quot;strikethrough&quot;</span>, STRIKETHRU},</div><div class="line">    {<span class="stringliteral">&quot;frame&quot;</span>, FRAME},</div><div class="line">    {<span class="stringliteral">&quot;encircle&quot;</span>, ENCIRCLE},</div><div class="line">    {<span class="stringliteral">&quot;circle&quot;</span>, ENCIRCLE},</div><div class="line">    {<span class="stringliteral">&quot;overline&quot;</span>, OVERLINE},</div><div class="line">}</div></div><!-- fragment -->
<p>A list of <a class="el" href="colr_8h.html#structStyleInfo" title="Holds a known style name and it&#39;s StyleValue. ">StyleInfo</a> items, used with StyleName_from_str(). </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="colr_8c.html">colr.c</a></li>
    <li class="footer">Generated by
        <a href="http://www.doxygen.org/index.html">
        Doxygen <!-- <img class="footer" src="doxygen.png" alt="doxygen"/> -->
        </a>
        1.8.13
    </li>
  </ul>
</div>
</body>
</html>
