<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ColrC: colr.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo">
    <a href="/colrc" alt="ColrC">
      <img alt="Logo" src="colrc-pixels.png"/>
    </a>
  </td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ColrC
   &#160;<span id="projectnumber">0.3.7</span>
   </div>
   <div id="projectbrief">An easy to use C library for linux terminal colors/escape-codes.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('colr_8c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">colr.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<h3 class="version">(0.3.7)</h3>
<p>Implements everything in the <a class="el" href="colr_8h.html" title="Declarations for ColrC functions, enums, structs, etc. ">colr.h</a> header.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="colr_8h_source.html">colr.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aaa888f1b31eb40ec7d252d3ee9175d76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#aaa888f1b31eb40ec7d252d3ee9175d76">_colr_free</a> (void *p)</td></tr>
<tr class="memdesc:aaa888f1b31eb40ec7d252d3ee9175d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls Colr <code>*_free()</code> functions for Colr objects, otherwise just calls <code>free()</code>.  <a href="#aaa888f1b31eb40ec7d252d3ee9175d76">More...</a><br /></td></tr>
<tr class="separator:aaa888f1b31eb40ec7d252d3ee9175d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64af11f4992c8143cb722772df98c98"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#af64af11f4992c8143cb722772df98c98">_colr_is_last_arg</a> (void *p)</td></tr>
<tr class="memdesc:af64af11f4992c8143cb722772df98c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a void pointer is _ColrLastArg (the last-arg-marker).  <a href="#af64af11f4992c8143cb722772df98c98">More...</a><br /></td></tr>
<tr class="separator:af64af11f4992c8143cb722772df98c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4227a65824fdd699a25d3200706c9e9e"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join</a> (void *joinerp,...)</td></tr>
<tr class="memdesc:a4227a65824fdd699a25d3200706c9e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joins ColorArgs, ColorTexts, and strings (<code>char*</code>) into one long string separated by it's first argument.  <a href="#a4227a65824fdd699a25d3200706c9e9e">More...</a><br /></td></tr>
<tr class="separator:a4227a65824fdd699a25d3200706c9e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d47ac6ee2a59e1c976cf2838545aa25"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a6d47ac6ee2a59e1c976cf2838545aa25">_colr_join_array_length</a> (void *ps)</td></tr>
<tr class="memdesc:a6d47ac6ee2a59e1c976cf2838545aa25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the length of a <code>NULL</code>-terminated array of strings (<code>char*</code>), <code><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a></code>s, <code><a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a></code>s, or <code><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a></code>s.  <a href="#a6d47ac6ee2a59e1c976cf2838545aa25">More...</a><br /></td></tr>
<tr class="separator:a6d47ac6ee2a59e1c976cf2838545aa25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49c3a33d328ebaf2b0564d5a9b1d4ec"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ac49c3a33d328ebaf2b0564d5a9b1d4ec">_colr_join_arrayn_size</a> (void *joinerp, void *ps, size_t count)</td></tr>
<tr class="memdesc:ac49c3a33d328ebaf2b0564d5a9b1d4ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size in bytes needed to join an array of strings (<code>char*</code>), <code><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a></code>s, <code><a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a></code>s, or <code><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a></code>s by another string (<code>char*</code>), <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.  <a href="#ac49c3a33d328ebaf2b0564d5a9b1d4ec">More...</a><br /></td></tr>
<tr class="separator:ac49c3a33d328ebaf2b0564d5a9b1d4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a051ef4cd2e7200a31f9de48766b4c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a91a051ef4cd2e7200a31f9de48766b4c">_colr_join_size</a> (void *joinerp, va_list args)</td></tr>
<tr class="memdesc:a91a051ef4cd2e7200a31f9de48766b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse arguments, just as in <a class="el" href="colr_8c.html#a4227a65824fdd699a25d3200706c9e9e" title="Joins ColorArgs, ColorTexts, and strings (char*) into one long string separated by it&#39;s first argumen...">_colr_join()</a>, but only return the size needed to allocate the resulting string.  <a href="#a91a051ef4cd2e7200a31f9de48766b4c">More...</a><br /></td></tr>
<tr class="separator:a91a051ef4cd2e7200a31f9de48766b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0be451277fc7e39aee0aa409c9d3f0c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ab0be451277fc7e39aee0aa409c9d3f0c">_colr_ptr_length</a> (void *p)</td></tr>
<tr class="memdesc:ab0be451277fc7e39aee0aa409c9d3f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size, in bytes, needed to convert a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, or string (<code>char*</code>) into a string.  <a href="#ab0be451277fc7e39aee0aa409c9d3f0c">More...</a><br /></td></tr>
<tr class="separator:ab0be451277fc7e39aee0aa409c9d3f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30cac3017a6ea8c78277882554c9419f"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a30cac3017a6ea8c78277882554c9419f">_colr_ptr_repr</a> (void *p)</td></tr>
<tr class="memdesc:a30cac3017a6ea8c78277882554c9419f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine what kind of pointer is being passed, and call the appropriate &lt;type&gt;_repr function to obtain an allocated string representation.  <a href="#a30cac3017a6ea8c78277882554c9419f">More...</a><br /></td></tr>
<tr class="separator:a30cac3017a6ea8c78277882554c9419f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d97f9b535a69642b926b38dce30b180"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a0d97f9b535a69642b926b38dce30b180">_colr_ptr_to_str</a> (void *p)</td></tr>
<tr class="memdesc:a0d97f9b535a69642b926b38dce30b180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine what kind of pointer is being passed, and call the appropriate &lt;type&gt;_to_str function to obtain an allocated string.  <a href="#a0d97f9b535a69642b926b38dce30b180">More...</a><br /></td></tr>
<tr class="separator:a0d97f9b535a69642b926b38dce30b180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88ca919420f2df896b7973401641ab4"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ab88ca919420f2df896b7973401641ab4">_rainbow</a> (<a class="el" href="colr_8h.html#adc966460db21ff6c35f23fcf6abe541e">RGB_fmter</a> fmter, const char *s, double freq, size_t offset, size_t spread)</td></tr>
<tr class="memdesc:ab88ca919420f2df896b7973401641ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles multibyte character string (<code>char*</code>) conversion and character iteration for all of the rainbow_ functions.  <a href="#ab88ca919420f2df896b7973401641ab4">More...</a><br /></td></tr>
<tr class="separator:ab88ca919420f2df896b7973401641ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d1fc130eeaf6ed62066e25478cb433"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a69d1fc130eeaf6ed62066e25478cb433">ArgType_eq</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> a, <a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> b)</td></tr>
<tr class="memdesc:a69d1fc130eeaf6ed62066e25478cb433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ArgTypes.  <a href="#a69d1fc130eeaf6ed62066e25478cb433">More...</a><br /></td></tr>
<tr class="separator:a69d1fc130eeaf6ed62066e25478cb433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01ccaf04c71fc2474da94b050236572"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ad01ccaf04c71fc2474da94b050236572">ArgType_repr</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type)</td></tr>
<tr class="memdesc:ad01ccaf04c71fc2474da94b050236572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation of a ArgType.  <a href="#ad01ccaf04c71fc2474da94b050236572">More...</a><br /></td></tr>
<tr class="separator:ad01ccaf04c71fc2474da94b050236572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b270bebb1a01212b7e44e52f61f94be"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a2b270bebb1a01212b7e44e52f61f94be">ArgType_to_str</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type)</td></tr>
<tr class="memdesc:a2b270bebb1a01212b7e44e52f61f94be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a human-friendly string (<code>char*</code>) from an ArgType.  <a href="#a2b270bebb1a01212b7e44e52f61f94be">More...</a><br /></td></tr>
<tr class="separator:a2b270bebb1a01212b7e44e52f61f94be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17bf46ac385e41b729d07a65dd506cba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a17bf46ac385e41b729d07a65dd506cba">BasicValue_eq</a> (<a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> a, <a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> b)</td></tr>
<tr class="memdesc:a17bf46ac385e41b729d07a65dd506cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two BasicValues.  <a href="#a17bf46ac385e41b729d07a65dd506cba">More...</a><br /></td></tr>
<tr class="separator:a17bf46ac385e41b729d07a65dd506cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481b2cb2526e58b2fdb2e52a722d987b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a481b2cb2526e58b2fdb2e52a722d987b">BasicValue_from_esc</a> (const char *s)</td></tr>
<tr class="memdesc:a481b2cb2526e58b2fdb2e52a722d987b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an escape-code string (<code>char*</code>) to an actual BasicValue enum value.  <a href="#a481b2cb2526e58b2fdb2e52a722d987b">More...</a><br /></td></tr>
<tr class="separator:a481b2cb2526e58b2fdb2e52a722d987b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4163ac65dca3e222525808b80a40b733"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a4163ac65dca3e222525808b80a40b733">BasicValue_from_str</a> (const char *arg)</td></tr>
<tr class="memdesc:a4163ac65dca3e222525808b80a40b733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert named argument to an actual BasicValue enum value.  <a href="#a4163ac65dca3e222525808b80a40b733">More...</a><br /></td></tr>
<tr class="separator:a4163ac65dca3e222525808b80a40b733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6332bbd16e746a02491eee70c13d0735"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a6332bbd16e746a02491eee70c13d0735">BasicValue_is_invalid</a> (<a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> bval)</td></tr>
<tr class="memdesc:a6332bbd16e746a02491eee70c13d0735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a BasicValue is invalid.  <a href="#a6332bbd16e746a02491eee70c13d0735">More...</a><br /></td></tr>
<tr class="separator:a6332bbd16e746a02491eee70c13d0735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e4c8a4789232c78b9ef17e292839ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a29e4c8a4789232c78b9ef17e292839ca">BasicValue_is_valid</a> (<a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> bval)</td></tr>
<tr class="memdesc:a29e4c8a4789232c78b9ef17e292839ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a BasicValue is valid.  <a href="#a29e4c8a4789232c78b9ef17e292839ca">More...</a><br /></td></tr>
<tr class="separator:a29e4c8a4789232c78b9ef17e292839ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc0d9917621cab5b3efd162b7dc5a8c"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a1bc0d9917621cab5b3efd162b7dc5a8c">BasicValue_repr</a> (<a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> bval)</td></tr>
<tr class="memdesc:a1bc0d9917621cab5b3efd162b7dc5a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation of a BasicValue.  <a href="#a1bc0d9917621cab5b3efd162b7dc5a8c">More...</a><br /></td></tr>
<tr class="separator:a1bc0d9917621cab5b3efd162b7dc5a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a78ebb45cb53792d4c658bade99a70"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a71a78ebb45cb53792d4c658bade99a70">BasicValue_to_ansi</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type, <a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> bval)</td></tr>
<tr class="memdesc:a71a78ebb45cb53792d4c658bade99a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a fore/back BasicValue to the actual ansi code number.  <a href="#a71a78ebb45cb53792d4c658bade99a70">More...</a><br /></td></tr>
<tr class="separator:a71a78ebb45cb53792d4c658bade99a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ea2f6c1adea8535ae629051e74ced0"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a83ea2f6c1adea8535ae629051e74ced0">BasicValue_to_str</a> (<a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> bval)</td></tr>
<tr class="memdesc:a83ea2f6c1adea8535ae629051e74ced0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a human-friendly string (<code>char*</code>) representation for a BasicValue.  <a href="#a83ea2f6c1adea8535ae629051e74ced0">More...</a><br /></td></tr>
<tr class="separator:a83ea2f6c1adea8535ae629051e74ced0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af838f8479681d809beb868b2e1b547e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#af838f8479681d809beb868b2e1b547e7">ColorArg_empty</a> (void)</td></tr>
<tr class="memdesc:af838f8479681d809beb868b2e1b547e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> with ARGTYPE_NONE and ColorValue.type.TYPE_NONE.  <a href="#af838f8479681d809beb868b2e1b547e7">More...</a><br /></td></tr>
<tr class="separator:af838f8479681d809beb868b2e1b547e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb62efc0182d6f6107055eeda961a628"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#acb62efc0182d6f6107055eeda961a628">ColorArg_eq</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> a, <a class="el" href="colr_8h.html#structColorArg">ColorArg</a> b)</td></tr>
<tr class="memdesc:acb62efc0182d6f6107055eeda961a628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> structs.  <a href="#acb62efc0182d6f6107055eeda961a628">More...</a><br /></td></tr>
<tr class="separator:acb62efc0182d6f6107055eeda961a628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54ab1879f6de8ca2fcb4702250741f5"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#aa54ab1879f6de8ca2fcb4702250741f5">ColorArg_example</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> carg, bool colorized)</td></tr>
<tr class="memdesc:aa54ab1879f6de8ca2fcb4702250741f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a string (<code>char*</code>) representation of a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> with a stylized type/name using escape codes built from the <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s values.  <a href="#aa54ab1879f6de8ca2fcb4702250741f5">More...</a><br /></td></tr>
<tr class="separator:aa54ab1879f6de8ca2fcb4702250741f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1163a9c866767fb7fcb734d3c0d9b7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#aa1163a9c866767fb7fcb734d3c0d9b7c">ColorArg_free</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *p)</td></tr>
<tr class="memdesc:aa1163a9c866767fb7fcb734d3c0d9b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free allocated memory for a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>.  <a href="#aa1163a9c866767fb7fcb734d3c0d9b7c">More...</a><br /></td></tr>
<tr class="separator:aa1163a9c866767fb7fcb734d3c0d9b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad49f4597388e6bdb896ff28334cd5e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#aad49f4597388e6bdb896ff28334cd5e6">ColorArg_from_BasicValue</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type, <a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> value)</td></tr>
<tr class="memdesc:aad49f4597388e6bdb896ff28334cd5e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit version of ColorArg_from_value that only handles BasicValues.  <a href="#aad49f4597388e6bdb896ff28334cd5e6">More...</a><br /></td></tr>
<tr class="separator:aad49f4597388e6bdb896ff28334cd5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e9640f37dd85cde0b6f25c0b705912"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a70e9640f37dd85cde0b6f25c0b705912">ColorArg_from_esc</a> (const char *s)</td></tr>
<tr class="memdesc:a70e9640f37dd85cde0b6f25c0b705912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an escape-code string (<code>char*</code>) into a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>.  <a href="#a70e9640f37dd85cde0b6f25c0b705912">More...</a><br /></td></tr>
<tr class="separator:a70e9640f37dd85cde0b6f25c0b705912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed30e2a4b30ab5e3cf49608a3c410cc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#aed30e2a4b30ab5e3cf49608a3c410cc5">ColorArg_from_ExtendedValue</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type, <a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a> value)</td></tr>
<tr class="memdesc:aed30e2a4b30ab5e3cf49608a3c410cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit version of ColorArg_from_value that only handles ExtendedValues.  <a href="#aed30e2a4b30ab5e3cf49608a3c410cc5">More...</a><br /></td></tr>
<tr class="separator:aed30e2a4b30ab5e3cf49608a3c410cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa24bba74e99aa66ed41839576e57856"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#aaa24bba74e99aa66ed41839576e57856">ColorArg_from_RGB</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type, <a class="el" href="colr_8h.html#structRGB">RGB</a> value)</td></tr>
<tr class="memdesc:aaa24bba74e99aa66ed41839576e57856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit version of ColorArg_from_value that only handles <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> structs.  <a href="#aaa24bba74e99aa66ed41839576e57856">More...</a><br /></td></tr>
<tr class="separator:aaa24bba74e99aa66ed41839576e57856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62406b058b948941a8906475924536a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#aa62406b058b948941a8906475924536a">ColorArg_from_str</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type, const char *colorname)</td></tr>
<tr class="memdesc:aa62406b058b948941a8906475924536a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> (fore, back, or style value) from a known color name/style.  <a href="#aa62406b058b948941a8906475924536a">More...</a><br /></td></tr>
<tr class="separator:aa62406b058b948941a8906475924536a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf63bcee395dca3ca29dc324e3d7c8f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#acf63bcee395dca3ca29dc324e3d7c8f2">ColorArg_from_StyleValue</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type, <a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a> value)</td></tr>
<tr class="memdesc:acf63bcee395dca3ca29dc324e3d7c8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit version of ColorArg_from_value that only handles StyleValues.  <a href="#acf63bcee395dca3ca29dc324e3d7c8f2">More...</a><br /></td></tr>
<tr class="separator:acf63bcee395dca3ca29dc324e3d7c8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a5aa762bd5802872faf571aa32ea35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a89a5aa762bd5802872faf571aa32ea35">ColorArg_from_value</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type, <a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> colrtype, void *p)</td></tr>
<tr class="memdesc:a89a5aa762bd5802872faf571aa32ea35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used with the color_arg macro to dynamically create a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> based on it's argument type.  <a href="#a89a5aa762bd5802872faf571aa32ea35">More...</a><br /></td></tr>
<tr class="separator:a89a5aa762bd5802872faf571aa32ea35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752355c2d96d35688d3756558f8421ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a752355c2d96d35688d3756558f8421ba">ColorArg_is_empty</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> carg)</td></tr>
<tr class="memdesc:a752355c2d96d35688d3756558f8421ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> is an empty placeholder.  <a href="#a752355c2d96d35688d3756558f8421ba">More...</a><br /></td></tr>
<tr class="separator:a752355c2d96d35688d3756558f8421ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b4906cfb08588005536db1250dc899"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a66b4906cfb08588005536db1250dc899">ColorArg_is_invalid</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> carg)</td></tr>
<tr class="memdesc:a66b4906cfb08588005536db1250dc899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> holds an invalid value.  <a href="#a66b4906cfb08588005536db1250dc899">More...</a><br /></td></tr>
<tr class="separator:a66b4906cfb08588005536db1250dc899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15f3a714a6383123d3fb24ade173e29"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ad15f3a714a6383123d3fb24ade173e29">ColorArg_is_ptr</a> (void *p)</td></tr>
<tr class="memdesc:ad15f3a714a6383123d3fb24ade173e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a void pointer to see if it contains a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct.  <a href="#ad15f3a714a6383123d3fb24ade173e29">More...</a><br /></td></tr>
<tr class="separator:ad15f3a714a6383123d3fb24ade173e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e446f65d6987d52522a1755c909d421"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a1e446f65d6987d52522a1755c909d421">ColorArg_is_valid</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> carg)</td></tr>
<tr class="memdesc:a1e446f65d6987d52522a1755c909d421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> holds a valid value.  <a href="#a1e446f65d6987d52522a1755c909d421">More...</a><br /></td></tr>
<tr class="separator:a1e446f65d6987d52522a1755c909d421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaff727006f4c057aab75e55bfb473c4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#adaff727006f4c057aab75e55bfb473c4">ColorArg_length</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> carg)</td></tr>
<tr class="memdesc:adaff727006f4c057aab75e55bfb473c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length in bytes needed to allocate a string (<code>char*</code>) built with <a class="el" href="colr_8c.html#ad1d3aaca5e543f8fefbd863a959c9d67" title="Converts a ColorArg into an escape code string (char*). ">ColorArg_to_esc()</a>.  <a href="#adaff727006f4c057aab75e55bfb473c4">More...</a><br /></td></tr>
<tr class="separator:adaff727006f4c057aab75e55bfb473c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af692f2357d46b9cee45bb114f2a4a2"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a5af692f2357d46b9cee45bb114f2a4a2">ColorArg_repr</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> carg)</td></tr>
<tr class="memdesc:a5af692f2357d46b9cee45bb114f2a4a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation for a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>.  <a href="#a5af692f2357d46b9cee45bb114f2a4a2">More...</a><br /></td></tr>
<tr class="separator:a5af692f2357d46b9cee45bb114f2a4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d3aaca5e543f8fefbd863a959c9d67"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ad1d3aaca5e543f8fefbd863a959c9d67">ColorArg_to_esc</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> carg)</td></tr>
<tr class="memdesc:ad1d3aaca5e543f8fefbd863a959c9d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> into an escape code string (<code>char*</code>).  <a href="#ad1d3aaca5e543f8fefbd863a959c9d67">More...</a><br /></td></tr>
<tr class="separator:ad1d3aaca5e543f8fefbd863a959c9d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf3d02ff1292f2aaa605522665ae564"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#abaf3d02ff1292f2aaa605522665ae564">ColorArg_to_esc_s</a> (char *dest, <a class="el" href="colr_8h.html#structColorArg">ColorArg</a> carg)</td></tr>
<tr class="memdesc:abaf3d02ff1292f2aaa605522665ae564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> into an escape code string (<code>char*</code>) and fills the destination string.  <a href="#abaf3d02ff1292f2aaa605522665ae564">More...</a><br /></td></tr>
<tr class="separator:abaf3d02ff1292f2aaa605522665ae564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5ac0bd012b8162cea125ad0d9e8bf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#afb5ac0bd012b8162cea125ad0d9e8bf0">ColorArg_to_ptr</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> carg)</td></tr>
<tr class="memdesc:afb5ac0bd012b8162cea125ad0d9e8bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> into memory and returns the pointer.  <a href="#afb5ac0bd012b8162cea125ad0d9e8bf0">More...</a><br /></td></tr>
<tr class="separator:afb5ac0bd012b8162cea125ad0d9e8bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c5256623852632a4ba040e3447431c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a32c5256623852632a4ba040e3447431c">ColorArgs_array_free</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> **ps)</td></tr>
<tr class="memdesc:a32c5256623852632a4ba040e3447431c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an allocated array of ColorArgs, including the array itself.  <a href="#a32c5256623852632a4ba040e3447431c">More...</a><br /></td></tr>
<tr class="separator:a32c5256623852632a4ba040e3447431c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e16f30e878a6fb53ed9af5f8fdd674a"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a4e16f30e878a6fb53ed9af5f8fdd674a">ColorArgs_array_repr</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> **lst)</td></tr>
<tr class="memdesc:a4e16f30e878a6fb53ed9af5f8fdd674a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string representation for an array of <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointers.  <a href="#a4e16f30e878a6fb53ed9af5f8fdd674a">More...</a><br /></td></tr>
<tr class="separator:a4e16f30e878a6fb53ed9af5f8fdd674a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4897abe50811762a84ee409c0c2d300f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a4897abe50811762a84ee409c0c2d300f">ColorArgs_from_str</a> (const char *s, bool unique)</td></tr>
<tr class="memdesc:a4897abe50811762a84ee409c0c2d300f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an array of ColorArgs from escape-codes found in a string (<code>char*</code>).  <a href="#a4897abe50811762a84ee409c0c2d300f">More...</a><br /></td></tr>
<tr class="separator:a4897abe50811762a84ee409c0c2d300f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11e9457ca4e8f5be0e29351b49b6844"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ae11e9457ca4e8f5be0e29351b49b6844">ColorJustify_empty</a> (void)</td></tr>
<tr class="memdesc:ae11e9457ca4e8f5be0e29351b49b6844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an "empty" <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a>, with JUST_NONE set.  <a href="#ae11e9457ca4e8f5be0e29351b49b6844">More...</a><br /></td></tr>
<tr class="separator:ae11e9457ca4e8f5be0e29351b49b6844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71656e616aef4bbb3c278d43c4a326e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ab71656e616aef4bbb3c278d43c4a326e">ColorJustify_eq</a> (<a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a> a, <a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a> b)</td></tr>
<tr class="memdesc:ab71656e616aef4bbb3c278d43c4a326e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> structs.  <a href="#ab71656e616aef4bbb3c278d43c4a326e">More...</a><br /></td></tr>
<tr class="separator:ab71656e616aef4bbb3c278d43c4a326e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f193b6e6a20c63caecc1d9b53c89fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a34f193b6e6a20c63caecc1d9b53c89fb">ColorJustify_is_empty</a> (<a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a> cjust)</td></tr>
<tr class="memdesc:a34f193b6e6a20c63caecc1d9b53c89fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> is "empty".  <a href="#a34f193b6e6a20c63caecc1d9b53c89fb">More...</a><br /></td></tr>
<tr class="separator:a34f193b6e6a20c63caecc1d9b53c89fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4a7a21151993343ef96a068c6d5018"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a7d4a7a21151993343ef96a068c6d5018">ColorJustify_new</a> (<a class="el" href="colr_8h.html#af1a3fe0b966f944fd659a98be170045f">ColorJustifyMethod</a> method, int width, char padchar)</td></tr>
<tr class="memdesc:a7d4a7a21151993343ef96a068c6d5018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a>.  <a href="#a7d4a7a21151993343ef96a068c6d5018">More...</a><br /></td></tr>
<tr class="separator:a7d4a7a21151993343ef96a068c6d5018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c35f6b47cc737744487d14d20241656"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a6c35f6b47cc737744487d14d20241656">ColorJustify_repr</a> (<a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a> cjust)</td></tr>
<tr class="memdesc:a6c35f6b47cc737744487d14d20241656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation for a <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a>.  <a href="#a6c35f6b47cc737744487d14d20241656">More...</a><br /></td></tr>
<tr class="separator:a6c35f6b47cc737744487d14d20241656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf78eeb364553d130055d93e9892cd9c"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#adf78eeb364553d130055d93e9892cd9c">ColorJustifyMethod_repr</a> (<a class="el" href="colr_8h.html#af1a3fe0b966f944fd659a98be170045f">ColorJustifyMethod</a> meth)</td></tr>
<tr class="memdesc:adf78eeb364553d130055d93e9892cd9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation for a ColorJustifyMethod.  <a href="#adf78eeb364553d130055d93e9892cd9c">More...</a><br /></td></tr>
<tr class="separator:adf78eeb364553d130055d93e9892cd9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c95a667cdcd05fd108ddf20b9a7328"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ad4c95a667cdcd05fd108ddf20b9a7328">ColorResult_Colr</a> (<a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *cres,...)</td></tr>
<tr class="memdesc:ad4c95a667cdcd05fd108ddf20b9a7328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Colorize a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, and return a new allocated <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>.  <a href="#ad4c95a667cdcd05fd108ddf20b9a7328">More...</a><br /></td></tr>
<tr class="separator:ad4c95a667cdcd05fd108ddf20b9a7328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b59e832f322e617a89ca14046cc41d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a5b59e832f322e617a89ca14046cc41d2">ColorResult_empty</a> (void)</td></tr>
<tr class="memdesc:a5b59e832f322e617a89ca14046cc41d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> with <code>.result=NULL</code> and <code>.length=-1</code>, with the appropriate struct marker.  <a href="#a5b59e832f322e617a89ca14046cc41d2">More...</a><br /></td></tr>
<tr class="separator:a5b59e832f322e617a89ca14046cc41d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb35d2507389c11d6ffe2adc6876efcc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#afb35d2507389c11d6ffe2adc6876efcc">ColorResult_eq</a> (<a class="el" href="colr_8h.html#structColorResult">ColorResult</a> a, <a class="el" href="colr_8h.html#structColorResult">ColorResult</a> b)</td></tr>
<tr class="memdesc:afb35d2507389c11d6ffe2adc6876efcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ColorResults.  <a href="#afb35d2507389c11d6ffe2adc6876efcc">More...</a><br /></td></tr>
<tr class="separator:afb35d2507389c11d6ffe2adc6876efcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b70c6de9b2351424100bd742b1f1a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a27b70c6de9b2351424100bd742b1f1a8">ColorResult_free</a> (<a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *p)</td></tr>
<tr class="memdesc:a27b70c6de9b2351424100bd742b1f1a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free allocated memory for a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> and it's <code>.result</code> member.  <a href="#a27b70c6de9b2351424100bd742b1f1a8">More...</a><br /></td></tr>
<tr class="separator:a27b70c6de9b2351424100bd742b1f1a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c106f8d2e83b007a3fd633c3097c18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ac5c106f8d2e83b007a3fd633c3097c18">ColorResult_from_str</a> (const char *s)</td></tr>
<tr class="memdesc:ac5c106f8d2e83b007a3fd633c3097c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a copy of a string, and creates a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> from it.  <a href="#ac5c106f8d2e83b007a3fd633c3097c18">More...</a><br /></td></tr>
<tr class="separator:ac5c106f8d2e83b007a3fd633c3097c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d92286745806229c0369c20edf641c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a91d92286745806229c0369c20edf641c">ColorResult_from_stra</a> (const char *s)</td></tr>
<tr class="memdesc:a91d92286745806229c0369c20edf641c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a copy of a string, and creates an allocated <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> from it.  <a href="#a91d92286745806229c0369c20edf641c">More...</a><br /></td></tr>
<tr class="separator:a91d92286745806229c0369c20edf641c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5fe635f26119c3a341b5dfe23abc97"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#afd5fe635f26119c3a341b5dfe23abc97">ColorResult_is_ptr</a> (void *p)</td></tr>
<tr class="memdesc:afd5fe635f26119c3a341b5dfe23abc97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a void pointer to see if it contains a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> struct.  <a href="#afd5fe635f26119c3a341b5dfe23abc97">More...</a><br /></td></tr>
<tr class="separator:afd5fe635f26119c3a341b5dfe23abc97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5169ef5d27a9c14bb765f7e7b70c9e2b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a5169ef5d27a9c14bb765f7e7b70c9e2b">ColorResult_length</a> (<a class="el" href="colr_8h.html#structColorResult">ColorResult</a> cres)</td></tr>
<tr class="memdesc:a5169ef5d27a9c14bb765f7e7b70c9e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the length in bytes (including the null-terminator), that is needed to store the return from <a class="el" href="colr_8c.html#af5174a576892401ea59b737558f27d8b" title="Convert a ColorResult into a string (char*). ">ColorResult_to_str()</a> (<code>.result</code>).  <a href="#a5169ef5d27a9c14bb765f7e7b70c9e2b">More...</a><br /></td></tr>
<tr class="separator:a5169ef5d27a9c14bb765f7e7b70c9e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af752035c362c7c9ddb2e7f2f2305d509"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#af752035c362c7c9ddb2e7f2f2305d509">ColorResult_new</a> (char *s)</td></tr>
<tr class="memdesc:af752035c362c7c9ddb2e7f2f2305d509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a new <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> with an allocated string (<code>char*</code>).  <a href="#af752035c362c7c9ddb2e7f2f2305d509">More...</a><br /></td></tr>
<tr class="separator:af752035c362c7c9ddb2e7f2f2305d509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0b90c57e8c4c475d9e0f517f3a0d42"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#aae0b90c57e8c4c475d9e0f517f3a0d42">ColorResult_repr</a> (<a class="el" href="colr_8h.html#structColorResult">ColorResult</a> cres)</td></tr>
<tr class="memdesc:aae0b90c57e8c4c475d9e0f517f3a0d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a string representation for a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>.  <a href="#aae0b90c57e8c4c475d9e0f517f3a0d42">More...</a><br /></td></tr>
<tr class="separator:aae0b90c57e8c4c475d9e0f517f3a0d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5304067f9d673ce5b86ddba2a8807b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a5f5304067f9d673ce5b86ddba2a8807b">ColorResult_to_ptr</a> (<a class="el" href="colr_8h.html#structColorResult">ColorResult</a> cres)</td></tr>
<tr class="memdesc:a5f5304067f9d673ce5b86ddba2a8807b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory for a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, fill it, and return it.  <a href="#a5f5304067f9d673ce5b86ddba2a8807b">More...</a><br /></td></tr>
<tr class="separator:a5f5304067f9d673ce5b86ddba2a8807b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5174a576892401ea59b737558f27d8b"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#af5174a576892401ea59b737558f27d8b">ColorResult_to_str</a> (<a class="el" href="colr_8h.html#structColorResult">ColorResult</a> cres)</td></tr>
<tr class="memdesc:af5174a576892401ea59b737558f27d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> into a string (<code>char*</code>).  <a href="#af5174a576892401ea59b737558f27d8b">More...</a><br /></td></tr>
<tr class="separator:af5174a576892401ea59b737558f27d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341b4033c31c58e412ff15280185c6bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorText">ColorText</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a341b4033c31c58e412ff15280185c6bd">ColorText_empty</a> (void)</td></tr>
<tr class="memdesc:a341b4033c31c58e412ff15280185c6bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an "empty" <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> with pointers set to <code>NULL</code>.  <a href="#a341b4033c31c58e412ff15280185c6bd">More...</a><br /></td></tr>
<tr class="separator:a341b4033c31c58e412ff15280185c6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901e5738358a739629cc3aaccab3e73f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a901e5738358a739629cc3aaccab3e73f">ColorText_free</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> *p)</td></tr>
<tr class="memdesc:a901e5738358a739629cc3aaccab3e73f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> and it's ColorArgs.  <a href="#a901e5738358a739629cc3aaccab3e73f">More...</a><br /></td></tr>
<tr class="separator:a901e5738358a739629cc3aaccab3e73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4979a2ec9d5fb442ba025c6f2efc4864"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a4979a2ec9d5fb442ba025c6f2efc4864">ColorText_free_args</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> *p)</td></tr>
<tr class="memdesc:a4979a2ec9d5fb442ba025c6f2efc4864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> members of a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.  <a href="#a4979a2ec9d5fb442ba025c6f2efc4864">More...</a><br /></td></tr>
<tr class="separator:a4979a2ec9d5fb442ba025c6f2efc4864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4702d6ddc409a93a0b42c8f6141d2f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorText">ColorText</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ad4702d6ddc409a93a0b42c8f6141d2f2">ColorText_from_values</a> (char *text,...)</td></tr>
<tr class="memdesc:ad4702d6ddc409a93a0b42c8f6141d2f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> from 1 mandatory string (<code>char*</code>), and optional fore, back, and style args (pointers to ColorArgs).  <a href="#ad4702d6ddc409a93a0b42c8f6141d2f2">More...</a><br /></td></tr>
<tr class="separator:ad4702d6ddc409a93a0b42c8f6141d2f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bbb1f20ed69733be7750640ac297073"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorText">ColorText</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a9bbb1f20ed69733be7750640ac297073">ColorText_from_valuesv</a> (char *text, va_list args)</td></tr>
<tr class="memdesc:a9bbb1f20ed69733be7750640ac297073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> from 1 mandatory string (<code>char*</code>), and a <code>va_list</code> with optional fore, back, and style args (pointers to ColorArgs).  <a href="#a9bbb1f20ed69733be7750640ac297073">More...</a><br /></td></tr>
<tr class="separator:a9bbb1f20ed69733be7750640ac297073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f65430500d003575c547eb667330b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a93f65430500d003575c547eb667330b0">ColorText_has_arg</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> ctext, <a class="el" href="colr_8h.html#structColorArg">ColorArg</a> carg)</td></tr>
<tr class="memdesc:a93f65430500d003575c547eb667330b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> has a certain <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> value set.  <a href="#a93f65430500d003575c547eb667330b0">More...</a><br /></td></tr>
<tr class="separator:a93f65430500d003575c547eb667330b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b38987063bb127bb34761961d7f678"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a93b38987063bb127bb34761961d7f678">ColorText_has_args</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> ctext)</td></tr>
<tr class="memdesc:a93b38987063bb127bb34761961d7f678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> has any argument values set.  <a href="#a93b38987063bb127bb34761961d7f678">More...</a><br /></td></tr>
<tr class="separator:a93b38987063bb127bb34761961d7f678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac846e583415e832b9090270020320b9f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ac846e583415e832b9090270020320b9f">ColorText_is_empty</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> ctext)</td></tr>
<tr class="memdesc:ac846e583415e832b9090270020320b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> has no usable values.  <a href="#ac846e583415e832b9090270020320b9f">More...</a><br /></td></tr>
<tr class="separator:ac846e583415e832b9090270020320b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6eb8832110b943c3a3a17627a50288"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a1d6eb8832110b943c3a3a17627a50288">ColorText_is_ptr</a> (void *p)</td></tr>
<tr class="memdesc:a1d6eb8832110b943c3a3a17627a50288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a void pointer to see if it contains a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> struct.  <a href="#a1d6eb8832110b943c3a3a17627a50288">More...</a><br /></td></tr>
<tr class="separator:a1d6eb8832110b943c3a3a17627a50288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412833a097b050c8ee99874c733bd030"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a412833a097b050c8ee99874c733bd030">ColorText_length</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> ctext)</td></tr>
<tr class="memdesc:a412833a097b050c8ee99874c733bd030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length in bytes needed to allocate a string (<code>char*</code>) built with <a class="el" href="colr_8c.html#ae305b33e0a44b956ccf4123aa4f1a033" title="Stringifies a ColorText struct, creating a mix of escape codes and text. ">ColorText_to_str()</a> with the current <code>text</code>, <code>fore</code>, <code>back</code>, and <code>style</code> members.  <a href="#a412833a097b050c8ee99874c733bd030">More...</a><br /></td></tr>
<tr class="separator:a412833a097b050c8ee99874c733bd030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65363a3601cd9cfcdc7fc40722d5d3c3"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a65363a3601cd9cfcdc7fc40722d5d3c3">ColorText_repr</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> ctext)</td></tr>
<tr class="memdesc:a65363a3601cd9cfcdc7fc40722d5d3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a string (<code>char*</code>) representation for a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.  <a href="#a65363a3601cd9cfcdc7fc40722d5d3c3">More...</a><br /></td></tr>
<tr class="separator:a65363a3601cd9cfcdc7fc40722d5d3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab408d87cce896acccb75357acca8ade4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ab408d87cce896acccb75357acca8ade4">ColorText_set_just</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> *ctext, <a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a> cjust)</td></tr>
<tr class="memdesc:ab408d87cce896acccb75357acca8ade4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> method for a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, and return the <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.  <a href="#ab408d87cce896acccb75357acca8ade4">More...</a><br /></td></tr>
<tr class="separator:ab408d87cce896acccb75357acca8ade4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880b39cd2ce9b622dbe7790a162d88f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a880b39cd2ce9b622dbe7790a162d88f7">ColorText_set_values</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> *ctext, char *text,...)</td></tr>
<tr class="memdesc:a880b39cd2ce9b622dbe7790a162d88f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an existing <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> from 1 mandatory string (<code>char*</code>), and optional fore, back, and style args (pointers to ColorArgs).  <a href="#a880b39cd2ce9b622dbe7790a162d88f7">More...</a><br /></td></tr>
<tr class="separator:a880b39cd2ce9b622dbe7790a162d88f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e04de932a4cf712ac91e794bdc3f8db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a8e04de932a4cf712ac91e794bdc3f8db">ColorText_to_ptr</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> ctext)</td></tr>
<tr class="memdesc:a8e04de932a4cf712ac91e794bdc3f8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> into allocated memory and returns the pointer.  <a href="#a8e04de932a4cf712ac91e794bdc3f8db">More...</a><br /></td></tr>
<tr class="separator:a8e04de932a4cf712ac91e794bdc3f8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae305b33e0a44b956ccf4123aa4f1a033"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ae305b33e0a44b956ccf4123aa4f1a033">ColorText_to_str</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> ctext)</td></tr>
<tr class="memdesc:ae305b33e0a44b956ccf4123aa4f1a033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stringifies a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> struct, creating a mix of escape codes and text.  <a href="#ae305b33e0a44b956ccf4123aa4f1a033">More...</a><br /></td></tr>
<tr class="separator:ae305b33e0a44b956ccf4123aa4f1a033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e3483ae4add048424177fdc2b97b71"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a29e3483ae4add048424177fdc2b97b71">ColorType_eq</a> (<a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> a, <a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> b)</td></tr>
<tr class="memdesc:a29e3483ae4add048424177fdc2b97b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ColorTypes.  <a href="#a29e3483ae4add048424177fdc2b97b71">More...</a><br /></td></tr>
<tr class="separator:a29e3483ae4add048424177fdc2b97b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa75deef059c002134a88dbbdc18fd49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#afa75deef059c002134a88dbbdc18fd49">ColorType_from_str</a> (const char *arg)</td></tr>
<tr class="memdesc:afa75deef059c002134a88dbbdc18fd49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine which type of color value is desired by name.  <a href="#afa75deef059c002134a88dbbdc18fd49">More...</a><br /></td></tr>
<tr class="separator:afa75deef059c002134a88dbbdc18fd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc223f6fda6296396e9ecddcc68d4aec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#adc223f6fda6296396e9ecddcc68d4aec">ColorType_is_invalid</a> (<a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> type)</td></tr>
<tr class="memdesc:adc223f6fda6296396e9ecddcc68d4aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if a ColorType value is considered invalid.  <a href="#adc223f6fda6296396e9ecddcc68d4aec">More...</a><br /></td></tr>
<tr class="separator:adc223f6fda6296396e9ecddcc68d4aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5883d43e3206584ad048908720afb2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a5a5883d43e3206584ad048908720afb2">ColorType_is_valid</a> (<a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> type)</td></tr>
<tr class="memdesc:a5a5883d43e3206584ad048908720afb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if a ColorType value is considered valid.  <a href="#a5a5883d43e3206584ad048908720afb2">More...</a><br /></td></tr>
<tr class="separator:a5a5883d43e3206584ad048908720afb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a291ca6d28f9f430794413b76b7b094ed"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a291ca6d28f9f430794413b76b7b094ed">ColorType_repr</a> (<a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> type)</td></tr>
<tr class="memdesc:a291ca6d28f9f430794413b76b7b094ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation of a ColorType.  <a href="#a291ca6d28f9f430794413b76b7b094ed">More...</a><br /></td></tr>
<tr class="separator:a291ca6d28f9f430794413b76b7b094ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb73415f467b040d4b0f8f1ef5e95312"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#acb73415f467b040d4b0f8f1ef5e95312">ColorType_to_str</a> (<a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> type)</td></tr>
<tr class="memdesc:acb73415f467b040d4b0f8f1ef5e95312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a human-friendly string (<code>char*</code>) representation for a ColorType.  <a href="#acb73415f467b040d4b0f8f1ef5e95312">More...</a><br /></td></tr>
<tr class="separator:acb73415f467b040d4b0f8f1ef5e95312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce7c54ad0e31ecf6d790c5770c2b66b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a5ce7c54ad0e31ecf6d790c5770c2b66b">ColorValue_empty</a> (void)</td></tr>
<tr class="memdesc:a5ce7c54ad0e31ecf6d790c5770c2b66b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an "empty" <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>.  <a href="#a5ce7c54ad0e31ecf6d790c5770c2b66b">More...</a><br /></td></tr>
<tr class="separator:a5ce7c54ad0e31ecf6d790c5770c2b66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf57e195301864cec80739e7e0f3000c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#adf57e195301864cec80739e7e0f3000c">ColorValue_eq</a> (<a class="el" href="colr_8h.html#structColorValue">ColorValue</a> a, <a class="el" href="colr_8h.html#structColorValue">ColorValue</a> b)</td></tr>
<tr class="memdesc:adf57e195301864cec80739e7e0f3000c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> structs.  <a href="#adf57e195301864cec80739e7e0f3000c">More...</a><br /></td></tr>
<tr class="separator:adf57e195301864cec80739e7e0f3000c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b5fc81980cbbfb425c7756eb8f0d0a"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a89b5fc81980cbbfb425c7756eb8f0d0a">ColorValue_example</a> (<a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval)</td></tr>
<tr class="memdesc:a89b5fc81980cbbfb425c7756eb8f0d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a string (<code>char*</code>) representation of a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> with a human-friendly type/name.  <a href="#a89b5fc81980cbbfb425c7756eb8f0d0a">More...</a><br /></td></tr>
<tr class="separator:a89b5fc81980cbbfb425c7756eb8f0d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af308e8dcd4a1d47a05736882d5a9698d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#af308e8dcd4a1d47a05736882d5a9698d">ColorValue_from_esc</a> (const char *s)</td></tr>
<tr class="memdesc:af308e8dcd4a1d47a05736882d5a9698d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an escape-code string (<code>char*</code>) into a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>.  <a href="#af308e8dcd4a1d47a05736882d5a9698d">More...</a><br /></td></tr>
<tr class="separator:af308e8dcd4a1d47a05736882d5a9698d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c63f5f62e11d5f375a3824b12c80608"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a7c63f5f62e11d5f375a3824b12c80608">ColorValue_from_str</a> (const char *s)</td></tr>
<tr class="memdesc:a7c63f5f62e11d5f375a3824b12c80608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> from a known color name, or <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> string (<code>char*</code>).  <a href="#a7c63f5f62e11d5f375a3824b12c80608">More...</a><br /></td></tr>
<tr class="separator:a7c63f5f62e11d5f375a3824b12c80608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7fedbceb4f751d0d30034c0ef1dca8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#aca7fedbceb4f751d0d30034c0ef1dca8">ColorValue_from_value</a> (<a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> type, void *p)</td></tr>
<tr class="memdesc:aca7fedbceb4f751d0d30034c0ef1dca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used with the color_val macro to dynamically create a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> based on it's argument type.  <a href="#aca7fedbceb4f751d0d30034c0ef1dca8">More...</a><br /></td></tr>
<tr class="separator:aca7fedbceb4f751d0d30034c0ef1dca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711a955406cde9716797bf61ab43a7a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a711a955406cde9716797bf61ab43a7a7">ColorValue_has_BasicValue</a> (<a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval, <a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> bval)</td></tr>
<tr class="memdesc:a711a955406cde9716797bf61ab43a7a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has a BasicValue set.  <a href="#a711a955406cde9716797bf61ab43a7a7">More...</a><br /></td></tr>
<tr class="separator:a711a955406cde9716797bf61ab43a7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11dc047d1defc4de2239a45667b45f85"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a11dc047d1defc4de2239a45667b45f85">ColorValue_has_ExtendedValue</a> (<a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval, <a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a> eval)</td></tr>
<tr class="memdesc:a11dc047d1defc4de2239a45667b45f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has a ExtendedValue set.  <a href="#a11dc047d1defc4de2239a45667b45f85">More...</a><br /></td></tr>
<tr class="separator:a11dc047d1defc4de2239a45667b45f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6908a961d4165a458be1aa64f082a45"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ab6908a961d4165a458be1aa64f082a45">ColorValue_has_RGB</a> (<a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval, <a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:ab6908a961d4165a458be1aa64f082a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has a <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value set.  <a href="#ab6908a961d4165a458be1aa64f082a45">More...</a><br /></td></tr>
<tr class="separator:ab6908a961d4165a458be1aa64f082a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fbfa502deb1f2bb920b74b9f4867fcf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a3fbfa502deb1f2bb920b74b9f4867fcf">ColorValue_has_StyleValue</a> (<a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval, <a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a> sval)</td></tr>
<tr class="memdesc:a3fbfa502deb1f2bb920b74b9f4867fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has a StyleValue set.  <a href="#a3fbfa502deb1f2bb920b74b9f4867fcf">More...</a><br /></td></tr>
<tr class="separator:a3fbfa502deb1f2bb920b74b9f4867fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48005bb1589a7ebeef413ccee2a7c2a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a48005bb1589a7ebeef413ccee2a7c2a1">ColorValue_is_empty</a> (<a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval)</td></tr>
<tr class="memdesc:a48005bb1589a7ebeef413ccee2a7c2a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> is an empty placeholder.  <a href="#a48005bb1589a7ebeef413ccee2a7c2a1">More...</a><br /></td></tr>
<tr class="separator:a48005bb1589a7ebeef413ccee2a7c2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22fcf30338eb777592421543885f74e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a22fcf30338eb777592421543885f74e0">ColorValue_is_invalid</a> (<a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval)</td></tr>
<tr class="memdesc:a22fcf30338eb777592421543885f74e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> holds an invalid value.  <a href="#a22fcf30338eb777592421543885f74e0">More...</a><br /></td></tr>
<tr class="separator:a22fcf30338eb777592421543885f74e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7183410b61d12a99dda3f76c2705497"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ac7183410b61d12a99dda3f76c2705497">ColorValue_is_valid</a> (<a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval)</td></tr>
<tr class="memdesc:ac7183410b61d12a99dda3f76c2705497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> holds a valid value.  <a href="#ac7183410b61d12a99dda3f76c2705497">More...</a><br /></td></tr>
<tr class="separator:ac7183410b61d12a99dda3f76c2705497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af891527249f068cfcef057313c522a42"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#af891527249f068cfcef057313c522a42">ColorValue_length</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type, <a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval)</td></tr>
<tr class="memdesc:af891527249f068cfcef057313c522a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length in bytes needed to allocate a string (<code>char*</code>) built with <a class="el" href="colr_8c.html#ab62d1c5cc30bb9211de8b5321be5c3ee" title="Converts a ColorValue into an escape code string (char*). ">ColorValue_to_esc()</a> with the specified ArgType and <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>.  <a href="#af891527249f068cfcef057313c522a42">More...</a><br /></td></tr>
<tr class="separator:af891527249f068cfcef057313c522a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95cf6ab7c565726eeb7c276d734193f6"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a95cf6ab7c565726eeb7c276d734193f6">ColorValue_repr</a> (<a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval)</td></tr>
<tr class="memdesc:a95cf6ab7c565726eeb7c276d734193f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation of a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>.  <a href="#a95cf6ab7c565726eeb7c276d734193f6">More...</a><br /></td></tr>
<tr class="separator:a95cf6ab7c565726eeb7c276d734193f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62d1c5cc30bb9211de8b5321be5c3ee"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ab62d1c5cc30bb9211de8b5321be5c3ee">ColorValue_to_esc</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type, <a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval)</td></tr>
<tr class="memdesc:ab62d1c5cc30bb9211de8b5321be5c3ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> into an escape code string (<code>char*</code>).  <a href="#ab62d1c5cc30bb9211de8b5321be5c3ee">More...</a><br /></td></tr>
<tr class="separator:ab62d1c5cc30bb9211de8b5321be5c3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebcf95faa1465843b6510d534d0311a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#aebcf95faa1465843b6510d534d0311a0">ColorValue_to_esc_s</a> (char *dest, <a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type, <a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval)</td></tr>
<tr class="memdesc:aebcf95faa1465843b6510d534d0311a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> into an escape code string (<code>char*</code>) and fills the destination string.  <a href="#aebcf95faa1465843b6510d534d0311a0">More...</a><br /></td></tr>
<tr class="separator:aebcf95faa1465843b6510d534d0311a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc40c0187b5a18c21428e18434e8e0df"><td class="memItemLeft" align="right" valign="top">regmatch_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#afc40c0187b5a18c21428e18434e8e0df">colr_alloc_regmatch</a> (regmatch_t match)</td></tr>
<tr class="memdesc:afc40c0187b5a18c21428e18434e8e0df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates space for a regmatch_t, initializes it, and returns a pointer to it.  <a href="#afc40c0187b5a18c21428e18434e8e0df">More...</a><br /></td></tr>
<tr class="separator:afc40c0187b5a18c21428e18434e8e0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10030070daafdee7124638adfc5469d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a10030070daafdee7124638adfc5469d8">colr_append_reset</a> (char *s)</td></tr>
<tr class="memdesc:a10030070daafdee7124638adfc5469d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends CODE_RESET_ALL to a string (<code>char*</code>), but makes sure to do it before any newlines.  <a href="#a10030070daafdee7124638adfc5469d8">More...</a><br /></td></tr>
<tr class="separator:a10030070daafdee7124638adfc5469d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1ea562310969b7efa8711a843f103c"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a7f1ea562310969b7efa8711a843f103c">colr_char_escape_char</a> (const char c)</td></tr>
<tr class="memdesc:a7f1ea562310969b7efa8711a843f103c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the char needed to represent an escape sequence in C.  <a href="#a7f1ea562310969b7efa8711a843f103c">More...</a><br /></td></tr>
<tr class="separator:a7f1ea562310969b7efa8711a843f103c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38331775450608b94c5ecfeec28f9363"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a38331775450608b94c5ecfeec28f9363">colr_char_in_str</a> (const char *s, const char c)</td></tr>
<tr class="memdesc:a38331775450608b94c5ecfeec28f9363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a character exists in the given string (<code>char*</code>).  <a href="#a38331775450608b94c5ecfeec28f9363">More...</a><br /></td></tr>
<tr class="separator:a38331775450608b94c5ecfeec28f9363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4fed7123927027262875834964b0a94"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ab4fed7123927027262875834964b0a94">colr_char_is_code_end</a> (const char c)</td></tr>
<tr class="memdesc:ab4fed7123927027262875834964b0a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a character is suitable for an escape code ending.  <a href="#ab4fed7123927027262875834964b0a94">More...</a><br /></td></tr>
<tr class="separator:ab4fed7123927027262875834964b0a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78a98cb101d4d5f18df0023b3109013"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#af78a98cb101d4d5f18df0023b3109013">colr_char_repr</a> (char c)</td></tr>
<tr class="memdesc:af78a98cb101d4d5f18df0023b3109013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation for a char.  <a href="#af78a98cb101d4d5f18df0023b3109013">More...</a><br /></td></tr>
<tr class="separator:af78a98cb101d4d5f18df0023b3109013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ef4700a46e78c2bed1132428a610fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a67ef4700a46e78c2bed1132428a610fb">colr_char_should_escape</a> (const char c)</td></tr>
<tr class="memdesc:a67ef4700a46e78c2bed1132428a610fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if an ascii character has an escape sequence in C.  <a href="#a67ef4700a46e78c2bed1132428a610fb">More...</a><br /></td></tr>
<tr class="separator:a67ef4700a46e78c2bed1132428a610fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe470aae91128e4529563c90c214e3a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#adfe470aae91128e4529563c90c214e3a">colr_check_marker</a> (uint32_t marker, void *p)</td></tr>
<tr class="memdesc:adfe470aae91128e4529563c90c214e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks an unsigned int against the individual bytes behind a pointer's value.  <a href="#adfe470aae91128e4529563c90c214e3a">More...</a><br /></td></tr>
<tr class="separator:adfe470aae91128e4529563c90c214e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8963c87ccb1c39bdd4481bb81810ba78"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a8963c87ccb1c39bdd4481bb81810ba78">colr_empty_str</a> (void)</td></tr>
<tr class="memdesc:a8963c87ccb1c39bdd4481bb81810ba78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates an empty string (<code>char*</code>).  <a href="#a8963c87ccb1c39bdd4481bb81810ba78">More...</a><br /></td></tr>
<tr class="separator:a8963c87ccb1c39bdd4481bb81810ba78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008af1b6ab6db4d4dd98033471506f1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a008af1b6ab6db4d4dd98033471506f1e">Colr_fmt_str</a> (const char *fmt,...)</td></tr>
<tr class="memdesc:a008af1b6ab6db4d4dd98033471506f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and format a string like <code>asprintf</code>, but wrap it in an allocated <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>.  <a href="#a008af1b6ab6db4d4dd98033471506f1e">More...</a><br /></td></tr>
<tr class="separator:a008af1b6ab6db4d4dd98033471506f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197b7f21254d1729f30193905f8e237c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a197b7f21254d1729f30193905f8e237c">colr_free_argsv</a> (va_list args)</td></tr>
<tr class="memdesc:a197b7f21254d1729f30193905f8e237c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free any ColrC objects (<a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointer) passed in through a <code>va_list</code>.  <a href="#a197b7f21254d1729f30193905f8e237c">More...</a><br /></td></tr>
<tr class="separator:a197b7f21254d1729f30193905f8e237c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e72a18762c87886173dd0a0dc37887"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a67e72a18762c87886173dd0a0dc37887">colr_free_re_matches</a> (regmatch_t **matches)</td></tr>
<tr class="memdesc:a67e72a18762c87886173dd0a0dc37887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an array of allocated <code>regmatch_t</code>, like the return from <a class="el" href="colr_8c.html#a37cd9a8f2748629e68e9c41ffca557a9" title="Returns all regmatch_t matches for regex pattern in a string (char*). ">colr_re_matches()</a>.  <a href="#a67e72a18762c87886173dd0a0dc37887">More...</a><br /></td></tr>
<tr class="separator:a67e72a18762c87886173dd0a0dc37887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e06ee5b32cd583c71ecff7d6c18270"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a18e06ee5b32cd583c71ecff7d6c18270">colr_is_colr_ptr</a> (void *p)</td></tr>
<tr class="memdesc:a18e06ee5b32cd583c71ecff7d6c18270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a void pointer is a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointer.  <a href="#a18e06ee5b32cd583c71ecff7d6c18270">More...</a><br /></td></tr>
<tr class="separator:a18e06ee5b32cd583c71ecff7d6c18270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701126bd27c90fafa46152d9f9327b2f"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a701126bd27c90fafa46152d9f9327b2f">colr_join_array</a> (void *joinerp, void *ps)</td></tr>
<tr class="memdesc:a701126bd27c90fafa46152d9f9327b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join an array of strings (<code>char*</code>), <code><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a></code>s, or <code><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a></code>s by another string (<code>char*</code>), <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.  <a href="#a701126bd27c90fafa46152d9f9327b2f">More...</a><br /></td></tr>
<tr class="separator:a701126bd27c90fafa46152d9f9327b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71fcf08ad36d4424790e275d973445fc"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a71fcf08ad36d4424790e275d973445fc">colr_join_arrayn</a> (void *joinerp, void *ps, size_t count)</td></tr>
<tr class="memdesc:a71fcf08ad36d4424790e275d973445fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join an array of strings (<code>char*</code>), <code><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a></code>s, or <code><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a></code>s by another string (<code>char*</code>), <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.  <a href="#a71fcf08ad36d4424790e275d973445fc">More...</a><br /></td></tr>
<tr class="separator:a71fcf08ad36d4424790e275d973445fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade675256d9e88682d4bebdcc4a57f86f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ade675256d9e88682d4bebdcc4a57f86f">colr_mb_len</a> (const char *s, size_t length)</td></tr>
<tr class="memdesc:ade675256d9e88682d4bebdcc4a57f86f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>mbrlen</code>, except it will return the length of the next N (<code>length</code>) multibyte characters in bytes.  <a href="#ade675256d9e88682d4bebdcc4a57f86f">More...</a><br /></td></tr>
<tr class="separator:ade675256d9e88682d4bebdcc4a57f86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c359a48f811316d765b7abef1ea8f4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a34c359a48f811316d765b7abef1ea8f4">colr_printf_handler</a> (FILE *fp, const struct printf_info *info, const void *const *args)</td></tr>
<tr class="memdesc:a34c359a48f811316d765b7abef1ea8f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles printing with printf for Colr objects.  <a href="#a34c359a48f811316d765b7abef1ea8f4">More...</a><br /></td></tr>
<tr class="separator:a34c359a48f811316d765b7abef1ea8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95619a7f5eeb0158dfb969ae9a26a6bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a95619a7f5eeb0158dfb969ae9a26a6bb">colr_printf_info</a> (const struct printf_info *info, size_t n, int *argtypes, int *sz)</td></tr>
<tr class="memdesc:a95619a7f5eeb0158dfb969ae9a26a6bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles the arg count/size for the Colr printf handler.  <a href="#a95619a7f5eeb0158dfb969ae9a26a6bb">More...</a><br /></td></tr>
<tr class="separator:a95619a7f5eeb0158dfb969ae9a26a6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf134ca9a2188d83171fe91948354d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#aaaf134ca9a2188d83171fe91948354d9">colr_printf_register</a> (void)</td></tr>
<tr class="memdesc:aaaf134ca9a2188d83171fe91948354d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers COLR_FMT_CHAR to handle Colr objects in the printf-family functions.  <a href="#aaaf134ca9a2188d83171fe91948354d9">More...</a><br /></td></tr>
<tr class="separator:aaaf134ca9a2188d83171fe91948354d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37cd9a8f2748629e68e9c41ffca557a9"><td class="memItemLeft" align="right" valign="top">regmatch_t **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a37cd9a8f2748629e68e9c41ffca557a9">colr_re_matches</a> (const char *s, regex_t *repattern)</td></tr>
<tr class="memdesc:a37cd9a8f2748629e68e9c41ffca557a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all <code>regmatch_t</code> matches for regex pattern in a string (<code>char*</code>).  <a href="#a37cd9a8f2748629e68e9c41ffca557a9">More...</a><br /></td></tr>
<tr class="separator:a37cd9a8f2748629e68e9c41ffca557a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180c1ac4711df9fb025639c966f84727"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a180c1ac4711df9fb025639c966f84727">colr_set_locale</a> (void)</td></tr>
<tr class="memdesc:a180c1ac4711df9fb025639c966f84727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the locale to <code>(LC_ALL, "")</code> if it hasn't already been set.  <a href="#a180c1ac4711df9fb025639c966f84727">More...</a><br /></td></tr>
<tr class="separator:a180c1ac4711df9fb025639c966f84727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b98f363fb0873cfb7e60e99191647a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a1b98f363fb0873cfb7e60e99191647a6">colr_str_array_contains</a> (char **lst, const char *s)</td></tr>
<tr class="memdesc:a1b98f363fb0873cfb7e60e99191647a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a string (<code>char*</code>) is in an array of strings (<code>char**</code>, where the last element is <code>NULL</code>).  <a href="#a1b98f363fb0873cfb7e60e99191647a6">More...</a><br /></td></tr>
<tr class="separator:a1b98f363fb0873cfb7e60e99191647a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90384ff3082ad86bf5eb0923ac9a644a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a90384ff3082ad86bf5eb0923ac9a644a">colr_str_array_free</a> (char **ps)</td></tr>
<tr class="memdesc:a90384ff3082ad86bf5eb0923ac9a644a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an allocated array of strings, including the array itself.  <a href="#a90384ff3082ad86bf5eb0923ac9a644a">More...</a><br /></td></tr>
<tr class="separator:a90384ff3082ad86bf5eb0923ac9a644a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a8345393e635e1c5e148473bdce292d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a1a8345393e635e1c5e148473bdce292d">colr_str_center</a> (const char *s, int width, const char padchar)</td></tr>
<tr class="memdesc:a1a8345393e635e1c5e148473bdce292d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Center-justifies a string (<code>char*</code>), ignoring escape codes when measuring the width.  <a href="#a1a8345393e635e1c5e148473bdce292d">More...</a><br /></td></tr>
<tr class="separator:a1a8345393e635e1c5e148473bdce292d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e3ecc4a6c4bcaad1217df9200d271e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ad5e3ecc4a6c4bcaad1217df9200d271e">colr_str_char_count</a> (const char *s, const char c)</td></tr>
<tr class="memdesc:ad5e3ecc4a6c4bcaad1217df9200d271e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of characters (<code>c</code>) that are found in a string (<code>char*</code>) (<code>s</code>).  <a href="#ad5e3ecc4a6c4bcaad1217df9200d271e">More...</a><br /></td></tr>
<tr class="separator:ad5e3ecc4a6c4bcaad1217df9200d271e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae479b42d955b24cc1ddf572b9282a624"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ae479b42d955b24cc1ddf572b9282a624">colr_str_char_lcount</a> (const char *s, const char c)</td></tr>
<tr class="memdesc:ae479b42d955b24cc1ddf572b9282a624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of characters (<code>c</code>) that are found at the beginning of a string (<code>char*</code>) (<code>s</code>).  <a href="#ae479b42d955b24cc1ddf572b9282a624">More...</a><br /></td></tr>
<tr class="separator:ae479b42d955b24cc1ddf572b9282a624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566857db0f22ad4a1ba17ee3a56cf174"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a566857db0f22ad4a1ba17ee3a56cf174">colr_str_chars_lcount</a> (const char *restrict s, const char *restrict chars)</td></tr>
<tr class="memdesc:a566857db0f22ad4a1ba17ee3a56cf174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of characters that are found at the beginning of a string (<code>char*</code>) (<code>s</code>), where the character can be any of <code>chars</code>.  <a href="#a566857db0f22ad4a1ba17ee3a56cf174">More...</a><br /></td></tr>
<tr class="separator:a566857db0f22ad4a1ba17ee3a56cf174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa991b64a363bd5e6f1a722ed0759338"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#afa991b64a363bd5e6f1a722ed0759338">colr_str_code_count</a> (const char *s)</td></tr>
<tr class="memdesc:afa991b64a363bd5e6f1a722ed0759338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of escape-codes in a string (<code>char*</code>).  <a href="#afa991b64a363bd5e6f1a722ed0759338">More...</a><br /></td></tr>
<tr class="separator:afa991b64a363bd5e6f1a722ed0759338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6fa8ad1635fcff75ee1213a975dba4d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ab6fa8ad1635fcff75ee1213a975dba4d">colr_str_code_len</a> (const char *s)</td></tr>
<tr class="memdesc:ab6fa8ad1635fcff75ee1213a975dba4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of bytes that make up all the escape-codes in a string (<code>char*</code>).  <a href="#ab6fa8ad1635fcff75ee1213a975dba4d">More...</a><br /></td></tr>
<tr class="separator:ab6fa8ad1635fcff75ee1213a975dba4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb3c15e839f5c16d3e7cd001d32aee6"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a4fb3c15e839f5c16d3e7cd001d32aee6">colr_str_copy</a> (char *restrict dest, const char *restrict src, size_t length)</td></tr>
<tr class="memdesc:a4fb3c15e839f5c16d3e7cd001d32aee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a string (<code>char*</code>) like strncpy, but ensures null-termination.  <a href="#a4fb3c15e839f5c16d3e7cd001d32aee6">More...</a><br /></td></tr>
<tr class="separator:a4fb3c15e839f5c16d3e7cd001d32aee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd712bd8253271f0c88158db791c8bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a7dd712bd8253271f0c88158db791c8bf">colr_str_ends_with</a> (const char *restrict s, const char *restrict suffix)</td></tr>
<tr class="memdesc:a7dd712bd8253271f0c88158db791c8bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if one string (<code>char*</code>) ends with another.  <a href="#a7dd712bd8253271f0c88158db791c8bf">More...</a><br /></td></tr>
<tr class="separator:a7dd712bd8253271f0c88158db791c8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6292cbb8bd9f3d19bb0bd05a4d7b0bea"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a6292cbb8bd9f3d19bb0bd05a4d7b0bea">colr_str_get_codes</a> (const char *s, bool unique)</td></tr>
<tr class="memdesc:a6292cbb8bd9f3d19bb0bd05a4d7b0bea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an array of escape-codes from a string (<code>char*</code>).  <a href="#a6292cbb8bd9f3d19bb0bd05a4d7b0bea">More...</a><br /></td></tr>
<tr class="separator:a6292cbb8bd9f3d19bb0bd05a4d7b0bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9f4cbe1e806316e063206dfb610476"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a8b9f4cbe1e806316e063206dfb610476">colr_str_has_codes</a> (const char *s)</td></tr>
<tr class="memdesc:a8b9f4cbe1e806316e063206dfb610476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a string (<code>char*</code>) has ANSI escape codes in it.  <a href="#a8b9f4cbe1e806316e063206dfb610476">More...</a><br /></td></tr>
<tr class="separator:a8b9f4cbe1e806316e063206dfb610476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f8caf33e6befb9b78958f5d24911ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a39f8caf33e6befb9b78958f5d24911ff">colr_str_has_ColorArg</a> (const char *s, <a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *carg)</td></tr>
<tr class="memdesc:a39f8caf33e6befb9b78958f5d24911ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a string contains a specific color code.  <a href="#a39f8caf33e6befb9b78958f5d24911ff">More...</a><br /></td></tr>
<tr class="separator:a39f8caf33e6befb9b78958f5d24911ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5a3149704b14b85a0236d9940fb4e7"><td class="memItemLeft" align="right" valign="top">ColrHash&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#adf5a3149704b14b85a0236d9940fb4e7">colr_str_hash</a> (const char *s)</td></tr>
<tr class="memdesc:adf5a3149704b14b85a0236d9940fb4e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash a string using <a href="http://www.cse.yorku.ca/~oz/hash.html">djb2</a>.  <a href="#adf5a3149704b14b85a0236d9940fb4e7">More...</a><br /></td></tr>
<tr class="separator:adf5a3149704b14b85a0236d9940fb4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc3f370843b64e92fb7d79e7989b5c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a3dc3f370843b64e92fb7d79e7989b5c3">colr_str_is_all</a> (const char *s, const char c)</td></tr>
<tr class="memdesc:a3dc3f370843b64e92fb7d79e7989b5c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a string (<code>char*</code>) consists of only one character, possibly repeated.  <a href="#a3dc3f370843b64e92fb7d79e7989b5c3">More...</a><br /></td></tr>
<tr class="separator:a3dc3f370843b64e92fb7d79e7989b5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b2971301b5247769b08f5ed08564fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a85b2971301b5247769b08f5ed08564fb">colr_str_is_codes</a> (const char *s)</td></tr>
<tr class="memdesc:a85b2971301b5247769b08f5ed08564fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a string (<code>char*</code>) is composed entirely of escape codes.  <a href="#a85b2971301b5247769b08f5ed08564fb">More...</a><br /></td></tr>
<tr class="separator:a85b2971301b5247769b08f5ed08564fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5492da225ade4fd8fe71989826348b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#af5492da225ade4fd8fe71989826348b4">colr_str_is_digits</a> (const char *s)</td></tr>
<tr class="memdesc:af5492da225ade4fd8fe71989826348b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all characters in a string (<code>char*</code>) are digits.  <a href="#af5492da225ade4fd8fe71989826348b4">More...</a><br /></td></tr>
<tr class="separator:af5492da225ade4fd8fe71989826348b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eedebae47b5d22dda709f833f23a256"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a5eedebae47b5d22dda709f833f23a256">colr_str_ljust</a> (const char *s, int width, const char padchar)</td></tr>
<tr class="memdesc:a5eedebae47b5d22dda709f833f23a256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-justifies a string (<code>char*</code>), ignoring escape codes when measuring the width.  <a href="#a5eedebae47b5d22dda709f833f23a256">More...</a><br /></td></tr>
<tr class="separator:a5eedebae47b5d22dda709f833f23a256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116ec26960e79456dbf9cf7f40ffe0d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a116ec26960e79456dbf9cf7f40ffe0d7">colr_str_lower</a> (char *s)</td></tr>
<tr class="memdesc:a116ec26960e79456dbf9cf7f40ffe0d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string (<code>char*</code>) into lower case in place.  <a href="#a116ec26960e79456dbf9cf7f40ffe0d7">More...</a><br /></td></tr>
<tr class="separator:a116ec26960e79456dbf9cf7f40ffe0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ffd3ec364c8d0c0e96a0723b7aa46f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a35ffd3ec364c8d0c0e96a0723b7aa46f">colr_str_lstrip</a> (char *restrict dest, const char *restrict s, size_t length, const char c)</td></tr>
<tr class="memdesc:a35ffd3ec364c8d0c0e96a0723b7aa46f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strip a leading character from a string (<code>char*</code>), filling another string (<code>char*</code>) with the result.  <a href="#a35ffd3ec364c8d0c0e96a0723b7aa46f">More...</a><br /></td></tr>
<tr class="separator:a35ffd3ec364c8d0c0e96a0723b7aa46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060dc0f80eade56563d6942339c2859e"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a060dc0f80eade56563d6942339c2859e">colr_str_lstrip_char</a> (const char *s, const char c)</td></tr>
<tr class="memdesc:a060dc0f80eade56563d6942339c2859e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strips a leading character from a string (<code>char*</code>), and allocates a new string with the result.  <a href="#a060dc0f80eade56563d6942339c2859e">More...</a><br /></td></tr>
<tr class="separator:a060dc0f80eade56563d6942339c2859e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af502be785bdb221c2dc1a47fece1fc5f"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#af502be785bdb221c2dc1a47fece1fc5f">colr_str_lstrip_chars</a> (const char *restrict s, const char *restrict chars)</td></tr>
<tr class="memdesc:af502be785bdb221c2dc1a47fece1fc5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes certain characters from the start of a string (<code>char*</code>) and allocates a new string with the result.  <a href="#af502be785bdb221c2dc1a47fece1fc5f">More...</a><br /></td></tr>
<tr class="separator:af502be785bdb221c2dc1a47fece1fc5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab473f70278850994e1b7b9c8008353fa"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ab473f70278850994e1b7b9c8008353fa">colr_str_mb_len</a> (const char *s)</td></tr>
<tr class="memdesc:ab473f70278850994e1b7b9c8008353fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of characters in a string (<code>char*</code>), taking into account possibly multibyte characters.  <a href="#ab473f70278850994e1b7b9c8008353fa">More...</a><br /></td></tr>
<tr class="separator:ab473f70278850994e1b7b9c8008353fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037a0245a39d7ff5cfba5f779d0eb251"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a037a0245a39d7ff5cfba5f779d0eb251">colr_str_noncode_len</a> (const char *s)</td></tr>
<tr class="memdesc:a037a0245a39d7ff5cfba5f779d0eb251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of string (<code>char*</code>), ignoring escape codes and the the null-terminator.  <a href="#a037a0245a39d7ff5cfba5f779d0eb251">More...</a><br /></td></tr>
<tr class="separator:a037a0245a39d7ff5cfba5f779d0eb251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2144034980aea6427fbc9bdf70e5b8c3"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a2144034980aea6427fbc9bdf70e5b8c3">colr_str_replace</a> (const char *restrict s, const char *restrict target, const char *restrict repl)</td></tr>
<tr class="memdesc:a2144034980aea6427fbc9bdf70e5b8c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the first substring found in a string (<code>char*</code>).  <a href="#a2144034980aea6427fbc9bdf70e5b8c3">More...</a><br /></td></tr>
<tr class="separator:a2144034980aea6427fbc9bdf70e5b8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb81a3339840e1f527463eaddf994d8e"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#abb81a3339840e1f527463eaddf994d8e">colr_str_replace_all</a> (const char *restrict s, const char *restrict target, const char *restrict repl)</td></tr>
<tr class="memdesc:abb81a3339840e1f527463eaddf994d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the first substring found in a string (<code>char*</code>).  <a href="#abb81a3339840e1f527463eaddf994d8e">More...</a><br /></td></tr>
<tr class="separator:abb81a3339840e1f527463eaddf994d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c01a492bcbda6cf93705bff0cb0dbe"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#af7c01a492bcbda6cf93705bff0cb0dbe">colr_str_replace_all_ColorArg</a> (const char *restrict s, const char *restrict target, <a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *repl)</td></tr>
<tr class="memdesc:af7c01a492bcbda6cf93705bff0cb0dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all substrings in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string result.  <a href="#af7c01a492bcbda6cf93705bff0cb0dbe">More...</a><br /></td></tr>
<tr class="separator:af7c01a492bcbda6cf93705bff0cb0dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53fa120c1074c836f65b4aace67d0c83"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a53fa120c1074c836f65b4aace67d0c83">colr_str_replace_all_ColorResult</a> (const char *restrict s, const char *restrict target, <a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *repl)</td></tr>
<tr class="memdesc:a53fa120c1074c836f65b4aace67d0c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all substrings in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>'s string result.  <a href="#a53fa120c1074c836f65b4aace67d0c83">More...</a><br /></td></tr>
<tr class="separator:a53fa120c1074c836f65b4aace67d0c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73789c11eaeb5a36b5f97556103a108d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a73789c11eaeb5a36b5f97556103a108d">colr_str_replace_all_ColorText</a> (const char *restrict s, const char *restrict target, <a class="el" href="colr_8h.html#structColorText">ColorText</a> *repl)</td></tr>
<tr class="memdesc:a73789c11eaeb5a36b5f97556103a108d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all substrings in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string result.  <a href="#a73789c11eaeb5a36b5f97556103a108d">More...</a><br /></td></tr>
<tr class="separator:a73789c11eaeb5a36b5f97556103a108d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420403f3115f43c5e6356deee5644e84"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a420403f3115f43c5e6356deee5644e84">colr_str_replace_cnt</a> (const char *restrict s, const char *restrict target, const char *restrict repl, int count)</td></tr>
<tr class="memdesc:a420403f3115f43c5e6356deee5644e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces one or more substrings in a string (<code>char*</code>).  <a href="#a420403f3115f43c5e6356deee5644e84">More...</a><br /></td></tr>
<tr class="separator:a420403f3115f43c5e6356deee5644e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b61a4cadcf73e21eee109623695bad"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#aa8b61a4cadcf73e21eee109623695bad">colr_str_replace_ColorArg</a> (const char *restrict s, const char *restrict target, <a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *repl)</td></tr>
<tr class="memdesc:aa8b61a4cadcf73e21eee109623695bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a substring in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string result.  <a href="#aa8b61a4cadcf73e21eee109623695bad">More...</a><br /></td></tr>
<tr class="separator:aa8b61a4cadcf73e21eee109623695bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136d15edf2f804c89cee619bb811ef3a"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a136d15edf2f804c89cee619bb811ef3a">colr_str_replace_ColorResult</a> (const char *restrict s, const char *restrict target, <a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *repl)</td></tr>
<tr class="memdesc:a136d15edf2f804c89cee619bb811ef3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a substring in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>'s string result.  <a href="#a136d15edf2f804c89cee619bb811ef3a">More...</a><br /></td></tr>
<tr class="separator:a136d15edf2f804c89cee619bb811ef3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee8d79a90917974ee4537705e34fd76"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#aaee8d79a90917974ee4537705e34fd76">colr_str_replace_ColorText</a> (const char *restrict s, const char *restrict target, <a class="el" href="colr_8h.html#structColorText">ColorText</a> *repl)</td></tr>
<tr class="memdesc:aaee8d79a90917974ee4537705e34fd76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a substring in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string result.  <a href="#aaee8d79a90917974ee4537705e34fd76">More...</a><br /></td></tr>
<tr class="separator:aaee8d79a90917974ee4537705e34fd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09db8190822ff7e7e712399680325e6a"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a09db8190822ff7e7e712399680325e6a">colr_str_replace_re</a> (const char *restrict s, const char *restrict pattern, const char *restrict repl, int re_flags)</td></tr>
<tr class="memdesc:a09db8190822ff7e7e712399680325e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces a substring from a regex pattern string (<code>char*</code>) in a string (<code>char*</code>).  <a href="#a09db8190822ff7e7e712399680325e6a">More...</a><br /></td></tr>
<tr class="separator:a09db8190822ff7e7e712399680325e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232c65d12eb09d598eeb64490f39371c"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a232c65d12eb09d598eeb64490f39371c">colr_str_replace_re_all</a> (const char *restrict s, const char *restrict pattern, const char *restrict repl, int re_flags)</td></tr>
<tr class="memdesc:a232c65d12eb09d598eeb64490f39371c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all substrings from a regex pattern string (<code>char*</code>) in a string (<code>char*</code>).  <a href="#a232c65d12eb09d598eeb64490f39371c">More...</a><br /></td></tr>
<tr class="separator:a232c65d12eb09d598eeb64490f39371c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577e45a5c233dd1b4774a9034b17e3eb"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a577e45a5c233dd1b4774a9034b17e3eb">colr_str_replace_re_all_ColorArg</a> (const char *restrict s, const char *restrict pattern, <a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *repl, int re_flags)</td></tr>
<tr class="memdesc:a577e45a5c233dd1b4774a9034b17e3eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all substrings from a regex pattern string (<code>char*</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string result.  <a href="#a577e45a5c233dd1b4774a9034b17e3eb">More...</a><br /></td></tr>
<tr class="separator:a577e45a5c233dd1b4774a9034b17e3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e18a36736e5451529e80443cfb7b1fc"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a3e18a36736e5451529e80443cfb7b1fc">colr_str_replace_re_all_ColorResult</a> (const char *restrict s, const char *restrict pattern, <a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *repl, int re_flags)</td></tr>
<tr class="memdesc:a3e18a36736e5451529e80443cfb7b1fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all substrings from a regex pattern string (<code>char*</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>'s string result.  <a href="#a3e18a36736e5451529e80443cfb7b1fc">More...</a><br /></td></tr>
<tr class="separator:a3e18a36736e5451529e80443cfb7b1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747e31fa3d8961e0bdd11eabd673accc"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a747e31fa3d8961e0bdd11eabd673accc">colr_str_replace_re_all_ColorText</a> (const char *restrict s, const char *restrict pattern, <a class="el" href="colr_8h.html#structColorText">ColorText</a> *repl, int re_flags)</td></tr>
<tr class="memdesc:a747e31fa3d8961e0bdd11eabd673accc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all substrings from a regex pattern string (<code>char*</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string result.  <a href="#a747e31fa3d8961e0bdd11eabd673accc">More...</a><br /></td></tr>
<tr class="separator:a747e31fa3d8961e0bdd11eabd673accc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d58bde53845d6ab2c54e4ba0c68a3d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a78d58bde53845d6ab2c54e4ba0c68a3d">colr_str_replace_re_ColorArg</a> (const char *restrict s, const char *restrict pattern, <a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *repl, int re_flags)</td></tr>
<tr class="memdesc:a78d58bde53845d6ab2c54e4ba0c68a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace substrings from a regex pattern string (<code>char*</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string result.  <a href="#a78d58bde53845d6ab2c54e4ba0c68a3d">More...</a><br /></td></tr>
<tr class="separator:a78d58bde53845d6ab2c54e4ba0c68a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0376bed13e55acaca37e52c382044e1d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a0376bed13e55acaca37e52c382044e1d">colr_str_replace_re_ColorResult</a> (const char *restrict s, const char *restrict pattern, <a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *repl, int re_flags)</td></tr>
<tr class="memdesc:a0376bed13e55acaca37e52c382044e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace substrings from a regex pattern string (<code>char*</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>'s string result.  <a href="#a0376bed13e55acaca37e52c382044e1d">More...</a><br /></td></tr>
<tr class="separator:a0376bed13e55acaca37e52c382044e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d6a10f70b435559656bbad0090d92d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ab8d6a10f70b435559656bbad0090d92d">colr_str_replace_re_ColorText</a> (const char *restrict s, const char *restrict pattern, <a class="el" href="colr_8h.html#structColorText">ColorText</a> *repl, int re_flags)</td></tr>
<tr class="memdesc:ab8d6a10f70b435559656bbad0090d92d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace substrings from a regex pattern string (<code>char*</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string result.  <a href="#ab8d6a10f70b435559656bbad0090d92d">More...</a><br /></td></tr>
<tr class="separator:ab8d6a10f70b435559656bbad0090d92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fbc36f0f7aba3aa0616437f937efd20"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a2fbc36f0f7aba3aa0616437f937efd20">colr_str_replace_re_match</a> (const char *restrict s, regmatch_t *match, const char *restrict repl)</td></tr>
<tr class="memdesc:a2fbc36f0f7aba3aa0616437f937efd20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces substrings from a single regex match (<code>regmatch_t*</code>) in a string (<code>char*</code>).  <a href="#a2fbc36f0f7aba3aa0616437f937efd20">More...</a><br /></td></tr>
<tr class="separator:a2fbc36f0f7aba3aa0616437f937efd20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4cbd6a8fd3cef76f07b705b09d2a54"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a0d4cbd6a8fd3cef76f07b705b09d2a54">colr_str_replace_re_match_ColorArg</a> (const char *restrict s, regmatch_t *match, <a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *repl)</td></tr>
<tr class="memdesc:a0d4cbd6a8fd3cef76f07b705b09d2a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace substrings from a regex match (<code>regmatch_t*</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string result.  <a href="#a0d4cbd6a8fd3cef76f07b705b09d2a54">More...</a><br /></td></tr>
<tr class="separator:a0d4cbd6a8fd3cef76f07b705b09d2a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac092f944961dddc6574a6c55e6e878b0"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ac092f944961dddc6574a6c55e6e878b0">colr_str_replace_re_match_ColorResult</a> (const char *restrict s, regmatch_t *match, <a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *repl)</td></tr>
<tr class="memdesc:ac092f944961dddc6574a6c55e6e878b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace substrings from a regex match (<code>regmatch_t*</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>'s string result.  <a href="#ac092f944961dddc6574a6c55e6e878b0">More...</a><br /></td></tr>
<tr class="separator:ac092f944961dddc6574a6c55e6e878b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d954398333472c1436f9bc051f46392"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a4d954398333472c1436f9bc051f46392">colr_str_replace_re_match_ColorText</a> (const char *restrict s, regmatch_t *match, <a class="el" href="colr_8h.html#structColorText">ColorText</a> *repl)</td></tr>
<tr class="memdesc:a4d954398333472c1436f9bc051f46392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace substrings from a regex match (<code>regmatch_t*</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string result.  <a href="#a4d954398333472c1436f9bc051f46392">More...</a><br /></td></tr>
<tr class="separator:a4d954398333472c1436f9bc051f46392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205182bbcbf99a3faa1b207a28721c87"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a205182bbcbf99a3faa1b207a28721c87">colr_str_replace_re_match_i</a> (const char *restrict ref, char *target, regmatch_t *match, const char *restrict repl)</td></tr>
<tr class="memdesc:a205182bbcbf99a3faa1b207a28721c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces substrings from a regex match (<code>regmatch_t*</code>) in a string (<code>char*</code>).  <a href="#a205182bbcbf99a3faa1b207a28721c87">More...</a><br /></td></tr>
<tr class="separator:a205182bbcbf99a3faa1b207a28721c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c72d363d7f87e2a7546202b439557e1"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a8c72d363d7f87e2a7546202b439557e1">colr_str_replace_re_matches</a> (const char *restrict s, regmatch_t **matches, const char *restrict repl)</td></tr>
<tr class="memdesc:a8c72d363d7f87e2a7546202b439557e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces substrings from an array of regex match (<code>regmatch_t*</code>) in a string (<code>char*</code>).  <a href="#a8c72d363d7f87e2a7546202b439557e1">More...</a><br /></td></tr>
<tr class="separator:a8c72d363d7f87e2a7546202b439557e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b2cdee697818e2f9f38ec7eac98bcb"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a75b2cdee697818e2f9f38ec7eac98bcb">colr_str_replace_re_matches_ColorArg</a> (const char *restrict s, regmatch_t **matches, <a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *repl)</td></tr>
<tr class="memdesc:a75b2cdee697818e2f9f38ec7eac98bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace substrings from an array of regex matches (<code>regmatch_t**</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string result.  <a href="#a75b2cdee697818e2f9f38ec7eac98bcb">More...</a><br /></td></tr>
<tr class="separator:a75b2cdee697818e2f9f38ec7eac98bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4bb71015338108d86fcf47317cc5ff"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a4d4bb71015338108d86fcf47317cc5ff">colr_str_replace_re_matches_ColorResult</a> (const char *restrict s, regmatch_t **matches, <a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *repl)</td></tr>
<tr class="memdesc:a4d4bb71015338108d86fcf47317cc5ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace substrings from an array of regex matches (<code>regmatch_t**</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>'s string result.  <a href="#a4d4bb71015338108d86fcf47317cc5ff">More...</a><br /></td></tr>
<tr class="separator:a4d4bb71015338108d86fcf47317cc5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4fe38cc205cbd49b2f8477744574294"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#aa4fe38cc205cbd49b2f8477744574294">colr_str_replace_re_matches_ColorText</a> (const char *restrict s, regmatch_t **matches, <a class="el" href="colr_8h.html#structColorText">ColorText</a> *repl)</td></tr>
<tr class="memdesc:aa4fe38cc205cbd49b2f8477744574294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace substrings from an array of regex matches (<code>regmatch_t**</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string result.  <a href="#aa4fe38cc205cbd49b2f8477744574294">More...</a><br /></td></tr>
<tr class="separator:aa4fe38cc205cbd49b2f8477744574294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63621c6749d8219112ff51ebf0ecb22a"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a63621c6749d8219112ff51ebf0ecb22a">colr_str_replace_re_pat</a> (const char *restrict s, regex_t *repattern, const char *restrict repl)</td></tr>
<tr class="memdesc:a63621c6749d8219112ff51ebf0ecb22a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces regex patterns in a string (<code>char*</code>).  <a href="#a63621c6749d8219112ff51ebf0ecb22a">More...</a><br /></td></tr>
<tr class="separator:a63621c6749d8219112ff51ebf0ecb22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd19623913d27e2d9a5af3496a478c2b"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#afd19623913d27e2d9a5af3496a478c2b">colr_str_replace_re_pat_all</a> (const char *restrict s, regex_t *repattern, const char *restrict repl)</td></tr>
<tr class="memdesc:afd19623913d27e2d9a5af3496a478c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all matches to a regex pattern in a string (<code>char*</code>).  <a href="#afd19623913d27e2d9a5af3496a478c2b">More...</a><br /></td></tr>
<tr class="separator:afd19623913d27e2d9a5af3496a478c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090ba95c4560134ef9c2807eff6a0ea1"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a090ba95c4560134ef9c2807eff6a0ea1">colr_str_replace_re_pat_all_ColorArg</a> (const char *restrict s, regex_t *repattern, <a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *repl)</td></tr>
<tr class="memdesc:a090ba95c4560134ef9c2807eff6a0ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all matches to a regex pattern in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string result.  <a href="#a090ba95c4560134ef9c2807eff6a0ea1">More...</a><br /></td></tr>
<tr class="separator:a090ba95c4560134ef9c2807eff6a0ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af083c2e1867ecaad0ae38a1324c915ac"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#af083c2e1867ecaad0ae38a1324c915ac">colr_str_replace_re_pat_all_ColorResult</a> (const char *restrict s, regex_t *repattern, <a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *repl)</td></tr>
<tr class="memdesc:af083c2e1867ecaad0ae38a1324c915ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all matches to a regex pattern in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>'s string result.  <a href="#af083c2e1867ecaad0ae38a1324c915ac">More...</a><br /></td></tr>
<tr class="separator:af083c2e1867ecaad0ae38a1324c915ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c4a5c34b26473dc45f93ce2c66faf1"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ab9c4a5c34b26473dc45f93ce2c66faf1">colr_str_replace_re_pat_all_ColorText</a> (const char *restrict s, regex_t *repattern, <a class="el" href="colr_8h.html#structColorText">ColorText</a> *repl)</td></tr>
<tr class="memdesc:ab9c4a5c34b26473dc45f93ce2c66faf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all matches to a regex pattern in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string result.  <a href="#ab9c4a5c34b26473dc45f93ce2c66faf1">More...</a><br /></td></tr>
<tr class="separator:ab9c4a5c34b26473dc45f93ce2c66faf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adecbe2f1e87613b6f4a51158325dd4f7"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#adecbe2f1e87613b6f4a51158325dd4f7">colr_str_replace_re_pat_ColorArg</a> (const char *restrict s, regex_t *repattern, <a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *repl)</td></tr>
<tr class="memdesc:adecbe2f1e87613b6f4a51158325dd4f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace regex patterns in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string result.  <a href="#adecbe2f1e87613b6f4a51158325dd4f7">More...</a><br /></td></tr>
<tr class="separator:adecbe2f1e87613b6f4a51158325dd4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd756c82acab9505343b614d52c0b19"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#abcd756c82acab9505343b614d52c0b19">colr_str_replace_re_pat_ColorResult</a> (const char *restrict s, regex_t *repattern, <a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *repl)</td></tr>
<tr class="memdesc:abcd756c82acab9505343b614d52c0b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace regex patterns in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>'s string result.  <a href="#abcd756c82acab9505343b614d52c0b19">More...</a><br /></td></tr>
<tr class="separator:abcd756c82acab9505343b614d52c0b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8b04b6d851f26304183d1111b8f0dc"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a6f8b04b6d851f26304183d1111b8f0dc">colr_str_replace_re_pat_ColorText</a> (const char *restrict s, regex_t *repattern, <a class="el" href="colr_8h.html#structColorText">ColorText</a> *repl)</td></tr>
<tr class="memdesc:a6f8b04b6d851f26304183d1111b8f0dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace regex patterns in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string result.  <a href="#a6f8b04b6d851f26304183d1111b8f0dc">More...</a><br /></td></tr>
<tr class="separator:a6f8b04b6d851f26304183d1111b8f0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196ad91a69cfbeb27a5266ffc93ed353"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a196ad91a69cfbeb27a5266ffc93ed353">colr_str_repr</a> (const char *s)</td></tr>
<tr class="memdesc:a196ad91a69cfbeb27a5266ffc93ed353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string (<code>char*</code>) into a representation of a string, by wrapping it in quotes and escaping characters that need escaping.  <a href="#a196ad91a69cfbeb27a5266ffc93ed353">More...</a><br /></td></tr>
<tr class="separator:a196ad91a69cfbeb27a5266ffc93ed353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc75e3bf729168f9ac204ef0a1708d46"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#acc75e3bf729168f9ac204ef0a1708d46">colr_str_rjust</a> (const char *s, int width, const char padchar)</td></tr>
<tr class="memdesc:acc75e3bf729168f9ac204ef0a1708d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right-justifies a string (<code>char*</code>), ignoring escape codes when measuring the width.  <a href="#acc75e3bf729168f9ac204ef0a1708d46">More...</a><br /></td></tr>
<tr class="separator:acc75e3bf729168f9ac204ef0a1708d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23328cead6a65d7b3ef2c2ca48d11ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ac23328cead6a65d7b3ef2c2ca48d11ce">colr_str_starts_with</a> (const char *restrict s, const char *restrict prefix)</td></tr>
<tr class="memdesc:ac23328cead6a65d7b3ef2c2ca48d11ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a string (<code>char*</code>) for a certain prefix substring.  <a href="#ac23328cead6a65d7b3ef2c2ca48d11ce">More...</a><br /></td></tr>
<tr class="separator:ac23328cead6a65d7b3ef2c2ca48d11ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b13b04dc178d0990ab2ae403ee64e0"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ab0b13b04dc178d0990ab2ae403ee64e0">colr_str_strip_codes</a> (const char *s)</td></tr>
<tr class="memdesc:ab0b13b04dc178d0990ab2ae403ee64e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strips escape codes from a string (<code>char*</code>), resulting in a new allocated string.  <a href="#ab0b13b04dc178d0990ab2ae403ee64e0">More...</a><br /></td></tr>
<tr class="separator:ab0b13b04dc178d0990ab2ae403ee64e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b847e10db135f7ebc89031b3a7ad56"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ae9b847e10db135f7ebc89031b3a7ad56">colr_str_to_lower</a> (const char *s)</td></tr>
<tr class="memdesc:ae9b847e10db135f7ebc89031b3a7ad56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new lowercase version of a string (<code>char*</code>).  <a href="#ae9b847e10db135f7ebc89031b3a7ad56">More...</a><br /></td></tr>
<tr class="separator:ae9b847e10db135f7ebc89031b3a7ad56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ebdcd3c6e598a244292c7605452e9d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ab2ebdcd3c6e598a244292c7605452e9d">colr_supports_rgb</a> (void)</td></tr>
<tr class="memdesc:ab2ebdcd3c6e598a244292c7605452e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the current environment support <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> (True Colors).  <a href="#ab2ebdcd3c6e598a244292c7605452e9d">More...</a><br /></td></tr>
<tr class="separator:ab2ebdcd3c6e598a244292c7605452e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2aab28fe264005a5d17b888b542610b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ac2aab28fe264005a5d17b888b542610b">colr_supports_rgb_static</a> (void)</td></tr>
<tr class="memdesc:ac2aab28fe264005a5d17b888b542610b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="colr_8c.html#ab2ebdcd3c6e598a244292c7605452e9d" title="Determine whether the current environment support RGB (True Colors). ">colr_supports_rgb()</a>, but the environment is only checked on the first call.  <a href="#ac2aab28fe264005a5d17b888b542610b">More...</a><br /></td></tr>
<tr class="separator:ac2aab28fe264005a5d17b888b542610b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c11bb5b3b1bb2848bb16aee39763b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structTermSize">TermSize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ae4c11bb5b3b1bb2848bb16aee39763b2">colr_term_size</a> (void)</td></tr>
<tr class="memdesc:ae4c11bb5b3b1bb2848bb16aee39763b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to retrieve the row/column size of the terminal and returns a <a class="el" href="colr_8h.html#structTermSize" title="Holds a terminal size, usually retrieved with colr_term_size(). ">TermSize</a>.  <a href="#ae4c11bb5b3b1bb2848bb16aee39763b2">More...</a><br /></td></tr>
<tr class="separator:ae4c11bb5b3b1bb2848bb16aee39763b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d7b7bf1080742eeb588ba70ce9ea77"><td class="memItemLeft" align="right" valign="top">struct winsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ae7d7b7bf1080742eeb588ba70ce9ea77">colr_win_size</a> (void)</td></tr>
<tr class="memdesc:ae7d7b7bf1080742eeb588ba70ce9ea77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to retrieve a <code>winsize</code> struct from an <code>ioctl</code> call.  <a href="#ae7d7b7bf1080742eeb588ba70ce9ea77">More...</a><br /></td></tr>
<tr class="separator:ae7d7b7bf1080742eeb588ba70ce9ea77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2c53ebede7f97645f671401bfe356d"><td class="memItemLeft" align="right" valign="top">struct winsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#afc2c53ebede7f97645f671401bfe356d">colr_win_size_env</a> (void)</td></tr>
<tr class="memdesc:afc2c53ebede7f97645f671401bfe356d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get window/terminal size using the environment variables <code>LINES</code>, <code>COLUMNS</code>, or <code>COLS</code>.  <a href="#afc2c53ebede7f97645f671401bfe356d">More...</a><br /></td></tr>
<tr class="separator:afc2c53ebede7f97645f671401bfe356d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac847d91a396ae6babc0bd46e6386a701"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ac847d91a396ae6babc0bd46e6386a701">ExtendedValue_eq</a> (<a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a> a, <a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a> b)</td></tr>
<tr class="memdesc:ac847d91a396ae6babc0bd46e6386a701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ExtendedValues.  <a href="#ac847d91a396ae6babc0bd46e6386a701">More...</a><br /></td></tr>
<tr class="separator:ac847d91a396ae6babc0bd46e6386a701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b464ee51d75d7f45ddd5926a7c9cf5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#af0b464ee51d75d7f45ddd5926a7c9cf5">ExtendedValue_from_BasicValue</a> (<a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> bval)</td></tr>
<tr class="memdesc:af0b464ee51d75d7f45ddd5926a7c9cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a BasicValue into an ExtendedValue.  <a href="#af0b464ee51d75d7f45ddd5926a7c9cf5">More...</a><br /></td></tr>
<tr class="separator:af0b464ee51d75d7f45ddd5926a7c9cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabf63956f397a0fe628313622ba5cde"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#aaabf63956f397a0fe628313622ba5cde">ExtendedValue_from_esc</a> (const char *s)</td></tr>
<tr class="memdesc:aaabf63956f397a0fe628313622ba5cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an escape-code string (<code>char*</code>) to an ExtendedValue.  <a href="#aaabf63956f397a0fe628313622ba5cde">More...</a><br /></td></tr>
<tr class="separator:aaabf63956f397a0fe628313622ba5cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0632d78965000b1e50068a64e335133b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a0632d78965000b1e50068a64e335133b">ExtendedValue_from_hex</a> (const char *hexstr)</td></tr>
<tr class="memdesc:a0632d78965000b1e50068a64e335133b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an ExtendedValue from a hex string (<code>char*</code>).  <a href="#a0632d78965000b1e50068a64e335133b">More...</a><br /></td></tr>
<tr class="separator:a0632d78965000b1e50068a64e335133b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757be189530b4925c84df25742374485"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a757be189530b4925c84df25742374485">ExtendedValue_from_hex_default</a> (const char *hexstr, <a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a> default_value)</td></tr>
<tr class="memdesc:a757be189530b4925c84df25742374485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an ExtendedValue from a hex string (<code>char*</code>), but return a default value if the hex string is invalid.  <a href="#a757be189530b4925c84df25742374485">More...</a><br /></td></tr>
<tr class="separator:a757be189530b4925c84df25742374485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1548d9fc5f3e00a7b5d834eb1e12ff93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a1548d9fc5f3e00a7b5d834eb1e12ff93">ExtendedValue_from_RGB</a> (<a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:a1548d9fc5f3e00a7b5d834eb1e12ff93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value into the closest matching ExtendedValue.  <a href="#a1548d9fc5f3e00a7b5d834eb1e12ff93">More...</a><br /></td></tr>
<tr class="separator:a1548d9fc5f3e00a7b5d834eb1e12ff93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e859d542a8aa0939e4f76b1f33cb5f8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a2e859d542a8aa0939e4f76b1f33cb5f8">ExtendedValue_from_str</a> (const char *arg)</td></tr>
<tr class="memdesc:a2e859d542a8aa0939e4f76b1f33cb5f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a known name, integer string (0-255), or a hex string (<code>char*</code>), into an ExtendedValue suitable for the extended-value-based functions.  <a href="#a2e859d542a8aa0939e4f76b1f33cb5f8">More...</a><br /></td></tr>
<tr class="separator:a2e859d542a8aa0939e4f76b1f33cb5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669c8872f6b44a047470d33eb5d8b765"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a669c8872f6b44a047470d33eb5d8b765">ExtendedValue_is_invalid</a> (int eval)</td></tr>
<tr class="memdesc:a669c8872f6b44a047470d33eb5d8b765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether an integer is an invalid ExtendedValue.  <a href="#a669c8872f6b44a047470d33eb5d8b765">More...</a><br /></td></tr>
<tr class="separator:a669c8872f6b44a047470d33eb5d8b765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b43e6ee55b05d9b73950794f2dd53a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a6b43e6ee55b05d9b73950794f2dd53a4">ExtendedValue_is_valid</a> (int eval)</td></tr>
<tr class="memdesc:a6b43e6ee55b05d9b73950794f2dd53a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether an integer is a valid ExtendedValue.  <a href="#a6b43e6ee55b05d9b73950794f2dd53a4">More...</a><br /></td></tr>
<tr class="separator:a6b43e6ee55b05d9b73950794f2dd53a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa45baebc38756a40e7084f8198999902"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#aa45baebc38756a40e7084f8198999902">ExtendedValue_repr</a> (int eval)</td></tr>
<tr class="memdesc:aa45baebc38756a40e7084f8198999902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation of a ExtendedValue.  <a href="#aa45baebc38756a40e7084f8198999902">More...</a><br /></td></tr>
<tr class="separator:aa45baebc38756a40e7084f8198999902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e334d6b9145fca9717fe5a2aeb542fe"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a4e334d6b9145fca9717fe5a2aeb542fe">ExtendedValue_to_str</a> (<a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a> eval)</td></tr>
<tr class="memdesc:a4e334d6b9145fca9717fe5a2aeb542fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a human-friendly string (<code>char*</code>) from an ExtendedValue's actual value, suitable for use with <a class="el" href="colr_8c.html#a2e859d542a8aa0939e4f76b1f33cb5f8" title="Converts a known name, integer string (0-255), or a hex string (char*), into an ExtendedValue suitabl...">ExtendedValue_from_str()</a>.  <a href="#a4e334d6b9145fca9717fe5a2aeb542fe">More...</a><br /></td></tr>
<tr class="separator:a4e334d6b9145fca9717fe5a2aeb542fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29032483aea8cb25d6b90750767ffc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ae29032483aea8cb25d6b90750767ffc1">format_bg</a> (char *out, <a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> value)</td></tr>
<tr class="memdesc:ae29032483aea8cb25d6b90750767ffc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for a background color.  <a href="#ae29032483aea8cb25d6b90750767ffc1">More...</a><br /></td></tr>
<tr class="separator:ae29032483aea8cb25d6b90750767ffc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97257ad40619df6a6c190890ff2873c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a97257ad40619df6a6c190890ff2873c4">format_bg_RGB</a> (char *out, <a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:a97257ad40619df6a6c190890ff2873c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for a true color (rgb) background color using values from an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct.  <a href="#a97257ad40619df6a6c190890ff2873c4">More...</a><br /></td></tr>
<tr class="separator:a97257ad40619df6a6c190890ff2873c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185cec167afe41b6401206659d2d406c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a185cec167afe41b6401206659d2d406c">format_bg_RGB_term</a> (char *out, <a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:a185cec167afe41b6401206659d2d406c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for a true color (rgb) fore color using an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct's values, approximating 256-color values.  <a href="#a185cec167afe41b6401206659d2d406c">More...</a><br /></td></tr>
<tr class="separator:a185cec167afe41b6401206659d2d406c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4853b53fa18d26741ab7178606e5724"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#aa4853b53fa18d26741ab7178606e5724">format_bgx</a> (char *out, unsigned char num)</td></tr>
<tr class="memdesc:aa4853b53fa18d26741ab7178606e5724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for an extended background color.  <a href="#aa4853b53fa18d26741ab7178606e5724">More...</a><br /></td></tr>
<tr class="separator:aa4853b53fa18d26741ab7178606e5724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6027d93e8768f3c152edafd92e757801"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a6027d93e8768f3c152edafd92e757801">format_fg</a> (char *out, <a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> value)</td></tr>
<tr class="memdesc:a6027d93e8768f3c152edafd92e757801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for a fore color.  <a href="#a6027d93e8768f3c152edafd92e757801">More...</a><br /></td></tr>
<tr class="separator:a6027d93e8768f3c152edafd92e757801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3391a0cd6b6f73d9d39f8179fc0eb0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#aa3391a0cd6b6f73d9d39f8179fc0eb0b">format_fg_RGB</a> (char *out, <a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:aa3391a0cd6b6f73d9d39f8179fc0eb0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for a true color (rgb) fore color using an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct's values.  <a href="#aa3391a0cd6b6f73d9d39f8179fc0eb0b">More...</a><br /></td></tr>
<tr class="separator:aa3391a0cd6b6f73d9d39f8179fc0eb0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4661c576a4da879b8d4a2c525a42ad78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a4661c576a4da879b8d4a2c525a42ad78">format_fg_RGB_term</a> (char *out, <a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:a4661c576a4da879b8d4a2c525a42ad78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for a true color (rgb) fore color using an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct's values, approximating 256-color values.  <a href="#a4661c576a4da879b8d4a2c525a42ad78">More...</a><br /></td></tr>
<tr class="separator:a4661c576a4da879b8d4a2c525a42ad78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd2cf68768c59fc3ed5c31b93590c53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#acfd2cf68768c59fc3ed5c31b93590c53">format_fgx</a> (char *out, unsigned char num)</td></tr>
<tr class="memdesc:acfd2cf68768c59fc3ed5c31b93590c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for an extended fore color.  <a href="#acfd2cf68768c59fc3ed5c31b93590c53">More...</a><br /></td></tr>
<tr class="separator:acfd2cf68768c59fc3ed5c31b93590c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aec8e6a80b4ca158df2ad20e3e6a59e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a6aec8e6a80b4ca158df2ad20e3e6a59e">format_style</a> (char *out, <a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a> <a class="el" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662">style</a>)</td></tr>
<tr class="memdesc:a6aec8e6a80b4ca158df2ad20e3e6a59e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for a style.  <a href="#a6aec8e6a80b4ca158df2ad20e3e6a59e">More...</a><br /></td></tr>
<tr class="separator:a6aec8e6a80b4ca158df2ad20e3e6a59e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39e0b3981b4f0a8a113c6949bc8b103"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ab39e0b3981b4f0a8a113c6949bc8b103">rainbow_bg</a> (const char *s, double freq, size_t offset, size_t spread)</td></tr>
<tr class="memdesc:ab39e0b3981b4f0a8a113c6949bc8b103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rainbow-ize some text using rgb back colors, lolcat style.  <a href="#ab39e0b3981b4f0a8a113c6949bc8b103">More...</a><br /></td></tr>
<tr class="separator:ab39e0b3981b4f0a8a113c6949bc8b103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf264c63c394f9ecb19cd8565cda7197"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#adf264c63c394f9ecb19cd8565cda7197">rainbow_bg_term</a> (const char *s, double freq, size_t offset, size_t spread)</td></tr>
<tr class="memdesc:adf264c63c394f9ecb19cd8565cda7197"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is exactly like <a class="el" href="colr_8c.html#ab39e0b3981b4f0a8a113c6949bc8b103" title="Rainbow-ize some text using rgb back colors, lolcat style. ">rainbow_bg()</a>, except it uses colors that are closer to the standard 256-color values.  <a href="#adf264c63c394f9ecb19cd8565cda7197">More...</a><br /></td></tr>
<tr class="separator:adf264c63c394f9ecb19cd8565cda7197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50eca5901ca237550cf4129237a3411"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ac50eca5901ca237550cf4129237a3411">rainbow_fg</a> (const char *s, double freq, size_t offset, size_t spread)</td></tr>
<tr class="memdesc:ac50eca5901ca237550cf4129237a3411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rainbow-ize some text using rgb fore colors, lolcat style.  <a href="#ac50eca5901ca237550cf4129237a3411">More...</a><br /></td></tr>
<tr class="separator:ac50eca5901ca237550cf4129237a3411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a24d379435d64d1212858b173e6f9a7"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a5a24d379435d64d1212858b173e6f9a7">rainbow_fg_term</a> (const char *s, double freq, size_t offset, size_t spread)</td></tr>
<tr class="memdesc:a5a24d379435d64d1212858b173e6f9a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is exactly like <a class="el" href="colr_8c.html#ac50eca5901ca237550cf4129237a3411" title="Rainbow-ize some text using rgb fore colors, lolcat style. ">rainbow_fg()</a>, except it uses colors that are closer to the standard 256-color values.  <a href="#a5a24d379435d64d1212858b173e6f9a7">More...</a><br /></td></tr>
<tr class="separator:a5a24d379435d64d1212858b173e6f9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3580f33d058571dffd8e5ff789c49296"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a3580f33d058571dffd8e5ff789c49296">rainbow_step</a> (double freq, size_t offset)</td></tr>
<tr class="memdesc:a3580f33d058571dffd8e5ff789c49296"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single step in rainbow-izing produces the next color in the "rainbow" as an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.  <a href="#a3580f33d058571dffd8e5ff789c49296">More...</a><br /></td></tr>
<tr class="separator:a3580f33d058571dffd8e5ff789c49296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d649fff907b84a625db3fc3b3ae545e"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a0d649fff907b84a625db3fc3b3ae545e">RGB_average</a> (<a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:a0d649fff907b84a625db3fc3b3ae545e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the average for an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.  <a href="#a0d649fff907b84a625db3fc3b3ae545e">More...</a><br /></td></tr>
<tr class="separator:a0d649fff907b84a625db3fc3b3ae545e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b5f73b8aa9d72216d7386221418ae1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ad4b5f73b8aa9d72216d7386221418ae1">RGB_eq</a> (<a class="el" href="colr_8h.html#structRGB">RGB</a> a, <a class="el" href="colr_8h.html#structRGB">RGB</a> b)</td></tr>
<tr class="memdesc:ad4b5f73b8aa9d72216d7386221418ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> structs.  <a href="#ad4b5f73b8aa9d72216d7386221418ae1">More...</a><br /></td></tr>
<tr class="separator:ad4b5f73b8aa9d72216d7386221418ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5fbdea47463b284cbc9b1242ace4f1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ac5fbdea47463b284cbc9b1242ace4f1e">RGB_from_BasicValue</a> (<a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> bval)</td></tr>
<tr class="memdesc:ac5fbdea47463b284cbc9b1242ace4f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value from a known BasicValue.  <a href="#ac5fbdea47463b284cbc9b1242ace4f1e">More...</a><br /></td></tr>
<tr class="separator:ac5fbdea47463b284cbc9b1242ace4f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252adee47cc218a9208f16cb0ff42bfe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a252adee47cc218a9208f16cb0ff42bfe">RGB_from_esc</a> (const char *s, <a class="el" href="colr_8h.html#structRGB">RGB</a> *<a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:a252adee47cc218a9208f16cb0ff42bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an escape-code string (<code>char*</code>) to an actual <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.  <a href="#a252adee47cc218a9208f16cb0ff42bfe">More...</a><br /></td></tr>
<tr class="separator:a252adee47cc218a9208f16cb0ff42bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab857a1ddce9743c1ef6d54d39e890275"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ab857a1ddce9743c1ef6d54d39e890275">RGB_from_ExtendedValue</a> (<a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a> eval)</td></tr>
<tr class="memdesc:ab857a1ddce9743c1ef6d54d39e890275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value from a known ExtendedValue.  <a href="#ab857a1ddce9743c1ef6d54d39e890275">More...</a><br /></td></tr>
<tr class="separator:ab857a1ddce9743c1ef6d54d39e890275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33884dcde034819c5e6749667247194"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ad33884dcde034819c5e6749667247194">RGB_from_hex</a> (const char *hexstr, <a class="el" href="colr_8h.html#structRGB">RGB</a> *<a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:ad33884dcde034819c5e6749667247194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a hex color into an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.  <a href="#ad33884dcde034819c5e6749667247194">More...</a><br /></td></tr>
<tr class="separator:ad33884dcde034819c5e6749667247194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6133112d9c73a8b56995e16e1af62d3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a6133112d9c73a8b56995e16e1af62d3b">RGB_from_hex_default</a> (const char *hexstr, <a class="el" href="colr_8h.html#structRGB">RGB</a> default_value)</td></tr>
<tr class="memdesc:a6133112d9c73a8b56995e16e1af62d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a hex color into an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value, but use a default value when errors occur.  <a href="#a6133112d9c73a8b56995e16e1af62d3b">More...</a><br /></td></tr>
<tr class="separator:a6133112d9c73a8b56995e16e1af62d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c9e50fe14ad0c82bcf1a62699c05de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a98c9e50fe14ad0c82bcf1a62699c05de">RGB_from_str</a> (const char *arg, <a class="el" href="colr_8h.html#structRGB">RGB</a> *<a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:a98c9e50fe14ad0c82bcf1a62699c05de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> string (<code>char*</code>) into an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.  <a href="#a98c9e50fe14ad0c82bcf1a62699c05de">More...</a><br /></td></tr>
<tr class="separator:a98c9e50fe14ad0c82bcf1a62699c05de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ce6e92a3b495166213e203ad3ab846"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a49ce6e92a3b495166213e203ad3ab846">RGB_grayscale</a> (<a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:a49ce6e92a3b495166213e203ad3ab846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grayscale version of an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.  <a href="#a49ce6e92a3b495166213e203ad3ab846">More...</a><br /></td></tr>
<tr class="separator:a49ce6e92a3b495166213e203ad3ab846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958e45854d69e8b59859244ce791673c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a958e45854d69e8b59859244ce791673c">RGB_inverted</a> (<a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:a958e45854d69e8b59859244ce791673c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a copy of an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value, with the colors "inverted" (like highlighting text in the terminal).  <a href="#a958e45854d69e8b59859244ce791673c">More...</a><br /></td></tr>
<tr class="separator:a958e45854d69e8b59859244ce791673c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd85b5c5b79142c8656a065c58e4509e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#abd85b5c5b79142c8656a065c58e4509e">RGB_monochrome</a> (<a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:abd85b5c5b79142c8656a065c58e4509e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value into either black or white, depending on it's average grayscale value.  <a href="#abd85b5c5b79142c8656a065c58e4509e">More...</a><br /></td></tr>
<tr class="separator:abd85b5c5b79142c8656a065c58e4509e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd28864afbcfa4a344e4596130645177"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#afd28864afbcfa4a344e4596130645177">RGB_repr</a> (<a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:afd28864afbcfa4a344e4596130645177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation for an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.  <a href="#afd28864afbcfa4a344e4596130645177">More...</a><br /></td></tr>
<tr class="separator:afd28864afbcfa4a344e4596130645177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e4feb89e009f00cfe7e74a55fab56f"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a95e4feb89e009f00cfe7e74a55fab56f">RGB_to_hex</a> (<a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:a95e4feb89e009f00cfe7e74a55fab56f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value into a hex string (<code>char*</code>).  <a href="#a95e4feb89e009f00cfe7e74a55fab56f">More...</a><br /></td></tr>
<tr class="separator:a95e4feb89e009f00cfe7e74a55fab56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d2f9a1133c8a955f0a551870d7ebe8"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a16d2f9a1133c8a955f0a551870d7ebe8">RGB_to_str</a> (<a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:a16d2f9a1133c8a955f0a551870d7ebe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value into a human-friendly <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> string (<code>char*</code>) suitable for input to <a class="el" href="colr_8c.html#a98c9e50fe14ad0c82bcf1a62699c05de" title="Convert an RGB string (char*) into an RGB value. ">RGB_from_str()</a>.  <a href="#a16d2f9a1133c8a955f0a551870d7ebe8">More...</a><br /></td></tr>
<tr class="separator:a16d2f9a1133c8a955f0a551870d7ebe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4576c531151e398b7ecede2e30df70d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ab4576c531151e398b7ecede2e30df70d">RGB_to_term_RGB</a> (<a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:ab4576c531151e398b7ecede2e30df70d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value into it's nearest terminal-friendly <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.  <a href="#ab4576c531151e398b7ecede2e30df70d">More...</a><br /></td></tr>
<tr class="separator:ab4576c531151e398b7ecede2e30df70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32bf31475b0f6264b45438bd5c09ee7d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a32bf31475b0f6264b45438bd5c09ee7d">StyleValue_eq</a> (<a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a> a, <a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a> b)</td></tr>
<tr class="memdesc:a32bf31475b0f6264b45438bd5c09ee7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two StyleValues.  <a href="#a32bf31475b0f6264b45438bd5c09ee7d">More...</a><br /></td></tr>
<tr class="separator:a32bf31475b0f6264b45438bd5c09ee7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4fd7f8901569c053bd29f2035c69b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a9f4fd7f8901569c053bd29f2035c69b7">StyleValue_from_esc</a> (const char *s)</td></tr>
<tr class="memdesc:a9f4fd7f8901569c053bd29f2035c69b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an escape-code string (<code>char*</code>) to an actual StyleValue enum value.  <a href="#a9f4fd7f8901569c053bd29f2035c69b7">More...</a><br /></td></tr>
<tr class="separator:a9f4fd7f8901569c053bd29f2035c69b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca63735ad2cbc6475d4af83dc7c1a9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a4ca63735ad2cbc6475d4af83dc7c1a9b">StyleValue_from_str</a> (const char *arg)</td></tr>
<tr class="memdesc:a4ca63735ad2cbc6475d4af83dc7c1a9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a named argument to actual StyleValue enum value.  <a href="#a4ca63735ad2cbc6475d4af83dc7c1a9b">More...</a><br /></td></tr>
<tr class="separator:a4ca63735ad2cbc6475d4af83dc7c1a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f8126147490f88283a53e9ef48d33f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a3f8126147490f88283a53e9ef48d33f0">StyleValue_is_invalid</a> (<a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a> sval)</td></tr>
<tr class="memdesc:a3f8126147490f88283a53e9ef48d33f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a StyleValue is invalid.  <a href="#a3f8126147490f88283a53e9ef48d33f0">More...</a><br /></td></tr>
<tr class="separator:a3f8126147490f88283a53e9ef48d33f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6598b05bc5c742fbb94b47d8a3213a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a2d6598b05bc5c742fbb94b47d8a3213a">StyleValue_is_valid</a> (<a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a> sval)</td></tr>
<tr class="memdesc:a2d6598b05bc5c742fbb94b47d8a3213a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a StyleValue is valid.  <a href="#a2d6598b05bc5c742fbb94b47d8a3213a">More...</a><br /></td></tr>
<tr class="separator:a2d6598b05bc5c742fbb94b47d8a3213a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b74664587dd3c0e981603ee75c331b"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a24b74664587dd3c0e981603ee75c331b">StyleValue_repr</a> (<a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a> sval)</td></tr>
<tr class="memdesc:a24b74664587dd3c0e981603ee75c331b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation of a StyleValue.  <a href="#a24b74664587dd3c0e981603ee75c331b">More...</a><br /></td></tr>
<tr class="separator:a24b74664587dd3c0e981603ee75c331b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac767fb032c9617e2830cc5e13e66c400"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#ac767fb032c9617e2830cc5e13e66c400">StyleValue_to_str</a> (<a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a> sval)</td></tr>
<tr class="memdesc:ac767fb032c9617e2830cc5e13e66c400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a human-friendly string (<code>char*</code>) representation for a StyleValue.  <a href="#ac767fb032c9617e2830cc5e13e66c400">More...</a><br /></td></tr>
<tr class="separator:ac767fb032c9617e2830cc5e13e66c400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b4ed49acc5d806f161a3b31f5bf023"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a41b4ed49acc5d806f161a3b31f5bf023">TermSize_repr</a> (<a class="el" href="colr_8h.html#structTermSize">TermSize</a> ts)</td></tr>
<tr class="memdesc:a41b4ed49acc5d806f161a3b31f5bf023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a string (<code>char*</code>) representation for a <a class="el" href="colr_8h.html#structTermSize" title="Holds a terminal size, usually retrieved with colr_term_size(). ">TermSize</a>.  <a href="#a41b4ed49acc5d806f161a3b31f5bf023">More...</a><br /></td></tr>
<tr class="separator:a41b4ed49acc5d806f161a3b31f5bf023"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a3a3db0fb0c98d24ec072dfed5f88d717"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="colr_8h.html#structBasicInfo">BasicInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a3a3db0fb0c98d24ec072dfed5f88d717">basic_names</a> []</td></tr>
<tr class="memdesc:a3a3db0fb0c98d24ec072dfed5f88d717"><td class="mdescLeft">&#160;</td><td class="mdescRight">An array of <a class="el" href="colr_8h.html#structBasicInfo" title="Holds a known color name and it&#39;s BasicValue. ">BasicInfo</a> items, used with <a class="el" href="colr_8c.html#a4163ac65dca3e222525808b80a40b733" title="Convert named argument to an actual BasicValue enum value. ">BasicValue_from_str()</a>.  <a href="#a3a3db0fb0c98d24ec072dfed5f88d717">More...</a><br /></td></tr>
<tr class="separator:a3a3db0fb0c98d24ec072dfed5f88d717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e51bb70ff49bcce2b23c75a83f099a7"><td class="memItemLeft" align="right" valign="top"><a id="a9e51bb70ff49bcce2b23c75a83f099a7"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a9e51bb70ff49bcce2b23c75a83f099a7">basic_names_len</a> = (sizeof(<a class="el" href="colr_8c.html#a3a3db0fb0c98d24ec072dfed5f88d717">basic_names</a>) / sizeof(<a class="el" href="colr_8c.html#a3a3db0fb0c98d24ec072dfed5f88d717">basic_names</a>[0])) - 1</td></tr>
<tr class="memdesc:a9e51bb70ff49bcce2b23c75a83f099a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of usable values basic_names. <br /></td></tr>
<tr class="separator:a9e51bb70ff49bcce2b23c75a83f099a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7295537f3f6be454d92f57ed54766d7"><td class="memItemLeft" align="right" valign="top"><a id="aa7295537f3f6be454d92f57ed54766d7"></a>
const <a class="el" href="colr_8h.html#structColorNameData">ColorNameData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#aa7295537f3f6be454d92f57ed54766d7">colr_name_data</a> []</td></tr>
<tr class="memdesc:aa7295537f3f6be454d92f57ed54766d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">An array that holds a known color name, it's ExtendedValue, and it's <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value. <br /></td></tr>
<tr class="separator:aa7295537f3f6be454d92f57ed54766d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5116a18af30d2256b8f465d2b35f4a01"><td class="memItemLeft" align="right" valign="top"><a id="a5116a18af30d2256b8f465d2b35f4a01"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a5116a18af30d2256b8f465d2b35f4a01">colr_name_data_len</a> = sizeof(<a class="el" href="colr_8c.html#aa7295537f3f6be454d92f57ed54766d7">colr_name_data</a>) / sizeof(<a class="el" href="colr_8c.html#aa7295537f3f6be454d92f57ed54766d7">colr_name_data</a>[0])</td></tr>
<tr class="memdesc:a5116a18af30d2256b8f465d2b35f4a01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of colr_name_data. <br /></td></tr>
<tr class="separator:a5116a18af30d2256b8f465d2b35f4a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b38c28aba614d1bd1706d6099df0e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a62b38c28aba614d1bd1706d6099df0e6">colr_printf_esc_mod</a> = 0</td></tr>
<tr class="memdesc:a62b38c28aba614d1bd1706d6099df0e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer to test for the presence of the "escaped output modifier" in colr_printf_handler.  <a href="#a62b38c28aba614d1bd1706d6099df0e6">More...</a><br /></td></tr>
<tr class="separator:a62b38c28aba614d1bd1706d6099df0e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4b773fe2fc7907fdfcf5ef9b202758"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#afb4b773fe2fc7907fdfcf5ef9b202758">ext2rgb_map</a> []</td></tr>
<tr class="memdesc:afb4b773fe2fc7907fdfcf5ef9b202758"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map from ExtendedValue (256-color) to <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value, where the index is the is the ExtendedValue, and the value is the <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a>.  <a href="#afb4b773fe2fc7907fdfcf5ef9b202758">More...</a><br /></td></tr>
<tr class="separator:afb4b773fe2fc7907fdfcf5ef9b202758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8d8b99b472b84bccff92eab6277ce4"><td class="memItemLeft" align="right" valign="top"><a id="aea8d8b99b472b84bccff92eab6277ce4"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#aea8d8b99b472b84bccff92eab6277ce4">ext2rgb_map_len</a> = sizeof(<a class="el" href="colr_8c.html#afb4b773fe2fc7907fdfcf5ef9b202758">ext2rgb_map</a>) / sizeof(<a class="el" href="colr_8c.html#afb4b773fe2fc7907fdfcf5ef9b202758">ext2rgb_map</a>[0])</td></tr>
<tr class="memdesc:aea8d8b99b472b84bccff92eab6277ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of ext2rgb_map (should always be 256). <br /></td></tr>
<tr class="separator:aea8d8b99b472b84bccff92eab6277ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abffaf3629342a2b3e9cb7ea53c12c4f0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="colr_8h.html#structExtendedInfo">ExtendedInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#abffaf3629342a2b3e9cb7ea53c12c4f0">extended_names</a> []</td></tr>
<tr class="memdesc:abffaf3629342a2b3e9cb7ea53c12c4f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">An array of <a class="el" href="colr_8h.html#structExtendedInfo" title="Holds a known color name and it&#39;s ExtendedValue. ">ExtendedInfo</a>, used with <a class="el" href="colr_8c.html#a2e859d542a8aa0939e4f76b1f33cb5f8" title="Converts a known name, integer string (0-255), or a hex string (char*), into an ExtendedValue suitabl...">ExtendedValue_from_str()</a>.  <a href="#abffaf3629342a2b3e9cb7ea53c12c4f0">More...</a><br /></td></tr>
<tr class="separator:abffaf3629342a2b3e9cb7ea53c12c4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41163e87b52c4568025714dbc6ffcbfd"><td class="memItemLeft" align="right" valign="top"><a id="a41163e87b52c4568025714dbc6ffcbfd"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a41163e87b52c4568025714dbc6ffcbfd">extended_names_len</a> = (sizeof(<a class="el" href="colr_8c.html#abffaf3629342a2b3e9cb7ea53c12c4f0">extended_names</a>) / sizeof(<a class="el" href="colr_8c.html#abffaf3629342a2b3e9cb7ea53c12c4f0">extended_names</a>[0])) - 1</td></tr>
<tr class="memdesc:a41163e87b52c4568025714dbc6ffcbfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of usable values in extended_names. <br /></td></tr>
<tr class="separator:a41163e87b52c4568025714dbc6ffcbfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9303c010fd45eab23c7903d1175ae20a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="colr_8h.html#structStyleInfo">StyleInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a9303c010fd45eab23c7903d1175ae20a">style_names</a> []</td></tr>
<tr class="memdesc:a9303c010fd45eab23c7903d1175ae20a"><td class="mdescLeft">&#160;</td><td class="mdescRight">An array of <a class="el" href="colr_8h.html#structStyleInfo" title="Holds a known style name and it&#39;s StyleValue. ">StyleInfo</a> items, used with StyleName_from_str().  <a href="#a9303c010fd45eab23c7903d1175ae20a">More...</a><br /></td></tr>
<tr class="separator:a9303c010fd45eab23c7903d1175ae20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d274b3747f3ddd52d5e97cd7843388"><td class="memItemLeft" align="right" valign="top"><a id="a05d274b3747f3ddd52d5e97cd7843388"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8c.html#a05d274b3747f3ddd52d5e97cd7843388">style_names_len</a> = (sizeof(<a class="el" href="colr_8c.html#a9303c010fd45eab23c7903d1175ae20a">style_names</a>) / sizeof(<a class="el" href="colr_8c.html#a9303c010fd45eab23c7903d1175ae20a">style_names</a>[0])) - 1</td></tr>
<tr class="memdesc:a05d274b3747f3ddd52d5e97cd7843388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of usable values in style_names. <br /></td></tr>
<tr class="separator:a05d274b3747f3ddd52d5e97cd7843388"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implements everything in the <a class="el" href="colr_8h.html" title="Declarations for ColrC functions, enums, structs, etc. ">colr.h</a> header. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aaa888f1b31eb40ec7d252d3ee9175d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa888f1b31eb40ec7d252d3ee9175d76">&#9670;&nbsp;</a></span>_colr_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _colr_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls Colr <code>*_free()</code> functions for Colr objects, otherwise just calls <code>free()</code>. </p>
<p>You should use the <a class="el" href="colr_8h.html#a76eae619668e01987653932a7492fd94" title="Calls the &lt;type&gt;_free functions for the supported types. ">colr_free()</a> macro instead.</p>
<dl class="section warning"><dt>Warning</dt><dd>This is for internal use only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Pointer to a heap-allocated object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af64af11f4992c8143cb722772df98c98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af64af11f4992c8143cb722772df98c98">&#9670;&nbsp;</a></span>_colr_is_last_arg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool _colr_is_last_arg </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a void pointer is _ColrLastArg (the last-arg-marker). </p>
<dl class="section warning"><dt>Warning</dt><dd>This is for internal use only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The pointer to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the pointer is _ColrLastArg, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a4227a65824fdd699a25d3200706c9e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4227a65824fdd699a25d3200706c9e9e">&#9670;&nbsp;</a></span>_colr_join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* _colr_join </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>joinerp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Joins ColorArgs, ColorTexts, and strings (<code>char*</code>) into one long string separated by it's first argument. </p>
<p>This will free() any <code><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a></code>s, <code><a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a></code>s, or <code><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a></code>s that are passed in. It is backing the <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, <a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465" title="Like colr_cat(), but returns an allocated ColorResult that the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros will automatically free(). ">Colr_cat()</a>, and <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> macros, and enables easy throw-away color values.</p>
<p>Any plain strings that are passed in are left alone. It is up to the caller to free those. ColrC only manages the temporary Colr-based objects needed to build up these strings.</p>
<p>You should use <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, <a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465" title="Like colr_cat(), but returns an allocated ColorResult that the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros will automatically free(). ">Colr_cat()</a>, and <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> macros instead.</p>
<dl class="section warning"><dt>Warning</dt><dd>This is for internal use only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">joinerp</td><td>The joiner (any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, or string). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Zero or more ColorArgs, ColorResults, ColorTexts, or strings to join by the joiner. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with mixed escape codes/strings. CODE_RESET_ALL is appended to all <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> arguments. This allows easy part-colored messages.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. Also, <code>NULL</code> will be returned if <code>joinerp</code> is <code>NULL</code>. </p>
</dd></dl>

</div>
</div>
<a id="a6d47ac6ee2a59e1c976cf2838545aa25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d47ac6ee2a59e1c976cf2838545aa25">&#9670;&nbsp;</a></span>_colr_join_array_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t _colr_join_array_length </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the length of a <code>NULL</code>-terminated array of strings (<code>char*</code>), <code><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a></code>s, <code><a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a></code>s, or <code><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a></code>s. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is for internal use only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ps</td><td>A <code>NULL</code>-terminated array of <code><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a></code>s, <code><a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a></code>s, <code><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a></code>s, or strings (<code>char*</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of items (before <code>NULL</code>) in the array. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a701126bd27c90fafa46152d9f9327b2f">colr_join_array()</a>.</p>

</div>
</div>
<a id="ac49c3a33d328ebaf2b0564d5a9b1d4ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac49c3a33d328ebaf2b0564d5a9b1d4ec">&#9670;&nbsp;</a></span>_colr_join_arrayn_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t _colr_join_arrayn_size </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>joinerp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size in bytes needed to join an array of strings (<code>char*</code>), <code><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a></code>s, <code><a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a></code>s, or <code><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a></code>s by another string (<code>char*</code>), <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>. </p>
<p>This is used to allocate memory in the _colr_join_array() function.</p>
<dl class="section warning"><dt>Warning</dt><dd>This is for internal use only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">joinerp</td><td>The joiner (any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, or string). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ps</td><td>An array of pointers to <code><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a></code>s, <code><a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a></code>s, <code><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a></code>s, or strings. The array must have <code>NULL</code> as the last item if <code>count</code> is greater than the total number of items. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Total number of items in the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes needed to allocate the result of <a class="el" href="colr_8c.html#a71fcf08ad36d4424790e275d973445fc" title="Join an array of strings (char*), ColorArgs, or ColorTexts by another string (char*), ColorArg, or ColorText. ">colr_join_arrayn()</a>, possibly <code>0</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a753093cd4c872eed4b77feaa7816212b" title="Create an allocated string directly from Colr() arguments. ">colr</a> </dd>
<dd>
<a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join</a> </dd>
<dd>
<a class="el" href="colr_8c.html#a701126bd27c90fafa46152d9f9327b2f" title="Join an array of strings (char*), ColorArgs, or ColorTexts by another string (char*), ColorArg, or ColorText. ">colr_join_array</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a71fcf08ad36d4424790e275d973445fc">colr_join_arrayn()</a>.</p>

</div>
</div>
<a id="a91a051ef4cd2e7200a31f9de48766b4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a051ef4cd2e7200a31f9de48766b4c">&#9670;&nbsp;</a></span>_colr_join_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t _colr_join_size </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>joinerp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse arguments, just as in <a class="el" href="colr_8c.html#a4227a65824fdd699a25d3200706c9e9e" title="Joins ColorArgs, ColorTexts, and strings (char*) into one long string separated by it&#39;s first argumen...">_colr_join()</a>, but only return the size needed to allocate the resulting string. </p>
<p>This allows <a class="el" href="colr_8c.html#a4227a65824fdd699a25d3200706c9e9e" title="Joins ColorArgs, ColorTexts, and strings (char*) into one long string separated by it&#39;s first argumen...">_colr_join()</a> to allocate once, instead of reallocating for each argument that is passed.</p>
<dl class="section warning"><dt>Warning</dt><dd>This is for internal use only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">joinerp</td><td>The joiner (any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, or string (<code>char*</code>)). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>A <code>va_list</code> with zero or more <code><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a></code>s, <code><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a></code>s, or strings (<code>char*</code>) to join. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length (in bytes) needed to allocate a string built with _colr_cat(). This function will return <code>0</code> if <code>joinerp</code> is <code>NULL</code>/empty). Except for <code>0</code>, it will never return anything less than <code>CODE_RESET_LEN</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>_colr </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>.</p>

</div>
</div>
<a id="ab0be451277fc7e39aee0aa409c9d3f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0be451277fc7e39aee0aa409c9d3f0c">&#9670;&nbsp;</a></span>_colr_ptr_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t _colr_ptr_length </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size, in bytes, needed to convert a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, or string (<code>char*</code>) into a string. </p>
<p>This is used in the variadic _colr* functions.</p>
<dl class="section warning"><dt>Warning</dt><dd>This is for internal use only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointer, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> pointer, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointer, or string (<code>char*</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length needed to convert the object into a string (<code>strlen() + 1</code> for strings). </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ac49c3a33d328ebaf2b0564d5a9b1d4ec">_colr_join_arrayn_size()</a>, and <a class="el" href="colr_8h.html#a91a051ef4cd2e7200a31f9de48766b4c">_colr_join_size()</a>.</p>

</div>
</div>
<a id="a30cac3017a6ea8c78277882554c9419f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30cac3017a6ea8c78277882554c9419f">&#9670;&nbsp;</a></span>_colr_ptr_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* _colr_ptr_repr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine what kind of pointer is being passed, and call the appropriate &lt;type&gt;_repr function to obtain an allocated string representation. </p>
<p>You should use <a class="el" href="colr_8h.html#ac1ef824dd213274fb239526269315543" title="Transforms several ColrC objects into their string representations. ">colr_repr()</a> instead.</p>
<dl class="section warning"><dt>Warning</dt><dd>This is for internal use only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointer, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> pointer, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointer, or string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#ac1ef824dd213274fb239526269315543" title="Transforms several ColrC objects into their string representations. ">colr_repr</a> </dd></dl>

</div>
</div>
<a id="a0d97f9b535a69642b926b38dce30b180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d97f9b535a69642b926b38dce30b180">&#9670;&nbsp;</a></span>_colr_ptr_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* _colr_ptr_to_str </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine what kind of pointer is being passed, and call the appropriate &lt;type&gt;_to_str function to obtain an allocated string. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is for internal use only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointer, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> pointer, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointer, or string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>

</div>
</div>
<a id="ab88ca919420f2df896b7973401641ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab88ca919420f2df896b7973401641ab4">&#9670;&nbsp;</a></span>_rainbow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* _rainbow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#adc966460db21ff6c35f23fcf6abe541e">RGB_fmter</a>&#160;</td>
          <td class="paramname"><em>fmter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>spread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles multibyte character string (<code>char*</code>) conversion and character iteration for all of the rainbow_ functions. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is for internal use only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fmter</td><td>A formatter function (RGB_fmter) that can create escape codes from <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">The string to "rainbowize".</p>
<p class="endtd">Input <em>must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freq</td><td>The "tightness" for colors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting offset into the rainbow. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spread</td><td>Number of characters per color. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string (<code>char*</code>) with the result.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ab39e0b3981b4f0a8a113c6949bc8b103">rainbow_bg()</a>, <a class="el" href="colr_8h.html#adf264c63c394f9ecb19cd8565cda7197">rainbow_bg_term()</a>, <a class="el" href="colr_8h.html#ac50eca5901ca237550cf4129237a3411">rainbow_fg()</a>, and <a class="el" href="colr_8h.html#a5a24d379435d64d1212858b173e6f9a7">rainbow_fg_term()</a>.</p>

</div>
</div>
<a id="a69d1fc130eeaf6ed62066e25478cb433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69d1fc130eeaf6ed62066e25478cb433">&#9670;&nbsp;</a></span>ArgType_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ArgType_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two ArgTypes. </p>
<p>This is used to implement <a class="el" href="colr_8h.html#a36af8aa0f01eaa780da182e856923faa" title="Calls the &lt;type&gt;_eq functions for the supported types. ">colr_eq()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first ArgType to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second ArgType to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if they are equal, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="ad01ccaf04c71fc2474da94b050236572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01ccaf04c71fc2474da94b050236572">&#9670;&nbsp;</a></span>ArgType_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ArgType_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation of a ArgType. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>An ArgType to get the type from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">A pointer to an allocated string.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1" title="Argument types (fore, back, style). ">ArgType</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a5af692f2357d46b9cee45bb114f2a4a2">ColorArg_repr()</a>.</p>

</div>
</div>
<a id="a2b270bebb1a01212b7e44e52f61f94be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b270bebb1a01212b7e44e52f61f94be">&#9670;&nbsp;</a></span>ArgType_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ArgType_to_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a human-friendly string (<code>char*</code>) from an ArgType. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>An ArgType to get the type from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">A pointer to an allocated string.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1" title="Argument types (fore, back, style). ">ArgType</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#aa54ab1879f6de8ca2fcb4702250741f5">ColorArg_example()</a>.</p>

</div>
</div>
<a id="a17bf46ac385e41b729d07a65dd506cba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17bf46ac385e41b729d07a65dd506cba">&#9670;&nbsp;</a></span>BasicValue_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BasicValue_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two BasicValues. </p>
<p>This is used to implement <a class="el" href="colr_8h.html#a36af8aa0f01eaa780da182e856923faa" title="Calls the &lt;type&gt;_eq functions for the supported types. ">colr_eq()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first BasicValue to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second BasicValue to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if they are equal, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee" title="Basic color values, with a few convenience values for extended colors. ">BasicValue</a> </dd></dl>

</div>
</div>
<a id="a481b2cb2526e58b2fdb2e52a722d987b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a481b2cb2526e58b2fdb2e52a722d987b">&#9670;&nbsp;</a></span>BasicValue_from_esc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> BasicValue_from_esc </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an escape-code string (<code>char*</code>) to an actual BasicValue enum value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">Escape-code string.</p>
<p class="endtd"><em>Must be <code>null</code>-terminated</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">BasicValue</td><td>value on success. </td></tr>
    <tr><td class="paramname">BASIC_INVALID</td><td>on error (or if <code>s</code> is <code>NULL</code>). </td></tr>
    <tr><td class="paramname">BASIC_INVALID_RANGE</td><td>if the code number was outside of the range <code>0-255</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee" title="Basic color values, with a few convenience values for extended colors. ">BasicValue</a> </dd></dl>

</div>
</div>
<a id="a4163ac65dca3e222525808b80a40b733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4163ac65dca3e222525808b80a40b733">&#9670;&nbsp;</a></span>BasicValue_from_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> BasicValue_from_str </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert named argument to an actual BasicValue enum value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Color name to find the BasicValue for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BasicValue value on success, or BASIC_INVALID on error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee" title="Basic color values, with a few convenience values for extended colors. ">BasicValue</a> </dd></dl>

</div>
</div>
<a id="a6332bbd16e746a02491eee70c13d0735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6332bbd16e746a02491eee70c13d0735">&#9670;&nbsp;</a></span>BasicValue_is_invalid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BasicValue_is_invalid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>bval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a BasicValue is invalid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bval</td><td>A BasicValue to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is considered invalid, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee" title="Basic color values, with a few convenience values for extended colors. ">BasicValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#af0b464ee51d75d7f45ddd5926a7c9cf5">ExtendedValue_from_BasicValue()</a>.</p>

</div>
</div>
<a id="a29e4c8a4789232c78b9ef17e292839ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29e4c8a4789232c78b9ef17e292839ca">&#9670;&nbsp;</a></span>BasicValue_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BasicValue_is_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>bval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a BasicValue is valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bval</td><td>A BasicValue to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is considered valid, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee" title="Basic color values, with a few convenience values for extended colors. ">BasicValue</a> </dd></dl>

</div>
</div>
<a id="a1bc0d9917621cab5b3efd162b7dc5a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc0d9917621cab5b3efd162b7dc5a8c">&#9670;&nbsp;</a></span>BasicValue_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* BasicValue_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>bval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation of a BasicValue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bval</td><td>A BasicValue to get the value from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">A pointer to an allocated string.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee" title="Basic color values, with a few convenience values for extended colors. ">BasicValue</a> </dd></dl>

</div>
</div>
<a id="a71a78ebb45cb53792d4c658bade99a70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71a78ebb45cb53792d4c658bade99a70">&#9670;&nbsp;</a></span>BasicValue_to_ansi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BasicValue_to_ansi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>bval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a fore/back BasicValue to the actual ansi code number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ArgType (FORE/BACK). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bval</td><td>BasicValue to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer usable with basic escape code fore/back colors.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee" title="Basic color values, with a few convenience values for extended colors. ">BasicValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ae29032483aea8cb25d6b90750767ffc1">format_bg()</a>, and <a class="el" href="colr_8h.html#a6027d93e8768f3c152edafd92e757801">format_fg()</a>.</p>

</div>
</div>
<a id="a83ea2f6c1adea8535ae629051e74ced0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83ea2f6c1adea8535ae629051e74ced0">&#9670;&nbsp;</a></span>BasicValue_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* BasicValue_to_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>bval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a human-friendly string (<code>char*</code>) representation for a BasicValue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bval</td><td>BasicValue to get the name for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee" title="Basic color values, with a few convenience values for extended colors. ">BasicValue</a> </dd></dl>

</div>
</div>
<a id="af838f8479681d809beb868b2e1b547e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af838f8479681d809beb868b2e1b547e7">&#9670;&nbsp;</a></span>ColorArg_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> ColorArg_empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> with ARGTYPE_NONE and ColorValue.type.TYPE_NONE. </p>
<p>This is used to pass "empty" fore/back/style args to the <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a>, <a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465" title="Like colr_cat(), but returns an allocated ColorResult that the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros will automatically free(). ">Colr_cat()</a>, and <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> macros, where <code>NULL</code> may have a different meaning for users of the <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>(<a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>){.type=ARGTYPE_NONE, .value.type=TYPE_NONE}</code></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#a752355c2d96d35688d3756558f8421ba" title="Checks to see if a ColorArg is an empty placeholder. ">ColorArg_is_empty</a> </dd>
<dd>
<a class="el" href="colr_8c.html#a5ce7c54ad0e31ecf6d790c5770c2b66b" title="Create an &quot;empty&quot; ColorValue. ">ColorValue_empty</a> </dd></dl>

</div>
</div>
<a id="acb62efc0182d6f6107055eeda961a628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb62efc0182d6f6107055eeda961a628">&#9670;&nbsp;</a></span>ColorArg_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorArg_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> structs. </p>
<p>They are considered "equal" if their <code>.type</code> and <code>.value</code> match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if they are equal, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a93f65430500d003575c547eb667330b0">ColorText_has_arg()</a>.</p>

</div>
</div>
<a id="aa54ab1879f6de8ca2fcb4702250741f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa54ab1879f6de8ca2fcb4702250741f5">&#9670;&nbsp;</a></span>ColorArg_example()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorArg_example </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>carg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>colorized</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a string (<code>char*</code>) representation of a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> with a stylized type/name using escape codes built from the <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">carg</td><td>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to get an example string for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">colorized</td><td>Whether to include a colorized example. If set to <code>false</code>, there will be no escape-codes in the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#ColorArg_example-example" id="ColorArg_example-example" class="diamond-bullet">&#160;</a> ColorArg_example example: </div><div class="fragment"><div class="line"><a class="code" href="colr_8h.html#structColorArg">ColorArg</a> args[] = {</div><div class="line">    <a class="code" href="colr_8h.html#a3cc38de52ea52344113083ba4d90088e">fore_arg</a>(<a class="code" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>(75, 25, 155)),</div><div class="line">    <a class="code" href="colr_8h.html#a3cc38de52ea52344113083ba4d90088e">fore_arg</a>(<a class="code" href="colr_8h.html#aa3c79297600d8ab15a495843d63db54d">ext_hex</a>(<span class="stringliteral">&quot;#ff00bb&quot;</span>)),</div><div class="line">    <a class="code" href="colr_8h.html#aeba419af1d4c23615eb844db37e46ee6">back_arg</a>(RED),</div><div class="line">    <a class="code" href="colr_8h.html#a53683a9e279942578e46768be25587d0">style_arg</a>(UNDERLINE),</div><div class="line">    <a class="code" href="colr_8h.html#a3cc38de52ea52344113083ba4d90088e">fore_arg</a>(<span class="stringliteral">&quot;NOT_VALID&quot;</span>),</div><div class="line">    <a class="code" href="colr_8h.html#aeba419af1d4c23615eb844db37e46ee6">back_arg</a>(<span class="stringliteral">&quot;NOT_VALID&quot;</span>),</div><div class="line">    <a class="code" href="colr_8h.html#a53683a9e279942578e46768be25587d0">style_arg</a>(<span class="stringliteral">&quot;NOT_VALID&quot;</span>)</div><div class="line">};</div><div class="line"><span class="keywordtype">size_t</span> arg_len = <span class="keyword">sizeof</span>(args) / <span class="keyword">sizeof</span>(args[0]);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; arg_len; i++) {</div><div class="line">    <span class="keywordtype">char</span>* example = <a class="code" href="colr_8c.html#aa54ab1879f6de8ca2fcb4702250741f5">ColorArg_example</a>(args[i], <span class="keyword">true</span>);</div><div class="line">    <span class="keywordflow">if</span> (!example) <span class="keywordflow">continue</span>;</div><div class="line">    printf(<span class="stringliteral">&quot;%s\n&quot;</span>, example);</div><div class="line">    free(example);</div><div class="line">}</div></div><!-- fragment --> </div> 
</div>
</div>
<a id="aa1163a9c866767fb7fcb734d3c0d9b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1163a9c866767fb7fcb734d3c0d9b7c">&#9670;&nbsp;</a></span>ColorArg_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ColorArg_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free allocated memory for a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>. </p>
<p>This has no advantage over <code>free(colorarg)</code> right now, it is used in debugging, and may be extended in the future. It's better just to use it (or the <a class="el" href="colr_8h.html#a76eae619668e01987653932a7492fd94" title="Calls the &lt;type&gt;_free functions for the supported types. ">colr_free()</a> macro).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to free.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#aaa888f1b31eb40ec7d252d3ee9175d76">_colr_free()</a>, <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>, <a class="el" href="colr_8h.html#a4979a2ec9d5fb442ba025c6f2efc4864">ColorText_free_args()</a>, <a class="el" href="colr_8h.html#a34c359a48f811316d765b7abef1ea8f4">colr_printf_handler()</a>, <a class="el" href="colr_8h.html#af7c01a492bcbda6cf93705bff0cb0dbe">colr_str_replace_all_ColorArg()</a>, <a class="el" href="colr_8h.html#aa8b61a4cadcf73e21eee109623695bad">colr_str_replace_ColorArg()</a>, <a class="el" href="colr_8h.html#a577e45a5c233dd1b4774a9034b17e3eb">colr_str_replace_re_all_ColorArg()</a>, <a class="el" href="colr_8h.html#a78d58bde53845d6ab2c54e4ba0c68a3d">colr_str_replace_re_ColorArg()</a>, <a class="el" href="colr_8h.html#a0d4cbd6a8fd3cef76f07b705b09d2a54">colr_str_replace_re_match_ColorArg()</a>, <a class="el" href="colr_8h.html#a75b2cdee697818e2f9f38ec7eac98bcb">colr_str_replace_re_matches_ColorArg()</a>, <a class="el" href="colr_8h.html#a090ba95c4560134ef9c2807eff6a0ea1">colr_str_replace_re_pat_all_ColorArg()</a>, and <a class="el" href="colr_8h.html#adecbe2f1e87613b6f4a51158325dd4f7">colr_str_replace_re_pat_ColorArg()</a>.</p>

</div>
</div>
<a id="aad49f4597388e6bdb896ff28334cd5e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad49f4597388e6bdb896ff28334cd5e6">&#9670;&nbsp;</a></span>ColorArg_from_BasicValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> ColorArg_from_BasicValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicit version of ColorArg_from_value that only handles BasicValues. </p>
<p>This is used in some macros to aid in dynamic escape code creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ArgType (FORE, BACK, STYLE). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>BasicValue to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, with the <code>.value.type</code> member possibly set to <code>TYPE_INVALID</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

</div>
</div>
<a id="a70e9640f37dd85cde0b6f25c0b705912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70e9640f37dd85cde0b6f25c0b705912">&#9670;&nbsp;</a></span>ColorArg_from_esc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> ColorArg_from_esc </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an escape-code string (<code>char*</code>) into a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>. </p>
<p>For malformed escape-codes the <code>.type</code> member will be <code>ARGTYPE_NONE</code>, and the <code>.value.type</code> member will be set to <code>TYPE_INVALID</code>. This means that <code>ColorArg_is_invalid(carg) == true</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The escape code to parse. It must not have extra characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An initialized <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, possibly invalid.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd>
<dd>
<a class="el" href="colr_8c.html#a6292cbb8bd9f3d19bb0bd05a4d7b0bea" title="Get an array of escape-codes from a string (char*). ">colr_str_get_codes</a> </dd>
<dd>
<a class="el" href="colr_8c.html#af308e8dcd4a1d47a05736882d5a9698d" title="Convert an escape-code string (char*) into a ColorValue. ">ColorValue_from_esc</a> </dd>
<dd>
<a class="el" href="colr_8c.html#a481b2cb2526e58b2fdb2e52a722d987b" title="Convert an escape-code string (char*) to an actual BasicValue enum value. ">BasicValue_from_esc</a> </dd>
<dd>
<a class="el" href="colr_8c.html#aaabf63956f397a0fe628313622ba5cde" title="Convert an escape-code string (char*) to an ExtendedValue. ">ExtendedValue_from_esc</a> </dd>
<dd>
<a class="el" href="colr_8c.html#a9f4fd7f8901569c053bd29f2035c69b7" title="Convert an escape-code string (char*) to an actual StyleValue enum value. ">StyleValue_from_esc</a> </dd>
<dd>
<a class="el" href="colr_8c.html#a252adee47cc218a9208f16cb0ff42bfe" title="Convert an escape-code string (char*) to an actual RGB value. ">RGB_from_esc</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a4897abe50811762a84ee409c0c2d300f">ColorArgs_from_str()</a>.</p>

</div>
</div>
<a id="aed30e2a4b30ab5e3cf49608a3c410cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed30e2a4b30ab5e3cf49608a3c410cc5">&#9670;&nbsp;</a></span>ColorArg_from_ExtendedValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> ColorArg_from_ExtendedValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicit version of ColorArg_from_value that only handles ExtendedValues. </p>
<p>This is used in some macros to aid in dynamic escape code creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ArgType (FORE, BACK, STYLE). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>ExtendedValue to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, with the <code>.value.type</code> member possibly set to <code>TYPE_INVALID</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

</div>
</div>
<a id="aaa24bba74e99aa66ed41839576e57856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa24bba74e99aa66ed41839576e57856">&#9670;&nbsp;</a></span>ColorArg_from_RGB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> ColorArg_from_RGB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicit version of ColorArg_from_value that only handles <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> structs. </p>
<p>This is used in some macros to aid in dynamic escape code creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ArgType (FORE, BACK, STYLE). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, with the <code>.value.type</code> member possibly set to <code>TYPE_INVALID</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

</div>
</div>
<a id="aa62406b058b948941a8906475924536a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa62406b058b948941a8906475924536a">&#9670;&nbsp;</a></span>ColorArg_from_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> ColorArg_from_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>colorname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> (fore, back, or style value) from a known color name/style. </p>
<p>The <code>.value.type</code> attribute can be checked for an invalid type, or you can call ColorArg_is_invalid(x).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ArgType (FORE, BACK, STYLE). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">colorname</td><td>A known color name/style.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct with usable values.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

</div>
</div>
<a id="acf63bcee395dca3ca29dc324e3d7c8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf63bcee395dca3ca29dc324e3d7c8f2">&#9670;&nbsp;</a></span>ColorArg_from_StyleValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> ColorArg_from_StyleValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicit version of ColorArg_from_value that only handles StyleValues. </p>
<p>This is used in some macros to aid in dynamic escape code creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ArgType (FORE, BACK, STYLE). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>StyleValue to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, with the <code>.value.type</code> member possibly set to <code>TYPE_INVALID</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

</div>
</div>
<a id="a89a5aa762bd5802872faf571aa32ea35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a5aa762bd5802872faf571aa32ea35">&#9670;&nbsp;</a></span>ColorArg_from_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> ColorArg_from_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>&#160;</td>
          <td class="paramname"><em>colrtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used with the color_arg macro to dynamically create a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> based on it's argument type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ArgType value, to mark the type of <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">colrtype</td><td>ColorType value, to mark the type of <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A pointer to either a BasicValue, ExtendedValue, or a <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct with the appropriate <code>.value.type</code> member set for the value that was passed. For invalid types the <code>.value.type</code> member may be set to one of:<ul>
<li>TYPE_INVALID</li>
<li>TYPE_INVALID_EXT_RANGE</li>
<li>TYPE_INVALID_RGB_RANGE </li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

</div>
</div>
<a id="a752355c2d96d35688d3756558f8421ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a752355c2d96d35688d3756558f8421ba">&#9670;&nbsp;</a></span>ColorArg_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorArg_is_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>carg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> is an empty placeholder. </p>
<p>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> is empty if it's <code>.type</code> is set to <code>ARGTYPE_NONE</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">carg</td><td>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> is considered "empty", otherwise <code>false</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#adaff727006f4c057aab75e55bfb473c4">ColorArg_length()</a>, <a class="el" href="colr_8h.html#ad1d3aaca5e543f8fefbd863a959c9d67">ColorArg_to_esc()</a>, <a class="el" href="colr_8h.html#abaf3d02ff1292f2aaa605522665ae564">ColorArg_to_esc_s()</a>, <a class="el" href="colr_8h.html#a93b38987063bb127bb34761961d7f678">ColorText_has_args()</a>, and <a class="el" href="colr_8h.html#ae305b33e0a44b956ccf4123aa4f1a033">ColorText_to_str()</a>.</p>

</div>
</div>
<a id="a66b4906cfb08588005536db1250dc899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b4906cfb08588005536db1250dc899">&#9670;&nbsp;</a></span>ColorArg_is_invalid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorArg_is_invalid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>carg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> holds an invalid value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">carg</td><td><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is invalid, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

</div>
</div>
<a id="ad15f3a714a6383123d3fb24ade173e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad15f3a714a6383123d3fb24ade173e29">&#9670;&nbsp;</a></span>ColorArg_is_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorArg_is_ptr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks a void pointer to see if it contains a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct. </p>
<p>The first member of a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> is a marker.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A void pointer to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the pointer is a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#aaa888f1b31eb40ec7d252d3ee9175d76">_colr_free()</a>, <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>, <a class="el" href="colr_8h.html#a6d47ac6ee2a59e1c976cf2838545aa25">_colr_join_array_length()</a>, <a class="el" href="colr_8h.html#ac49c3a33d328ebaf2b0564d5a9b1d4ec">_colr_join_arrayn_size()</a>, <a class="el" href="colr_8h.html#ab0be451277fc7e39aee0aa409c9d3f0c">_colr_ptr_length()</a>, <a class="el" href="colr_8h.html#a30cac3017a6ea8c78277882554c9419f">_colr_ptr_repr()</a>, <a class="el" href="colr_8h.html#a0d97f9b535a69642b926b38dce30b180">_colr_ptr_to_str()</a>, <a class="el" href="colr_8h.html#a9bbb1f20ed69733be7750640ac297073">ColorText_from_valuesv()</a>, <a class="el" href="colr_8h.html#a880b39cd2ce9b622dbe7790a162d88f7">ColorText_set_values()</a>, <a class="el" href="colr_8h.html#a18e06ee5b32cd583c71ecff7d6c18270">colr_is_colr_ptr()</a>, <a class="el" href="colr_8h.html#a71fcf08ad36d4424790e275d973445fc">colr_join_arrayn()</a>, and <a class="el" href="colr_8h.html#a34c359a48f811316d765b7abef1ea8f4">colr_printf_handler()</a>.</p>

</div>
</div>
<a id="a1e446f65d6987d52522a1755c909d421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e446f65d6987d52522a1755c909d421">&#9670;&nbsp;</a></span>ColorArg_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorArg_is_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>carg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> holds a valid value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">carg</td><td><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is valid, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

</div>
</div>
<a id="adaff727006f4c057aab75e55bfb473c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaff727006f4c057aab75e55bfb473c4">&#9670;&nbsp;</a></span>ColorArg_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ColorArg_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>carg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length in bytes needed to allocate a string (<code>char*</code>) built with <a class="el" href="colr_8c.html#ad1d3aaca5e543f8fefbd863a959c9d67" title="Converts a ColorArg into an escape code string (char*). ">ColorArg_to_esc()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">carg</td><td><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length (<code>size_t</code>) needed to allocate a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string, or <code>1</code> (size of an empty string) for invalid/empty arg types/values.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ac49c3a33d328ebaf2b0564d5a9b1d4ec">_colr_join_arrayn_size()</a>, <a class="el" href="colr_8h.html#ab0be451277fc7e39aee0aa409c9d3f0c">_colr_ptr_length()</a>, and <a class="el" href="colr_8h.html#a412833a097b050c8ee99874c733bd030">ColorText_length()</a>.</p>

</div>
</div>
<a id="a5af692f2357d46b9cee45bb114f2a4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af692f2357d46b9cee45bb114f2a4a2">&#9670;&nbsp;</a></span>ColorArg_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorArg_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>carg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation for a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>. </p>
<p>Allocates memory for the string representation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">carg</td><td><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct to get the representation for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">Allocated string for the representation.</p>
<p class="enddd"><em>You must <code>free()</code> the memory allocated by this function.</em> </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a30cac3017a6ea8c78277882554c9419f">_colr_ptr_repr()</a>, and <a class="el" href="colr_8h.html#a65363a3601cd9cfcdc7fc40722d5d3c3">ColorText_repr()</a>.</p>

</div>
</div>
<a id="ad1d3aaca5e543f8fefbd863a959c9d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d3aaca5e543f8fefbd863a959c9d67">&#9670;&nbsp;</a></span>ColorArg_to_esc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorArg_to_esc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>carg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> into an escape code string (<code>char*</code>). </p>
<p>Allocates memory for the string.</p>
<p>If the <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> is empty (<code>ARGTYPE_NONE</code>), an empty string is returned.</p>
<p>If the <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> is invalid, an empty string is returned. You must still free the empty string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">carg</td><td><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to get the ArgType and <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">Allocated string for the escape code.</p>
<p class="enddd"><em>You must <code>free()</code> the memory allocated by this function.</em> If the <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> is considered "empty", or the <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> is invalid, then <code>NULL</code> is returned. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>, <a class="el" href="colr_8h.html#a0d97f9b535a69642b926b38dce30b180">_colr_ptr_to_str()</a>, <a class="el" href="colr_8h.html#ae305b33e0a44b956ccf4123aa4f1a033">ColorText_to_str()</a>, <a class="el" href="colr_8h.html#a71fcf08ad36d4424790e275d973445fc">colr_join_arrayn()</a>, <a class="el" href="colr_8h.html#a34c359a48f811316d765b7abef1ea8f4">colr_printf_handler()</a>, <a class="el" href="colr_8h.html#af7c01a492bcbda6cf93705bff0cb0dbe">colr_str_replace_all_ColorArg()</a>, <a class="el" href="colr_8h.html#aa8b61a4cadcf73e21eee109623695bad">colr_str_replace_ColorArg()</a>, <a class="el" href="colr_8h.html#a577e45a5c233dd1b4774a9034b17e3eb">colr_str_replace_re_all_ColorArg()</a>, <a class="el" href="colr_8h.html#a78d58bde53845d6ab2c54e4ba0c68a3d">colr_str_replace_re_ColorArg()</a>, <a class="el" href="colr_8h.html#a0d4cbd6a8fd3cef76f07b705b09d2a54">colr_str_replace_re_match_ColorArg()</a>, <a class="el" href="colr_8h.html#a75b2cdee697818e2f9f38ec7eac98bcb">colr_str_replace_re_matches_ColorArg()</a>, <a class="el" href="colr_8h.html#a090ba95c4560134ef9c2807eff6a0ea1">colr_str_replace_re_pat_all_ColorArg()</a>, and <a class="el" href="colr_8h.html#adecbe2f1e87613b6f4a51158325dd4f7">colr_str_replace_re_pat_ColorArg()</a>.</p>

</div>
</div>
<a id="abaf3d02ff1292f2aaa605522665ae564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaf3d02ff1292f2aaa605522665ae564">&#9670;&nbsp;</a></span>ColorArg_to_esc_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorArg_to_esc_s </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>carg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> into an escape code string (<code>char*</code>) and fills the destination string. </p>
<p>If the <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> is empty (<code>ARGTYPE_NONE</code>), <code>dest[0]</code> is set to `'\0'`.</p>
<p>If the <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> is invalid, <code>dest[0]</code> is set to `'\0'`.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>Destination for the escape code string. <em>Must have room for the code type being used</em>. See <a class="el" href="colr_8c.html#adaff727006f4c057aab75e55bfb473c4" title="Returns the length in bytes needed to allocate a string (char*) built with ColorArg_to_esc(). ">ColorArg_length()</a> for determining the size needed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">carg</td><td><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to get the ArgType and <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> was valid, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a39f8caf33e6befb9b78958f5d24911ff">colr_str_has_ColorArg()</a>.</p>

</div>
</div>
<a id="afb5ac0bd012b8162cea125ad0d9e8bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb5ac0bd012b8162cea125ad0d9e8bf0">&#9670;&nbsp;</a></span>ColorArg_to_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>* ColorArg_to_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>carg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> into memory and returns the pointer. </p>
<p>You must free() the memory if you call this directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">carg</td><td><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to copy/allocate for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">Pointer to a heap-allocated <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a4897abe50811762a84ee409c0c2d300f">ColorArgs_from_str()</a>.</p>

</div>
</div>
<a id="a32c5256623852632a4ba040e3447431c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c5256623852632a4ba040e3447431c">&#9670;&nbsp;</a></span>ColorArgs_array_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ColorArgs_array_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> **&#160;</td>
          <td class="paramname"><em>ps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free an allocated array of ColorArgs, including the array itself. </p>
<p>Each individual <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> will be released, and finally the allocated memory for the array of pointers will be released.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ps</td><td>A pointer to an array of ColorArgs, where <code>NULL</code> is the last item.</td></tr>
  </table>
  </dd>
</dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#ColorArgs_array_free-example" id="ColorArgs_array_free-example" class="diamond-bullet">&#160;</a> ColorArgs_array_free example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* s = <a class="code" href="colr_8h.html#a753093cd4c872eed4b77feaa7816212b">colr</a>(<span class="stringliteral">&quot;Test&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED), <a class="code" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8">back</a>(WHITE), <a class="code" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662">style</a>(BRIGHT));</div><div class="line"><span class="keywordflow">if</span> (!s) exit(1);</div><div class="line"><span class="comment">// Call something that creates an array of ColorArgs on the heap.</span></div><div class="line"><a class="code" href="colr_8h.html#structColorArg">ColorArg</a>** carg_array = <a class="code" href="colr_8c.html#a4897abe50811762a84ee409c0c2d300f">ColorArgs_from_str</a>(s, <span class="keyword">false</span>);</div><div class="line">free(s);</div><div class="line"><span class="keywordflow">if</span> (!carg_array) exit(1);</div><div class="line"><span class="comment">// ... do something with the array of ColorArgs.</span></div><div class="line"></div><div class="line"><span class="comment">// And then free it:</span></div><div class="line"><a class="code" href="colr_8c.html#a32c5256623852632a4ba040e3447431c">ColorArgs_array_free</a>(carg_array);</div></div><!-- fragment --> </div> 
</div>
</div>
<a id="a4e16f30e878a6fb53ed9af5f8fdd674a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e16f30e878a6fb53ed9af5f8fdd674a">&#9670;&nbsp;</a></span>ColorArgs_array_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorArgs_array_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> **&#160;</td>
          <td class="paramname"><em>lst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string representation for an array of <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lst</td><td>The <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> array to create the representation for (<code>ColorArg**</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string, or <code>NULL</code> if <code>lst</code> is <code>NULL</code>, or the allocation fails.</dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#ColorArgs_array_repr-example" id="ColorArgs_array_repr-example" class="diamond-bullet">&#160;</a> ColorArgs_array_repr example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* s = <a class="code" href="colr_8h.html#a753093cd4c872eed4b77feaa7816212b">colr</a>(<span class="stringliteral">&quot;Test&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED), <a class="code" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8">back</a>(WHITE), <a class="code" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662">style</a>(BRIGHT));</div><div class="line"><span class="keywordflow">if</span> (!s) exit(1);</div><div class="line"><span class="comment">// Call something that creates an array of ColorArgs on the heap.</span></div><div class="line"><a class="code" href="colr_8h.html#structColorArg">ColorArg</a>** carg_array = <a class="code" href="colr_8c.html#a4897abe50811762a84ee409c0c2d300f">ColorArgs_from_str</a>(s, <span class="keyword">false</span>);</div><div class="line">free(s);</div><div class="line"><span class="keywordflow">if</span> (!carg_array) exit(1);</div><div class="line"><span class="keywordtype">char</span>* lst_repr = <a class="code" href="colr_8c.html#a4e16f30e878a6fb53ed9af5f8fdd674a">ColorArgs_array_repr</a>(carg_array);</div><div class="line"><a class="code" href="colr_8c.html#a32c5256623852632a4ba040e3447431c">ColorArgs_array_free</a>(carg_array);</div><div class="line"><span class="keywordflow">if</span> (!lst_repr) exit(1);</div><div class="line">printf(<span class="stringliteral">&quot;ColorArg carg_array[] = %s\n&quot;</span>, lst_repr);</div><div class="line"><span class="comment">// And then free it:</span></div><div class="line">free(lst_repr);</div></div><!-- fragment --> </div> 
</div>
</div>
<a id="a4897abe50811762a84ee409c0c2d300f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4897abe50811762a84ee409c0c2d300f">&#9670;&nbsp;</a></span>ColorArgs_from_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>** ColorArgs_from_str </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unique</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an array of ColorArgs from escape-codes found in a string (<code>char*</code>). </p>
<p>This uses <a class="el" href="colr_8c.html#a70e9640f37dd85cde0b6f25c0b705912" title="Parse an escape-code string (char*) into a ColorArg. ">ColorArg_from_esc()</a> and <a class="el" href="colr_8c.html#a6292cbb8bd9f3d19bb0bd05a4d7b0bea" title="Get an array of escape-codes from a string (char*). ">colr_str_get_codes()</a> to build a heap-allocated array of heap-allocated ColorArgs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">A string to get the escape-codes from.</p>
<p class="endtd"><em>Must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unique</td><td>Whether to only include <em>unique</em> ColorArgs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated array of <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointers, where the last element is <code>NULL</code>.</p>
<p class="enddd"><em>You must <code>free()</code> the memory allocated by this function.</em> </p>
</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">If</td><td><code>s</code> is <code>NULL</code>, or empty, or there are otherwise no escape-codes found in the string, then <code>NULL</code> is returned. </td></tr>
    <tr><td class="paramname">On</td><td>success, there will be at least two pointers behind the return value. The last pointer is always <code>NULL</code>.</td></tr>
  </table>
  </dd>
</dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#ColorArgs_from_str-example" id="ColorArgs_from_str-example" class="diamond-bullet">&#160;</a> ColorArgs_from_str example: </div><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="colr_8h.html">colr.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div><div class="line">    <span class="keywordtype">char</span>* s = <a class="code" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa">colr_cat</a>(</div><div class="line">        <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;Testing this out.&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED), <a class="code" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8">back</a>(WHITE)),</div><div class="line">        <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;Again.&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED), <a class="code" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662">style</a>(UNDERLINE))</div><div class="line">    );</div><div class="line">    <span class="keywordflow">if</span> (!s) <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    <a class="code" href="colr_8h.html#structColorArg">ColorArg</a>** carg_array = <a class="code" href="colr_8c.html#a4897abe50811762a84ee409c0c2d300f">ColorArgs_from_str</a>(s, <span class="keyword">false</span>);</div><div class="line">    free(s);</div><div class="line">    <span class="keywordflow">if</span> (!carg_array) {</div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;No code found? Impossible!\n&quot;</span>);</div><div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line">    <span class="comment">// Iterate over the ColorArg array.</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; carg_array[i]; i++) {</div><div class="line">        <span class="keywordtype">char</span>* carg_example = <a class="code" href="colr_8c.html#aa54ab1879f6de8ca2fcb4702250741f5">ColorArg_example</a>(*(carg_array[i]), <span class="keyword">true</span>);</div><div class="line">        <span class="keywordflow">if</span> (!carg_example) <span class="keywordflow">continue</span>;</div><div class="line">        printf(<span class="stringliteral">&quot;%s\n&quot;</span>, carg_example);</div><div class="line">        free(carg_example);</div><div class="line">    }</div><div class="line">    <span class="comment">// Free the ColorArgs, and the array of pointers.</span></div><div class="line">    <a class="code" href="colr_8c.html#a32c5256623852632a4ba040e3447431c">ColorArgs_array_free</a>(carg_array);</div><div class="line">}</div></div><!-- fragment --> </div> 
</div>
</div>
<a id="ae11e9457ca4e8f5be0e29351b49b6844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae11e9457ca4e8f5be0e29351b49b6844">&#9670;&nbsp;</a></span>ColorJustify_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a> ColorJustify_empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an "empty" <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a>, with JUST_NONE set. </p>
<dl class="section return"><dt>Returns</dt><dd>An initialized <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a>, with no justification method set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a341b4033c31c58e412ff15280185c6bd">ColorText_empty()</a>.</p>

</div>
</div>
<a id="ab71656e616aef4bbb3c278d43c4a326e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab71656e616aef4bbb3c278d43c4a326e">&#9670;&nbsp;</a></span>ColorJustify_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorJustify_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> structs. </p>
<p>They are considered "equal" if their member values match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if they are equal, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> </dd></dl>

</div>
</div>
<a id="a34f193b6e6a20c63caecc1d9b53c89fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f193b6e6a20c63caecc1d9b53c89fb">&#9670;&nbsp;</a></span>ColorJustify_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorJustify_is_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a>&#160;</td>
          <td class="paramname"><em>cjust</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> is "empty". </p>
<p>A <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> is considered "empty" if the <code>.method</code> member is set to <code>JUST_NONE</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cjust</td><td>The <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> is empty, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> </dd>
<dd>
<a class="el" href="colr_8c.html#ae11e9457ca4e8f5be0e29351b49b6844" title="Creates an &quot;empty&quot; ColorJustify, with JUST_NONE set. ">ColorJustify_empty</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ac846e583415e832b9090270020320b9f">ColorText_is_empty()</a>, and <a class="el" href="colr_8h.html#a412833a097b050c8ee99874c733bd030">ColorText_length()</a>.</p>

</div>
</div>
<a id="a7d4a7a21151993343ef96a068c6d5018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4a7a21151993343ef96a068c6d5018">&#9670;&nbsp;</a></span>ColorJustify_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a> ColorJustify_new </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#af1a3fe0b966f944fd659a98be170045f">ColorJustifyMethod</a>&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>padchar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a>. </p>
<p>This is used to ensure every <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> has it's <code>.marker</code> member set correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>ColorJustifyMethod to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>Width for justification. If <code>0</code> is given, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> will use the width from <a class="el" href="colr_8c.html#ae4c11bb5b3b1bb2848bb16aee39763b2" title="Attempts to retrieve the row/column size of the terminal and returns a TermSize. ">colr_term_size()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">padchar</td><td>Padding character to use. If <code>0</code> is given, the default, space (`' '`), is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An initialized <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a>. </dd></dl>

</div>
</div>
<a id="a6c35f6b47cc737744487d14d20241656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c35f6b47cc737744487d14d20241656">&#9670;&nbsp;</a></span>ColorJustify_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorJustify_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a>&#160;</td>
          <td class="paramname"><em>cjust</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation for a <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a>. </p>
<p>Allocates memory for the string representation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cjust</td><td><a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> struct to get the representation for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">Allocated string for the representation.</p>
<p class="enddd"><em>You must <code>free()</code> the memory allocated by this function.</em> </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a65363a3601cd9cfcdc7fc40722d5d3c3">ColorText_repr()</a>.</p>

</div>
</div>
<a id="adf78eeb364553d130055d93e9892cd9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf78eeb364553d130055d93e9892cd9c">&#9670;&nbsp;</a></span>ColorJustifyMethod_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorJustifyMethod_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#af1a3fe0b966f944fd659a98be170045f">ColorJustifyMethod</a>&#160;</td>
          <td class="paramname"><em>meth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation for a ColorJustifyMethod. </p>
<p>Allocates memory for the string representation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meth</td><td>ColorJustifyMethod to get the representation for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">Allocated string for the representation.</p>
<p class="enddd"><em>You must <code>free()</code> the memory allocated by this function.</em> </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#af1a3fe0b966f944fd659a98be170045f" title="Justification style for ColorTexts. ">ColorJustifyMethod</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a6c35f6b47cc737744487d14d20241656">ColorJustify_repr()</a>.</p>

</div>
</div>
<a id="ad4c95a667cdcd05fd108ddf20b9a7328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4c95a667cdcd05fd108ddf20b9a7328">&#9670;&nbsp;</a></span>ColorResult_Colr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a>* ColorResult_Colr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *&#160;</td>
          <td class="paramname"><em>cres</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Colorize a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, and return a new allocated <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>. </p>
<p>This is like ColorText_from_value(), except it accepts an allocated <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> as the first argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cres</td><td>An allocated <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> to colorize. This will be released to create the new <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>One or more <a class="el" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f" title="Create a fore color suitable for use with the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros. ">fore()</a>, <a class="el" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8" title="Create a back color suitable for use with the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros. ">back()</a>, or <a class="el" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662" title="Create a style suitable for use with the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros. ">style()</a> arguments (ColorArgs). The last argument must be _ColrLastArg. The allocated ColorArgs will be <code>free()</code>'d. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, or <code>NULL</code> if <code>cres</code> is <code>NULL</code>.</p>
<p><em>If allocation fails, <code>NULL</code> is returned</em>.</p>
<p class="enddd">If used inside of the <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a>, <a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465" title="Like colr_cat(), but returns an allocated ColorResult that the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros will automatically free(). ">Colr_cat()</a>, and <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> macros, <em>they will <code>free()</code> the result</em>. Otherwise, <em>you are responsible for calling <code>free()</code></em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> </dd></dl>

</div>
</div>
<a id="a5b59e832f322e617a89ca14046cc41d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b59e832f322e617a89ca14046cc41d2">&#9670;&nbsp;</a></span>ColorResult_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a> ColorResult_empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> with <code>.result=NULL</code> and <code>.length=-1</code>, with the appropriate struct marker. </p>
<dl class="section return"><dt>Returns</dt><dd>An "empty" (initialized) <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a91d92286745806229c0369c20edf641c">ColorResult_from_stra()</a>, and <a class="el" href="colr_8h.html#af752035c362c7c9ddb2e7f2f2305d509">ColorResult_new()</a>.</p>

</div>
</div>
<a id="afb35d2507389c11d6ffe2adc6876efcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb35d2507389c11d6ffe2adc6876efcc">&#9670;&nbsp;</a></span>ColorResult_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorResult_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two ColorResults. </p>
<p>They are equal if all of their members are equal, excluding the memory address for the <code>.result</code> member.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if they are equal, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> </dd></dl>

</div>
</div>
<a id="a27b70c6de9b2351424100bd742b1f1a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b70c6de9b2351424100bd742b1f1a8">&#9670;&nbsp;</a></span>ColorResult_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ColorResult_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free allocated memory for a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> and it's <code>.result</code> member. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> with a <code>NULL</code> or heap-allocated <code>.result</code> member.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#aaa888f1b31eb40ec7d252d3ee9175d76">_colr_free()</a>, <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>, <a class="el" href="colr_8h.html#ad4c95a667cdcd05fd108ddf20b9a7328">ColorResult_Colr()</a>, <a class="el" href="colr_8h.html#a34c359a48f811316d765b7abef1ea8f4">colr_printf_handler()</a>, <a class="el" href="colr_8h.html#a53fa120c1074c836f65b4aace67d0c83">colr_str_replace_all_ColorResult()</a>, <a class="el" href="colr_8h.html#a136d15edf2f804c89cee619bb811ef3a">colr_str_replace_ColorResult()</a>, <a class="el" href="colr_8h.html#a3e18a36736e5451529e80443cfb7b1fc">colr_str_replace_re_all_ColorResult()</a>, <a class="el" href="colr_8h.html#a0376bed13e55acaca37e52c382044e1d">colr_str_replace_re_ColorResult()</a>, <a class="el" href="colr_8h.html#ac092f944961dddc6574a6c55e6e878b0">colr_str_replace_re_match_ColorResult()</a>, <a class="el" href="colr_8h.html#a4d4bb71015338108d86fcf47317cc5ff">colr_str_replace_re_matches_ColorResult()</a>, <a class="el" href="colr_8h.html#af083c2e1867ecaad0ae38a1324c915ac">colr_str_replace_re_pat_all_ColorResult()</a>, and <a class="el" href="colr_8h.html#abcd756c82acab9505343b614d52c0b19">colr_str_replace_re_pat_ColorResult()</a>.</p>

</div>
</div>
<a id="ac5c106f8d2e83b007a3fd633c3097c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c106f8d2e83b007a3fd633c3097c18">&#9670;&nbsp;</a></span>ColorResult_from_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a> ColorResult_from_str </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a copy of a string, and creates a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> from it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An initialized <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>. The <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> may be "empty" if <code>s</code> is <code>NULL</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> </dd></dl>

</div>
</div>
<a id="a91d92286745806229c0369c20edf641c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91d92286745806229c0369c20edf641c">&#9670;&nbsp;</a></span>ColorResult_from_stra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a>* ColorResult_from_stra </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a copy of a string, and creates an allocated <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> from it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>. The <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> may be "empty" if <code>s</code> is <code>NULL</code>.</p>
<p><em>If allocation fails, <code>NULL</code> is returned</em>.</p>
<p class="enddd">If used inside of the <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a>, <a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465" title="Like colr_cat(), but returns an allocated ColorResult that the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros will automatically free(). ">Colr_cat()</a>, and <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> macros, <em>they will <code>free()</code> the result</em>. Otherwise, <em>you are responsible for calling <code>free()</code></em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8controls_8h.html#a539a34ed0f6d42af46f9eabed5dc96bb">Colr_cursor_hide()</a>, <a class="el" href="colr_8controls_8h.html#a26ca58da32fbb8b748be6d1f3be28991">Colr_cursor_show()</a>, <a class="el" href="colr_8controls_8h.html#a6f073609c3c701e1e94d57ffdf101b5c">Colr_erase_display()</a>, <a class="el" href="colr_8controls_8h.html#a5dbeee52b0527cf77523535dcb0cfb4f">Colr_erase_line()</a>, <a class="el" href="colr_8controls_8h.html#ad0a32ea7c15e5b40eda9d3277f7035d3">Colr_move_return()</a>, <a class="el" href="colr_8controls_8h.html#abf70c357e4cb15198020a6fbb29f09b8">Colr_pos_restore()</a>, and <a class="el" href="colr_8controls_8h.html#a5784c31cca2244df4005754b43185a5d">Colr_pos_save()</a>.</p>

</div>
</div>
<a id="afd5fe635f26119c3a341b5dfe23abc97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd5fe635f26119c3a341b5dfe23abc97">&#9670;&nbsp;</a></span>ColorResult_is_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorResult_is_ptr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks a void pointer to see if it contains a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> struct. </p>
<p>The first member of a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> is a marker.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A void pointer to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the pointer is a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#aaa888f1b31eb40ec7d252d3ee9175d76">_colr_free()</a>, <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>, <a class="el" href="colr_8h.html#a6d47ac6ee2a59e1c976cf2838545aa25">_colr_join_array_length()</a>, <a class="el" href="colr_8h.html#ac49c3a33d328ebaf2b0564d5a9b1d4ec">_colr_join_arrayn_size()</a>, <a class="el" href="colr_8h.html#ab0be451277fc7e39aee0aa409c9d3f0c">_colr_ptr_length()</a>, <a class="el" href="colr_8h.html#a30cac3017a6ea8c78277882554c9419f">_colr_ptr_repr()</a>, <a class="el" href="colr_8h.html#a0d97f9b535a69642b926b38dce30b180">_colr_ptr_to_str()</a>, <a class="el" href="colr_8h.html#a18e06ee5b32cd583c71ecff7d6c18270">colr_is_colr_ptr()</a>, <a class="el" href="colr_8h.html#a71fcf08ad36d4424790e275d973445fc">colr_join_arrayn()</a>, and <a class="el" href="colr_8h.html#a34c359a48f811316d765b7abef1ea8f4">colr_printf_handler()</a>.</p>

</div>
</div>
<a id="a5169ef5d27a9c14bb765f7e7b70c9e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5169ef5d27a9c14bb765f7e7b70c9e2b">&#9670;&nbsp;</a></span>ColorResult_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ColorResult_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a>&#160;</td>
          <td class="paramname"><em>cres</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the length in bytes (including the null-terminator), that is needed to store the return from <a class="el" href="colr_8c.html#af5174a576892401ea59b737558f27d8b" title="Convert a ColorResult into a string (char*). ">ColorResult_to_str()</a> (<code>.result</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cres</td><td>A <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> to calculate the length for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, possibly <code>0</code> if <code>.result</code> is <code>NULL</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ac49c3a33d328ebaf2b0564d5a9b1d4ec">_colr_join_arrayn_size()</a>, and <a class="el" href="colr_8h.html#ab0be451277fc7e39aee0aa409c9d3f0c">_colr_ptr_length()</a>.</p>

</div>
</div>
<a id="af752035c362c7c9ddb2e7f2f2305d509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af752035c362c7c9ddb2e7f2f2305d509">&#9670;&nbsp;</a></span>ColorResult_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a> ColorResult_new </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a new <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> with an allocated string (<code>char*</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>An allocated string to use for the <code>.result</code> member. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An initialized <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>. The <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> will be considered "empty" if <code>s</code> is <code>NULL</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ad4c95a667cdcd05fd108ddf20b9a7328">ColorResult_Colr()</a>, <a class="el" href="colr_8h.html#ac5c106f8d2e83b007a3fd633c3097c18">ColorResult_from_str()</a>, <a class="el" href="colr_8h.html#a008af1b6ab6db4d4dd98033471506f1e">Colr_fmt_str()</a>, <a class="el" href="colr_8controls_8h.html#a63f1bbac577f13c42ecc0358d179cbcd">Colr_move_back()</a>, <a class="el" href="colr_8controls_8h.html#ad6ed55c687b39c03f157796c9301557d">Colr_move_column()</a>, <a class="el" href="colr_8controls_8h.html#a199f6e456028c66c2429ec862f9ac5a0">Colr_move_down()</a>, <a class="el" href="colr_8controls_8h.html#a1d75da8b76f80e26cd02a31517a79861">Colr_move_forward()</a>, <a class="el" href="colr_8controls_8h.html#a0a2ecf5b0f26e46db5277e864b27bca5">Colr_move_next()</a>, <a class="el" href="colr_8controls_8h.html#ac43155350dda523b5aeedb50e02104fa">Colr_move_pos()</a>, <a class="el" href="colr_8controls_8h.html#a585d85a38f63bfae83026e36428f43c4">Colr_move_prev()</a>, <a class="el" href="colr_8controls_8h.html#a3808823bc9698483636970d6cdd02acb">Colr_move_up()</a>, <a class="el" href="colr_8controls_8h.html#ae2201d43b84b8060cfb5e00f32110f56">Colr_scroll_down()</a>, and <a class="el" href="colr_8controls_8h.html#ac0a2a79d8106fad5ad1ba8821b8591ae">Colr_scroll_up()</a>.</p>

</div>
</div>
<a id="aae0b90c57e8c4c475d9e0f517f3a0d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0b90c57e8c4c475d9e0f517f3a0d42">&#9670;&nbsp;</a></span>ColorResult_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorResult_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a>&#160;</td>
          <td class="paramname"><em>cres</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a string representation for a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>. </p>
<p>This happens to be the same as <code>colr_str_repr(cres.result)</code> right now.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cres</td><td>A <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> to create the representation string for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a30cac3017a6ea8c78277882554c9419f">_colr_ptr_repr()</a>.</p>

</div>
</div>
<a id="a5f5304067f9d673ce5b86ddba2a8807b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f5304067f9d673ce5b86ddba2a8807b">&#9670;&nbsp;</a></span>ColorResult_to_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a>* ColorResult_to_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a>&#160;</td>
          <td class="paramname"><em>cres</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate memory for a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, fill it, and return it. </p>
<p>This ensure the appropriate struct marker is set, for use with Colr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cres</td><td>A <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p>If used inside of the <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a>, <a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465" title="Like colr_cat(), but returns an allocated ColorResult that the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros will automatically free(). ">Colr_cat()</a>, and <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> macros, <em>they will <code>free()</code> the result</em>. Otherwise, <em>you are responsible for calling <code>free()</code></em>.</p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ad4c95a667cdcd05fd108ddf20b9a7328">ColorResult_Colr()</a>, <a class="el" href="colr_8h.html#a91d92286745806229c0369c20edf641c">ColorResult_from_stra()</a>, <a class="el" href="colr_8h.html#a008af1b6ab6db4d4dd98033471506f1e">Colr_fmt_str()</a>, <a class="el" href="colr_8controls_8h.html#a63f1bbac577f13c42ecc0358d179cbcd">Colr_move_back()</a>, <a class="el" href="colr_8controls_8h.html#ad6ed55c687b39c03f157796c9301557d">Colr_move_column()</a>, <a class="el" href="colr_8controls_8h.html#a199f6e456028c66c2429ec862f9ac5a0">Colr_move_down()</a>, <a class="el" href="colr_8controls_8h.html#a1d75da8b76f80e26cd02a31517a79861">Colr_move_forward()</a>, <a class="el" href="colr_8controls_8h.html#a0a2ecf5b0f26e46db5277e864b27bca5">Colr_move_next()</a>, <a class="el" href="colr_8controls_8h.html#ac43155350dda523b5aeedb50e02104fa">Colr_move_pos()</a>, <a class="el" href="colr_8controls_8h.html#a585d85a38f63bfae83026e36428f43c4">Colr_move_prev()</a>, <a class="el" href="colr_8controls_8h.html#a3808823bc9698483636970d6cdd02acb">Colr_move_up()</a>, <a class="el" href="colr_8controls_8h.html#ae2201d43b84b8060cfb5e00f32110f56">Colr_scroll_down()</a>, and <a class="el" href="colr_8controls_8h.html#ac0a2a79d8106fad5ad1ba8821b8591ae">Colr_scroll_up()</a>.</p>

</div>
</div>
<a id="af5174a576892401ea59b737558f27d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5174a576892401ea59b737558f27d8b">&#9670;&nbsp;</a></span>ColorResult_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorResult_to_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a>&#160;</td>
          <td class="paramname"><em>cres</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> into a string (<code>char*</code>). </p>
<p>This simply returns the <code>.result</code> member right now. It is used for compatibility with the <a class="el" href="colr_8h.html#a790e5a9bd0b3ca7cd7d428007f6a21b9" title="Calls the &lt;type&gt;_to_str functions for the supported types. ">colr_to_str()</a> macro.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cres</td><td>A <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A stringified-version if this <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, which happens to be the <code>.result</code> member. <em>If you free the result of this function, the original string used to create the <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> will be lost</em>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>, <a class="el" href="colr_8h.html#a0d97f9b535a69642b926b38dce30b180">_colr_ptr_to_str()</a>, <a class="el" href="colr_8h.html#ad4c95a667cdcd05fd108ddf20b9a7328">ColorResult_Colr()</a>, <a class="el" href="colr_8h.html#a71fcf08ad36d4424790e275d973445fc">colr_join_arrayn()</a>, <a class="el" href="colr_8h.html#a34c359a48f811316d765b7abef1ea8f4">colr_printf_handler()</a>, <a class="el" href="colr_8h.html#a53fa120c1074c836f65b4aace67d0c83">colr_str_replace_all_ColorResult()</a>, <a class="el" href="colr_8h.html#a136d15edf2f804c89cee619bb811ef3a">colr_str_replace_ColorResult()</a>, <a class="el" href="colr_8h.html#a3e18a36736e5451529e80443cfb7b1fc">colr_str_replace_re_all_ColorResult()</a>, <a class="el" href="colr_8h.html#a0376bed13e55acaca37e52c382044e1d">colr_str_replace_re_ColorResult()</a>, <a class="el" href="colr_8h.html#ac092f944961dddc6574a6c55e6e878b0">colr_str_replace_re_match_ColorResult()</a>, <a class="el" href="colr_8h.html#a4d4bb71015338108d86fcf47317cc5ff">colr_str_replace_re_matches_ColorResult()</a>, <a class="el" href="colr_8h.html#af083c2e1867ecaad0ae38a1324c915ac">colr_str_replace_re_pat_all_ColorResult()</a>, and <a class="el" href="colr_8h.html#abcd756c82acab9505343b614d52c0b19">colr_str_replace_re_pat_ColorResult()</a>.</p>

</div>
</div>
<a id="a341b4033c31c58e412ff15280185c6bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a341b4033c31c58e412ff15280185c6bd">&#9670;&nbsp;</a></span>ColorText_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorText">ColorText</a> ColorText_empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an "empty" <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> with pointers set to <code>NULL</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>An initialized <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a9bbb1f20ed69733be7750640ac297073">ColorText_from_valuesv()</a>, and <a class="el" href="colr_8h.html#a880b39cd2ce9b622dbe7790a162d88f7">ColorText_set_values()</a>.</p>

</div>
</div>
<a id="a901e5738358a739629cc3aaccab3e73f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a901e5738358a739629cc3aaccab3e73f">&#9670;&nbsp;</a></span>ColorText_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ColorText_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> and it's ColorArgs. </p>
<p>The text member is left alone, because it wasn't created by ColrC.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Pointer to <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to free, along with it's Colr-based members.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#aaa888f1b31eb40ec7d252d3ee9175d76">_colr_free()</a>, <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>, <a class="el" href="colr_8h.html#a34c359a48f811316d765b7abef1ea8f4">colr_printf_handler()</a>, <a class="el" href="colr_8h.html#a73789c11eaeb5a36b5f97556103a108d">colr_str_replace_all_ColorText()</a>, <a class="el" href="colr_8h.html#aaee8d79a90917974ee4537705e34fd76">colr_str_replace_ColorText()</a>, <a class="el" href="colr_8h.html#a747e31fa3d8961e0bdd11eabd673accc">colr_str_replace_re_all_ColorText()</a>, <a class="el" href="colr_8h.html#ab8d6a10f70b435559656bbad0090d92d">colr_str_replace_re_ColorText()</a>, <a class="el" href="colr_8h.html#a4d954398333472c1436f9bc051f46392">colr_str_replace_re_match_ColorText()</a>, <a class="el" href="colr_8h.html#aa4fe38cc205cbd49b2f8477744574294">colr_str_replace_re_matches_ColorText()</a>, <a class="el" href="colr_8h.html#ab9c4a5c34b26473dc45f93ce2c66faf1">colr_str_replace_re_pat_all_ColorText()</a>, and <a class="el" href="colr_8h.html#a6f8b04b6d851f26304183d1111b8f0dc">colr_str_replace_re_pat_ColorText()</a>.</p>

</div>
</div>
<a id="a4979a2ec9d5fb442ba025c6f2efc4864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4979a2ec9d5fb442ba025c6f2efc4864">&#9670;&nbsp;</a></span>ColorText_free_args()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ColorText_free_args </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> members of a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>. </p>
<p>The <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> itself is not free'd.</p>
<p>This is safe to use on a stack-allocated <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> with heap-allocated ColorArgs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Pointer to a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ad4c95a667cdcd05fd108ddf20b9a7328">ColorResult_Colr()</a>, and <a class="el" href="colr_8h.html#a901e5738358a739629cc3aaccab3e73f">ColorText_free()</a>.</p>

</div>
</div>
<a id="ad4702d6ddc409a93a0b42c8f6141d2f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4702d6ddc409a93a0b42c8f6141d2f2">&#9670;&nbsp;</a></span>ColorText_from_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorText">ColorText</a> ColorText_from_values </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> from 1 mandatory string (<code>char*</code>), and optional fore, back, and style args (pointers to ColorArgs). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>Text to colorize (a regular string). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>ColorArgs for fore, back, and style, in any order. The last argument must be _ColrLastArg. The <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a> macro takes care of this for you. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An initialized <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> struct.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

</div>
</div>
<a id="a9bbb1f20ed69733be7750640ac297073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bbb1f20ed69733be7750640ac297073">&#9670;&nbsp;</a></span>ColorText_from_valuesv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorText">ColorText</a> ColorText_from_valuesv </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> from 1 mandatory string (<code>char*</code>), and a <code>va_list</code> with optional fore, back, and style args (pointers to ColorArgs). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>Text to colorize (a regular string). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td><code>va_list</code> with ColorArgs for fore, back, and style, in any order. The last argument must be _ColrLastArg. The <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a> macro takes care of this for you, and should be used for basic text colorization. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An initialized <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> struct.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ad4c95a667cdcd05fd108ddf20b9a7328">ColorResult_Colr()</a>, and <a class="el" href="colr_8h.html#ad4702d6ddc409a93a0b42c8f6141d2f2">ColorText_from_values()</a>.</p>

</div>
</div>
<a id="a93f65430500d003575c547eb667330b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f65430500d003575c547eb667330b0">&#9670;&nbsp;</a></span>ColorText_has_arg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorText_has_arg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a>&#160;</td>
          <td class="paramname"><em>ctext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>carg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> has a certain <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> value set. </p>
<p>Uses <a class="el" href="colr_8c.html#acb62efc0182d6f6107055eeda961a628" title="Compares two ColorArg structs. ">ColorArg_eq()</a> to inspect the <code>fore</code>, <code>back</code>, and <code>style</code> members.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctext</td><td>The <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to inspect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">carg</td><td>The <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <code>fore</code>, <code>back</code>, or <code>style</code> arg matches <code>carg</code>, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

</div>
</div>
<a id="a93b38987063bb127bb34761961d7f678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93b38987063bb127bb34761961d7f678">&#9670;&nbsp;</a></span>ColorText_has_args()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorText_has_args </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a>&#160;</td>
          <td class="paramname"><em>ctext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> has any argument values set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctext</td><td>A <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>.fore</code>, <code>.back</code>, or .<code>style</code> is set to a non-empty <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

</div>
</div>
<a id="ac846e583415e832b9090270020320b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac846e583415e832b9090270020320b9f">&#9670;&nbsp;</a></span>ColorText_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorText_is_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a>&#160;</td>
          <td class="paramname"><em>ctext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> has no usable values. </p>
<p>A <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> is considered "empty" if the <code>.text</code>, <code>.fore</code>, <code>.back</code>, and <code>.style</code> pointers are <code>NULL</code>, and the <code>.just</code> member is set to an "empty" <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctext</td><td>The <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> is empty, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd>
<dd>
<a class="el" href="colr_8c.html#a341b4033c31c58e412ff15280185c6bd" title="Creates an &quot;empty&quot; ColorText with pointers set to NULL. ">ColorText_empty</a> </dd></dl>

</div>
</div>
<a id="a1d6eb8832110b943c3a3a17627a50288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6eb8832110b943c3a3a17627a50288">&#9670;&nbsp;</a></span>ColorText_is_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorText_is_ptr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks a void pointer to see if it contains a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> struct. </p>
<p>The first member of a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> is a marker.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A void pointer to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the pointer is a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#aaa888f1b31eb40ec7d252d3ee9175d76">_colr_free()</a>, <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>, <a class="el" href="colr_8h.html#a6d47ac6ee2a59e1c976cf2838545aa25">_colr_join_array_length()</a>, <a class="el" href="colr_8h.html#ac49c3a33d328ebaf2b0564d5a9b1d4ec">_colr_join_arrayn_size()</a>, <a class="el" href="colr_8h.html#ab0be451277fc7e39aee0aa409c9d3f0c">_colr_ptr_length()</a>, <a class="el" href="colr_8h.html#a30cac3017a6ea8c78277882554c9419f">_colr_ptr_repr()</a>, <a class="el" href="colr_8h.html#a0d97f9b535a69642b926b38dce30b180">_colr_ptr_to_str()</a>, <a class="el" href="colr_8h.html#a18e06ee5b32cd583c71ecff7d6c18270">colr_is_colr_ptr()</a>, <a class="el" href="colr_8h.html#a71fcf08ad36d4424790e275d973445fc">colr_join_arrayn()</a>, and <a class="el" href="colr_8h.html#a34c359a48f811316d765b7abef1ea8f4">colr_printf_handler()</a>.</p>

</div>
</div>
<a id="a412833a097b050c8ee99874c733bd030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a412833a097b050c8ee99874c733bd030">&#9670;&nbsp;</a></span>ColorText_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ColorText_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a>&#160;</td>
          <td class="paramname"><em>ctext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length in bytes needed to allocate a string (<code>char*</code>) built with <a class="el" href="colr_8c.html#ae305b33e0a44b956ccf4123aa4f1a033" title="Stringifies a ColorText struct, creating a mix of escape codes and text. ">ColorText_to_str()</a> with the current <code>text</code>, <code>fore</code>, <code>back</code>, and <code>style</code> members. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctext</td><td><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length (<code>size_t</code>) needed to allocate a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string, or <code>1</code> (size of an empty string) for invalid/empty arg types/values.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ac49c3a33d328ebaf2b0564d5a9b1d4ec">_colr_join_arrayn_size()</a>, <a class="el" href="colr_8h.html#ab0be451277fc7e39aee0aa409c9d3f0c">_colr_ptr_length()</a>, and <a class="el" href="colr_8h.html#ae305b33e0a44b956ccf4123aa4f1a033">ColorText_to_str()</a>.</p>

</div>
</div>
<a id="a65363a3601cd9cfcdc7fc40722d5d3c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65363a3601cd9cfcdc7fc40722d5d3c3">&#9670;&nbsp;</a></span>ColorText_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorText_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a>&#160;</td>
          <td class="paramname"><em>ctext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a string (<code>char*</code>) representation for a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctext</td><td><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to get the string representation for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Allocated string for the <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a30cac3017a6ea8c78277882554c9419f">_colr_ptr_repr()</a>.</p>

</div>
</div>
<a id="ab408d87cce896acccb75357acca8ade4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab408d87cce896acccb75357acca8ade4">&#9670;&nbsp;</a></span>ColorText_set_just()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorText">ColorText</a>* ColorText_set_just </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td>
          <td class="paramname"><em>ctext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a>&#160;</td>
          <td class="paramname"><em>cjust</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> method for a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, and return the <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>. </p>
<p>This is to facilitate the justification macros. If you already have a pointer to a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, you can just do <code>ctext-&gt;just = just;</code>. The purpose of this is to allow <code>ColorText_set_just(ColorText_to_ptr(...), ...)</code> to work.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ctext</td><td>The <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to set the justification method for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cjust</td><td>The <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> struct to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The same pointer that was given as <code>ctext</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

</div>
</div>
<a id="a880b39cd2ce9b622dbe7790a162d88f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a880b39cd2ce9b622dbe7790a162d88f7">&#9670;&nbsp;</a></span>ColorText_set_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ColorText_set_values </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td>
          <td class="paramname"><em>ctext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an existing <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> from 1 mandatory string (<code>char*</code>), and optional fore, back, and style args (pointers to ColorArgs). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ctext</td><td>A <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to initialize with values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>Text to colorize (a regular string). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>A <code>va_list</code> with ColorArgs pointers for fore, back, and style, in any order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An initialized <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> struct.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

</div>
</div>
<a id="a8e04de932a4cf712ac91e794bdc3f8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e04de932a4cf712ac91e794bdc3f8db">&#9670;&nbsp;</a></span>ColorText_to_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorText">ColorText</a>* ColorText_to_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a>&#160;</td>
          <td class="paramname"><em>ctext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> into allocated memory and returns the pointer. </p>
<p>You must free() the memory if you call this directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctext</td><td><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to copy/allocate for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">Pointer to a heap-allocated <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

</div>
</div>
<a id="ae305b33e0a44b956ccf4123aa4f1a033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae305b33e0a44b956ccf4123aa4f1a033">&#9670;&nbsp;</a></span>ColorText_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorText_to_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a>&#160;</td>
          <td class="paramname"><em>ctext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stringifies a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> struct, creating a mix of escape codes and text. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctext</td><td><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to stringify. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with text/escape-codes.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. If the <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> has a <code>NULL</code> <code>.text</code> member, <code>NULL</code> is returned. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>, <a class="el" href="colr_8h.html#a0d97f9b535a69642b926b38dce30b180">_colr_ptr_to_str()</a>, <a class="el" href="colr_8h.html#ad4c95a667cdcd05fd108ddf20b9a7328">ColorResult_Colr()</a>, <a class="el" href="colr_8h.html#a71fcf08ad36d4424790e275d973445fc">colr_join_arrayn()</a>, <a class="el" href="colr_8h.html#a34c359a48f811316d765b7abef1ea8f4">colr_printf_handler()</a>, <a class="el" href="colr_8h.html#a73789c11eaeb5a36b5f97556103a108d">colr_str_replace_all_ColorText()</a>, <a class="el" href="colr_8h.html#aaee8d79a90917974ee4537705e34fd76">colr_str_replace_ColorText()</a>, <a class="el" href="colr_8h.html#a747e31fa3d8961e0bdd11eabd673accc">colr_str_replace_re_all_ColorText()</a>, <a class="el" href="colr_8h.html#ab8d6a10f70b435559656bbad0090d92d">colr_str_replace_re_ColorText()</a>, <a class="el" href="colr_8h.html#a4d954398333472c1436f9bc051f46392">colr_str_replace_re_match_ColorText()</a>, <a class="el" href="colr_8h.html#aa4fe38cc205cbd49b2f8477744574294">colr_str_replace_re_matches_ColorText()</a>, <a class="el" href="colr_8h.html#ab9c4a5c34b26473dc45f93ce2c66faf1">colr_str_replace_re_pat_all_ColorText()</a>, and <a class="el" href="colr_8h.html#a6f8b04b6d851f26304183d1111b8f0dc">colr_str_replace_re_pat_ColorText()</a>.</p>

</div>
</div>
<a id="a29e3483ae4add048424177fdc2b97b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29e3483ae4add048424177fdc2b97b71">&#9670;&nbsp;</a></span>ColorType_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorType_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two ColorTypes. </p>
<p>This is used to implement <a class="el" href="colr_8h.html#a36af8aa0f01eaa780da182e856923faa" title="Calls the &lt;type&gt;_eq functions for the supported types. ">colr_eq()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first ColorType to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second ColorType to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if they are equal, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83" title="Color/Style code types. Used with ColorType_from_str() and ColorValue. ">ColorType</a> </dd></dl>

</div>
</div>
<a id="afa75deef059c002134a88dbbdc18fd49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa75deef059c002134a88dbbdc18fd49">&#9670;&nbsp;</a></span>ColorType_from_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> ColorType_from_str </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine which type of color value is desired by name. </p>
<p>Example:</p><ul>
<li>"red" == TYPE_BASIC</li>
<li>"253" == TYPE_EXTENDED</li>
<li>"123,55,67" == TYPE_RGB</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Color name to get the ColorType for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ColorType</td><td>value on success. </td></tr>
    <tr><td class="paramname">TYPE_INVALID</td><td>for invalid color names/strings. </td></tr>
    <tr><td class="paramname">TYPE_INVALID_EXT_RANGE</td><td>for ExtendedValues outside of 0-255. </td></tr>
    <tr><td class="paramname">TYPE_INVALID_RGB_RANGE</td><td>for rgb values outside of 0-255.</td></tr>
  </table>
  </dd>
</dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#ColorType_from_str-example" id="ColorType_from_str-example" class="diamond-bullet">&#160;</a> ColorType_from_str example: </div><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="colr_8h.html">colr.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div><div class="line">    <span class="keywordtype">char</span>* userarg;</div><div class="line">    <span class="keywordflow">if</span> (argc == 1) {</div><div class="line">        <span class="keywordflow">if</span> (asprintf(&amp;userarg, <span class="stringliteral">&quot;%s&quot;</span>, <span class="stringliteral">&quot;123,54,25&quot;</span>) &lt; 1) <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">        <span class="keywordflow">if</span> (asprintf(&amp;userarg, <span class="stringliteral">&quot;%s&quot;</span>,  argv[1]) &lt; 1) <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line">    <a class="code" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> type = <a class="code" href="colr_8c.html#afa75deef059c002134a88dbbdc18fd49">ColorType_from_str</a>(userarg);</div><div class="line">    <span class="keywordflow">if</span> (!<a class="code" href="colr_8c.html#adc223f6fda6296396e9ecddcc68d4aec">ColorType_is_invalid</a>(type)) {</div><div class="line">        <span class="keywordtype">char</span>* repr = <a class="code" href="colr_8h.html#ac1ef824dd213274fb239526269315543">colr_repr</a>(type);</div><div class="line">        printf(<span class="stringliteral">&quot;User passed in a %s, %s\n&quot;</span>, repr, userarg);</div><div class="line">        free(repr);</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">        printf(<span class="stringliteral">&quot;User passed in an invalid color name: %s\n&quot;</span>, userarg);</div><div class="line">    }</div><div class="line">    free(userarg);</div><div class="line">}</div></div><!-- fragment --> </div> <dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83" title="Color/Style code types. Used with ColorType_from_str() and ColorValue. ">ColorType</a> </dd></dl>

</div>
</div>
<a id="adc223f6fda6296396e9ecddcc68d4aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc223f6fda6296396e9ecddcc68d4aec">&#9670;&nbsp;</a></span>ColorType_is_invalid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorType_is_invalid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check to see if a ColorType value is considered invalid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ColorType value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is considered invalid, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83" title="Color/Style code types. Used with ColorType_from_str() and ColorValue. ">ColorType</a> </dd></dl>

</div>
</div>
<a id="a5a5883d43e3206584ad048908720afb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a5883d43e3206584ad048908720afb2">&#9670;&nbsp;</a></span>ColorType_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorType_is_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check to see if a ColorType value is considered valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ColorType value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is considered valid, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83" title="Color/Style code types. Used with ColorType_from_str() and ColorValue. ">ColorType</a> </dd></dl>

</div>
</div>
<a id="a291ca6d28f9f430794413b76b7b094ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a291ca6d28f9f430794413b76b7b094ed">&#9670;&nbsp;</a></span>ColorType_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorType_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation of a ColorType. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>A ColorType to get the type from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">A pointer to an allocated string.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83" title="Color/Style code types. Used with ColorType_from_str() and ColorValue. ">ColorType</a> </dd></dl>

</div>
</div>
<a id="acb73415f467b040d4b0f8f1ef5e95312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb73415f467b040d4b0f8f1ef5e95312">&#9670;&nbsp;</a></span>ColorType_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorType_to_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a human-friendly string (<code>char*</code>) representation for a ColorType. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>A ColorType to get the name for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83" title="Color/Style code types. Used with ColorType_from_str() and ColorValue. ">ColorType</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a89b5fc81980cbbfb425c7756eb8f0d0a">ColorValue_example()</a>.</p>

</div>
</div>
<a id="a5ce7c54ad0e31ecf6d790c5770c2b66b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce7c54ad0e31ecf6d790c5770c2b66b">&#9670;&nbsp;</a></span>ColorValue_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a> ColorValue_empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an "empty" <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>. </p>
<p>This is used with <a class="el" href="colr_8c.html#af838f8479681d809beb868b2e1b547e7" title="Create a ColorArg with ARGTYPE_NONE and ColorValue.type.TYPE_NONE. ">ColorArg_empty()</a> to build ColorArgs that don't do anything, where using <code>NULL</code> has a different meaning inside the <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a>, <a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465" title="Like colr_cat(), but returns an allocated ColorResult that the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros will automatically free(). ">Colr_cat()</a>, and <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> macros.</p>
<dl class="section return"><dt>Returns</dt><dd><code>(<a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>){.type=TYPE_NONE, .basic=0, .ext=0, .rgb=(<a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a>){0, 0, 0}}</code></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd>
<dd>
<a class="el" href="colr_8c.html#af838f8479681d809beb868b2e1b547e7" title="Create a ColorArg with ARGTYPE_NONE and ColorValue.type.TYPE_NONE. ">ColorArg_empty</a> </dd>
<dd>
<a class="el" href="colr_8c.html#a752355c2d96d35688d3756558f8421ba" title="Checks to see if a ColorArg is an empty placeholder. ">ColorArg_is_empty</a> </dd>
<dd>
<a class="el" href="colr_8c.html#a48005bb1589a7ebeef413ccee2a7c2a1" title="Checks to see if a ColorValue is an empty placeholder. ">ColorValue_is_empty</a> </dd></dl>

</div>
</div>
<a id="adf57e195301864cec80739e7e0f3000c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf57e195301864cec80739e7e0f3000c">&#9670;&nbsp;</a></span>ColorValue_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorValue_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> structs. </p>
<p>They are considered "equal" if all of their members match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if they are equal, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#acb62efc0182d6f6107055eeda961a628">ColorArg_eq()</a>.</p>

</div>
</div>
<a id="a89b5fc81980cbbfb425c7756eb8f0d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89b5fc81980cbbfb425c7756eb8f0d0a">&#9670;&nbsp;</a></span>ColorValue_example()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorValue_example </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a string (<code>char*</code>) representation of a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> with a human-friendly type/name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td>A <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to get an example string for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#aa54ab1879f6de8ca2fcb4702250741f5">ColorArg_example()</a>.</p>

</div>
</div>
<a id="af308e8dcd4a1d47a05736882d5a9698d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af308e8dcd4a1d47a05736882d5a9698d">&#9670;&nbsp;</a></span>ColorValue_from_esc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a> ColorValue_from_esc </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an escape-code string (<code>char*</code>) into a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">An escape-code string to parse.</p>
<p class="endtd"><em>Must be <code>null</code>-terminated</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> (with no fore/back information, only the color type and value). </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">For</td><td>invalid strings, the <code>.type</code> member can be one of:<ul>
<li>TYPE_INVALID</li>
<li>TYPE_INVALID_EXT_RANGE</li>
<li>TYPE_INVALID_RGB_RANGE</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd>
<dd>
<a class="el" href="colr_8c.html#a70e9640f37dd85cde0b6f25c0b705912" title="Parse an escape-code string (char*) into a ColorArg. ">ColorArg_from_esc</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a70e9640f37dd85cde0b6f25c0b705912">ColorArg_from_esc()</a>.</p>

</div>
</div>
<a id="a7c63f5f62e11d5f375a3824b12c80608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c63f5f62e11d5f375a3824b12c80608">&#9670;&nbsp;</a></span>ColorValue_from_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a> ColorValue_from_str </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> from a known color name, or <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> string (<code>char*</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>A string to parse the color name from (can be an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> string). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> (with no fore/back information, only the color type and value).</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">For</td><td>invalid strings, the <code>.type</code> member can be one of:<ul>
<li>TYPE_INVALID</li>
<li>TYPE_INVALID_EXT_RANGE</li>
<li>TYPE_INVALID_RGB_RANGE</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#aa62406b058b948941a8906475924536a">ColorArg_from_str()</a>.</p>

</div>
</div>
<a id="aca7fedbceb4f751d0d30034c0ef1dca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca7fedbceb4f751d0d30034c0ef1dca8">&#9670;&nbsp;</a></span>ColorValue_from_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a> ColorValue_from_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used with the color_val macro to dynamically create a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> based on it's argument type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>A ColorType value, to mark the type of <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A pointer to either a BasicValue, ExtendedValue, or a <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> struct with the appropriate <code>.type</code> member set for the value that was passed. For invalid types the <code>.type</code> member may be set to one of:<ul>
<li>TYPE_INVALID</li>
<li>TYPE_INVALID_EXT_RANGE</li>
<li>TYPE_INVALID_RGB_RANGE </li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#aad49f4597388e6bdb896ff28334cd5e6">ColorArg_from_BasicValue()</a>, <a class="el" href="colr_8h.html#aed30e2a4b30ab5e3cf49608a3c410cc5">ColorArg_from_ExtendedValue()</a>, <a class="el" href="colr_8h.html#aaa24bba74e99aa66ed41839576e57856">ColorArg_from_RGB()</a>, <a class="el" href="colr_8h.html#acf63bcee395dca3ca29dc324e3d7c8f2">ColorArg_from_StyleValue()</a>, <a class="el" href="colr_8h.html#af308e8dcd4a1d47a05736882d5a9698d">ColorValue_from_esc()</a>, and <a class="el" href="colr_8h.html#a7c63f5f62e11d5f375a3824b12c80608">ColorValue_from_str()</a>.</p>

</div>
</div>
<a id="a711a955406cde9716797bf61ab43a7a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a711a955406cde9716797bf61ab43a7a7">&#9670;&nbsp;</a></span>ColorValue_has_BasicValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorValue_has_BasicValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>bval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has a BasicValue set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bval</td><td>BasicValue to look for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has the exact BasicValue set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

</div>
</div>
<a id="a11dc047d1defc4de2239a45667b45f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11dc047d1defc4de2239a45667b45f85">&#9670;&nbsp;</a></span>ColorValue_has_ExtendedValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorValue_has_ExtendedValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>&#160;</td>
          <td class="paramname"><em>eval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has a ExtendedValue set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eval</td><td>ExtendedValue to look for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has the exact ExtendedValue set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

</div>
</div>
<a id="ab6908a961d4165a458be1aa64f082a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6908a961d4165a458be1aa64f082a45">&#9670;&nbsp;</a></span>ColorValue_has_RGB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorValue_has_RGB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has a <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value to look for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has the exact <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

</div>
</div>
<a id="a3fbfa502deb1f2bb920b74b9f4867fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fbfa502deb1f2bb920b74b9f4867fcf">&#9670;&nbsp;</a></span>ColorValue_has_StyleValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorValue_has_StyleValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>&#160;</td>
          <td class="paramname"><em>sval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has a StyleValue set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sval</td><td>StyleValue to look for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has the exact StyleValue set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

</div>
</div>
<a id="a48005bb1589a7ebeef413ccee2a7c2a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48005bb1589a7ebeef413ccee2a7c2a1">&#9670;&nbsp;</a></span>ColorValue_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorValue_is_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> is an empty placeholder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> is "empty", otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd>
<dd>
<a class="el" href="colr_8c.html#a5ce7c54ad0e31ecf6d790c5770c2b66b" title="Create an &quot;empty&quot; ColorValue. ">ColorValue_empty</a> </dd>
<dd>
<a class="el" href="colr_8c.html#af838f8479681d809beb868b2e1b547e7" title="Create a ColorArg with ARGTYPE_NONE and ColorValue.type.TYPE_NONE. ">ColorArg_empty</a> </dd>
<dd>
<a class="el" href="colr_8c.html#a752355c2d96d35688d3756558f8421ba" title="Checks to see if a ColorArg is an empty placeholder. ">ColorArg_is_empty</a> </dd></dl>

</div>
</div>
<a id="a22fcf30338eb777592421543885f74e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22fcf30338eb777592421543885f74e0">&#9670;&nbsp;</a></span>ColorValue_is_invalid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorValue_is_invalid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> holds an invalid value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> struct to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is invalid, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a70e9640f37dd85cde0b6f25c0b705912">ColorArg_from_esc()</a>.</p>

</div>
</div>
<a id="ac7183410b61d12a99dda3f76c2705497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7183410b61d12a99dda3f76c2705497">&#9670;&nbsp;</a></span>ColorValue_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorValue_is_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> holds a valid value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> struct to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is valid, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

</div>
</div>
<a id="af891527249f068cfcef057313c522a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af891527249f068cfcef057313c522a42">&#9670;&nbsp;</a></span>ColorValue_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ColorValue_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length in bytes needed to allocate a string (<code>char*</code>) built with <a class="el" href="colr_8c.html#ab62d1c5cc30bb9211de8b5321be5c3ee" title="Converts a ColorValue into an escape code string (char*). ">ColorValue_to_esc()</a> with the specified ArgType and <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ArgType (<code>FORE</code>, <code>BACK</code>, <code>STYLE</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length (<code>size_t</code>) needed to allocate a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>'s string, or <code>1</code> (size of an empty string) for invalid/empty arg types/values.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#adaff727006f4c057aab75e55bfb473c4">ColorArg_length()</a>.</p>

</div>
</div>
<a id="a95cf6ab7c565726eeb7c276d734193f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95cf6ab7c565726eeb7c276d734193f6">&#9670;&nbsp;</a></span>ColorValue_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorValue_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation of a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td>A <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to get the type and value from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">A pointer to an allocated string.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a5af692f2357d46b9cee45bb114f2a4a2">ColorArg_repr()</a>.</p>

</div>
</div>
<a id="ab62d1c5cc30bb9211de8b5321be5c3ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab62d1c5cc30bb9211de8b5321be5c3ee">&#9670;&nbsp;</a></span>ColorValue_to_esc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorValue_to_esc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> into an escape code string (<code>char*</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ArgType (FORE, BACK, STYLE) to build the escape code for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to get the color value from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the appropriate escape code. For invalid values, an empty string is returned.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ad1d3aaca5e543f8fefbd863a959c9d67">ColorArg_to_esc()</a>.</p>

</div>
</div>
<a id="aebcf95faa1465843b6510d534d0311a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebcf95faa1465843b6510d534d0311a0">&#9670;&nbsp;</a></span>ColorValue_to_esc_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorValue_to_esc_s </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> into an escape code string (<code>char*</code>) and fills the destination string. </p>
<p>For invalid ArgType/ColorValue combinations, <code>dest[0]</code> is set to `'\0'`.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>Destination string for the escape code string. <em>Must have room for the code type being used</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ArgType (FORE, BACK, STYLE) to build the escape code for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to get the color value from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a proper ArgType/ColorValue combination was used, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#abaf3d02ff1292f2aaa605522665ae564">ColorArg_to_esc_s()</a>.</p>

</div>
</div>
<a id="afc40c0187b5a18c21428e18434e8e0df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc40c0187b5a18c21428e18434e8e0df">&#9670;&nbsp;</a></span>colr_alloc_regmatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regmatch_t* colr_alloc_regmatch </td>
          <td>(</td>
          <td class="paramtype">regmatch_t&#160;</td>
          <td class="paramname"><em>match</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates space for a regmatch_t, initializes it, and returns a pointer to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">match</td><td>A <code>regmatch_t</code> to allocate for and copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated copy of the <code>regmatch_t</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a37cd9a8f2748629e68e9c41ffca557a9">colr_re_matches()</a>.</p>

</div>
</div>
<a id="a10030070daafdee7124638adfc5469d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10030070daafdee7124638adfc5469d8">&#9670;&nbsp;</a></span>colr_append_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void colr_append_reset </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends CODE_RESET_ALL to a string (<code>char*</code>), but makes sure to do it before any newlines. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">The string to append to. <em>Must have extra room for CODE_RESET_ALL</em>.</p>
<p class="endtd"><em>Must be <code>null</code>-terminated</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>, <a class="el" href="colr_8h.html#ab88ca919420f2df896b7973401641ab4">_rainbow()</a>, <a class="el" href="colr_8h.html#ae305b33e0a44b956ccf4123aa4f1a033">ColorText_to_str()</a>, and <a class="el" href="colr_8h.html#a71fcf08ad36d4424790e275d973445fc">colr_join_arrayn()</a>.</p>

</div>
</div>
<a id="a7f1ea562310969b7efa8711a843f103c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f1ea562310969b7efa8711a843f103c">&#9670;&nbsp;</a></span>colr_char_escape_char()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char colr_char_escape_char </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the char needed to represent an escape sequence in C. </p>
<p>The following characters are supported: </p><table class="doxtable">
<tr>
<th align="right">Escape Sequence </th><th align="left">Description Representation  </th></tr>
<tr>
<td align="right">\ ' </td><td align="left">single quote </td></tr>
<tr>
<td align="right">\ " </td><td align="left">double quote </td></tr>
<tr>
<td align="right">\ ? </td><td align="left">question mark </td></tr>
<tr>
<td align="right">\ \ </td><td align="left">backslash </td></tr>
<tr>
<td align="right">\ a </td><td align="left">audible bell </td></tr>
<tr>
<td align="right">\ b </td><td align="left">backspace </td></tr>
<tr>
<td align="right">\ f </td><td align="left">form feed - new page </td></tr>
<tr>
<td align="right">\ n </td><td align="left">line feed - new line </td></tr>
<tr>
<td align="right">\ r </td><td align="left">carriage return </td></tr>
<tr>
<td align="right">\ t </td><td align="left">horizontal tab </td></tr>
<tr>
<td align="right">\ v </td><td align="left">vertical tab </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The character to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The letter, without a backslash, needed to create an escape sequence. If the char doesn't need an escape sequence, it is simply returned.</dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_char_escape_char-example" id="colr_char_escape_char-example" class="diamond-bullet">&#160;</a> colr_char_escape_char example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span> constantchar = <a class="code" href="colr_8c.html#a7f1ea562310969b7efa8711a843f103c">colr_char_escape_char</a>(<span class="charliteral">&#39;\n&#39;</span>);</div><div class="line">assert(constantchar == <span class="charliteral">&#39;n&#39;</span>);</div><div class="line"></div><div class="line"><span class="keywordtype">char</span> constantquote = <a class="code" href="colr_8c.html#a7f1ea562310969b7efa8711a843f103c">colr_char_escape_char</a>(<span class="charliteral">&#39;&quot;&#39;</span>);</div><div class="line">assert(constantquote == <span class="charliteral">&#39;&quot;&#39;</span>);</div><div class="line"></div><div class="line"><span class="comment">// The actual escape sequence would need the backslash added to it:</span></div><div class="line"><span class="keywordtype">char</span>* escaped;</div><div class="line">asprintf(&amp;escaped, <span class="stringliteral">&quot;\\%c&quot;</span>, <a class="code" href="colr_8c.html#a7f1ea562310969b7efa8711a843f103c">colr_char_escape_char</a>(<span class="charliteral">&#39;\t&#39;</span>));</div><div class="line">free(escaped);</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a196ad91a69cfbeb27a5266ffc93ed353">colr_str_repr()</a>.</p>

</div>
</div>
<a id="a38331775450608b94c5ecfeec28f9363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38331775450608b94c5ecfeec28f9363">&#9670;&nbsp;</a></span>colr_char_in_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_char_in_str </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a character exists in the given string (<code>char*</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Character to search for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">String to check.</p>
<p class="endtd">Input <em>must be <code>null</code>-terminated</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>c</code> is found in <code>s</code>, otherwise <code>false</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a566857db0f22ad4a1ba17ee3a56cf174">colr_str_chars_lcount()</a>, and <a class="el" href="colr_8h.html#af502be785bdb221c2dc1a47fece1fc5f">colr_str_lstrip_chars()</a>.</p>

</div>
</div>
<a id="ab4fed7123927027262875834964b0a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4fed7123927027262875834964b0a94">&#9670;&nbsp;</a></span>colr_char_is_code_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_char_is_code_end </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a character is suitable for an escape code ending. </p>
<p><code>m</code> is used as the last character in color codes, but other characters can be used for escape sequences (such as "\x1b[2A", cursor up). Actual escape code endings can be in the range (<code>char</code>) 64-126 (inclusive).</p>
<p>Since ColrC only deals with color codes and maybe some cursor/erase codes, this function tests if the character is either <code>A-Z</code> or <code>a-z</code>.</p>
<p>For more information, see: <a href="https://en.wikipedia.org/wiki/ANSI_escape_code">https://en.wikipedia.org/wiki/ANSI_escape_code</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Character to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the character is a possible escape code ending, otherwise <code>false</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#afa991b64a363bd5e6f1a722ed0759338">colr_str_code_count()</a>, <a class="el" href="colr_8h.html#ab6fa8ad1635fcff75ee1213a975dba4d">colr_str_code_len()</a>, <a class="el" href="colr_8h.html#a6292cbb8bd9f3d19bb0bd05a4d7b0bea">colr_str_get_codes()</a>, <a class="el" href="colr_8h.html#a85b2971301b5247769b08f5ed08564fb">colr_str_is_codes()</a>, <a class="el" href="colr_8h.html#a037a0245a39d7ff5cfba5f779d0eb251">colr_str_noncode_len()</a>, and <a class="el" href="colr_8h.html#ab0b13b04dc178d0990ab2ae403ee64e0">colr_str_strip_codes()</a>.</p>

</div>
</div>
<a id="af78a98cb101d4d5f18df0023b3109013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af78a98cb101d4d5f18df0023b3109013">&#9670;&nbsp;</a></span>colr_char_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_char_repr </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation for a char. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Value to create the representation for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a6c35f6b47cc737744487d14d20241656">ColorJustify_repr()</a>.</p>

</div>
</div>
<a id="a67ef4700a46e78c2bed1132428a610fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ef4700a46e78c2bed1132428a610fb">&#9670;&nbsp;</a></span>colr_char_should_escape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_char_should_escape </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if an ascii character has an escape sequence in C. </p>
<p>The following characters are supported: </p><table class="doxtable">
<tr>
<th align="right">Escape Sequence </th><th align="left">Description Representation  </th></tr>
<tr>
<td align="right">\ ' </td><td align="left">single quote </td></tr>
<tr>
<td align="right">\ " </td><td align="left">double quote </td></tr>
<tr>
<td align="right">\ ? </td><td align="left">question mark </td></tr>
<tr>
<td align="right">\ \ </td><td align="left">backslash </td></tr>
<tr>
<td align="right">\ a </td><td align="left">audible bell </td></tr>
<tr>
<td align="right">\ b </td><td align="left">backspace </td></tr>
<tr>
<td align="right">\ f </td><td align="left">form feed - new page </td></tr>
<tr>
<td align="right">\ n </td><td align="left">line feed - new line </td></tr>
<tr>
<td align="right">\ r </td><td align="left">carriage return </td></tr>
<tr>
<td align="right">\ t </td><td align="left">horizontal tab </td></tr>
<tr>
<td align="right">\ v </td><td align="left">vertical tab </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The character to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the character needs an escape sequence, otherwise <code>false</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a196ad91a69cfbeb27a5266ffc93ed353">colr_str_repr()</a>.</p>

</div>
</div>
<a id="adfe470aae91128e4529563c90c214e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfe470aae91128e4529563c90c214e3a">&#9670;&nbsp;</a></span>colr_check_marker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_check_marker </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>marker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks an unsigned int against the individual bytes behind a pointer's value. </p>
<p>This helps to guard against overflows, because only a single byte is checked at a time. If any byte doesn't match the marker, <code>false</code> is immediately returned, instead of continuing past the pointer's bounds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">marker</td><td>A colr marker, like COLORARG_MARKER, COLORTEXT_MARKER, etc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A pointer to check, to see if it starts with the marker. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all bytes match the marker, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#ad15f3a714a6383123d3fb24ade173e29" title="Checks a void pointer to see if it contains a ColorArg struct. ">ColorArg_is_ptr</a> </dd>
<dd>
<a class="el" href="colr_8c.html#a1d6eb8832110b943c3a3a17627a50288" title="Checks a void pointer to see if it contains a ColorText struct. ">ColorText_is_ptr</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_check_marker-example" id="colr_check_marker-example" class="diamond-bullet">&#160;</a> colr_check_marker example: </div><div class="fragment"><div class="line"><span class="comment">// This is actually used with void pointer, where the type is not known.</span></div><div class="line"><span class="comment">// It&#39;s only known that the pointer will be 1 of 3 types.</span></div><div class="line"><a class="code" href="colr_8h.html#structColorArg">ColorArg</a>* cargp = <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(GREEN);</div><div class="line">assert(<a class="code" href="colr_8c.html#adfe470aae91128e4529563c90c214e3a">colr_check_marker</a>(<a class="code" href="colr_8h.html#a22fa09afcaf087080075551d293a72fd">COLORARG_MARKER</a>, cargp));</div><div class="line"><a class="code" href="colr_8h.html#a76eae619668e01987653932a7492fd94">colr_free</a>(cargp);</div><div class="line"></div><div class="line"><span class="keywordtype">char</span>* s = <span class="stringliteral">&quot;Not a ColorText at all.&quot;</span>;</div><div class="line">assert(!<a class="code" href="colr_8c.html#adfe470aae91128e4529563c90c214e3a">colr_check_marker</a>(<a class="code" href="colr_8h.html#afc3756a551f1f8e5dfb56f6ab41d9e07">COLORTEXT_MARKER</a>, s));</div><div class="line"></div><div class="line"><a class="code" href="colr_8h.html#structColorText">ColorText</a>* ctextp = <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;But this is a ColorText.&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(GREEN));</div><div class="line">assert(<a class="code" href="colr_8c.html#adfe470aae91128e4529563c90c214e3a">colr_check_marker</a>(<a class="code" href="colr_8h.html#afc3756a551f1f8e5dfb56f6ab41d9e07">COLORTEXT_MARKER</a>, ctextp));</div><div class="line"><a class="code" href="colr_8h.html#a76eae619668e01987653932a7492fd94">colr_free</a>(ctextp);</div><div class="line"></div><div class="line">printf(<span class="stringliteral">&quot;colr_check_marker() assertions held up.\n&quot;</span>);</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#af64af11f4992c8143cb722772df98c98">_colr_is_last_arg()</a>, <a class="el" href="colr_8h.html#ad15f3a714a6383123d3fb24ade173e29">ColorArg_is_ptr()</a>, <a class="el" href="colr_8h.html#afd5fe635f26119c3a341b5dfe23abc97">ColorResult_is_ptr()</a>, and <a class="el" href="colr_8h.html#a1d6eb8832110b943c3a3a17627a50288">ColorText_is_ptr()</a>.</p>

</div>
</div>
<a id="a8963c87ccb1c39bdd4481bb81810ba78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8963c87ccb1c39bdd4481bb81810ba78">&#9670;&nbsp;</a></span>colr_empty_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_empty_str </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates an empty string (<code>char*</code>). </p>
<p>This is for keeping the interface simple, so the return values from color functions with invalid values can be consistent.</p>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">Pointer to an allocated string consisting of '\0'.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a1a8345393e635e1c5e148473bdce292d">colr_str_center()</a>, <a class="el" href="colr_8h.html#a5eedebae47b5d22dda709f833f23a256">colr_str_ljust()</a>, <a class="el" href="colr_8h.html#a2fbc36f0f7aba3aa0616437f937efd20">colr_str_replace_re_match()</a>, <a class="el" href="colr_8h.html#acc75e3bf729168f9ac204ef0a1708d46">colr_str_rjust()</a>, and <a class="el" href="colr_8h.html#ab0b13b04dc178d0990ab2ae403ee64e0">colr_str_strip_codes()</a>.</p>

</div>
</div>
<a id="a008af1b6ab6db4d4dd98033471506f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a008af1b6ab6db4d4dd98033471506f1e">&#9670;&nbsp;</a></span>Colr_fmt_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a>* Colr_fmt_str </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and format a string like <code>asprintf</code>, but wrap it in an allocated <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>. </p>
<p>This is declared with <code>__attribute__((__format__(__printf__, 1, 2)))</code> so the compiler can check for bad format strings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>Format string for <code>asprintf</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Other arguments for <code>asprintf</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, or <code>NULL</code> if <code>fmt</code> is <code>NULL</code>.</p>
<p><em>If allocation fails, <code>NULL</code> is returned</em>.</p>
<p class="enddd">If used inside of the <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a>, <a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465" title="Like colr_cat(), but returns an allocated ColorResult that the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros will automatically free(). ">Colr_cat()</a>, and <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> macros, <em>they will <code>free()</code> the result</em>. Otherwise, <em>you are responsible for calling <code>free()</code></em>. </p>
</dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#Colr_fmt_str-example" id="Colr_fmt_str-example" class="diamond-bullet">&#160;</a> Colr_fmt_str example: </div><div class="fragment"><div class="line"><span class="keywordtype">int</span> i = 2600;</div><div class="line"><span class="keywordtype">double</span> d = 1.337;</div><div class="line"><a class="code" href="colr_8h.html#af050c0377cbd1960fa057dc160da3c34">colr_puts</a>(<a class="code" href="colr_8c.html#a008af1b6ab6db4d4dd98033471506f1e">Colr_fmt_str</a>(<span class="stringliteral">&quot;&lt;%d&gt; &lt;%0.3f&gt;&quot;</span>, i, d));</div></div><!-- fragment --> </div> 
</div>
</div>
<a id="a197b7f21254d1729f30193905f8e237c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a197b7f21254d1729f30193905f8e237c">&#9670;&nbsp;</a></span>colr_free_argsv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void colr_free_argsv </td>
          <td>(</td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free any ColrC objects (<a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointer) passed in through a <code>va_list</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>The <code>va_list</code> with ColrC objects (<a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointer). The last argument must be <code>_ColrLastArg</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ad4c95a667cdcd05fd108ddf20b9a7328">ColorResult_Colr()</a>.</p>

</div>
</div>
<a id="a67e72a18762c87886173dd0a0dc37887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67e72a18762c87886173dd0a0dc37887">&#9670;&nbsp;</a></span>colr_free_re_matches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void colr_free_re_matches </td>
          <td>(</td>
          <td class="paramtype">regmatch_t **&#160;</td>
          <td class="paramname"><em>matches</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free an array of allocated <code>regmatch_t</code>, like the return from <a class="el" href="colr_8c.html#a37cd9a8f2748629e68e9c41ffca557a9" title="Returns all regmatch_t matches for regex pattern in a string (char*). ">colr_re_matches()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">matches</td><td>A pointer to an array of <code>regmatch_t</code> pointers. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#afd19623913d27e2d9a5af3496a478c2b">colr_str_replace_re_pat_all()</a>.</p>

</div>
</div>
<a id="a18e06ee5b32cd583c71ecff7d6c18270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e06ee5b32cd583c71ecff7d6c18270">&#9670;&nbsp;</a></span>colr_is_colr_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_is_colr_ptr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a void pointer is a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A pointer to a possible ColrC object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>p</code> is a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointer, otherwise <code>false</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a197b7f21254d1729f30193905f8e237c">colr_free_argsv()</a>.</p>

</div>
</div>
<a id="a701126bd27c90fafa46152d9f9327b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a701126bd27c90fafa46152d9f9327b2f">&#9670;&nbsp;</a></span>colr_join_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_join_array </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>joinerp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join an array of strings (<code>char*</code>), <code><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a></code>s, or <code><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a></code>s by another string (<code>char*</code>), <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">joinerp</td><td>The joiner (any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, or string (<code>char*</code>)). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ps</td><td>An array of pointers to <code><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a></code>s, <code><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a></code>s, or strings (<code>char*</code>). The array must have <code>NULL</code> as the last item. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_join_array-example" id="colr_join_array-example" class="diamond-bullet">&#160;</a> colr_join_array example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* joiner = <span class="stringliteral">&quot; [and] &quot;</span>;</div><div class="line"><a class="code" href="colr_8h.html#structColorText">ColorText</a>* words[] = {</div><div class="line">    <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;this&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED)),</div><div class="line">    <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;that&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(<a class="code" href="colr_8h.html#a8fe812f8e76e4baed394ee9adf46b3df">hex</a>(<span class="stringliteral">&quot;ff3599&quot;</span>))),</div><div class="line">    <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;the other&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(BLUE), <a class="code" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662">style</a>(UNDERLINE)),</div><div class="line">    NULL</div><div class="line">};</div><div class="line"><span class="keywordtype">char</span>* s = <a class="code" href="colr_8c.html#a701126bd27c90fafa46152d9f9327b2f">colr_join_array</a>(joiner, words);</div><div class="line"><span class="keywordflow">if</span> (!s) exit(1);</div><div class="line">printf(<span class="stringliteral">&quot;%s\n&quot;</span>, s);</div><div class="line">free(s);</div><div class="line"></div><div class="line"><span class="comment">// Don&#39;t forget to free the ColorTexts/ColorArgs.</span></div><div class="line"><span class="keywordtype">size_t</span> i = 0;</div><div class="line"><span class="keywordflow">while</span> (words[i]) <a class="code" href="colr_8c.html#a901e5738358a739629cc3aaccab3e73f">ColorText_free</a>(words[i++]);</div></div><!-- fragment --> </div> <dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a753093cd4c872eed4b77feaa7816212b" title="Create an allocated string directly from Colr() arguments. ">colr</a> </dd>
<dd>
<a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join</a> </dd>
<dd>
<a class="el" href="colr_8c.html#a71fcf08ad36d4424790e275d973445fc" title="Join an array of strings (char*), ColorArgs, or ColorTexts by another string (char*), ColorArg, or ColorText. ">colr_join_arrayn</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="colr_join_example_8c-example.html#a10">colr_join_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="a71fcf08ad36d4424790e275d973445fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71fcf08ad36d4424790e275d973445fc">&#9670;&nbsp;</a></span>colr_join_arrayn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_join_arrayn </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>joinerp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join an array of strings (<code>char*</code>), <code><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a></code>s, or <code><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a></code>s by another string (<code>char*</code>), <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">joinerp</td><td>The joiner (any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, or string (<code>char*</code>)). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ps</td><td>An array of pointers to <code><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a></code>s, <code><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a></code>s, or strings (<code>char*</code>). The array must have at least a length of <code>count</code>, unless a <code>NULL</code> element is placed at the end. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The total number of items in the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. If any parameter is <code>NULL</code>, <code>NULL</code> is returned. </p>
</dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_join_arrayn-example" id="colr_join_arrayn-example" class="diamond-bullet">&#160;</a> colr_join_arrayn example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* joiner = <span class="stringliteral">&quot; [and] &quot;</span>;</div><div class="line"><a class="code" href="colr_8h.html#structColorText">ColorText</a>* words[] = {</div><div class="line">    <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;this&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED)),</div><div class="line">    <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;that&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(<a class="code" href="colr_8h.html#a8fe812f8e76e4baed394ee9adf46b3df">hex</a>(<span class="stringliteral">&quot;ff3599&quot;</span>))),</div><div class="line">    <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;the other&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(BLUE), <a class="code" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662">style</a>(UNDERLINE))</div><div class="line">};</div><div class="line"><span class="comment">// This only works for actual arrays, not malloc&#39;d stuff.</span></div><div class="line"><span class="keywordtype">size_t</span> arr_length = <span class="keyword">sizeof</span>(words) / <span class="keyword">sizeof</span>(words[0]);</div><div class="line"><span class="keywordtype">char</span>* s = <a class="code" href="colr_8c.html#a71fcf08ad36d4424790e275d973445fc">colr_join_arrayn</a>(joiner, words, arr_length);</div><div class="line"><span class="keywordflow">if</span> (!s) exit(1);</div><div class="line">printf(<span class="stringliteral">&quot;%s\n&quot;</span>, s);</div><div class="line">free(s);</div><div class="line"></div><div class="line"><span class="comment">// Don&#39;t forget to free the ColorTexts/ColorArgs.</span></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; arr_length; i++) <a class="code" href="colr_8c.html#a901e5738358a739629cc3aaccab3e73f">ColorText_free</a>(words[i]);</div></div><!-- fragment --> </div> <dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a753093cd4c872eed4b77feaa7816212b" title="Create an allocated string directly from Colr() arguments. ">colr</a> </dd>
<dd>
<a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a701126bd27c90fafa46152d9f9327b2f">colr_join_array()</a>.</p>

</div>
</div>
<a id="ade675256d9e88682d4bebdcc4a57f86f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade675256d9e88682d4bebdcc4a57f86f">&#9670;&nbsp;</a></span>colr_mb_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t colr_mb_len </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <code>mbrlen</code>, except it will return the length of the next N (<code>length</code>) multibyte characters in bytes. </p>
<p>/details Unlike <a class="el" href="colr_8c.html#ab473f70278850994e1b7b9c8008353fa" title="Returns the number of characters in a string (char*), taking into account possibly multibyte characte...">colr_str_mb_len()</a>, which returns the number of multibyte characters, this function will return the number of bytes that make up the next number (<code>length</code>) of multibyte characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Number of multibyte characters to get the length for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes parsed in <code>s</code> to get at least <code>length</code> multibyte characters. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if <code>s</code> is <code>NULL</code>/empty, or <code>length</code> is <code>0</code>. </td></tr>
    <tr><td class="paramname">(size_t)-1</td><td>if an invalid multibyte sequence is found at the start of <code>s</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#ab473f70278850994e1b7b9c8008353fa" title="Returns the number of characters in a string (char*), taking into account possibly multibyte characte...">colr_str_mb_len</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a9b95dc82c67a2ec94053e207b0b87594" title="Checks return values from mbrlen() and colr_mb_len(). ">colr_is_valid_mblen</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_mb_len-example" id="colr_mb_len-example" class="diamond-bullet">&#160;</a> colr_mb_len example: </div><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="colr_8h.html">colr.h</a>&quot;</span></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div><div class="line">    <span class="comment">// There are 4 multibyte characters in the string.</span></div><div class="line">    <span class="comment">// There are multiple bytes making up each character, probably 3 each,</span></div><div class="line">    <span class="comment">// which makes the byte-length 12.</span></div><div class="line">    <span class="keywordtype">char</span>* s = <span class="stringliteral">&quot;&quot;</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Calling colr_mb_len(s, 1) is like calling mbrlen().</span></div><div class="line">    <span class="keywordtype">size_t</span> first_len = <a class="code" href="colr_8c.html#ade675256d9e88682d4bebdcc4a57f86f">colr_mb_len</a>(s, 1);</div><div class="line">    mbstate_t st;</div><div class="line">    memset(&amp;st, 0, <span class="keyword">sizeof</span>(mbstate_t));</div><div class="line">    assert(first_len == (<span class="keywordtype">size_t</span>)mbrlen(s, MB_LEN_MAX, &amp;st));</div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> first_two_len = <a class="code" href="colr_8c.html#ade675256d9e88682d4bebdcc4a57f86f">colr_mb_len</a>(s, 2);</div><div class="line">    <span class="comment">// This assertion doesn&#39;t hold for ALL characters, but it should hold</span></div><div class="line">    <span class="comment">// for these, because they are all FULLWIDTH DIGIT chars.</span></div><div class="line">    assert(first_two_len == (first_len * 2));</div><div class="line"></div><div class="line">    <span class="comment">// Skip about 6 bytes, to get past the first 2</span></div><div class="line">    <span class="keywordtype">char</span>* skip2 = s + first_two_len;</div><div class="line">    assert(strcmp(skip2, <span class="stringliteral">&quot;&quot;</span>) == 0);</div><div class="line"></div><div class="line">    <span class="comment">// There are only about 7 bytes (6 + 1 for the null).</span></div><div class="line">    <span class="comment">// Calling colr_mb_len with a `length` that is too large is okay.</span></div><div class="line">    <span class="keywordtype">size_t</span> length = <a class="code" href="colr_8c.html#ade675256d9e88682d4bebdcc4a57f86f">colr_mb_len</a>(skip2, 100);</div><div class="line">    assert(length == strlen(skip2));</div><div class="line">    <span class="keywordtype">size_t</span> charlength = <a class="code" href="colr_8c.html#ab473f70278850994e1b7b9c8008353fa">colr_str_mb_len</a>(skip2);</div><div class="line">    printf(<span class="stringliteral">&quot;\&quot;%s\&quot; contains %lu bytes for %lu chars.\n&quot;</span>, skip2, length, charlength);</div><div class="line"></div><div class="line">    <span class="comment">// This should always hold true, even though it is useless:</span></div><div class="line">    assert(<a class="code" href="colr_8c.html#ade675256d9e88682d4bebdcc4a57f86f">colr_mb_len</a>(s, strlen(s)) == strlen(s));</div><div class="line"></div><div class="line">}</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#ab88ca919420f2df896b7973401641ab4">_rainbow()</a>.</p>

</div>
</div>
<a id="a34c359a48f811316d765b7abef1ea8f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34c359a48f811316d765b7abef1ea8f4">&#9670;&nbsp;</a></span>colr_printf_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int colr_printf_handler </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct printf_info *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *const *&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles printing with printf for Colr objects. </p>
<p>This function matches the required <code>typedef</code> in <code>printf.h</code> (<code>printf_function</code>), for handling a custom printf format char with <code>register_printf_specifier</code>.</p>
<dl class="section attention"><dt>Attention</dt><dd>This feature uses a GNU extension, and is only available when COLR_GNU is defined. See the documentation for COLR_GNU.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fp</td><td>FILE pointer for output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">info</td><td>Info from printf about how to format the argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Argument list (with only 1 argument), containing a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, or string (<code>char*</code>) to format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters written. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#aaaf134ca9a2188d83171fe91948354d9">colr_printf_register()</a>.</p>

</div>
</div>
<a id="a95619a7f5eeb0158dfb969ae9a26a6bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95619a7f5eeb0158dfb969ae9a26a6bb">&#9670;&nbsp;</a></span>colr_printf_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int colr_printf_info </td>
          <td>(</td>
          <td class="paramtype">const struct printf_info *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>argtypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles the arg count/size for the Colr printf handler. </p>
<p>This function matches the required <code>typedef</code> in <code>printf.h</code> (<code>printf_arginfo_size_function</code>) for handling a custom printf format char with <code>register_printf_specifier</code>.</p>
<dl class="section attention"><dt>Attention</dt><dd>This feature uses a GNU extension, and is only available when COLR_GNU is defined. See the documentation for COLR_GNU.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">info</td><td>Info from printf about how to format the argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of arguments for the format char. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">argtypes</td><td>Type of arguments being handled, from an <code>enum</code> defined in <code>printf</code>. Colr uses/sets one argument, a <code>PA_POINTER</code> type. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sz</td><td>Size of the arguments. Not used in Colr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of argument types set in <code>argtypes</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#aaaf134ca9a2188d83171fe91948354d9">colr_printf_register()</a>.</p>

</div>
</div>
<a id="aaaf134ca9a2188d83171fe91948354d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf134ca9a2188d83171fe91948354d9">&#9670;&nbsp;</a></span>colr_printf_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void colr_printf_register </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers COLR_FMT_CHAR to handle Colr objects in the printf-family functions. </p>
<p>This function only needs to be called once and <code>register_printf_specifier</code> is only called the first time this function is called.</p>
<dl class="section attention"><dt>Attention</dt><dd>This feature uses a GNU extension, and is only available when COLR_GNU is defined. See the documentation for COLR_GNU.</dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_printf_register-example" id="colr_printf_register-example" class="diamond-bullet">&#160;</a> colr_printf_register example: </div><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="colr_8h.html">colr.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="comment">// These are needed if you have certain warnings enabled.</span></div><div class="line"><span class="preprocessor">#pragma clang diagnostic ignored &quot;-Winvalid-format-specifier&quot;</span></div><div class="line"><span class="preprocessor">#pragma GCC diagnostic ignored &quot;-Wformat=&quot;</span></div><div class="line"><span class="preprocessor">#pragma GCC diagnostic ignored &quot;-Wformat-extra-args&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div><div class="line">    <a class="code" href="colr_8c.html#aaaf134ca9a2188d83171fe91948354d9">colr_printf_register</a>();</div><div class="line">    printf(<span class="stringliteral">&quot;A colr object: %R\n&quot;</span>, <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;Hello&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED)));</div><div class="line"></div><div class="line">    <span class="keywordtype">char</span>* colorized = NULL;</div><div class="line">    asprintf(</div><div class="line">        &amp;colorized,</div><div class="line">        <span class="stringliteral">&quot;I made this: %R&quot;</span>,</div><div class="line">        <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;No, I made this.&quot;</span>, <a class="code" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662">style</a>(UNDERLINE))</div><div class="line">    );</div><div class="line">    puts(colorized);</div><div class="line">    free(colorized);</div><div class="line">}</div></div><!-- fragment --> </div> 
</div>
</div>
<a id="a37cd9a8f2748629e68e9c41ffca557a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37cd9a8f2748629e68e9c41ffca557a9">&#9670;&nbsp;</a></span>colr_re_matches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regmatch_t** colr_re_matches </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">regex_t *&#160;</td>
          <td class="paramname"><em>repattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all <code>regmatch_t</code> matches for regex pattern in a string (<code>char*</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repattern</td><td>The pattern to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">A pointer to an allocated array of <code>regmatch_t*</code>, or <code>NULL</code> if <code>s</code> is <code>NULL</code> or <code>repattern</code> is <code>NULL</code>. The last member is always <code>NULL</code>.</p>
<p class="enddd"><em>You must <code>free()</code> the memory allocated by this function.</em> </p>
</dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_re_matches-example" id="colr_re_matches-example" class="diamond-bullet">&#160;</a> colr_re_matches example: </div><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="colr_8h.html">colr.h</a>&quot;</span></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div><div class="line">    <span class="comment">// Compile a regex pattern.</span></div><div class="line">    regex_t pat;</div><div class="line">    <span class="keywordflow">if</span> (regcomp(&amp;pat, <span class="stringliteral">&quot;foo&quot;</span>, 0)) {</div><div class="line">        regfree(&amp;pat);</div><div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line">    <span class="comment">// The string to operate on.</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* s = <span class="stringliteral">&quot;This foo is a foo string, foo?&quot;</span>;</div><div class="line">    <span class="comment">// Get all matches.</span></div><div class="line">    regmatch_t** matches = <a class="code" href="colr_8c.html#a37cd9a8f2748629e68e9c41ffca557a9">colr_re_matches</a>(s, &amp;pat);</div><div class="line">    <span class="keywordflow">if</span> (!matches) {</div><div class="line">        <span class="comment">// This should be impossible (for this example).</span></div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;No matches?\n&quot;</span>);</div><div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line">    puts(s);</div><div class="line">    <span class="comment">// `colr_re_matches` always leaves `NULL` as the last member.</span></div><div class="line">    <span class="keywordtype">size_t</span> cnt = 0;</div><div class="line">    <span class="keywordflow">while</span> (matches[cnt]) {</div><div class="line">        printf(<span class="stringliteral">&quot;Found a match at: %d-%d\n&quot;</span>, matches[cnt]-&gt;rm_so, matches[cnt]-&gt;rm_eo);</div><div class="line">        cnt++;</div><div class="line">    }</div><div class="line">    <span class="comment">// Free all of your resources.</span></div><div class="line">    <a class="code" href="colr_8h.html#a76eae619668e01987653932a7492fd94">colr_free</a>(matches);</div><div class="line">    regfree(&amp;pat);</div><div class="line">}</div></div><!-- fragment --> </div> <dl><dt><b>Examples: </b></dt><dd><a class="el" href="colr_replace_all_example_8c-example.html#a6">colr_replace_all_example.c</a>.</dd>
</dl>
<p class="reference">Referenced by <a class="el" href="colr_8h.html#afd19623913d27e2d9a5af3496a478c2b">colr_str_replace_re_pat_all()</a>.</p>

</div>
</div>
<a id="a180c1ac4711df9fb025639c966f84727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a180c1ac4711df9fb025639c966f84727">&#9670;&nbsp;</a></span>colr_set_locale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_set_locale </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the locale to <code>(LC_ALL, "")</code> if it hasn't already been set. </p>
<p>This is used for functions dealing with multibyte strings.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the locale had to be set, <code>false</code> if it was already set. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ade675256d9e88682d4bebdcc4a57f86f">colr_mb_len()</a>, and <a class="el" href="colr_8h.html#ab473f70278850994e1b7b9c8008353fa">colr_str_mb_len()</a>.</p>

</div>
</div>
<a id="a1b98f363fb0873cfb7e60e99191647a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b98f363fb0873cfb7e60e99191647a6">&#9670;&nbsp;</a></span>colr_str_array_contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_str_array_contains </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>lst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a string (<code>char*</code>) is in an array of strings (<code>char**</code>, where the last element is <code>NULL</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lst</td><td>The string array to look in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the string is found, otherwise <code>false</code>. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&lt;tt&gt;false&lt;/tt&gt;</td><td>if <code>lst</code> is <code>NULL</code> or <code>s</code> is <code>NULL</code>.</td></tr>
  </table>
  </dd>
</dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_array_contains-example" id="colr_str_array_contains-example" class="diamond-bullet">&#160;</a> colr_str_array_contains example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* strarray[] = {</div><div class="line">    <span class="stringliteral">&quot;this&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;that&quot;</span>,</div><div class="line">    NULL</div><div class="line">};</div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="colr_8c.html#a1b98f363fb0873cfb7e60e99191647a6">colr_str_array_contains</a>(strarray, <span class="stringliteral">&quot;that&quot;</span>)) {</div><div class="line">    printf(<span class="stringliteral">&quot;List contained \&quot;that\&quot;.\n&quot;</span>);</div><div class="line">}</div><div class="line"><span class="keywordflow">if</span> (!<a class="code" href="colr_8c.html#a1b98f363fb0873cfb7e60e99191647a6">colr_str_array_contains</a>(strarray, <span class="stringliteral">&quot;NONEXISTENT&quot;</span>)) {</div><div class="line">    printf(<span class="stringliteral">&quot;List did not contain \&quot;NONEXISTENT\&quot;.\n&quot;</span>);</div><div class="line">}</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a6292cbb8bd9f3d19bb0bd05a4d7b0bea">colr_str_get_codes()</a>.</p>

</div>
</div>
<a id="a90384ff3082ad86bf5eb0923ac9a644a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90384ff3082ad86bf5eb0923ac9a644a">&#9670;&nbsp;</a></span>colr_str_array_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void colr_str_array_free </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free an allocated array of strings, including the array itself. </p>
<p>Each individual string will be released, and finally the allocated memory for the array of pointers will be released.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ps</td><td>A pointer to an array of strings.</td></tr>
  </table>
  </dd>
</dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_array_free-example" id="colr_str_array_free-example" class="diamond-bullet">&#160;</a> colr_str_array_free example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* s = <a class="code" href="colr_8h.html#a753093cd4c872eed4b77feaa7816212b">colr</a>(<span class="stringliteral">&quot;Test&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED), <a class="code" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8">back</a>(WHITE), <a class="code" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662">style</a>(BRIGHT));</div><div class="line"><span class="keywordflow">if</span> (!s) exit(1);</div><div class="line"><span class="comment">// Call something that creates an array of strings on the heap.</span></div><div class="line"><span class="keywordtype">char</span>** code_array = <a class="code" href="colr_8c.html#a6292cbb8bd9f3d19bb0bd05a4d7b0bea">colr_str_get_codes</a>(s, <span class="keyword">false</span>);</div><div class="line">free(s);</div><div class="line"><span class="keywordflow">if</span> (!code_array) exit(1);</div><div class="line"><span class="comment">// ... do something with the array of strings.</span></div><div class="line"></div><div class="line"><span class="comment">// And then free it:</span></div><div class="line"><a class="code" href="colr_8c.html#a90384ff3082ad86bf5eb0923ac9a644a">colr_str_array_free</a>(code_array);</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a4897abe50811762a84ee409c0c2d300f">ColorArgs_from_str()</a>.</p>

</div>
</div>
<a id="a1a8345393e635e1c5e148473bdce292d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a8345393e635e1c5e148473bdce292d">&#9670;&nbsp;</a></span>colr_str_center()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_center </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>padchar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Center-justifies a string (<code>char*</code>), ignoring escape codes when measuring the width. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">The string to justify.</p>
<p class="endtd">Input <em>must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The overall width for the resulting string. If set to '0', the terminal width will be used from <a class="el" href="colr_8c.html#ae4c11bb5b3b1bb2848bb16aee39763b2" title="Attempts to retrieve the row/column size of the terminal and returns a TermSize. ">colr_term_size()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">padchar</td><td>The character to pad with. If '0', then `' '` is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#a5eedebae47b5d22dda709f833f23a256" title="Left-justifies a string (char*), ignoring escape codes when measuring the width. ">colr_str_ljust</a> </dd>
<dd>
<a class="el" href="colr_8c.html#acc75e3bf729168f9ac204ef0a1708d46" title="Right-justifies a string (char*), ignoring escape codes when measuring the width. ...">colr_str_rjust</a> </dd>
<dd>
<a class="el" href="colr_8c.html#ae4c11bb5b3b1bb2848bb16aee39763b2" title="Attempts to retrieve the row/column size of the terminal and returns a TermSize. ">colr_term_size</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_center-example" id="colr_str_center-example" class="diamond-bullet">&#160;</a> colr_str_center example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* colorized = <a class="code" href="colr_8h.html#a753093cd4c872eed4b77feaa7816212b">colr</a>(<span class="stringliteral">&quot;This.&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED), <a class="code" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8">back</a>(WHITE));</div><div class="line"><span class="keywordtype">char</span>* justified = <a class="code" href="colr_8c.html#a1a8345393e635e1c5e148473bdce292d">colr_str_center</a>(colorized, 9, <span class="charliteral">&#39; &#39;</span>);</div><div class="line">free(colorized);</div><div class="line"><span class="comment">// The string still has codes, but only 4 spaces were added.</span></div><div class="line">assert(<a class="code" href="colr_8c.html#ac23328cead6a65d7b3ef2c2ca48d11ce">colr_str_starts_with</a>(justified, <span class="stringliteral">&quot;  &quot;</span>));</div><div class="line">assert(<a class="code" href="colr_8c.html#a7dd712bd8253271f0c88158db791c8bf">colr_str_ends_with</a>(justified, <span class="stringliteral">&quot;  &quot;</span>));</div><div class="line"><span class="comment">// It was &quot;justified&quot; to 9 characters long, but it is well over that.</span></div><div class="line">assert(strlen(justified) &gt; 9);</div><div class="line">printf(<span class="stringliteral">&quot;&#39;%s&#39;\n&quot;</span>, justified);</div><div class="line">free(justified);</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a34c359a48f811316d765b7abef1ea8f4">colr_printf_handler()</a>.</p>

</div>
</div>
<a id="ad5e3ecc4a6c4bcaad1217df9200d271e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e3ecc4a6c4bcaad1217df9200d271e">&#9670;&nbsp;</a></span>colr_str_char_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t colr_str_char_count </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of characters (<code>c</code>) that are found in a string (<code>char*</code>) (<code>s</code>). </p>
<p>Returns <code>0</code> if <code>s</code> is <code>NULL</code>, or <code>c</code> is `'\0'`.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">The string to examine.</p>
<p class="endtd"><em>Must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td><p class="starttd">The character to count.</p>
<p class="endtd"><em>Must not be <code>0</code></em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of times <code>c</code> occurs in <code>s</code>.</dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_char_count-example" id="colr_str_char_count-example" class="diamond-bullet">&#160;</a> colr_str_char_count example: </div><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> ps = <a class="code" href="colr_8c.html#ad5e3ecc4a6c4bcaad1217df9200d271e">colr_str_char_count</a>(<span class="stringliteral">&quot;apple&quot;</span>, <span class="charliteral">&#39;p&#39;</span>);</div><div class="line">assert(ps == 2);</div><div class="line">printf(<span class="stringliteral">&quot;Found %lu &#39;p&#39; characters.\n&quot;</span>, ps)</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#ab88ca919420f2df896b7973401641ab4">_rainbow()</a>.</p>

</div>
</div>
<a id="ae479b42d955b24cc1ddf572b9282a624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae479b42d955b24cc1ddf572b9282a624">&#9670;&nbsp;</a></span>colr_str_char_lcount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t colr_str_char_lcount </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of characters (<code>c</code>) that are found at the beginning of a string (<code>char*</code>) (<code>s</code>). </p>
<p>Returns <code>0</code> if <code>s</code> is <code>NULL</code>, <code>c</code> is `'\0'`, or the string doesn't start with <code>c</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">The string to examine.</p>
<p class="endtd"><em>Must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td><p class="starttd">The character to count.</p>
<p class="endtd"><em>Must not be <code>0</code></em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of times <code>c</code> occurs at the start of <code>s</code>.</dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_char_lcount-example" id="colr_str_char_lcount-example" class="diamond-bullet">&#160;</a> colr_str_char_lcount example: </div><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> xs = <a class="code" href="colr_8c.html#ae479b42d955b24cc1ddf572b9282a624">colr_str_char_lcount</a>(<span class="stringliteral">&quot;xxApple&quot;</span>, <span class="charliteral">&#39;x&#39;</span>);</div><div class="line">assert(xs == 2);</div><div class="line">printf(<span class="stringliteral">&quot;Found %lu &#39;x&#39; characters.\n&quot;</span>, xs)</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a060dc0f80eade56563d6942339c2859e">colr_str_lstrip_char()</a>.</p>

</div>
</div>
<a id="a566857db0f22ad4a1ba17ee3a56cf174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a566857db0f22ad4a1ba17ee3a56cf174">&#9670;&nbsp;</a></span>colr_str_chars_lcount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t colr_str_chars_lcount </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>chars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of characters that are found at the beginning of a string (<code>char*</code>) (<code>s</code>), where the character can be any of <code>chars</code>. </p>
<p>Returns <code>0</code> if <code>s</code> is <code>NULL</code>/empty, <code>chars</code> is <code>NULL</code>/empty, or the string doesn't start with any of the characters in <code>chars</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">The string to examine.</p>
<p class="endtd"><em>Must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">chars</td><td><p class="starttd">The characters to count, in any order.</p>
<p class="endtd"><em>Must not be <code>0</code></em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of times a character in <code>chars</code> occurs at the start of <code>s</code>.</dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_chars_lcount-example" id="colr_str_chars_lcount-example" class="diamond-bullet">&#160;</a> colr_str_chars_lcount example: </div><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> chars = <a class="code" href="colr_8c.html#a566857db0f22ad4a1ba17ee3a56cf174">colr_str_chars_lcount</a>(<span class="stringliteral">&quot;cbaabcbbccApple&quot;</span>, <span class="stringliteral">&quot;abc&quot;</span>);</div><div class="line">assert(chars == 10);</div><div class="line">printf(<span class="stringliteral">&quot;Found %lu &#39;a&#39;, &#39;b&#39;, or &#39;c&#39; characters.\n&quot;</span>, chars)</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#af502be785bdb221c2dc1a47fece1fc5f">colr_str_lstrip_chars()</a>.</p>

</div>
</div>
<a id="afa991b64a363bd5e6f1a722ed0759338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa991b64a363bd5e6f1a722ed0759338">&#9670;&nbsp;</a></span>colr_str_code_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t colr_str_code_count </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of escape-codes in a string (<code>char*</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">A string to count the escape-codes for.</p>
<p class="endtd"><em>Must be <code>null</code>-terminated</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of escape-codes, or <code>0</code> if <code>s</code> is <code>NULL</code>, or doesn't contain any escape-codes.</dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_code_count-example" id="colr_str_code_count-example" class="diamond-bullet">&#160;</a> colr_str_code_count example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* s = <a class="code" href="colr_8h.html#a753093cd4c872eed4b77feaa7816212b">colr</a>(<span class="stringliteral">&quot;Testing this out.&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED), <a class="code" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8">back</a>(WHITE));</div><div class="line"><span class="keywordflow">if</span> (!s) exit(1);</div><div class="line"><span class="keywordtype">size_t</span> code_cnt = <a class="code" href="colr_8c.html#afa991b64a363bd5e6f1a722ed0759338">colr_str_code_count</a>(s);</div><div class="line">assert(code_cnt == 3); <span class="comment">// The reset code is also appended.</span></div><div class="line">printf(<span class="stringliteral">&quot;Found codes: %zu\n&quot;</span>, code_cnt);</div><div class="line">free(s);</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a6292cbb8bd9f3d19bb0bd05a4d7b0bea">colr_str_get_codes()</a>.</p>

</div>
</div>
<a id="ab6fa8ad1635fcff75ee1213a975dba4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6fa8ad1635fcff75ee1213a975dba4d">&#9670;&nbsp;</a></span>colr_str_code_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t colr_str_code_len </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of bytes that make up all the escape-codes in a string (<code>char*</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">A string to count the code-chars for.</p>
<p class="endtd"><em>Must be <code>null</code>-terminated</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of escape-code characters, or <code>0</code> if <code>s</code> is <code>NULL</code>, or doesn't contain any escape-codes.</dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_code_len-example" id="colr_str_code_len-example" class="diamond-bullet">&#160;</a> colr_str_code_len example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* s = <a class="code" href="colr_8h.html#a753093cd4c872eed4b77feaa7816212b">colr</a>(<span class="stringliteral">&quot;Testing this out.&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED), <a class="code" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8">back</a>(WHITE));</div><div class="line"><span class="keywordflow">if</span> (!s) exit(1);</div><div class="line"><span class="keywordtype">size_t</span> code_len = <a class="code" href="colr_8c.html#ab6fa8ad1635fcff75ee1213a975dba4d">colr_str_code_len</a>(s);</div><div class="line">assert(code_len == 14); <span class="comment">// The reset code is also appended.</span></div><div class="line">printf(<span class="stringliteral">&quot;Found code chars: %zu\n&quot;</span>, code_len);</div><div class="line">free(s);</div></div><!-- fragment --> </div> 
</div>
</div>
<a id="a4fb3c15e839f5c16d3e7cd001d32aee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fb3c15e839f5c16d3e7cd001d32aee6">&#9670;&nbsp;</a></span>colr_str_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_copy </td>
          <td>(</td>
          <td class="paramtype">char *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a string (<code>char*</code>) like strncpy, but ensures null-termination. </p>
<p>If <code>src</code> is <code>NULL</code>, or <code>dest</code> is <code>NULL</code>, <code>NULL</code> is returned.</p>
<p>If <code>src</code> does not contain a null-terminator, <em>this function will truncate at <code>length</code> characters</em>.</p>
<p>If <code>src</code> is an empty string, then <code>dest[0]</code> will be `'\0'` (an empty string).</p>
<p>A null-terminator is always appended to <code>dest</code>.</p>
<p><code>src</code> and <code>dest</code> must not overlap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>Memory allocated for new string. <em>Must have room for <code>strlen(src) + 1</code> or <code>length + 1</code></em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source string to copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Maximum characters to copy. <em>This does not include the null-terminator</em>. Usually set to <code>strlen(dest)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a pointer to dest is returned.</dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_copy-example" id="colr_str_copy-example" class="diamond-bullet">&#160;</a> colr_str_copy example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* s = <span class="stringliteral">&quot;testing&quot;</span>;</div><div class="line"><span class="keywordtype">size_t</span> length = strlen(s);</div><div class="line"><span class="keywordtype">char</span>* dest = malloc(length + 1);</div><div class="line"></div><div class="line"><span class="comment">// Copy the entire string:</span></div><div class="line"><a class="code" href="colr_8c.html#a4fb3c15e839f5c16d3e7cd001d32aee6">colr_str_copy</a>(dest, s, length);</div><div class="line">assert(strcmp(dest, <span class="stringliteral">&quot;testing&quot;</span>) == 0);</div><div class="line">printf(<span class="stringliteral">&quot;Copied: %s\n&quot;</span>, dest);</div><div class="line"></div><div class="line"><span class="comment">// Copy only 4 bytes:</span></div><div class="line"><a class="code" href="colr_8c.html#a4fb3c15e839f5c16d3e7cd001d32aee6">colr_str_copy</a>(dest, s, 4);</div><div class="line">assert(strcmp(dest, <span class="stringliteral">&quot;test&quot;</span>) == 0);</div><div class="line">printf(<span class="stringliteral">&quot;Truncated: %s\n&quot;</span>, dest);</div><div class="line"></div><div class="line"><span class="comment">// String gets truncated when dest is too small:</span></div><div class="line"><a class="code" href="colr_8c.html#a4fb3c15e839f5c16d3e7cd001d32aee6">colr_str_copy</a>(dest, <span class="stringliteral">&quot;this is too long.&quot;</span>, length);</div><div class="line">assert(strcmp(dest, <span class="stringliteral">&quot;this is&quot;</span>) == 0);</div><div class="line">assert(dest[length] == <span class="charliteral">&#39;\0&#39;</span>);</div><div class="line">printf(<span class="stringliteral">&quot;Truncated: %s\n&quot;</span>, dest);</div><div class="line">free(dest);</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a91d92286745806229c0369c20edf641c">ColorResult_from_stra()</a>.</p>

</div>
</div>
<a id="a7dd712bd8253271f0c88158db791c8bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd712bd8253271f0c88158db791c8bf">&#9670;&nbsp;</a></span>colr_str_ends_with()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_str_ends_with </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if one string (<code>char*</code>) ends with another. </p>
<p><code>str</code> and <code>suffix</code> must not overlap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">String to check.</p>
<p class="endtd"><em>Must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">suffix</td><td><p class="starttd">Suffix to check for.</p>
<p class="endtd"><em>Must be <code>null</code>-terminated</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <code>str</code> ends with <code>suffix</code>. </dd>
<dd>
False if either is NULL, or the string doesn't end with the suffix. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a10030070daafdee7124638adfc5469d8">colr_append_reset()</a>.</p>

</div>
</div>
<a id="a6292cbb8bd9f3d19bb0bd05a4d7b0bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6292cbb8bd9f3d19bb0bd05a4d7b0bea">&#9670;&nbsp;</a></span>colr_str_get_codes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** colr_str_get_codes </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unique</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an array of escape-codes from a string (<code>char*</code>). </p>
<p>This function copies the escape-code strings, and the pointers to the heap, if any escape-codes are found in the string.</p>
<p><a class="el" href="colr_8c.html#a90384ff3082ad86bf5eb0923ac9a644a" title="Free an allocated array of strings, including the array itself. ">colr_str_array_free()</a> can be used to easily <code>free()</code> the result of this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">A string to get the escape-codes from.</p>
<p class="endtd"><em>Must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unique</td><td>Whether to only include <em>unique</em> escape codes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated array of string (<code>char*</code>) pointers, where the last element is <code>NULL</code>.</p>
<p class="enddd"><em>You must <code>free()</code> the memory allocated by this function.</em> </p>
</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">If</td><td><code>s</code> is <code>NULL</code>, or empty, or there are otherwise no escape-codes found in the string, or allocation fails for the strings/array, then <code>NULL</code> is returned. </td></tr>
    <tr><td class="paramname">On</td><td>success, there will be at least two pointers behind the return value. The last pointer is always <code>NULL</code>.</td></tr>
  </table>
  </dd>
</dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_get_codes-example" id="colr_str_get_codes-example" class="diamond-bullet">&#160;</a> colr_str_get_codes example: </div><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="colr_8h.html">colr.h</a>&quot;</span></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div><div class="line">    <span class="keywordtype">char</span>* s = <a class="code" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa">colr_cat</a>(</div><div class="line">        <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;Testing this out.&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED), <a class="code" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8">back</a>(WHITE)),</div><div class="line">        <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;Again.&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED), <a class="code" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662">style</a>(UNDERLINE))</div><div class="line">    );</div><div class="line">    <span class="keywordflow">if</span> (!s) <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    <span class="keywordtype">char</span>** code_array = <a class="code" href="colr_8c.html#a6292cbb8bd9f3d19bb0bd05a4d7b0bea">colr_str_get_codes</a>(s, <span class="keyword">false</span>);</div><div class="line">    free(s);</div><div class="line">    <span class="keywordflow">if</span> (!code_array) {</div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;No code found? Impossible!\n&quot;</span>);</div><div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line">    <span class="comment">// Iterate over the code array.</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; code_array[i]; i++) {</div><div class="line">        <span class="keywordtype">char</span>* code_repr = <a class="code" href="colr_8h.html#ac1ef824dd213274fb239526269315543">colr_repr</a>(code_array[i]);</div><div class="line">        printf(<span class="stringliteral">&quot;Found code: %s\n&quot;</span>, code_repr);</div><div class="line">        free(code_repr);</div><div class="line">    }</div><div class="line">    <span class="comment">// Free the strings, and the array of pointers.</span></div><div class="line">    <a class="code" href="colr_8c.html#a90384ff3082ad86bf5eb0923ac9a644a">colr_str_array_free</a>(code_array);</div><div class="line">}</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a4897abe50811762a84ee409c0c2d300f">ColorArgs_from_str()</a>.</p>

</div>
</div>
<a id="a8b9f4cbe1e806316e063206dfb610476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b9f4cbe1e806316e063206dfb610476">&#9670;&nbsp;</a></span>colr_str_has_codes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_str_has_codes </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a string (<code>char*</code>) has ANSI escape codes in it. </p>
<p>This will detect any ansi escape code, not just colors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">The string to check. Can be <code>NULL</code>.</p>
<p class="endtd">Input <em>must be <code>null</code>-terminated</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the string has at least one escape code, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#a85b2971301b5247769b08f5ed08564fb" title="Determines if a string (char*) is composed entirely of escape codes. ">colr_str_is_codes</a> </dd></dl>

</div>
</div>
<a id="a39f8caf33e6befb9b78958f5d24911ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39f8caf33e6befb9b78958f5d24911ff">&#9670;&nbsp;</a></span>colr_str_has_ColorArg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_str_has_ColorArg </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *&#160;</td>
          <td class="paramname"><em>carg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a string contains a specific color code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">carg</td><td>The <a class="el" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f" title="Create a fore color suitable for use with the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros. ">fore()</a>, <a class="el" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8" title="Create a back color suitable for use with the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros. ">back()</a>, or <a class="el" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662" title="Create a style suitable for use with the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros. ">style()</a> <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to check for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the string contains the escape codes formed by the <code>ColorArg*</code> given, otherwise <code>false</code>. If <code>s</code> is <code>NULL</code>/empty, or <code>carg</code> is <code>NULL</code>/empty, this will return <code>false</code>. </dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_has_ColorArg-example" id="colr_str_has_ColorArg-example" class="diamond-bullet">&#160;</a> colr_str_has_ColorArg example: </div><div class="fragment"><div class="line"><a class="code" href="colr_8h.html#structColorArg">ColorArg</a>* forered = <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED);</div><div class="line"><span class="keywordtype">char</span>* s = <a class="code" href="colr_8h.html#a753093cd4c872eed4b77feaa7816212b">colr</a>(<span class="stringliteral">&quot;Testing&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED));</div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="colr_8c.html#a39f8caf33e6befb9b78958f5d24911ff">colr_str_has_ColorArg</a>(s, forered)) {</div><div class="line">    puts(<span class="stringliteral">&quot;Yep, there&#39;s a fore:red in there.&quot;</span>);</div><div class="line">} <span class="keywordflow">else</span> {</div><div class="line">    puts(<span class="stringliteral">&quot;Hmmm...no red?&quot;</span>);</div><div class="line">}</div><div class="line"><span class="comment">// That ColorArg was allocated, free() it.</span></div><div class="line"><a class="code" href="colr_8h.html#a76eae619668e01987653932a7492fd94">colr_free</a>(forered);</div><div class="line"></div><div class="line"><a class="code" href="colr_8h.html#structColorArg">ColorArg</a>* backblue = <a class="code" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8">back</a>(BLUE);</div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="colr_8c.html#a39f8caf33e6befb9b78958f5d24911ff">colr_str_has_ColorArg</a>(s, backblue)) {</div><div class="line">    fprintf(stderr, <span class="stringliteral">&quot;Illegal back:blue found in a red string!\n&quot;</span>);</div><div class="line">}</div><div class="line"><span class="comment">// Free this one too.</span></div><div class="line"><span class="comment">// If it was used inside of a colr/Colr macro call, we wouldn&#39;t have to do this.</span></div><div class="line"><a class="code" href="colr_8h.html#a76eae619668e01987653932a7492fd94">colr_free</a>(backblue);</div><div class="line"></div><div class="line"><span class="comment">// Free the string we created to test with.</span></div><div class="line">free(s);</div></div><!-- fragment --> </div> 
</div>
</div>
<a id="adf5a3149704b14b85a0236d9940fb4e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf5a3149704b14b85a0236d9940fb4e7">&#9670;&nbsp;</a></span>colr_str_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ColrHash colr_str_hash </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hash a string using <a href="http://www.cse.yorku.ca/~oz/hash.html">djb2</a>. </p>
<p>This is only used for simple, short, string (<code>char*</code>) hashing. It is not designed for cryptography.</p>
<p>There are some notes about collision rates for this function <a href="https://softwareengineering.stackexchange.com/a/145633">here</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">The string to hash.</p>
<p class="endtd"><em>Must be <code>null</code>-terminated</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A ColrHash (<code>unsigned long</code>) value with the hash. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if <code>s</code> is <code>NULL</code>. </td></tr>
    <tr><td class="paramname">COLR_HASH_SEED</td><td>if <code>s</code> is an empty string.</td></tr>
  </table>
  </dd>
</dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_hash-example" id="colr_str_hash-example" class="diamond-bullet">&#160;</a> colr_str_hash example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* strings[] = {</div><div class="line">    <span class="stringliteral">&quot;fore&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;back&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;style&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;invalid&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;red&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;\x1b[4m&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;\x1b[0m&quot;</span></div><div class="line">};</div><div class="line"><span class="keywordtype">size_t</span> strings_len = <span class="keyword">sizeof</span>(strings) / <span class="keyword">sizeof</span>(strings[0]);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; strings_len; i++) {</div><div class="line">    ColrHash hashval = <a class="code" href="colr_8c.html#adf5a3149704b14b85a0236d9940fb4e7">colr_str_hash</a>(strings[i]);</div><div class="line">    printf(<span class="stringliteral">&quot;%8s: hash=%lu\n&quot;</span>, strings[i], hashval);</div><div class="line">}</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a1b98f363fb0873cfb7e60e99191647a6">colr_str_array_contains()</a>.</p>

</div>
</div>
<a id="a3dc3f370843b64e92fb7d79e7989b5c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc3f370843b64e92fb7d79e7989b5c3">&#9670;&nbsp;</a></span>colr_str_is_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_str_is_all </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a string (<code>char*</code>) consists of only one character, possibly repeated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>String to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Character to test for. Must not be <code>0</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>s</code> contains only the character <code>c</code>, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a85b2971301b5247769b08f5ed08564fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b2971301b5247769b08f5ed08564fb">&#9670;&nbsp;</a></span>colr_str_is_codes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_str_is_codes </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a string (<code>char*</code>) is composed entirely of escape codes. </p>
<p>Returns <code>false</code> if the string is <code>NULL</code>, or empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">The string to check.</p>
<p class="endtd">Input <em>must be <code>null</code>-terminated</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the string is escape-codes only, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#a8b9f4cbe1e806316e063206dfb610476" title="Determines if a string (char*) has ANSI escape codes in it. ">colr_str_has_codes</a> </dd></dl>

</div>
</div>
<a id="af5492da225ade4fd8fe71989826348b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5492da225ade4fd8fe71989826348b4">&#9670;&nbsp;</a></span>colr_str_is_digits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_str_is_digits </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether all characters in a string (<code>char*</code>) are digits. </p>
<p>If <code>s</code> is NULL or an empty string (<code>""</code>), <code>false</code> is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">String to check.</p>
<p class="endtd">Input <em>must be <code>null</code>-terminated</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all characters are digits (0-9), otherwise <code>false</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a2e859d542a8aa0939e4f76b1f33cb5f8">ExtendedValue_from_str()</a>.</p>

</div>
</div>
<a id="a5eedebae47b5d22dda709f833f23a256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eedebae47b5d22dda709f833f23a256">&#9670;&nbsp;</a></span>colr_str_ljust()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_ljust </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>padchar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left-justifies a string (<code>char*</code>), ignoring escape codes when measuring the width. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">The string to justify.</p>
<p class="endtd">Input <em>must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The overall width for the resulting string. If set to '0', the terminal width will be used from <a class="el" href="colr_8c.html#ae4c11bb5b3b1bb2848bb16aee39763b2" title="Attempts to retrieve the row/column size of the terminal and returns a TermSize. ">colr_term_size()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">padchar</td><td>The character to pad with. If '0', then `' '` is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#a1a8345393e635e1c5e148473bdce292d" title="Center-justifies a string (char*), ignoring escape codes when measuring the width. ">colr_str_center</a> </dd>
<dd>
<a class="el" href="colr_8c.html#acc75e3bf729168f9ac204ef0a1708d46" title="Right-justifies a string (char*), ignoring escape codes when measuring the width. ...">colr_str_rjust</a> </dd>
<dd>
<a class="el" href="colr_8c.html#ae4c11bb5b3b1bb2848bb16aee39763b2" title="Attempts to retrieve the row/column size of the terminal and returns a TermSize. ">colr_term_size</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_ljust-example" id="colr_str_ljust-example" class="diamond-bullet">&#160;</a> colr_str_ljust example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* colorized = <a class="code" href="colr_8h.html#a753093cd4c872eed4b77feaa7816212b">colr</a>(<span class="stringliteral">&quot;This.&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED), <a class="code" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8">back</a>(WHITE));</div><div class="line"><span class="keywordtype">char</span>* justified = <a class="code" href="colr_8c.html#a5eedebae47b5d22dda709f833f23a256">colr_str_ljust</a>(colorized, 8, <span class="charliteral">&#39; &#39;</span>);</div><div class="line">free(colorized);</div><div class="line"><span class="comment">// The string still has codes, but only 3 spaces were added.</span></div><div class="line">assert(<a class="code" href="colr_8c.html#a7dd712bd8253271f0c88158db791c8bf">colr_str_ends_with</a>(justified, <span class="stringliteral">&quot;   &quot;</span>));</div><div class="line"><span class="comment">// It was &quot;justified&quot; to 8 characters long, but it is well over that.</span></div><div class="line">assert(strlen(justified) &gt; 8);</div><div class="line">printf(<span class="stringliteral">&quot;&#39;%s&#39;\n&quot;</span>, justified);</div><div class="line">free(justified);</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a34c359a48f811316d765b7abef1ea8f4">colr_printf_handler()</a>.</p>

</div>
</div>
<a id="a116ec26960e79456dbf9cf7f40ffe0d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116ec26960e79456dbf9cf7f40ffe0d7">&#9670;&nbsp;</a></span>colr_str_lower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void colr_str_lower </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a string (<code>char*</code>) into lower case in place. </p>
<p>Input <em>must be <code>null</code>-terminated</em>.</p>
<p>If <code>s</code> is <code>NULL</code>, nothing is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The input string to convert to lower case. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35ffd3ec364c8d0c0e96a0723b7aa46f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35ffd3ec364c8d0c0e96a0723b7aa46f">&#9670;&nbsp;</a></span>colr_str_lstrip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t colr_str_lstrip </td>
          <td>(</td>
          <td class="paramtype">char *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Strip a leading character from a string (<code>char*</code>), filling another string (<code>char*</code>) with the result. </p>
<p><code>dest</code> and <code>s</code> should not overlap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>Destination <code>char</code> array. Must have room for <code>strlen(s) + 1</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>String to strip the character from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of <code>s</code>, the input string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Character to strip. If set to <code>0</code>, all whitespace characters will be used (' ', '\n', '\t', '\v', '\f', '\r'). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of <code>c</code> characters removed. May return <code>0</code> if <code>s</code> is <code>NULL</code>/empty, <code>dest</code> is <code>NULL</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a060dc0f80eade56563d6942339c2859e">colr_str_lstrip_char()</a>, and <a class="el" href="colr_8h.html#ad33884dcde034819c5e6749667247194">RGB_from_hex()</a>.</p>

</div>
</div>
<a id="a060dc0f80eade56563d6942339c2859e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a060dc0f80eade56563d6942339c2859e">&#9670;&nbsp;</a></span>colr_str_lstrip_char()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_lstrip_char </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Strips a leading character from a string (<code>char*</code>), and allocates a new string with the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>String to strip the character from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Character to strip. If set to <code>0</code>, all whitespace characters will be used (' ', '\n', '\t'). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result. May return <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>

</div>
</div>
<a id="af502be785bdb221c2dc1a47fece1fc5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af502be785bdb221c2dc1a47fece1fc5f">&#9670;&nbsp;</a></span>colr_str_lstrip_chars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_lstrip_chars </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>chars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes certain characters from the start of a string (<code>char*</code>) and allocates a new string with the result. </p>
<p>The order of the characters in <code>chars</code> does not matter. If any of them are found at the start of a string, they will be removed.</p>
<p><code>colr_str_lstrip_chars("aabbccTEST", "bca") == "TEST"</code></p>
<p><code>s</code> and <code>chars</code> must not overlap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to strip. <code>s</code> <em>Must be <code>null</code>-terminated</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">chars</td><td>A string of characters to remove. Each will be removed from the start of the string. <code>chars</code> <em>Must be <code>null</code>-terminated</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result. May return NULL if <code>s</code> or <code>chars</code> is NULL.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>

</div>
</div>
<a id="ab473f70278850994e1b7b9c8008353fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab473f70278850994e1b7b9c8008353fa">&#9670;&nbsp;</a></span>colr_str_mb_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t colr_str_mb_len </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of characters in a string (<code>char*</code>), taking into account possibly multibyte characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to get the length of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters, single and multibyte, or <code>0</code> if <code>s</code> is <code>NULL</code>, empty, or has invalid multibyte sequences.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#ade675256d9e88682d4bebdcc4a57f86f" title="Like mbrlen, except it will return the length of the next N (length) multibyte characters in bytes...">colr_mb_len</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_mb_len-example" id="colr_str_mb_len-example" class="diamond-bullet">&#160;</a> colr_str_mb_len example: </div><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="colr_8h.html">colr.h</a>&quot;</span></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div><div class="line">    <span class="keywordtype">char</span>* s = <span class="stringliteral">&quot;&quot;</span>;</div><div class="line">    <span class="comment">// There are 4 multibyte characters in the string.</span></div><div class="line">    assert(<a class="code" href="colr_8c.html#ab473f70278850994e1b7b9c8008353fa">colr_str_mb_len</a>(s) == 4);</div><div class="line">    <span class="comment">// There are multiple bytes making up each characters, probably 3 each,</span></div><div class="line">    <span class="comment">// which makes the byte-length 12.</span></div><div class="line">    assert(strlen(s) &gt; 4);</div><div class="line">}</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#ab88ca919420f2df896b7973401641ab4">_rainbow()</a>.</p>

</div>
</div>
<a id="a037a0245a39d7ff5cfba5f779d0eb251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037a0245a39d7ff5cfba5f779d0eb251">&#9670;&nbsp;</a></span>colr_str_noncode_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t colr_str_noncode_len </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length of string (<code>char*</code>), ignoring escape codes and the the null-terminator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">String to get the length for.</p>
<p class="endtd">Input <em>must be <code>null</code>-terminated</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the string, as if it didn't contain escape codes. For non-escape-code strings, this is like <code>strlen()</code>. For <code>NULL</code> or "empty" strings, <code>0</code> is returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#ab0b13b04dc178d0990ab2ae403ee64e0" title="Strips escape codes from a string (char*), resulting in a new allocated string. ">colr_str_strip_codes</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a412833a097b050c8ee99874c733bd030">ColorText_length()</a>, <a class="el" href="colr_8h.html#a1a8345393e635e1c5e148473bdce292d">colr_str_center()</a>, <a class="el" href="colr_8h.html#a5eedebae47b5d22dda709f833f23a256">colr_str_ljust()</a>, and <a class="el" href="colr_8h.html#acc75e3bf729168f9ac204ef0a1708d46">colr_str_rjust()</a>.</p>

</div>
</div>
<a id="a2144034980aea6427fbc9bdf70e5b8c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2144034980aea6427fbc9bdf70e5b8c3">&#9670;&nbsp;</a></span>colr_str_replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the first substring found in a string (<code>char*</code>). </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string (""), which removes the <code>target</code> string from <code>s</code>.</p>
<p>For a more dynamic version, see the colr_replace and colr_replace_re macros.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>The string to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The string to replace with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, or <code>target</code> is <code>NULL</code>/empty.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_replace-example" id="colr_str_replace-example" class="diamond-bullet">&#160;</a> colr_str_replace example: </div><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="colr_8h.html">colr.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div><div class="line">    <span class="keywordtype">char</span>* mystring = <span class="stringliteral">&quot;This is a foo foo foo line.&quot;</span>;</div><div class="line">    <span class="keywordtype">char</span>* replaced = <a class="code" href="colr_8c.html#a420403f3115f43c5e6356deee5644e84">colr_str_replace_cnt</a>(mystring, <span class="stringliteral">&quot;foo&quot;</span>, <span class="stringliteral">&quot;replaced&quot;</span>, 2);</div><div class="line">    <span class="keywordflow">if</span> (!replaced) {</div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;Failed to allocate for new string!\n&quot;</span>);</div><div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line">    printf(<span class="stringliteral">&quot;%s\n&quot;</span>, replaced);</div><div class="line">    <span class="comment">// Don&#39;t forget to free the new string.</span></div><div class="line">    free(replaced);</div><div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#aa8b61a4cadcf73e21eee109623695bad">colr_str_replace_ColorArg()</a>, <a class="el" href="colr_8h.html#a136d15edf2f804c89cee619bb811ef3a">colr_str_replace_ColorResult()</a>, and <a class="el" href="colr_8h.html#aaee8d79a90917974ee4537705e34fd76">colr_str_replace_ColorText()</a>.</p>

</div>
</div>
<a id="abb81a3339840e1f527463eaddf994d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb81a3339840e1f527463eaddf994d8e">&#9670;&nbsp;</a></span>colr_str_replace_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_all </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the first substring found in a string (<code>char*</code>). </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string (""), which removes the <code>target</code> string from <code>s</code>.</p>
<p>For a more dynamic version, see the colr_replace and colr_replace_re macros.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>The string to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The string to replace with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, or <code>target</code> is <code>NULL</code>/empty.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_replace_all-example" id="colr_str_replace_all-example" class="diamond-bullet">&#160;</a> colr_str_replace_all example: </div><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="colr_8h.html">colr.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div><div class="line">    <span class="keywordtype">char</span>* mystring = <span class="stringliteral">&quot;This is a foo foo foo line.&quot;</span>;</div><div class="line">    <span class="keywordtype">char</span>* replaced = <a class="code" href="colr_8c.html#abb81a3339840e1f527463eaddf994d8e">colr_str_replace_all</a>(mystring, <span class="stringliteral">&quot;foo&quot;</span>, <span class="stringliteral">&quot;replaced&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (!replaced) {</div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;Failed to allocate for new string!\n&quot;</span>);</div><div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line">    printf(<span class="stringliteral">&quot;%s\n&quot;</span>, replaced);</div><div class="line">    <span class="comment">// Don&#39;t forget to free the new string.</span></div><div class="line">    free(replaced);</div><div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#af7c01a492bcbda6cf93705bff0cb0dbe">colr_str_replace_all_ColorArg()</a>, <a class="el" href="colr_8h.html#a53fa120c1074c836f65b4aace67d0c83">colr_str_replace_all_ColorResult()</a>, and <a class="el" href="colr_8h.html#a73789c11eaeb5a36b5f97556103a108d">colr_str_replace_all_ColorText()</a>.</p>

</div>
</div>
<a id="af7c01a492bcbda6cf93705bff0cb0dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c01a492bcbda6cf93705bff0cb0dbe">&#9670;&nbsp;</a></span>colr_str_replace_all_ColorArg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_all_ColorArg </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all substrings in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>The string to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to produce escape-codes to replace with. <a class="el" href="colr_8c.html#aa1163a9c866767fb7fcb734d3c0d9b7c" title="Free allocated memory for a ColorArg. ">ColorArg_free()</a> is called after the replacement is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, or <code>target</code> is <code>NULL</code>/empty.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="a53fa120c1074c836f65b4aace67d0c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53fa120c1074c836f65b4aace67d0c83">&#9670;&nbsp;</a></span>colr_str_replace_all_ColorResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_all_ColorResult </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all substrings in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>The string to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> to produce escape-codes to replace with. <a class="el" href="colr_8c.html#a27b70c6de9b2351424100bd742b1f1a8" title="Free allocated memory for a ColorResult and it&#39;s .result member. ">ColorResult_free()</a> is called after the replacement is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, or <code>target</code> is <code>NULL</code>/empty.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="a73789c11eaeb5a36b5f97556103a108d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73789c11eaeb5a36b5f97556103a108d">&#9670;&nbsp;</a></span>colr_str_replace_all_ColorText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_all_ColorText </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all substrings in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>The string to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to produce text/escape-codes to replace with. <a class="el" href="colr_8c.html#a901e5738358a739629cc3aaccab3e73f" title="Frees a ColorText and it&#39;s ColorArgs. ">ColorText_free()</a> is called after the replacement is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, or <code>target</code> is <code>NULL</code>/empty.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="a420403f3115f43c5e6356deee5644e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a420403f3115f43c5e6356deee5644e84">&#9670;&nbsp;</a></span>colr_str_replace_cnt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_cnt </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces one or more substrings in a string (<code>char*</code>). </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string (""), which removes the <code>target</code> string from <code>s</code>.</p>
<p>For a more dynamic version, see the colr_replace and colr_replace_re macros.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>The string to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The string to replace with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of substrings to replace, or <code>0</code> to replace all substrings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, or <code>target</code> is <code>NULL</code>/empty.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_replace_cnt-example" id="colr_str_replace_cnt-example" class="diamond-bullet">&#160;</a> colr_str_replace_cnt example: </div><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="colr_8h.html">colr.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div><div class="line">    <span class="keywordtype">char</span>* mystring = <span class="stringliteral">&quot;This is a foo foo foo line.&quot;</span>;</div><div class="line">    <span class="keywordtype">char</span>* replaced = <a class="code" href="colr_8c.html#a420403f3115f43c5e6356deee5644e84">colr_str_replace_cnt</a>(mystring, <span class="stringliteral">&quot;foo&quot;</span>, <span class="stringliteral">&quot;replaced&quot;</span>, 2);</div><div class="line">    <span class="keywordflow">if</span> (!replaced) {</div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;Failed to allocate for new string!\n&quot;</span>);</div><div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line">    printf(<span class="stringliteral">&quot;%s\n&quot;</span>, replaced);</div><div class="line">    <span class="comment">// Don&#39;t forget to free the new string.</span></div><div class="line">    free(replaced);</div><div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a2144034980aea6427fbc9bdf70e5b8c3">colr_str_replace()</a>, and <a class="el" href="colr_8h.html#abb81a3339840e1f527463eaddf994d8e">colr_str_replace_all()</a>.</p>

</div>
</div>
<a id="aa8b61a4cadcf73e21eee109623695bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b61a4cadcf73e21eee109623695bad">&#9670;&nbsp;</a></span>colr_str_replace_ColorArg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_ColorArg </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a substring in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>The string to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to produce escape-codes to replace with. <a class="el" href="colr_8c.html#aa1163a9c866767fb7fcb734d3c0d9b7c" title="Free allocated memory for a ColorArg. ">ColorArg_free()</a> is called after the replacement is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, or <code>target</code> is <code>NULL</code>/empty.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="a136d15edf2f804c89cee619bb811ef3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a136d15edf2f804c89cee619bb811ef3a">&#9670;&nbsp;</a></span>colr_str_replace_ColorResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_ColorResult </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a substring in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>The string to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> to produce escape-codes to replace with. <a class="el" href="colr_8c.html#a27b70c6de9b2351424100bd742b1f1a8" title="Free allocated memory for a ColorResult and it&#39;s .result member. ">ColorResult_free()</a> is called after the replacement is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, or <code>target</code> is <code>NULL</code>/empty.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="aaee8d79a90917974ee4537705e34fd76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee8d79a90917974ee4537705e34fd76">&#9670;&nbsp;</a></span>colr_str_replace_ColorText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_ColorText </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a substring in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>The string to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to produce text/escape-codes to replace with. <a class="el" href="colr_8c.html#a901e5738358a739629cc3aaccab3e73f" title="Frees a ColorText and it&#39;s ColorArgs. ">ColorText_free()</a> is called after the replacement is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, or <code>target</code> is <code>NULL</code>/empty.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="a09db8190822ff7e7e712399680325e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09db8190822ff7e7e712399680325e6a">&#9670;&nbsp;</a></span>colr_str_replace_re()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>re_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces a substring from a regex pattern string (<code>char*</code>) in a string (<code>char*</code>). </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string (""), which removes the <code>target</code> string from <code>s</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>The regex match object to find text to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The string to replace with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">re_flags</td><td>Flags for <code>regcomp()</code>. <code>REG_EXTENDED</code> is always used, whether flags are provided or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>pattern</code> is <code>NULL</code>, or the regex pattern</p>
<p>doesn't compile/match.</p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_replace_re-example" id="colr_str_replace_re-example" class="diamond-bullet">&#160;</a> colr_str_replace_re example: </div><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="colr_8h.html">colr.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div><div class="line">    <span class="keywordtype">char</span>* mystring = <span class="stringliteral">&quot;This is a foo line.&quot;</span>;</div><div class="line">    <span class="keywordtype">char</span>* replaced = <a class="code" href="colr_8c.html#a09db8190822ff7e7e712399680325e6a">colr_str_replace_re</a>(mystring, <span class="stringliteral">&quot;foo&quot;</span>, <span class="stringliteral">&quot;replaced&quot;</span>, 0);</div><div class="line">    <span class="keywordflow">if</span> (!replaced) <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    puts(replaced);</div><div class="line">    free(replaced);</div><div class="line">    replaced = <a class="code" href="colr_8c.html#a09db8190822ff7e7e712399680325e6a">colr_str_replace_re</a>(mystring, <span class="stringliteral">&quot;^([^ ]+)&quot;</span>, <span class="stringliteral">&quot;That&quot;</span>, 0);</div><div class="line">    <span class="keywordflow">if</span> (!replaced) <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    puts(replaced);</div><div class="line">    free(replaced);</div><div class="line">}</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a78d58bde53845d6ab2c54e4ba0c68a3d">colr_str_replace_re_ColorArg()</a>, <a class="el" href="colr_8h.html#a0376bed13e55acaca37e52c382044e1d">colr_str_replace_re_ColorResult()</a>, and <a class="el" href="colr_8h.html#ab8d6a10f70b435559656bbad0090d92d">colr_str_replace_re_ColorText()</a>.</p>

</div>
</div>
<a id="a232c65d12eb09d598eeb64490f39371c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a232c65d12eb09d598eeb64490f39371c">&#9670;&nbsp;</a></span>colr_str_replace_re_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_all </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>re_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all substrings from a regex pattern string (<code>char*</code>) in a string (<code>char*</code>). </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string (""), which removes the <code>target</code> string from <code>s</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>The regex match object to find text to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The string to replace with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">re_flags</td><td>Flags for <code>regcomp()</code>. <code>REG_EXTENDED</code> is always used, whether flags are provided or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>pattern</code> is <code>NULL</code>, or the regex pattern</p>
<p>doesn't compile/match.</p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_replace_re_all-example" id="colr_str_replace_re_all-example" class="diamond-bullet">&#160;</a> colr_str_replace_re_all example: </div><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="colr_8h.html">colr.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div><div class="line">    <span class="keywordtype">char</span>* mystring = <span class="stringliteral">&quot;This is a foo bar line.&quot;</span>;</div><div class="line">    <span class="keywordtype">char</span>* replaced = <a class="code" href="colr_8c.html#a232c65d12eb09d598eeb64490f39371c">colr_str_replace_re_all</a>(mystring, <span class="stringliteral">&quot;(foo)|(bar)&quot;</span>, <span class="stringliteral">&quot;replaced&quot;</span>, 0);</div><div class="line">    <span class="keywordflow">if</span> (!replaced) <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    puts(replaced);</div><div class="line">    free(replaced);</div><div class="line">    replaced = <a class="code" href="colr_8c.html#a232c65d12eb09d598eeb64490f39371c">colr_str_replace_re_all</a>(mystring, <span class="stringliteral">&quot;^([^ ]+)&quot;</span>, <span class="stringliteral">&quot;That&quot;</span>, 0);</div><div class="line">    <span class="keywordflow">if</span> (!replaced) <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    puts(replaced);</div><div class="line">    free(replaced);</div><div class="line">}</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a577e45a5c233dd1b4774a9034b17e3eb">colr_str_replace_re_all_ColorArg()</a>, <a class="el" href="colr_8h.html#a3e18a36736e5451529e80443cfb7b1fc">colr_str_replace_re_all_ColorResult()</a>, and <a class="el" href="colr_8h.html#a747e31fa3d8961e0bdd11eabd673accc">colr_str_replace_re_all_ColorText()</a>.</p>

</div>
</div>
<a id="a577e45a5c233dd1b4774a9034b17e3eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a577e45a5c233dd1b4774a9034b17e3eb">&#9670;&nbsp;</a></span>colr_str_replace_re_all_ColorArg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_all_ColorArg </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *&#160;</td>
          <td class="paramname"><em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>re_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all substrings from a regex pattern string (<code>char*</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>The regex pattern to compile. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to produce escape-codes to replace with. <a class="el" href="colr_8c.html#aa1163a9c866767fb7fcb734d3c0d9b7c" title="Free allocated memory for a ColorArg. ">ColorArg_free()</a> is called after the replacement is done. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">re_flags</td><td>Flags for <code>regcomp()</code>. <code>REG_EXTENDED</code> is always used, whether flags are provided or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>pattern</code> is <code>NULL</code>, or the regex pattern doesn't compile/match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="a3e18a36736e5451529e80443cfb7b1fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e18a36736e5451529e80443cfb7b1fc">&#9670;&nbsp;</a></span>colr_str_replace_re_all_ColorResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_all_ColorResult </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *&#160;</td>
          <td class="paramname"><em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>re_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all substrings from a regex pattern string (<code>char*</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>The regex match object to find text to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> to produce escape-codes to replace with. <a class="el" href="colr_8c.html#a27b70c6de9b2351424100bd742b1f1a8" title="Free allocated memory for a ColorResult and it&#39;s .result member. ">ColorResult_free()</a> is called after the replacement is done. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">re_flags</td><td>Flags for <code>regcomp()</code>. <code>REG_EXTENDED</code> is always used, whether flags are provided or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>pattern</code> is <code>NULL</code>, or the regex pattern doesn't compile/match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="a747e31fa3d8961e0bdd11eabd673accc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a747e31fa3d8961e0bdd11eabd673accc">&#9670;&nbsp;</a></span>colr_str_replace_re_all_ColorText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_all_ColorText </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td>
          <td class="paramname"><em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>re_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all substrings from a regex pattern string (<code>char*</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>The regex match object to find text to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to produce text/escape-codes to replace with. <a class="el" href="colr_8c.html#a901e5738358a739629cc3aaccab3e73f" title="Frees a ColorText and it&#39;s ColorArgs. ">ColorText_free()</a> is called after the replacement is done. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">re_flags</td><td>Flags for <code>regcomp()</code>. <code>REG_EXTENDED</code> is always used, whether flags are provided or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>pattern</code> is <code>NULL</code>, or the regex pattern doesn't compile/match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="a78d58bde53845d6ab2c54e4ba0c68a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78d58bde53845d6ab2c54e4ba0c68a3d">&#9670;&nbsp;</a></span>colr_str_replace_re_ColorArg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_ColorArg </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *&#160;</td>
          <td class="paramname"><em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>re_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace substrings from a regex pattern string (<code>char*</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>The regex pattern to compile. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to produce escape-codes to replace with. <a class="el" href="colr_8c.html#aa1163a9c866767fb7fcb734d3c0d9b7c" title="Free allocated memory for a ColorArg. ">ColorArg_free()</a> is called after the replacement is done. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">re_flags</td><td>Flags for <code>regcomp()</code>. <code>REG_EXTENDED</code> is always used, whether flags are provided or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>pattern</code> is <code>NULL</code>, or the regex pattern doesn't compile/match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="a0376bed13e55acaca37e52c382044e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0376bed13e55acaca37e52c382044e1d">&#9670;&nbsp;</a></span>colr_str_replace_re_ColorResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_ColorResult </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *&#160;</td>
          <td class="paramname"><em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>re_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace substrings from a regex pattern string (<code>char*</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>The regex match object to find text to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> to produce escape-codes to replace with. <a class="el" href="colr_8c.html#a27b70c6de9b2351424100bd742b1f1a8" title="Free allocated memory for a ColorResult and it&#39;s .result member. ">ColorResult_free()</a> is called after the replacement is done. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">re_flags</td><td>Flags for <code>regcomp()</code>. <code>REG_EXTENDED</code> is always used, whether flags are provided or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>pattern</code> is <code>NULL</code>, or the regex pattern doesn't compile/match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="ab8d6a10f70b435559656bbad0090d92d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d6a10f70b435559656bbad0090d92d">&#9670;&nbsp;</a></span>colr_str_replace_re_ColorText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_ColorText </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td>
          <td class="paramname"><em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>re_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace substrings from a regex pattern string (<code>char*</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>The regex match object to find text to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to produce text/escape-codes to replace with. <a class="el" href="colr_8c.html#a901e5738358a739629cc3aaccab3e73f" title="Frees a ColorText and it&#39;s ColorArgs. ">ColorText_free()</a> is called after the replacement is done. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">re_flags</td><td>Flags for <code>regcomp()</code>. <code>REG_EXTENDED</code> is always used, whether flags are provided or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>pattern</code> is <code>NULL</code>, or the regex pattern doesn't compile/match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="a2fbc36f0f7aba3aa0616437f937efd20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fbc36f0f7aba3aa0616437f937efd20">&#9670;&nbsp;</a></span>colr_str_replace_re_match()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_match </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">regmatch_t *&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces substrings from a single regex match (<code>regmatch_t*</code>) in a string (<code>char*</code>). </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string (""), which removes the <code>target</code> string from <code>s</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">match</td><td>The regex match object to find text to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The string to replace with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>match</code> is <code>NULL</code>, or the regex pattern doesn't match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_replace_re_match-example" id="colr_str_replace_re_match-example" class="diamond-bullet">&#160;</a> colr_str_replace_re_match example: </div><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="colr_8h.html">colr.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div><div class="line">    <span class="comment">// Build a regex pattern.</span></div><div class="line">    regex_t pat;</div><div class="line">    <span class="keywordflow">if</span> (regcomp(&amp;pat, <span class="stringliteral">&quot;foo&quot;</span>, 0)) {</div><div class="line">        <span class="comment">// Failed to compile the pattern.</span></div><div class="line">        regfree(&amp;pat);</div><div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Set up our matches (only 1 can be used with colr_replace_re_match).</span></div><div class="line">    <span class="keywordtype">size_t</span> matchcnt = 1;</div><div class="line">    regmatch_t rematches[matchcnt];</div><div class="line"></div><div class="line">    <span class="comment">// Run the regex and we should get an initialized `regmatch_t`.</span></div><div class="line">    <span class="keywordtype">char</span>* mystring = <span class="stringliteral">&quot;This is a foo line.&quot;</span>;</div><div class="line">    <span class="keywordflow">if</span> (regexec(&amp;pat, mystring, matchcnt, rematches, 0)) {</div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;No matches!?&quot;</span>);</div><div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Replace the matched text with our string.</span></div><div class="line">    <span class="keywordtype">char</span>* replaced = <a class="code" href="colr_8c.html#a2fbc36f0f7aba3aa0616437f937efd20">colr_str_replace_re_match</a>(</div><div class="line">        mystring,</div><div class="line">        rematches,</div><div class="line">        <span class="stringliteral">&quot;REPLACED&quot;</span></div><div class="line">    );</div><div class="line">    <span class="comment">// Don&#39;t forget to free your regex object (even if stack-allocated).</span></div><div class="line">    regfree(&amp;pat);</div><div class="line">    <span class="keywordflow">if</span> (!replaced) {</div><div class="line">            fprintf(stderr, <span class="stringliteral">&quot;Cannot allocate for replaced string!\n&quot;</span>);</div><div class="line">            <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line">    printf(<span class="stringliteral">&quot;%s\n&quot;</span>, replaced);</div><div class="line">    free(replaced);</div><div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a0d4cbd6a8fd3cef76f07b705b09d2a54">colr_str_replace_re_match_ColorArg()</a>, <a class="el" href="colr_8h.html#ac092f944961dddc6574a6c55e6e878b0">colr_str_replace_re_match_ColorResult()</a>, <a class="el" href="colr_8h.html#a4d954398333472c1436f9bc051f46392">colr_str_replace_re_match_ColorText()</a>, and <a class="el" href="colr_8h.html#a63621c6749d8219112ff51ebf0ecb22a">colr_str_replace_re_pat()</a>.</p>

</div>
</div>
<a id="a0d4cbd6a8fd3cef76f07b705b09d2a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d4cbd6a8fd3cef76f07b705b09d2a54">&#9670;&nbsp;</a></span>colr_str_replace_re_match_ColorArg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_match_ColorArg </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">regmatch_t *&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace substrings from a regex match (<code>regmatch_t*</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">match</td><td>The regex match object to find text to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to produce escape-codes to replace with. <a class="el" href="colr_8c.html#aa1163a9c866767fb7fcb734d3c0d9b7c" title="Free allocated memory for a ColorArg. ">ColorArg_free()</a> is called after the replacement is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>match</code> is <code>NULL</code>, or the regex pattern doesn't match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="ac092f944961dddc6574a6c55e6e878b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac092f944961dddc6574a6c55e6e878b0">&#9670;&nbsp;</a></span>colr_str_replace_re_match_ColorResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_match_ColorResult </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">regmatch_t *&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace substrings from a regex match (<code>regmatch_t*</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">match</td><td>The regex match object to find text to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> to produce escape-codes to replace with. <a class="el" href="colr_8c.html#a27b70c6de9b2351424100bd742b1f1a8" title="Free allocated memory for a ColorResult and it&#39;s .result member. ">ColorResult_free()</a> is called after the replacement is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>match</code> is <code>NULL</code>, or the regex pattern doesn't match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="a4d954398333472c1436f9bc051f46392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d954398333472c1436f9bc051f46392">&#9670;&nbsp;</a></span>colr_str_replace_re_match_ColorText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_match_ColorText </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">regmatch_t *&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace substrings from a regex match (<code>regmatch_t*</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">match</td><td>The regex match object to find text to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to produce text/escape-codes to replace with. <a class="el" href="colr_8c.html#a901e5738358a739629cc3aaccab3e73f" title="Frees a ColorText and it&#39;s ColorArgs. ">ColorText_free()</a> is called after the replacement is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>match</code> is <code>NULL</code>, or the regex pattern doesn't match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="a205182bbcbf99a3faa1b207a28721c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a205182bbcbf99a3faa1b207a28721c87">&#9670;&nbsp;</a></span>colr_str_replace_re_match_i()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_match_i </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">regmatch_t *&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces substrings from a regex match (<code>regmatch_t*</code>) in a string (<code>char*</code>). </p>
<p>This modifies <code>target</code> in place. It must have capacity for the result.</p>
<p>Using <code>NULL</code> as a replacement is like using an empty string (""), which removes the <code>target</code> string from <code>s</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ref</td><td>The string to use for offset references. Can be <code>target</code>. Set this to the source string if <code>target</code> has not been filled yet. If <code>target</code> has been filled, you may use <code>target</code> for both <code>ref</code> and <code>target</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">target</td><td>The string to modify. Must have room for the resulting string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">match</td><td>The regex match object to find text to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The string to replace with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>match</code> is <code>NULL</code>, or the regex pattern doesn't match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_replace_re_match_i-example" id="colr_str_replace_re_match_i-example" class="diamond-bullet">&#160;</a> colr_str_replace_re_match_i example: </div><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="colr_8h.html">colr.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div><div class="line">    <span class="comment">// Build a regex pattern.</span></div><div class="line">    regex_t pat;</div><div class="line">    <span class="keywordflow">if</span> (regcomp(&amp;pat, <span class="stringliteral">&quot;foo&quot;</span>, 0)) {</div><div class="line">        <span class="comment">// Failed to compile the pattern.</span></div><div class="line">        regfree(&amp;pat);</div><div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Set up our matches (only 1 can be used with colr_replace_re_match_i).</span></div><div class="line">    <span class="keywordtype">size_t</span> matchcnt = 1;</div><div class="line">    regmatch_t rematches[matchcnt];</div><div class="line"></div><div class="line">    <span class="comment">// Run the regex and we should get an initialized `regmatch_t`.</span></div><div class="line">    <span class="keywordtype">char</span>* mystring = <span class="stringliteral">&quot;This is a foo line.&quot;</span>;</div><div class="line">    <span class="keywordtype">char</span>* replacement = <span class="stringliteral">&quot;REPLACED&quot;</span>;</div><div class="line">    <span class="keywordtype">size_t</span> length = strlen(mystring);</div><div class="line">    <span class="keywordtype">char</span>* targetstring = calloc(length + strlen(replacement) + 1, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));</div><div class="line">    strncpy(targetstring, mystring, length + 1);</div><div class="line">    <span class="keywordflow">if</span> (regexec(&amp;pat, mystring, matchcnt, rematches, 0)) {</div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;No matches!?&quot;</span>);</div><div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line">    <span class="comment">// Don&#39;t forget to free your regex object (even if stack-allocated).</span></div><div class="line">    regfree(&amp;pat);</div><div class="line"></div><div class="line">    <span class="comment">// Replace the matched text with our string.</span></div><div class="line">    <span class="keywordtype">char</span>* replaced = <a class="code" href="colr_8c.html#a205182bbcbf99a3faa1b207a28721c87">colr_str_replace_re_match_i</a>(</div><div class="line">        mystring,</div><div class="line">        targetstring,</div><div class="line">        rematches,</div><div class="line">        replacement</div><div class="line">    );</div><div class="line">    <span class="keywordflow">if</span> (!replaced) {</div><div class="line">            fprintf(stderr, <span class="stringliteral">&quot;An error occurred!\n&quot;</span>);</div><div class="line">            <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line">    printf(<span class="stringliteral">&quot;%s\n&quot;</span>, replaced);</div><div class="line">    free(targetstring);</div><div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a8c72d363d7f87e2a7546202b439557e1">colr_str_replace_re_matches()</a>.</p>

</div>
</div>
<a id="a8c72d363d7f87e2a7546202b439557e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c72d363d7f87e2a7546202b439557e1">&#9670;&nbsp;</a></span>colr_str_replace_re_matches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_matches </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">regmatch_t **&#160;</td>
          <td class="paramname"><em>matches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces substrings from an array of regex match (<code>regmatch_t*</code>) in a string (<code>char*</code>). </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string (""), which removes the <code>target</code> string from <code>s</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matches</td><td>Regex match objects to find text to replace. The array must have <code>NULL</code> as the last member. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The string to replace with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>match</code> is <code>NULL</code>, or the regex pattern doesn't match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a75b2cdee697818e2f9f38ec7eac98bcb">colr_str_replace_re_matches_ColorArg()</a>, <a class="el" href="colr_8h.html#a4d4bb71015338108d86fcf47317cc5ff">colr_str_replace_re_matches_ColorResult()</a>, <a class="el" href="colr_8h.html#aa4fe38cc205cbd49b2f8477744574294">colr_str_replace_re_matches_ColorText()</a>, and <a class="el" href="colr_8h.html#afd19623913d27e2d9a5af3496a478c2b">colr_str_replace_re_pat_all()</a>.</p>

</div>
</div>
<a id="a75b2cdee697818e2f9f38ec7eac98bcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b2cdee697818e2f9f38ec7eac98bcb">&#9670;&nbsp;</a></span>colr_str_replace_re_matches_ColorArg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_matches_ColorArg </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">regmatch_t **&#160;</td>
          <td class="paramname"><em>matches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace substrings from an array of regex matches (<code>regmatch_t**</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matches</td><td>The regex match objects to find text to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to produce escape-codes to replace with. <a class="el" href="colr_8c.html#aa1163a9c866767fb7fcb734d3c0d9b7c" title="Free allocated memory for a ColorArg. ">ColorArg_free()</a> is called after the replacement is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>match</code> is <code>NULL</code>, or the regex pattern doesn't match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="a4d4bb71015338108d86fcf47317cc5ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d4bb71015338108d86fcf47317cc5ff">&#9670;&nbsp;</a></span>colr_str_replace_re_matches_ColorResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_matches_ColorResult </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">regmatch_t **&#160;</td>
          <td class="paramname"><em>matches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace substrings from an array of regex matches (<code>regmatch_t**</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matches</td><td>The regex match objects to find text to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> to produce escape-codes to replace with. <a class="el" href="colr_8c.html#a27b70c6de9b2351424100bd742b1f1a8" title="Free allocated memory for a ColorResult and it&#39;s .result member. ">ColorResult_free()</a> is called after the replacement is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>match</code> is <code>NULL</code>, or the regex pattern doesn't match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="aa4fe38cc205cbd49b2f8477744574294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4fe38cc205cbd49b2f8477744574294">&#9670;&nbsp;</a></span>colr_str_replace_re_matches_ColorText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_matches_ColorText </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">regmatch_t **&#160;</td>
          <td class="paramname"><em>matches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace substrings from an array of regex matches (<code>regmatch_t**</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matches</td><td>The regex match objects to find text to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to produce text/escape-codes to replace with. <a class="el" href="colr_8c.html#a901e5738358a739629cc3aaccab3e73f" title="Frees a ColorText and it&#39;s ColorArgs. ">ColorText_free()</a> is called after the replacement is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>match</code> is <code>NULL</code>, or the regex pattern doesn't match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="a63621c6749d8219112ff51ebf0ecb22a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63621c6749d8219112ff51ebf0ecb22a">&#9670;&nbsp;</a></span>colr_str_replace_re_pat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_pat </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">regex_t *&#160;</td>
          <td class="paramname"><em>repattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces regex patterns in a string (<code>char*</code>). </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string (""), which removes the <code>target</code> string from <code>s</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repattern</td><td>The regex pattern to match (<code>regex_t*</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The string to replace with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>repattern</code> is <code>NULL</code>, or the regex pattern doesn't match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_replace_re_pat-example" id="colr_str_replace_re_pat-example" class="diamond-bullet">&#160;</a> colr_str_replace_re_pat example: </div><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="colr_8h.html">colr.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div><div class="line">    <span class="comment">// Compile a regex pattern.</span></div><div class="line">    regex_t pat;</div><div class="line">    <span class="keywordflow">if</span> (regcomp(&amp;pat, <span class="stringliteral">&quot;foo&quot;</span>, 0)) {</div><div class="line">        <span class="comment">// Failed to compile the pattern.</span></div><div class="line">        regfree(&amp;pat);</div><div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line">    <span class="keywordtype">char</span>* mystring = <span class="stringliteral">&quot;This is a foo line.&quot;</span>;</div><div class="line">    <span class="keywordtype">char</span>* replaced = <a class="code" href="colr_8c.html#a63621c6749d8219112ff51ebf0ecb22a">colr_str_replace_re_pat</a>(mystring, &amp;pat, <span class="stringliteral">&quot;replaced&quot;</span>);</div><div class="line">    <span class="comment">// Don&#39;t forget to free your regex pattern.</span></div><div class="line">    regfree(&amp;pat);</div><div class="line">    <span class="keywordflow">if</span> (!replaced) <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    puts(replaced);</div><div class="line">    free(replaced);</div><div class="line">}</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a09db8190822ff7e7e712399680325e6a">colr_str_replace_re()</a>, <a class="el" href="colr_8h.html#adecbe2f1e87613b6f4a51158325dd4f7">colr_str_replace_re_pat_ColorArg()</a>, <a class="el" href="colr_8h.html#abcd756c82acab9505343b614d52c0b19">colr_str_replace_re_pat_ColorResult()</a>, and <a class="el" href="colr_8h.html#a6f8b04b6d851f26304183d1111b8f0dc">colr_str_replace_re_pat_ColorText()</a>.</p>

</div>
</div>
<a id="afd19623913d27e2d9a5af3496a478c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd19623913d27e2d9a5af3496a478c2b">&#9670;&nbsp;</a></span>colr_str_replace_re_pat_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_pat_all </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">regex_t *&#160;</td>
          <td class="paramname"><em>repattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all matches to a regex pattern in a string (<code>char*</code>). </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string (""), which removes the <code>target</code> string from <code>s</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repattern</td><td>The regex pattern to match (<code>regex_t*</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The string to replace with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>repattern</code> is <code>NULL</code>, or the regex pattern doesn't match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_replace_re_pat_all-example" id="colr_str_replace_re_pat_all-example" class="diamond-bullet">&#160;</a> colr_str_replace_re_pat_all example: </div><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="colr_8h.html">colr.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div><div class="line">    <span class="comment">// Compile a regex pattern.</span></div><div class="line">    regex_t pat;</div><div class="line">    <span class="keywordflow">if</span> (regcomp(&amp;pat, <span class="stringliteral">&quot;[1-9]&quot;</span>, REG_EXTENDED)) {</div><div class="line">        <span class="comment">// Failed to compile the pattern.</span></div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;Cannot compile the pattern!\n&quot;</span>);</div><div class="line">        regfree(&amp;pat);</div><div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line">    <span class="keywordtype">char</span>* mystring = <span class="stringliteral">&quot;1 2 everywhere, but still no 3 to spare.&quot;</span>;</div><div class="line">    <span class="keywordtype">char</span>* replaced = <a class="code" href="colr_8c.html#afd19623913d27e2d9a5af3496a478c2b">colr_str_replace_re_pat_all</a>(mystring, &amp;pat, <span class="stringliteral">&quot;numbers&quot;</span>);</div><div class="line">    <span class="comment">// Don&#39;t forget to free your regex pattern.</span></div><div class="line">    regfree(&amp;pat);</div><div class="line">    <span class="keywordflow">if</span> (!replaced) <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    puts(replaced);</div><div class="line">    free(replaced);</div><div class="line">}</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a232c65d12eb09d598eeb64490f39371c">colr_str_replace_re_all()</a>, <a class="el" href="colr_8h.html#a090ba95c4560134ef9c2807eff6a0ea1">colr_str_replace_re_pat_all_ColorArg()</a>, <a class="el" href="colr_8h.html#af083c2e1867ecaad0ae38a1324c915ac">colr_str_replace_re_pat_all_ColorResult()</a>, and <a class="el" href="colr_8h.html#ab9c4a5c34b26473dc45f93ce2c66faf1">colr_str_replace_re_pat_all_ColorText()</a>.</p>

</div>
</div>
<a id="a090ba95c4560134ef9c2807eff6a0ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a090ba95c4560134ef9c2807eff6a0ea1">&#9670;&nbsp;</a></span>colr_str_replace_re_pat_all_ColorArg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_pat_all_ColorArg </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">regex_t *&#160;</td>
          <td class="paramname"><em>repattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all matches to a regex pattern in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repattern</td><td>The regex pattern to match (<code>regex_t*</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to produce escape-codes to replace with. <a class="el" href="colr_8c.html#aa1163a9c866767fb7fcb734d3c0d9b7c" title="Free allocated memory for a ColorArg. ">ColorArg_free()</a> is called after the replacement is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>repattern</code> is <code>NULL</code>, or the regex pattern doesn't match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="af083c2e1867ecaad0ae38a1324c915ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af083c2e1867ecaad0ae38a1324c915ac">&#9670;&nbsp;</a></span>colr_str_replace_re_pat_all_ColorResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_pat_all_ColorResult </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">regex_t *&#160;</td>
          <td class="paramname"><em>repattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all matches to a regex pattern in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repattern</td><td>The regex pattern to match (<code>regex_t*</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> to produce escape-codes to replace with. <a class="el" href="colr_8c.html#a27b70c6de9b2351424100bd742b1f1a8" title="Free allocated memory for a ColorResult and it&#39;s .result member. ">ColorResult_free()</a> is called after the replacement is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>repattern</code> is <code>NULL</code>, or the regex pattern doesn't match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="ab9c4a5c34b26473dc45f93ce2c66faf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9c4a5c34b26473dc45f93ce2c66faf1">&#9670;&nbsp;</a></span>colr_str_replace_re_pat_all_ColorText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_pat_all_ColorText </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">regex_t *&#160;</td>
          <td class="paramname"><em>repattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all matches to a regex pattern in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repattern</td><td>The regex pattern to match (<code>regex_t*</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to produce text/escape-codes to replace with. <a class="el" href="colr_8c.html#a901e5738358a739629cc3aaccab3e73f" title="Frees a ColorText and it&#39;s ColorArgs. ">ColorText_free()</a> is called after the replacement is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>repattern</code> is <code>NULL</code>, or the regex pattern doesn't match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="adecbe2f1e87613b6f4a51158325dd4f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adecbe2f1e87613b6f4a51158325dd4f7">&#9670;&nbsp;</a></span>colr_str_replace_re_pat_ColorArg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_pat_ColorArg </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">regex_t *&#160;</td>
          <td class="paramname"><em>repattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace regex patterns in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repattern</td><td>The regex pattern to match (<code>regex_t*</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to produce escape-codes to replace with. <a class="el" href="colr_8c.html#aa1163a9c866767fb7fcb734d3c0d9b7c" title="Free allocated memory for a ColorArg. ">ColorArg_free()</a> is called after the replacement is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>repattern</code> is <code>NULL</code>, or the regex pattern doesn't match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="abcd756c82acab9505343b614d52c0b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcd756c82acab9505343b614d52c0b19">&#9670;&nbsp;</a></span>colr_str_replace_re_pat_ColorResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_pat_ColorResult </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">regex_t *&#160;</td>
          <td class="paramname"><em>repattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace regex patterns in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repattern</td><td>The regex pattern to match (<code>regex_t*</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> to produce escape-codes to replace with. <a class="el" href="colr_8c.html#a27b70c6de9b2351424100bd742b1f1a8" title="Free allocated memory for a ColorResult and it&#39;s .result member. ">ColorResult_free()</a> is called after the replacement is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>repattern</code> is <code>NULL</code>, or the regex pattern doesn't match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="a6f8b04b6d851f26304183d1111b8f0dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f8b04b6d851f26304183d1111b8f0dc">&#9670;&nbsp;</a></span>colr_str_replace_re_pat_ColorText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_pat_ColorText </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">regex_t *&#160;</td>
          <td class="paramname"><em>repattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace regex patterns in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repattern</td><td>The regex pattern to match (<code>regex_t*</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to produce text/escape-codes to replace with. <a class="el" href="colr_8c.html#a901e5738358a739629cc3aaccab3e73f" title="Frees a ColorText and it&#39;s ColorArgs. ">ColorText_free()</a> is called after the replacement is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>repattern</code> is <code>NULL</code>, or the regex pattern doesn't match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="a196ad91a69cfbeb27a5266ffc93ed353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a196ad91a69cfbeb27a5266ffc93ed353">&#9670;&nbsp;</a></span>colr_str_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_repr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string (<code>char*</code>) into a representation of a string, by wrapping it in quotes and escaping characters that need escaping. </p>
<p>If <code>s</code> is NULL, then an allocated string containing the string "NULL" is returned (without quotes).</p>
<p>Escape codes will be escaped, so the terminal will ignore them if the result is printed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to represent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the representation.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#a67ef4700a46e78c2bed1132428a610fb" title="Determines if an ascii character has an escape sequence in C. ">colr_char_should_escape</a> </dd>
<dd>
<a class="el" href="colr_8c.html#a7f1ea562310969b7efa8711a843f103c" title="Returns the char needed to represent an escape sequence in C. ">colr_char_escape_char</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_repr-example" id="colr_str_repr-example" class="diamond-bullet">&#160;</a> colr_str_repr example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* s = <a class="code" href="colr_8c.html#a196ad91a69cfbeb27a5266ffc93ed353">colr_str_repr</a>(<span class="stringliteral">&quot;This\nhas \bspecial\tchars.&quot;</span>);</div><div class="line"><span class="comment">// The string `s` contains an escaped string, it *looks like* the definition,</span></div><div class="line"><span class="comment">// but no real newlines, backspaces, or tabs are in it.</span></div><div class="line">assert(strcmp(s, <span class="stringliteral">&quot;\&quot;This\\nhas \\bspecial\\tchars.\&quot;&quot;</span>) == 0);</div><div class="line">free(s);</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a30cac3017a6ea8c78277882554c9419f">_colr_ptr_repr()</a>, <a class="el" href="colr_8h.html#aae0b90c57e8c4c475d9e0f517f3a0d42">ColorResult_repr()</a>, and <a class="el" href="colr_8h.html#a65363a3601cd9cfcdc7fc40722d5d3c3">ColorText_repr()</a>.</p>

</div>
</div>
<a id="acc75e3bf729168f9ac204ef0a1708d46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc75e3bf729168f9ac204ef0a1708d46">&#9670;&nbsp;</a></span>colr_str_rjust()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_rjust </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>padchar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Right-justifies a string (<code>char*</code>), ignoring escape codes when measuring the width. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">The string to justify.</p>
<p class="endtd">Input <em>must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The overall width for the resulting string. If set to '0', the terminal width will be used from <a class="el" href="colr_8c.html#ae4c11bb5b3b1bb2848bb16aee39763b2" title="Attempts to retrieve the row/column size of the terminal and returns a TermSize. ">colr_term_size()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">padchar</td><td>The character to pad with. If '0', then `' '` is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#a1a8345393e635e1c5e148473bdce292d" title="Center-justifies a string (char*), ignoring escape codes when measuring the width. ">colr_str_center</a> </dd>
<dd>
<a class="el" href="colr_8c.html#a5eedebae47b5d22dda709f833f23a256" title="Left-justifies a string (char*), ignoring escape codes when measuring the width. ">colr_str_ljust</a> </dd>
<dd>
<a class="el" href="colr_8c.html#ae4c11bb5b3b1bb2848bb16aee39763b2" title="Attempts to retrieve the row/column size of the terminal and returns a TermSize. ">colr_term_size</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_rjust-example" id="colr_str_rjust-example" class="diamond-bullet">&#160;</a> colr_str_rjust example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* colorized = <a class="code" href="colr_8h.html#a753093cd4c872eed4b77feaa7816212b">colr</a>(<span class="stringliteral">&quot;This.&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED), <a class="code" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8">back</a>(WHITE));</div><div class="line"><span class="keywordtype">char</span>* justified = <a class="code" href="colr_8c.html#acc75e3bf729168f9ac204ef0a1708d46">colr_str_rjust</a>(colorized, 8, <span class="charliteral">&#39; &#39;</span>);</div><div class="line">free(colorized);</div><div class="line"><span class="comment">// The string still has codes, but only 3 spaces were added.</span></div><div class="line">assert(<a class="code" href="colr_8c.html#ac23328cead6a65d7b3ef2c2ca48d11ce">colr_str_starts_with</a>(justified, <span class="stringliteral">&quot;   &quot;</span>));</div><div class="line"><span class="comment">// It was &quot;justified&quot; to 8 characters long, but it is well over that.</span></div><div class="line">assert(strlen(justified) &gt; 8);</div><div class="line">printf(<span class="stringliteral">&quot;&#39;%s&#39;\n&quot;</span>, justified);</div><div class="line">free(justified);</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a34c359a48f811316d765b7abef1ea8f4">colr_printf_handler()</a>.</p>

</div>
</div>
<a id="ac23328cead6a65d7b3ef2c2ca48d11ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23328cead6a65d7b3ef2c2ca48d11ce">&#9670;&nbsp;</a></span>colr_str_starts_with()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_str_starts_with </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks a string (<code>char*</code>) for a certain prefix substring. </p>
<p><code>prefix</code> <em>Must be <code>null</code>-terminated</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>The prefix string to look for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the string <code>s</code> starts with prefix. </dd>
<dd>
False if one of the strings is null, or the prefix isn't found.</dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_starts_with-example" id="colr_str_starts_with-example" class="diamond-bullet">&#160;</a> colr_str_starts_with example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* s = <span class="stringliteral">&quot;This is my string.&quot;</span>;</div><div class="line">assert(<a class="code" href="colr_8c.html#ac23328cead6a65d7b3ef2c2ca48d11ce">colr_str_starts_with</a>(s, <span class="stringliteral">&quot;This&quot;</span>));</div><div class="line">assert(!<a class="code" href="colr_8c.html#ac23328cead6a65d7b3ef2c2ca48d11ce">colr_str_starts_with</a>(s, <span class="stringliteral">&quot;that&quot;</span>));</div></div><!-- fragment --> </div> 
</div>
</div>
<a id="ab0b13b04dc178d0990ab2ae403ee64e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b13b04dc178d0990ab2ae403ee64e0">&#9670;&nbsp;</a></span>colr_str_strip_codes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_strip_codes </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Strips escape codes from a string (<code>char*</code>), resulting in a new allocated string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">The string to strip escape codes from.</p>
<p class="endtd">Input <em>must be <code>null</code>-terminated</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#a037a0245a39d7ff5cfba5f779d0eb251" title="Returns the length of string (char*), ignoring escape codes and the the null-terminator. ">colr_str_noncode_len</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_strip_codes-example" id="colr_str_strip_codes-example" class="diamond-bullet">&#160;</a> colr_str_strip_codes example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* s = <span class="stringliteral">&quot;\x1b[31mRed text.\x1b[0m&quot;</span>;</div><div class="line">printf(<span class="stringliteral">&quot;With codes: %s\n&quot;</span>, s);</div><div class="line"><span class="keywordtype">char</span>* stripped = <a class="code" href="colr_8c.html#ab0b13b04dc178d0990ab2ae403ee64e0">colr_str_strip_codes</a>(s);</div><div class="line"><span class="keywordflow">if</span> (!stripped) exit(1);</div><div class="line">assert(!<a class="code" href="colr_8c.html#a8b9f4cbe1e806316e063206dfb610476">colr_str_has_codes</a>(stripped));</div><div class="line">assert(strlen(stripped) == 9);</div><div class="line">printf(<span class="stringliteral">&quot;Without codes: %s\n&quot;</span>, stripped);</div><div class="line"><span class="comment">// Don&#39;t forget to free the string:</span></div><div class="line">free(stripped);</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a34c359a48f811316d765b7abef1ea8f4">colr_printf_handler()</a>.</p>

</div>
</div>
<a id="ae9b847e10db135f7ebc89031b3a7ad56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b847e10db135f7ebc89031b3a7ad56">&#9670;&nbsp;</a></span>colr_str_to_lower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_to_lower </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new lowercase version of a string (<code>char*</code>). </p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">The input string to convert to lower case.</p>
<p class="endtd"><em>Must be <code>null</code>-terminated</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">The allocated string, or <code>NULL</code> if <code>s</code> is <code>NULL</code>.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a2e859d542a8aa0939e4f76b1f33cb5f8">ExtendedValue_from_str()</a>, and <a class="el" href="colr_8h.html#a98c9e50fe14ad0c82bcf1a62699c05de">RGB_from_str()</a>.</p>

</div>
</div>
<a id="ab2ebdcd3c6e598a244292c7605452e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ebdcd3c6e598a244292c7605452e9d">&#9670;&nbsp;</a></span>colr_supports_rgb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_supports_rgb </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether the current environment support <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> (True Colors). </p>
<p>This checks <code>$COLORTERM</code> for the appropriate value (<code>'truecolor'</code> or <code>'24bit'</code>). On "dumber" terminals, <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> codes are probably ignored or mistaken for a 256-color or even 8-color value.</p>
<p>For instance, <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> is supported in <code>konsole</code>, but not in <code>xterm</code> or <code>linux</code> ttys. Using <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> codes in <code>xterm</code> makes the colors appear as though a 256-color value was used (closest matching value, like <a class="el" href="colr_8c.html#ab4576c531151e398b7ecede2e30df70d" title="Convert an RGB value into it&#39;s nearest terminal-friendly RGB value. ">RGB_to_term_RGB()</a>). Using <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> codes in a simpler <code>linux</code> tty makes them appear as though an 8-color value was used. Very ugly, but not a disaster.</p>
<p>I haven't seen a <em>modern</em> linux terminal spew garbage across the screen from using <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> codes when they are not supported, but I could be wrong. I would like to see that terminal if you know of one.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if 24-bit (true color, or "rgb") support is detected, otherwise <code>false</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ac2aab28fe264005a5d17b888b542610b">colr_supports_rgb_static()</a>.</p>

</div>
</div>
<a id="ac2aab28fe264005a5d17b888b542610b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2aab28fe264005a5d17b888b542610b">&#9670;&nbsp;</a></span>colr_supports_rgb_static()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_supports_rgb_static </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="colr_8c.html#ab2ebdcd3c6e598a244292c7605452e9d" title="Determine whether the current environment support RGB (True Colors). ">colr_supports_rgb()</a>, but the environment is only checked on the first call. </p>
<p>All other calls return the same result as the first call.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if 24-bit (true color, or "rgb") support is detected, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="ae4c11bb5b3b1bb2848bb16aee39763b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c11bb5b3b1bb2848bb16aee39763b2">&#9670;&nbsp;</a></span>colr_term_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structTermSize">TermSize</a> colr_term_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to retrieve the row/column size of the terminal and returns a <a class="el" href="colr_8h.html#structTermSize" title="Holds a terminal size, usually retrieved with colr_term_size(). ">TermSize</a>. </p>
<p>If the call fails, the environment variables <code>LINES</code> and <code>COLUMNS</code> are checked. If that fails, a default <code><a class="el" href="colr_8h.html#structTermSize" title="Holds a terminal size, usually retrieved with colr_term_size(). ">TermSize</a></code> struct is returned: </p><div class="fragment"><div class="line">(<a class="code" href="colr_8h.html#structTermSize">TermSize</a>){.rows=35, .columns=80}</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structTermSize" title="Holds a terminal size, usually retrieved with colr_term_size(). ">TermSize</a> struct with terminal size information. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a412833a097b050c8ee99874c733bd030">ColorText_length()</a>, <a class="el" href="colr_8h.html#a1a8345393e635e1c5e148473bdce292d">colr_str_center()</a>, <a class="el" href="colr_8h.html#a5eedebae47b5d22dda709f833f23a256">colr_str_ljust()</a>, and <a class="el" href="colr_8h.html#acc75e3bf729168f9ac204ef0a1708d46">colr_str_rjust()</a>.</p>

</div>
</div>
<a id="ae7d7b7bf1080742eeb588ba70ce9ea77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d7b7bf1080742eeb588ba70ce9ea77">&#9670;&nbsp;</a></span>colr_win_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct winsize colr_win_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to retrieve a <code>winsize</code> struct from an <code>ioctl</code> call. </p>
<p>If the call fails, the environment variables <code>LINES</code> and <code>COLUMNS</code> are checked. If that fails, a default <code>winsize</code> struct is returned: </p><div class="fragment"><div class="line">(<span class="keyword">struct </span>winsize){.ws_row=35, .ws_col=80, .ws_xpixel=0, .ws_ypixel=0}</div></div><!-- fragment --><p><code>man ioctl_tty</code> says that <code>.ws_xpixel</code> and <code>.ws_ypixel</code> are unused.</p>
<dl class="section return"><dt>Returns</dt><dd>A <code>winsize</code> struct (<code>sys/ioctl.h</code>) with window size information. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ae4c11bb5b3b1bb2848bb16aee39763b2">colr_term_size()</a>.</p>

</div>
</div>
<a id="afc2c53ebede7f97645f671401bfe356d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc2c53ebede7f97645f671401bfe356d">&#9670;&nbsp;</a></span>colr_win_size_env()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct winsize colr_win_size_env </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get window/terminal size using the environment variables <code>LINES</code>, <code>COLUMNS</code>, or <code>COLS</code>. </p>
<p>This is used as a fallback if the <code>ioctl()</code> call fails in <a class="el" href="colr_8c.html#ae7d7b7bf1080742eeb588ba70ce9ea77" title="Attempts to retrieve a winsize struct from an ioctl call. ">colr_win_size()</a>. If environment variables are not available, a default <code>winsize</code> struct is returned: </p><div class="fragment"><div class="line">(<span class="keyword">struct </span>winsize){.ws_row=35, .ws_col=80, .ws_xpixel=0, .ws_ypixel=0}</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>A <code>winsize</code> struct (<code>sys/ioctl.h</code>) with window size information. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ae7d7b7bf1080742eeb588ba70ce9ea77">colr_win_size()</a>.</p>

</div>
</div>
<a id="ac847d91a396ae6babc0bd46e6386a701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac847d91a396ae6babc0bd46e6386a701">&#9670;&nbsp;</a></span>ExtendedValue_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ExtendedValue_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two ExtendedValues. </p>
<p>This is used to implement <a class="el" href="colr_8h.html#a36af8aa0f01eaa780da182e856923faa" title="Calls the &lt;type&gt;_eq functions for the supported types. ">colr_eq()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first ExtendedValue to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second ExtendedValue to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if they are equal, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94" title="Convenience typedef for clarity when dealing with extended (256) colors. ">ExtendedValue</a> </dd></dl>

</div>
</div>
<a id="af0b464ee51d75d7f45ddd5926a7c9cf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0b464ee51d75d7f45ddd5926a7c9cf5">&#9670;&nbsp;</a></span>ExtendedValue_from_BasicValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ExtendedValue_from_BasicValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>bval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a BasicValue into an ExtendedValue. </p>
<p>BASIC_INVALID, and other invalid BasicValues will return EXT_INVALID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bval</td><td>BasicValue to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ExtendedValue <code>0-15</code> on success, otherwise EXT_INVALID.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94" title="Convenience typedef for clarity when dealing with extended (256) colors. ">ExtendedValue</a> </dd></dl>

</div>
</div>
<a id="aaabf63956f397a0fe628313622ba5cde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaabf63956f397a0fe628313622ba5cde">&#9670;&nbsp;</a></span>ExtendedValue_from_esc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ExtendedValue_from_esc </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an escape-code string (<code>char*</code>) to an ExtendedValue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">Escape-code string.</p>
<p class="endtd"><em>Must be <code>null</code>-terminated</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">An</td><td>integer in the range <code>0-255</code> on success. </td></tr>
    <tr><td class="paramname">EXT_INVALID</td><td>on error (or if <code>s</code> is <code>NULL</code>). </td></tr>
    <tr><td class="paramname">EXT_INVALID_RANGE</td><td>if the code number was outside of the range <code>0-255</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94" title="Convenience typedef for clarity when dealing with extended (256) colors. ">ExtendedValue</a> </dd></dl>

</div>
</div>
<a id="a0632d78965000b1e50068a64e335133b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0632d78965000b1e50068a64e335133b">&#9670;&nbsp;</a></span>ExtendedValue_from_hex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ExtendedValue_from_hex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hexstr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an ExtendedValue from a hex string (<code>char*</code>). </p>
<p>This is not a 1:1 translation of hex to rgb. Use <a class="el" href="colr_8c.html#ad33884dcde034819c5e6749667247194" title="Convert a hex color into an RGB value. ">RGB_from_hex()</a> for that. This will convert the hex string to the closest matching ExtendedValue value.</p>
<p>The format for hex strings can be one of:</p><ul>
<li>"[#]ffffff" (Leading hash symbol is optional)</li>
<li>"[#]fff" (short-form)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hexstr</td><td>Hex string to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value between 0 and 255 on success. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">COLOR_INVALID</td><td>on error or bad values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94" title="Convenience typedef for clarity when dealing with extended (256) colors. ">ExtendedValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a757be189530b4925c84df25742374485">ExtendedValue_from_hex_default()</a>, and <a class="el" href="colr_8h.html#a2e859d542a8aa0939e4f76b1f33cb5f8">ExtendedValue_from_str()</a>.</p>

</div>
</div>
<a id="a757be189530b4925c84df25742374485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a757be189530b4925c84df25742374485">&#9670;&nbsp;</a></span>ExtendedValue_from_hex_default()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a> ExtendedValue_from_hex_default </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hexstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an ExtendedValue from a hex string (<code>char*</code>), but return a default value if the hex string is invalid. </p>
<p>This is not a 1:1 translation of hex to rgb. Use <a class="el" href="colr_8c.html#a6133112d9c73a8b56995e16e1af62d3b" title="Convert a hex color into an RGB value, but use a default value when errors occur. ...">RGB_from_hex_default()</a> for that. This will convert the hex string to the closest matching ExtendedValue value.</p>
<p>The format for hex strings can be one of:</p><ul>
<li>"[#]ffffff" (Leading hash symbol is optional)</li>
<li>"[#]fff" (short-form)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hexstr</td><td>Hex string to convert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_value</td><td>ExtendedValue to use for bad hex strings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ExtendedValue on success, or <code>default_value</code> on error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94" title="Convenience typedef for clarity when dealing with extended (256) colors. ">ExtendedValue</a> </dd>
<dd>
<a class="el" href="colr_8c.html#a0632d78965000b1e50068a64e335133b" title="Create an ExtendedValue from a hex string (char*). ">ExtendedValue_from_hex</a> </dd></dl>

</div>
</div>
<a id="a1548d9fc5f3e00a7b5d834eb1e12ff93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1548d9fc5f3e00a7b5d834eb1e12ff93">&#9670;&nbsp;</a></span>ExtendedValue_from_RGB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a> ExtendedValue_from_RGB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value into the closest matching ExtendedValue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ExtendedValue that closely matches the original <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94" title="Convenience typedef for clarity when dealing with extended (256) colors. ">ExtendedValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a0632d78965000b1e50068a64e335133b">ExtendedValue_from_hex()</a>, <a class="el" href="colr_8h.html#a185cec167afe41b6401206659d2d406c">format_bg_RGB_term()</a>, and <a class="el" href="colr_8h.html#a4661c576a4da879b8d4a2c525a42ad78">format_fg_RGB_term()</a>.</p>

</div>
</div>
<a id="a2e859d542a8aa0939e4f76b1f33cb5f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e859d542a8aa0939e4f76b1f33cb5f8">&#9670;&nbsp;</a></span>ExtendedValue_from_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ExtendedValue_from_str </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a known name, integer string (0-255), or a hex string (<code>char*</code>), into an ExtendedValue suitable for the extended-value-based functions. </p>
<p>Hex strings can be used:</p><ul>
<li>"#ffffff" (Leading hash symbol is <b>NOT</b> optional)</li>
<li>"#fff" (short-form)</li>
</ul>
<p>The `'#'` is not optional for hex strings because it is impossible to tell the difference between the hex value '111' and the extended value '111' without it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Color name to find the ExtendedValue for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value between 0 and 255 on success. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EXT_INVALID</td><td>on error or bad values. </td></tr>
    <tr><td class="paramname">EXT_INVALID_RANGE</td><td>if the number was outside of the range <code>0-255</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94" title="Convenience typedef for clarity when dealing with extended (256) colors. ">ExtendedValue</a> </dd></dl>

</div>
</div>
<a id="a669c8872f6b44a047470d33eb5d8b765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669c8872f6b44a047470d33eb5d8b765">&#9670;&nbsp;</a></span>ExtendedValue_is_invalid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ExtendedValue_is_invalid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether an integer is an invalid ExtendedValue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eval</td><td>A number to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is considered invalid, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94" title="Convenience typedef for clarity when dealing with extended (256) colors. ">ExtendedValue</a> </dd></dl>

</div>
</div>
<a id="a6b43e6ee55b05d9b73950794f2dd53a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b43e6ee55b05d9b73950794f2dd53a4">&#9670;&nbsp;</a></span>ExtendedValue_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ExtendedValue_is_valid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether an integer is a valid ExtendedValue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eval</td><td>A number to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is considered valid, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94" title="Convenience typedef for clarity when dealing with extended (256) colors. ">ExtendedValue</a> </dd></dl>

</div>
</div>
<a id="aa45baebc38756a40e7084f8198999902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa45baebc38756a40e7084f8198999902">&#9670;&nbsp;</a></span>ExtendedValue_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ExtendedValue_repr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation of a ExtendedValue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eval</td><td>A ExtendedValue to get the value from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">A pointer to an allocated string.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94" title="Convenience typedef for clarity when dealing with extended (256) colors. ">ExtendedValue</a> </dd></dl>

</div>
</div>
<a id="a4e334d6b9145fca9717fe5a2aeb542fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e334d6b9145fca9717fe5a2aeb542fe">&#9670;&nbsp;</a></span>ExtendedValue_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ExtendedValue_to_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>&#160;</td>
          <td class="paramname"><em>eval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a human-friendly string (<code>char*</code>) from an ExtendedValue's actual value, suitable for use with <a class="el" href="colr_8c.html#a2e859d542a8aa0939e4f76b1f33cb5f8" title="Converts a known name, integer string (0-255), or a hex string (char*), into an ExtendedValue suitabl...">ExtendedValue_from_str()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eval</td><td>A ExtendedValue to get the value from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">A pointer to an allocated string<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94" title="Convenience typedef for clarity when dealing with extended (256) colors. ">ExtendedValue</a> </dd></dl>

</div>
</div>
<a id="ae29032483aea8cb25d6b90750767ffc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae29032483aea8cb25d6b90750767ffc1">&#9670;&nbsp;</a></span>format_bg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_bg </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for a background color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. <em>Must have enough room for <code>CODEX_LEN</code></em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>BasicValue value to use for background. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97257ad40619df6a6c190890ff2873c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97257ad40619df6a6c190890ff2873c4">&#9670;&nbsp;</a></span>format_bg_RGB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_bg_RGB </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for a true color (rgb) background color using values from an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. <em>Must have enough room for <code>CODE_RGB_LEN</code></em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct to get red, blue, and green values from. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ab88ca919420f2df896b7973401641ab4">_rainbow()</a>, and <a class="el" href="colr_8h.html#ab39e0b3981b4f0a8a113c6949bc8b103">rainbow_bg()</a>.</p>

</div>
</div>
<a id="a185cec167afe41b6401206659d2d406c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a185cec167afe41b6401206659d2d406c">&#9670;&nbsp;</a></span>format_bg_RGB_term()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_bg_RGB_term </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for a true color (rgb) fore color using an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct's values, approximating 256-color values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td>Pointer to an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ab88ca919420f2df896b7973401641ab4">_rainbow()</a>, and <a class="el" href="colr_8h.html#adf264c63c394f9ecb19cd8565cda7197">rainbow_bg_term()</a>.</p>

</div>
</div>
<a id="aa4853b53fa18d26741ab7178606e5724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4853b53fa18d26741ab7178606e5724">&#9670;&nbsp;</a></span>format_bgx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_bgx </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for an extended background color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. <em>Must have enough room for <code>CODEX_LEN</code></em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>Value to use for background. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a185cec167afe41b6401206659d2d406c">format_bg_RGB_term()</a>.</p>

</div>
</div>
<a id="a6027d93e8768f3c152edafd92e757801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6027d93e8768f3c152edafd92e757801">&#9670;&nbsp;</a></span>format_fg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_fg </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for a fore color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. <em>Must have enough room for <code>CODEX_LEN</code></em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>BasicValue value to use for fore. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3391a0cd6b6f73d9d39f8179fc0eb0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3391a0cd6b6f73d9d39f8179fc0eb0b">&#9670;&nbsp;</a></span>format_fg_RGB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_fg_RGB </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for a true color (rgb) fore color using an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct's values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td>Pointer to an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ac50eca5901ca237550cf4129237a3411">rainbow_fg()</a>.</p>

</div>
</div>
<a id="a4661c576a4da879b8d4a2c525a42ad78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4661c576a4da879b8d4a2c525a42ad78">&#9670;&nbsp;</a></span>format_fg_RGB_term()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_fg_RGB_term </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for a true color (rgb) fore color using an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct's values, approximating 256-color values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td>Pointer to an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a5a24d379435d64d1212858b173e6f9a7">rainbow_fg_term()</a>.</p>

</div>
</div>
<a id="acfd2cf68768c59fc3ed5c31b93590c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfd2cf68768c59fc3ed5c31b93590c53">&#9670;&nbsp;</a></span>format_fgx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_fgx </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for an extended fore color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. <em>Must have enough room for <code>CODEX_LEN</code></em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>Value to use for fore. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a4661c576a4da879b8d4a2c525a42ad78">format_fg_RGB_term()</a>.</p>

</div>
</div>
<a id="a6aec8e6a80b4ca158df2ad20e3e6a59e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aec8e6a80b4ca158df2ad20e3e6a59e">&#9670;&nbsp;</a></span>format_style()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_style </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>&#160;</td>
          <td class="paramname"><em>style</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for a style. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. <em>Must have enough room for <code>STYLE_LEN</code></em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">style</td><td>StyleValue value to use for style. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab39e0b3981b4f0a8a113c6949bc8b103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab39e0b3981b4f0a8a113c6949bc8b103">&#9670;&nbsp;</a></span>rainbow_bg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* rainbow_bg </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>spread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rainbow-ize some text using rgb back colors, lolcat style. </p>
<p>This prepends a color code to every character in the string. Multi-byte characters are handled properly by checking <a class="el" href="colr_8c.html#ade675256d9e88682d4bebdcc4a57f86f" title="Like mbrlen, except it will return the length of the next N (length) multibyte characters in bytes...">colr_mb_len()</a>, and copying the bytes to the resulting string without codes between the multibyte characters.</p>
<p>The <code>CODE_RESET_ALL</code> code is appended to the result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">The string to colorize.</p>
<p class="endtd">Input <em>must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freq</td><td>Frequency ("tightness") for the colors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Starting offset in the rainbow. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spread</td><td>Number of characters per color. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">The allocated/formatted string on success.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>

</div>
</div>
<a id="adf264c63c394f9ecb19cd8565cda7197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf264c63c394f9ecb19cd8565cda7197">&#9670;&nbsp;</a></span>rainbow_bg_term()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* rainbow_bg_term </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>spread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is exactly like <a class="el" href="colr_8c.html#ab39e0b3981b4f0a8a113c6949bc8b103" title="Rainbow-ize some text using rgb back colors, lolcat style. ">rainbow_bg()</a>, except it uses colors that are closer to the standard 256-color values. </p>
<p>This prepends a color code to every character in the string. Multi-byte characters are handled properly by checking <a class="el" href="colr_8c.html#ade675256d9e88682d4bebdcc4a57f86f" title="Like mbrlen, except it will return the length of the next N (length) multibyte characters in bytes...">colr_mb_len()</a>, and copying the bytes to the resulting string without codes between the multibyte characters.</p>
<p>The <code>CODE_RESET_ALL</code> code is appended to the result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">The string to colorize.</p>
<p class="endtd">Input <em>must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freq</td><td>Frequency ("tightness") for the colors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Starting offset in the rainbow. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spread</td><td>Number of characters per color. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">The allocated/formatted string on success.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>

</div>
</div>
<a id="ac50eca5901ca237550cf4129237a3411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac50eca5901ca237550cf4129237a3411">&#9670;&nbsp;</a></span>rainbow_fg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* rainbow_fg </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>spread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rainbow-ize some text using rgb fore colors, lolcat style. </p>
<p>This prepends a color code to every character in the string. Multi-byte characters are handled properly by checking <a class="el" href="colr_8c.html#ade675256d9e88682d4bebdcc4a57f86f" title="Like mbrlen, except it will return the length of the next N (length) multibyte characters in bytes...">colr_mb_len()</a>, and copying the bytes to the resulting string without codes between the multibyte characters.</p>
<p>The <code>CODE_RESET_ALL</code> code is appended to the result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">The string to colorize.</p>
<p class="endtd">Input <em>must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freq</td><td>Frequency ("tightness") for the colors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Starting offset in the rainbow. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spread</td><td>Number of characters per color. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">The allocated/formatted string on success.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>

</div>
</div>
<a id="a5a24d379435d64d1212858b173e6f9a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a24d379435d64d1212858b173e6f9a7">&#9670;&nbsp;</a></span>rainbow_fg_term()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* rainbow_fg_term </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>spread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is exactly like <a class="el" href="colr_8c.html#ac50eca5901ca237550cf4129237a3411" title="Rainbow-ize some text using rgb fore colors, lolcat style. ">rainbow_fg()</a>, except it uses colors that are closer to the standard 256-color values. </p>
<p>This prepends a color code to every character in the string. Multi-byte characters are handled properly by checking <a class="el" href="colr_8c.html#ade675256d9e88682d4bebdcc4a57f86f" title="Like mbrlen, except it will return the length of the next N (length) multibyte characters in bytes...">colr_mb_len()</a>, and copying the bytes to the resulting string without codes between the multibyte characters.</p>
<p>The <code>CODE_RESET_ALL</code> code is appended to the result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">The string to colorize.</p>
<p class="endtd">Input <em>must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freq</td><td>Frequency ("tightness") for the colors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Starting offset in the rainbow. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spread</td><td>Number of characters per color. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">The allocated/formatted string on success.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>

</div>
</div>
<a id="a3580f33d058571dffd8e5ff789c49296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3580f33d058571dffd8e5ff789c49296">&#9670;&nbsp;</a></span>rainbow_step()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structRGB">RGB</a> rainbow_step </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A single step in rainbow-izing produces the next color in the "rainbow" as an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">freq</td><td>Frequency ("tightness") of the colors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Starting offset in the rainbow.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value with the next "step" in the "rainbow". </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ab88ca919420f2df896b7973401641ab4">_rainbow()</a>.</p>

</div>
</div>
<a id="a0d649fff907b84a625db3fc3b3ae545e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d649fff907b84a625db3fc3b3ae545e">&#9670;&nbsp;</a></span>RGB_average()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char RGB_average </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the average for an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value. </p>
<p>This is also it's "grayscale" value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td>The <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value to get the average for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value between <code>0-255</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a49ce6e92a3b495166213e203ad3ab846">RGB_grayscale()</a>.</p>

</div>
</div>
<a id="ad4b5f73b8aa9d72216d7386221418ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b5f73b8aa9d72216d7386221418ae1">&#9670;&nbsp;</a></span>RGB_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RGB_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> structs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>a</code> and <code>b</code> have the same <code>r</code>, <code>g</code>, and <code>b</code> values, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#adf57e195301864cec80739e7e0f3000c">ColorValue_eq()</a>, and <a class="el" href="colr_8h.html#a1548d9fc5f3e00a7b5d834eb1e12ff93">ExtendedValue_from_RGB()</a>.</p>

</div>
</div>
<a id="ac5fbdea47463b284cbc9b1242ace4f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5fbdea47463b284cbc9b1242ace4f1e">&#9670;&nbsp;</a></span>RGB_from_BasicValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structRGB">RGB</a> RGB_from_BasicValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>bval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value from a known BasicValue. </p>
<p>Terminals use different values to render basic 3/4-bit escape-codes. The values returned from this function match the names found in <code>colr_name_data[]</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bval</td><td>A BasicValue to get the <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value that matches the BasicValue's color.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

</div>
</div>
<a id="a252adee47cc218a9208f16cb0ff42bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a252adee47cc218a9208f16cb0ff42bfe">&#9670;&nbsp;</a></span>RGB_from_esc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RGB_from_esc </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a> *&#160;</td>
          <td class="paramname"><em>rgb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an escape-code string (<code>char*</code>) to an actual <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">Escape-code string.</p>
<p class="endtd"><em>Must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rgb</td><td>Pointer to an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct to fill in the values for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&lt;tt&gt;0&lt;/tt&gt;</td><td>on success, with <code>rgb</code> filled with values. </td></tr>
    <tr><td class="paramname">COLOR_INVALID</td><td>on error (or if <code>s</code> is <code>NULL</code>). </td></tr>
    <tr><td class="paramname">COLOR_INVALID_RANGE</td><td>if any code numbers were outside of the range <code>0-255</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

</div>
</div>
<a id="ab857a1ddce9743c1ef6d54d39e890275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab857a1ddce9743c1ef6d54d39e890275">&#9670;&nbsp;</a></span>RGB_from_ExtendedValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structRGB">RGB</a> RGB_from_ExtendedValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>&#160;</td>
          <td class="paramname"><em>eval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value from a known ExtendedValue. </p>
<p>This is just a type/bounds-checked alias for <code>ext2rgb_map[eval]</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eval</td><td>An ExtendedValue to get the <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value from <code>ext2rgb_map[]</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

</div>
</div>
<a id="ad33884dcde034819c5e6749667247194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad33884dcde034819c5e6749667247194">&#9670;&nbsp;</a></span>RGB_from_hex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RGB_from_hex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hexstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a> *&#160;</td>
          <td class="paramname"><em>rgb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a hex color into an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value. </p>
<p>The format for hex strings can be one of:</p><ul>
<li>"[#]ffffff" (Leading hash symbol is optional)</li>
<li>"[#]fff" (short-form)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hexstr</td><td><p class="starttd">String to check for hex values.</p>
<p class="endtd">Input <em>must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rgb</td><td>Pointer to an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct to fill in the values for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success, with <code>rgb</code> filled with the values. </td></tr>
    <tr><td class="paramname">COLOR_INVALID</td><td>for non-hex strings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a0632d78965000b1e50068a64e335133b">ExtendedValue_from_hex()</a>, <a class="el" href="colr_8h.html#a6133112d9c73a8b56995e16e1af62d3b">RGB_from_hex_default()</a>, and <a class="el" href="colr_8h.html#a98c9e50fe14ad0c82bcf1a62699c05de">RGB_from_str()</a>.</p>

</div>
</div>
<a id="a6133112d9c73a8b56995e16e1af62d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6133112d9c73a8b56995e16e1af62d3b">&#9670;&nbsp;</a></span>RGB_from_hex_default()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structRGB">RGB</a> RGB_from_hex_default </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hexstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a hex color into an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value, but use a default value when errors occur. </p>
<p>The format for hex strings can be one of:</p><ul>
<li>"[#]ffffff" (Leading hash symbol is optional)</li>
<li>"[#]fff" (short-form)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hexstr</td><td><p class="starttd">String to check for <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> values.</p>
<p class="endtd">Input <em>must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">default_value</td><td>An <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value to use when errors occur.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A valid <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value on success, or <code>default_value</code> on error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a8fe812f8e76e4baed394ee9adf46b3df" title="Use RGB_from_hex_default() to create an RGB value. ">hex</a> </dd></dl>

</div>
</div>
<a id="a98c9e50fe14ad0c82bcf1a62699c05de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c9e50fe14ad0c82bcf1a62699c05de">&#9670;&nbsp;</a></span>RGB_from_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RGB_from_str </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a> *&#160;</td>
          <td class="paramname"><em>rgb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> string (<code>char*</code>) into an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value. </p>
<p>The format for <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> strings can be one of:</p><ul>
<li>"RED,GREEN,BLUE"</li>
<li>"RED GREEN BLUE"</li>
<li>"RED:GREEN:BLUE"</li>
<li>"RED;GREEN;BLUE" Or hex strings can be used:</li>
<li>"#ffffff" (Leading hash symbol is <b>NOT</b> optional)</li>
<li>"#fff" (short-form)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td><p class="starttd">String to check for <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> values.</p>
<p class="endtd">Input <em>must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rgb</td><td>Pointer to an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct to fill in the values for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success, with <code>rgb</code> filled with the values. </td></tr>
    <tr><td class="paramname">COLOR_INVALID</td><td>for non-rgb strings. </td></tr>
    <tr><td class="paramname">COLOR_INVALID_RANGE</td><td>for rgb values outside of 0-255.</td></tr>
  </table>
  </dd>
</dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#RGB_from_str-example" id="RGB_from_str-example" class="diamond-bullet">&#160;</a> RGB_from_str example: </div><div class="fragment"><div class="line"><a class="code" href="colr_8h.html#structRGB">RGB</a> rgbval;</div><div class="line"><span class="keywordtype">int</span> ret = <a class="code" href="colr_8c.html#a98c9e50fe14ad0c82bcf1a62699c05de">RGB_from_str</a>(<span class="stringliteral">&quot;123,0,234&quot;</span>, &amp;rgbval);</div><div class="line"><span class="keywordflow">if</span> (ret == 0) {</div><div class="line">    <span class="keywordtype">char</span>* s = <a class="code" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa">colr_cat</a>(<a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;Test&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(rgbval)));</div><div class="line">    printf(<span class="stringliteral">&quot;%s\n&quot;</span>, s);</div><div class="line">    free(s);</div><div class="line">}</div></div><!-- fragment --> </div> <dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

</div>
</div>
<a id="a49ce6e92a3b495166213e203ad3ab846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ce6e92a3b495166213e203ad3ab846">&#9670;&nbsp;</a></span>RGB_grayscale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structRGB">RGB</a> RGB_grayscale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grayscale version of an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td>The <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A grayscale <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

</div>
</div>
<a id="a958e45854d69e8b59859244ce791673c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a958e45854d69e8b59859244ce791673c">&#9670;&nbsp;</a></span>RGB_inverted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structRGB">RGB</a> RGB_inverted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a copy of an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value, with the colors "inverted" (like highlighting text in the terminal). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td>The <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value to invert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An "inverted" <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

</div>
</div>
<a id="abd85b5c5b79142c8656a065c58e4509e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd85b5c5b79142c8656a065c58e4509e">&#9670;&nbsp;</a></span>RGB_monochrome()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structRGB">RGB</a> RGB_monochrome </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value into either black or white, depending on it's average grayscale value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td>The <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either <code><a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57" title="Creates an anonymous RGB struct for use in function calls. ">rgb(1, 1, 1)</a></code> or <code><a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57" title="Creates an anonymous RGB struct for use in function calls. ">rgb(255, 255, 255)</a></code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

</div>
</div>
<a id="afd28864afbcfa4a344e4596130645177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd28864afbcfa4a344e4596130645177">&#9670;&nbsp;</a></span>RGB_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* RGB_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation for an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value. </p>
<p>Allocates memory for the string representation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct to get the representation for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">Allocated string for the representation.</p>
<p class="enddd"><em>You must <code>free()</code> the memory allocated by this function.</em> </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

</div>
</div>
<a id="a95e4feb89e009f00cfe7e74a55fab56f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e4feb89e009f00cfe7e74a55fab56f">&#9670;&nbsp;</a></span>RGB_to_hex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* RGB_to_hex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value into a hex string (<code>char*</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string.</dd></dl>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p><em>If allocation fails, <code>NULL</code> is returned</em>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

</div>
</div>
<a id="a16d2f9a1133c8a955f0a551870d7ebe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16d2f9a1133c8a955f0a551870d7ebe8">&#9670;&nbsp;</a></span>RGB_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* RGB_to_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value into a human-friendly <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> string (<code>char*</code>) suitable for input to <a class="el" href="colr_8c.html#a98c9e50fe14ad0c82bcf1a62699c05de" title="Convert an RGB string (char*) into an RGB value. ">RGB_from_str()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string in the form <code>"red;green;blue"</code>.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

</div>
</div>
<a id="ab4576c531151e398b7ecede2e30df70d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4576c531151e398b7ecede2e30df70d">&#9670;&nbsp;</a></span>RGB_to_term_RGB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structRGB">RGB</a> RGB_to_term_RGB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value into it's nearest terminal-friendly <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value. </p>
<p>This is a helper for the 'to_term' functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> with values close to a terminal code color.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a1548d9fc5f3e00a7b5d834eb1e12ff93">ExtendedValue_from_RGB()</a>.</p>

</div>
</div>
<a id="a32bf31475b0f6264b45438bd5c09ee7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32bf31475b0f6264b45438bd5c09ee7d">&#9670;&nbsp;</a></span>StyleValue_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool StyleValue_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two StyleValues. </p>
<p>This is used to implement <a class="el" href="colr_8h.html#a36af8aa0f01eaa780da182e856923faa" title="Calls the &lt;type&gt;_eq functions for the supported types. ">colr_eq()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first StyleValue to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second StyleValue to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if they are equal, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6" title="Style values. ">StyleValue</a> </dd></dl>

</div>
</div>
<a id="a9f4fd7f8901569c053bd29f2035c69b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f4fd7f8901569c053bd29f2035c69b7">&#9670;&nbsp;</a></span>StyleValue_from_esc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a> StyleValue_from_esc </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an escape-code string (<code>char*</code>) to an actual StyleValue enum value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">Escape-code string.</p>
<p class="endtd"><em>Must be <code>null</code>-terminated</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">StyleValue</td><td>value on success. </td></tr>
    <tr><td class="paramname">STYLE_INVALID</td><td>on error (or if <code>s</code> is <code>NULL</code>). </td></tr>
    <tr><td class="paramname">STYLE_INVALID_RANGE</td><td>if the code number was outside of the range <code>0-255</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6" title="Style values. ">StyleValue</a> </dd></dl>

</div>
</div>
<a id="a4ca63735ad2cbc6475d4af83dc7c1a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ca63735ad2cbc6475d4af83dc7c1a9b">&#9670;&nbsp;</a></span>StyleValue_from_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a> StyleValue_from_str </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a named argument to actual StyleValue enum value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Style name to convert into a StyleValue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A usable StyleValue value on success, or STYLE_INVALID on error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6" title="Style values. ">StyleValue</a> </dd></dl>

</div>
</div>
<a id="a3f8126147490f88283a53e9ef48d33f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f8126147490f88283a53e9ef48d33f0">&#9670;&nbsp;</a></span>StyleValue_is_invalid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool StyleValue_is_invalid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>&#160;</td>
          <td class="paramname"><em>sval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a StyleValue is invalid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sval</td><td>A StyleValue to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is considered invalid, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6" title="Style values. ">StyleValue</a> </dd></dl>

</div>
</div>
<a id="a2d6598b05bc5c742fbb94b47d8a3213a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d6598b05bc5c742fbb94b47d8a3213a">&#9670;&nbsp;</a></span>StyleValue_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool StyleValue_is_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>&#160;</td>
          <td class="paramname"><em>sval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a StyleValue is valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sval</td><td>A StyleValue to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is considered valid, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6" title="Style values. ">StyleValue</a> </dd></dl>

</div>
</div>
<a id="a24b74664587dd3c0e981603ee75c331b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b74664587dd3c0e981603ee75c331b">&#9670;&nbsp;</a></span>StyleValue_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* StyleValue_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>&#160;</td>
          <td class="paramname"><em>sval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation of a StyleValue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sval</td><td>A StyleValue to get the value from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">A pointer to an allocated string.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6" title="Style values. ">StyleValue</a> </dd></dl>

</div>
</div>
<a id="ac767fb032c9617e2830cc5e13e66c400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac767fb032c9617e2830cc5e13e66c400">&#9670;&nbsp;</a></span>StyleValue_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* StyleValue_to_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>&#160;</td>
          <td class="paramname"><em>sval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a human-friendly string (<code>char*</code>) representation for a StyleValue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sval</td><td>StyleValue to get the name for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6" title="Style values. ">StyleValue</a> </dd></dl>

</div>
</div>
<a id="a41b4ed49acc5d806f161a3b31f5bf023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b4ed49acc5d806f161a3b31f5bf023">&#9670;&nbsp;</a></span>TermSize_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* TermSize_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structTermSize">TermSize</a>&#160;</td>
          <td class="paramname"><em>ts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a string (<code>char*</code>) representation for a <a class="el" href="colr_8h.html#structTermSize" title="Holds a terminal size, usually retrieved with colr_term_size(). ">TermSize</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td><a class="el" href="colr_8h.html#structTermSize" title="Holds a terminal size, usually retrieved with colr_term_size(). ">TermSize</a> to get the representation for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structTermSize" title="Holds a terminal size, usually retrieved with colr_term_size(). ">TermSize</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a3a3db0fb0c98d24ec072dfed5f88d717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a3db0fb0c98d24ec072dfed5f88d717">&#9670;&nbsp;</a></span>basic_names</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="colr_8h.html#structBasicInfo">BasicInfo</a> basic_names[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">    {<span class="stringliteral">&quot;reset&quot;</span>, RESET},</div><div class="line">    {<span class="stringliteral">&quot;none&quot;</span>, RESET},</div><div class="line">    {<span class="stringliteral">&quot;black&quot;</span>, BLACK},</div><div class="line">    {<span class="stringliteral">&quot;blue&quot;</span>, BLUE},</div><div class="line">    {<span class="stringliteral">&quot;cyan&quot;</span>, CYAN},</div><div class="line">    {<span class="stringliteral">&quot;green&quot;</span>, GREEN},</div><div class="line">    {<span class="stringliteral">&quot;magenta&quot;</span>, MAGENTA},</div><div class="line">    {<span class="stringliteral">&quot;red&quot;</span>, RED},</div><div class="line">    {<span class="stringliteral">&quot;white&quot;</span>, WHITE},</div><div class="line">    {<span class="stringliteral">&quot;normal&quot;</span>, WHITE},</div><div class="line">    {<span class="stringliteral">&quot;yellow&quot;</span>, YELLOW},</div><div class="line">    {<span class="stringliteral">&quot;lightblack&quot;</span>, LIGHTBLACK},</div><div class="line">    {<span class="stringliteral">&quot;lightblue&quot;</span>, LIGHTBLUE},</div><div class="line">    {<span class="stringliteral">&quot;lightcyan&quot;</span>, LIGHTCYAN},</div><div class="line">    {<span class="stringliteral">&quot;lightgreen&quot;</span>, LIGHTGREEN},</div><div class="line">    {<span class="stringliteral">&quot;lightmagenta&quot;</span>, LIGHTMAGENTA},</div><div class="line">    {<span class="stringliteral">&quot;lightred&quot;</span>, LIGHTRED},</div><div class="line">    {<span class="stringliteral">&quot;lightwhite&quot;</span>, LIGHTWHITE},</div><div class="line">    {<span class="stringliteral">&quot;lightnormal&quot;</span>, LIGHTWHITE},</div><div class="line">    {<span class="stringliteral">&quot;lightyellow&quot;</span>, LIGHTYELLOW},</div><div class="line">    {NULL, RESET},</div><div class="line">}</div></div><!-- fragment -->
<p>An array of <a class="el" href="colr_8h.html#structBasicInfo" title="Holds a known color name and it&#39;s BasicValue. ">BasicInfo</a> items, used with <a class="el" href="colr_8c.html#a4163ac65dca3e222525808b80a40b733" title="Convert named argument to an actual BasicValue enum value. ">BasicValue_from_str()</a>. </p>

</div>
</div>
<a id="a62b38c28aba614d1bd1706d6099df0e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b38c28aba614d1bd1706d6099df0e6">&#9670;&nbsp;</a></span>colr_printf_esc_mod</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int colr_printf_esc_mod = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integer to test for the presence of the "escaped output modifier" in colr_printf_handler. </p>
<p>It is used to trigger "escaped output mode" when printing ColrC objects, where the color codes are escaped so you can see what they look like (instead of affecting the terminal).</p>
<p>The character used as the "escaped output modifier" is COLR_FMT_MOD_ESC, from <a class="el" href="colr_8h.html" title="Declarations for ColrC functions, enums, structs, etc. ">colr.h</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>This is for ColrC only. You should have no reason to use or modify this variable.</dd></dl>
<p>This is set in colr_printf_register when the modifier is registered. On a successful call to register_printf_modifier, it will be a positive number representing the bit set in the USER field in 'struct printf_info'. So later on, in <a class="el" href="colr_8c.html#a34c359a48f811316d765b7abef1ea8f4" title="Handles printing with printf for Colr objects. ">colr_printf_handler()</a>: </p><div class="fragment"><div class="line">using_escape_modifier = (info-&gt;user &amp; <a class="code" href="colr_8c.html#a62b38c28aba614d1bd1706d6099df0e6">colr_printf_esc_mod</a>);</div></div><!-- fragment --> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a34c359a48f811316d765b7abef1ea8f4">colr_printf_handler()</a>, and <a class="el" href="colr_8h.html#aaaf134ca9a2188d83171fe91948354d9">colr_printf_register()</a>.</p>

</div>
</div>
<a id="afb4b773fe2fc7907fdfcf5ef9b202758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4b773fe2fc7907fdfcf5ef9b202758">&#9670;&nbsp;</a></span>ext2rgb_map</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="colr_8h.html#structRGB">RGB</a> ext2rgb_map[]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A map from ExtendedValue (256-color) to <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value, where the index is the is the ExtendedValue, and the value is the <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a>. </p>
<p>This is used in several RGB/ExtendedValue functions.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#a1548d9fc5f3e00a7b5d834eb1e12ff93" title="Convert an RGB value into the closest matching ExtendedValue. ">ExtendedValue_from_RGB</a> </dd>
<dd>
<a class="el" href="colr_8c.html#ab4576c531151e398b7ecede2e30df70d" title="Convert an RGB value into it&#39;s nearest terminal-friendly RGB value. ">RGB_to_term_RGB</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#ext2rgb_map-example" id="ext2rgb_map-example" class="diamond-bullet">&#160;</a> ext2rgb_map example: </div><div class="fragment"><div class="line"><span class="comment">// Fast map an ExtendedValue to an RGB value.</span></div><div class="line"><a class="code" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a> eval = 9; <span class="comment">// 9 happens to be XRED (255;85;85 in RGB).</span></div><div class="line"><a class="code" href="colr_8h.html#structRGB">RGB</a> rgbval = <a class="code" href="colr_8c.html#afb4b773fe2fc7907fdfcf5ef9b202758">ext2rgb_map</a>[eval];</div><div class="line"></div><div class="line"><span class="comment">// The result from ExtendedValue_from_RGB should always match the map.</span></div><div class="line">assert(<a class="code" href="colr_8c.html#a1548d9fc5f3e00a7b5d834eb1e12ff93">ExtendedValue_from_RGB</a>(rgbval) == eval);</div></div><!-- fragment --> </div> 
</div>
</div>
<a id="abffaf3629342a2b3e9cb7ea53c12c4f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abffaf3629342a2b3e9cb7ea53c12c4f0">&#9670;&nbsp;</a></span>extended_names</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="colr_8h.html#structExtendedInfo">ExtendedInfo</a> extended_names[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">    {<span class="stringliteral">&quot;xred&quot;</span>, XRED},</div><div class="line">    {<span class="stringliteral">&quot;xgreen&quot;</span>, XGREEN},</div><div class="line">    {<span class="stringliteral">&quot;xyellow&quot;</span>, XYELLOW},</div><div class="line">    {<span class="stringliteral">&quot;xblue&quot;</span>, XBLUE},</div><div class="line">    {<span class="stringliteral">&quot;xmagenta&quot;</span>, XMAGENTA},</div><div class="line">    {<span class="stringliteral">&quot;xcyan&quot;</span>, XCYAN},</div><div class="line">    {<span class="stringliteral">&quot;xwhite&quot;</span>, XWHITE},</div><div class="line">    {<span class="stringliteral">&quot;xnormal&quot;</span>, XWHITE},</div><div class="line">    {<span class="stringliteral">&quot;xlightred&quot;</span>, XLIGHTRED},</div><div class="line">    {<span class="stringliteral">&quot;xlightgreen&quot;</span>, XLIGHTGREEN},</div><div class="line">    {<span class="stringliteral">&quot;xlightyellow&quot;</span>, XLIGHTYELLOW},</div><div class="line">    {<span class="stringliteral">&quot;xlightblack&quot;</span>, XLIGHTBLACK},</div><div class="line">    {<span class="stringliteral">&quot;xlightblue&quot;</span>, XLIGHTBLUE},</div><div class="line">    {<span class="stringliteral">&quot;xlightmagenta&quot;</span>, XLIGHTMAGENTA},</div><div class="line">    {<span class="stringliteral">&quot;xlightwhite&quot;</span>, XLIGHTWHITE},</div><div class="line">    {<span class="stringliteral">&quot;xlightnormal&quot;</span>, XLIGHTWHITE},</div><div class="line">    {<span class="stringliteral">&quot;xlightcyan&quot;</span>, XLIGHTCYAN},</div><div class="line">    {NULL, RESET},</div><div class="line">}</div></div><!-- fragment -->
<p>An array of <a class="el" href="colr_8h.html#structExtendedInfo" title="Holds a known color name and it&#39;s ExtendedValue. ">ExtendedInfo</a>, used with <a class="el" href="colr_8c.html#a2e859d542a8aa0939e4f76b1f33cb5f8" title="Converts a known name, integer string (0-255), or a hex string (char*), into an ExtendedValue suitabl...">ExtendedValue_from_str()</a>. </p>

</div>
</div>
<a id="a9303c010fd45eab23c7903d1175ae20a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9303c010fd45eab23c7903d1175ae20a">&#9670;&nbsp;</a></span>style_names</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="colr_8h.html#structStyleInfo">StyleInfo</a> style_names[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">    </div><div class="line">    </div><div class="line">    {<span class="stringliteral">&quot;reset&quot;</span>, RESET_ALL},</div><div class="line">    {<span class="stringliteral">&quot;none&quot;</span>, RESET_ALL},</div><div class="line">    {<span class="stringliteral">&quot;resetall&quot;</span>, RESET_ALL},</div><div class="line">    {<span class="stringliteral">&quot;reset-all&quot;</span>, RESET_ALL},</div><div class="line">    {<span class="stringliteral">&quot;reset_all&quot;</span>, RESET_ALL},</div><div class="line">    {<span class="stringliteral">&quot;bold&quot;</span>, BRIGHT},</div><div class="line">    {<span class="stringliteral">&quot;bright&quot;</span>, BRIGHT},</div><div class="line">    {<span class="stringliteral">&quot;dim&quot;</span>, DIM},</div><div class="line">    {<span class="stringliteral">&quot;italic&quot;</span>, ITALIC},</div><div class="line">    {<span class="stringliteral">&quot;underline&quot;</span>, UNDERLINE},</div><div class="line">    {<span class="stringliteral">&quot;flash&quot;</span>, FLASH},</div><div class="line">    {<span class="stringliteral">&quot;highlight&quot;</span>, HIGHLIGHT},</div><div class="line">    {<span class="stringliteral">&quot;normal&quot;</span>, NORMAL},</div><div class="line">    {<span class="stringliteral">&quot;strikethru&quot;</span>, STRIKETHRU},</div><div class="line">    {<span class="stringliteral">&quot;strike&quot;</span>, STRIKETHRU},</div><div class="line">    {<span class="stringliteral">&quot;strikethrough&quot;</span>, STRIKETHRU},</div><div class="line">    {<span class="stringliteral">&quot;frame&quot;</span>, FRAME},</div><div class="line">    {<span class="stringliteral">&quot;encircle&quot;</span>, ENCIRCLE},</div><div class="line">    {<span class="stringliteral">&quot;circle&quot;</span>, ENCIRCLE},</div><div class="line">    {<span class="stringliteral">&quot;overline&quot;</span>, OVERLINE},</div><div class="line">    {NULL, RESET_ALL},</div><div class="line">}</div></div><!-- fragment -->
<p>An array of <a class="el" href="colr_8h.html#structStyleInfo" title="Holds a known style name and it&#39;s StyleValue. ">StyleInfo</a> items, used with StyleName_from_str(). </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="colr_8c.html">colr.c</a></li>
    <li class="footer">Generated by
        <a href="http://www.doxygen.org/index.html">
        Doxygen <!-- <img class="footer" src="doxygen.png" alt="doxygen"/> -->
        </a>
        1.8.13
    </li>
    <!-- This actually comes *before* the "generated by" msg, because of float. -->
    <li class="footer">
        ColrC v.0.3.7
    </li>
  </ul>
</div>
</body>
</html>
