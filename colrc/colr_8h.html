<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ColrC: colr.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="colrc-pixels.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ColrC
   &#160;<span id="projectnumber">0.3.6</span>
   </div>
   <div id="projectbrief">An easy to use C library for linux terminal colors/escape-codes.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('colr_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">colr.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<h3 class="version">(0.3.6)</h3>
<p>Declarations for ColrC functions, enums, structs, etc.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;assert.h&gt;</code><br />
<code>#include &lt;ctype.h&gt;</code><br />
<code>#include &lt;math.h&gt;</code><br />
<code>#include &lt;limits.h&gt;</code><br />
<code>#include &lt;locale.h&gt;</code><br />
<code>#include &lt;printf.h&gt;</code><br />
<code>#include &lt;regex.h&gt;</code><br />
<code>#include &lt;stdarg.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;sys/ioctl.h&gt;</code><br />
<code>#include &lt;unistd.h&gt;</code><br />
<code>#include &lt;wchar.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="colr_8h__dep__incl.png" border="0" usemap="#colr_8hdep" alt=""/></div>
<map name="colr_8hdep" id="colr_8hdep">
<area shape="rect" id="node2" href="colr_8c.html" title="Implements everything in the colr.h header. " alt="" coords="5,80,59,107"/>
</map>
</div>
</div>
<p><a href="colr_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structBasicInfo"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#structBasicInfo">BasicInfo</a></td></tr>
<tr class="memdesc:structBasicInfo"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a known color name and it's <code>BasicValue</code>.  <a href="colr_8h.html#structBasicInfo">More...</a><br /></td></tr>
<tr class="separator:structBasicInfo"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structColorArg"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a></td></tr>
<tr class="memdesc:structColorArg"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds an ArgType, and a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>.  <a href="colr_8h.html#structColorArg">More...</a><br /></td></tr>
<tr class="separator:structColorArg"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structColorJustify"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a></td></tr>
<tr class="memdesc:structColorJustify"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a string justification method, width, and padding character for ColorTexts.  <a href="colr_8h.html#structColorJustify">More...</a><br /></td></tr>
<tr class="separator:structColorJustify"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structColorNameData"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#structColorNameData">ColorNameData</a></td></tr>
<tr class="memdesc:structColorNameData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds info about a known color name, like it's ExtendedValue and it's <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.  <a href="colr_8h.html#structColorNameData">More...</a><br /></td></tr>
<tr class="separator:structColorNameData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structColorResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a></td></tr>
<tr class="memdesc:structColorResult"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a string (<code>char*</code>) that was definitely allocated by Colr.  <a href="colr_8h.html#structColorResult">More...</a><br /></td></tr>
<tr class="separator:structColorResult"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:unionColorStructMarker"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#unionColorStructMarker">ColorStructMarker</a></td></tr>
<tr class="memdesc:unionColorStructMarker"><td class="mdescLeft">&#160;</td><td class="mdescRight">Breaks down Colr struct markers, such as COLORARG_MARKER, into individual bytes.  <a href="colr_8h.html#unionColorStructMarker">More...</a><br /></td></tr>
<tr class="separator:unionColorStructMarker"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structColorStructMarker_8bytes"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#structColorStructMarker_8bytes">ColorStructMarker.bytes</a></td></tr>
<tr class="memdesc:structColorStructMarker_8bytes"><td class="mdescLeft">&#160;</td><td class="mdescRight">Individual bytes that make up the marker.  <a href="colr_8h.html#structColorStructMarker_8bytes">More...</a><br /></td></tr>
<tr class="separator:structColorStructMarker_8bytes"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structColorText"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#structColorText">ColorText</a></td></tr>
<tr class="memdesc:structColorText"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a string of text, and optional fore, back, and style ColorArgs.  <a href="colr_8h.html#structColorText">More...</a><br /></td></tr>
<tr class="separator:structColorText"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structColorValue"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a></td></tr>
<tr class="memdesc:structColorValue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a color type and it's value.  <a href="colr_8h.html#structColorValue">More...</a><br /></td></tr>
<tr class="separator:structColorValue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structExtendedInfo"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#structExtendedInfo">ExtendedInfo</a></td></tr>
<tr class="memdesc:structExtendedInfo"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a known color name and it's <code>ExtendedValue</code>.  <a href="colr_8h.html#structExtendedInfo">More...</a><br /></td></tr>
<tr class="separator:structExtendedInfo"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structRGB"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#structRGB">RGB</a></td></tr>
<tr class="memdesc:structRGB"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> values.  <a href="colr_8h.html#structRGB">More...</a><br /></td></tr>
<tr class="separator:structRGB"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structStyleInfo"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#structStyleInfo">StyleInfo</a></td></tr>
<tr class="memdesc:structStyleInfo"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a known style name and it's <code>StyleValue</code>.  <a href="colr_8h.html#structStyleInfo">More...</a><br /></td></tr>
<tr class="separator:structStyleInfo"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structTermSize"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#structTermSize">TermSize</a></td></tr>
<tr class="memdesc:structTermSize"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a terminal size, usually retrieved with <a class="el" href="colr_8c.html#ae4c11bb5b3b1bb2848bb16aee39763b2" title="Attempts to retrieve the row/column size of the terminal and returns a TermSize. ">colr_term_size()</a>.  <a href="colr_8h.html#structTermSize">More...</a><br /></td></tr>
<tr class="separator:structTermSize"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ab7f29d345901a016f81f020ca4326c61"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab7f29d345901a016f81f020ca4326c61">alloc_basic</a>()&#160;&#160;&#160;calloc(<a class="el" href="colr_8h.html#a4ef6ad74c493fe40e199341072fabefe">CODE_LEN</a>, sizeof(char))</td></tr>
<tr class="memdesc:ab7f29d345901a016f81f020ca4326c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate enough for a basic code.  <a href="#ab7f29d345901a016f81f020ca4326c61">More...</a><br /></td></tr>
<tr class="separator:ab7f29d345901a016f81f020ca4326c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c2b2b2835220a22a3b02e18febda40"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a27c2b2b2835220a22a3b02e18febda40">alloc_extended</a>()&#160;&#160;&#160;calloc(<a class="el" href="colr_8h.html#af77ec93393736fa98be724385d61614d">CODEX_LEN</a>, sizeof(char))</td></tr>
<tr class="memdesc:a27c2b2b2835220a22a3b02e18febda40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate enough for an extended code.  <a href="#a27c2b2b2835220a22a3b02e18febda40">More...</a><br /></td></tr>
<tr class="separator:a27c2b2b2835220a22a3b02e18febda40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4f7e3d0a7c1d9b991b0a33a995d6e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ade4f7e3d0a7c1d9b991b0a33a995d6e5">alloc_rgb</a>()&#160;&#160;&#160;calloc(<a class="el" href="colr_8h.html#ad50e6b68284102d5270834e02652af37">CODE_RGB_LEN</a>, sizeof(char))</td></tr>
<tr class="memdesc:ade4f7e3d0a7c1d9b991b0a33a995d6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate enough for an rgb code.  <a href="#ade4f7e3d0a7c1d9b991b0a33a995d6e5">More...</a><br /></td></tr>
<tr class="separator:ade4f7e3d0a7c1d9b991b0a33a995d6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af1a91e97e7aed226ab0cdc6ce205f8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a6af1a91e97e7aed226ab0cdc6ce205f8">alloc_style</a>()&#160;&#160;&#160;calloc(<a class="el" href="colr_8h.html#ac83d14a355d35b7af90deb99ad3b7601">STYLE_LEN</a>, sizeof(char))</td></tr>
<tr class="memdesc:a6af1a91e97e7aed226ab0cdc6ce205f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate enough for a style code.  <a href="#a6af1a91e97e7aed226ab0cdc6ce205f8">More...</a><br /></td></tr>
<tr class="separator:a6af1a91e97e7aed226ab0cdc6ce205f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e247a378d2359d2d6efa4af5e3cd03b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a6e247a378d2359d2d6efa4af5e3cd03b">asprintf_or_return</a>(retval, ...)&#160;&#160;&#160;<a class="el" href="colr_8h.html#a80a08fc1383c7260a31698864d52fee2">if_not_asprintf</a>(__VA_ARGS__) return retval</td></tr>
<tr class="memdesc:a6e247a378d2359d2d6efa4af5e3cd03b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro for bailing out of a function when asprintf fails.  <a href="#a6e247a378d2359d2d6efa4af5e3cd03b">More...</a><br /></td></tr>
<tr class="separator:a6e247a378d2359d2d6efa4af5e3cd03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947915cd251af5099f6a9232836b12d8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8">back</a>(x)&#160;&#160;&#160;<a class="el" href="colr_8h.html#afb5ac0bd012b8162cea125ad0d9e8bf0">ColorArg_to_ptr</a>(<a class="el" href="colr_8h.html#aeba419af1d4c23615eb844db37e46ee6">back_arg</a>(x))</td></tr>
<tr class="memdesc:a947915cd251af5099f6a9232836b12d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a back color suitable for use with the <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a>, <a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465" title="Like colr_cat(), but returns an allocated ColorResult that the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros will automatically free(). ">Colr_cat()</a>, and <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> macros.  <a href="#a947915cd251af5099f6a9232836b12d8">More...</a><br /></td></tr>
<tr class="separator:a947915cd251af5099f6a9232836b12d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba419af1d4c23615eb844db37e46ee6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aeba419af1d4c23615eb844db37e46ee6">back_arg</a>(x)</td></tr>
<tr class="memdesc:aeba419af1d4c23615eb844db37e46ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses ColorArg_from_&lt;type&gt; to build a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> with the appropriate color type, based on the type of it's argument.  <a href="#aeba419af1d4c23615eb844db37e46ee6">More...</a><br /></td></tr>
<tr class="separator:aeba419af1d4c23615eb844db37e46ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f85c3a1434551be3846414be3d1bdb9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a5f85c3a1434551be3846414be3d1bdb9">back_str</a>(x)&#160;&#160;&#160;<a class="el" href="colr_8h.html#ad1d3aaca5e543f8fefbd863a959c9d67">ColorArg_to_esc</a>(<a class="el" href="colr_8h.html#aeba419af1d4c23615eb844db37e46ee6">back_arg</a>(x))</td></tr>
<tr class="memdesc:a5f85c3a1434551be3846414be3d1bdb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return just the escape code string for a back color.  <a href="#a5f85c3a1434551be3846414be3d1bdb9">More...</a><br /></td></tr>
<tr class="separator:a5f85c3a1434551be3846414be3d1bdb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686865036c288a8c6d1626ce2f120039"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a686865036c288a8c6d1626ce2f120039">back_str_static</a>(x)</td></tr>
<tr class="memdesc:a686865036c288a8c6d1626ce2f120039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a stack-allocated escape code string (<code>char*</code>) for a back color.  <a href="#a686865036c288a8c6d1626ce2f120039">More...</a><br /></td></tr>
<tr class="separator:a686865036c288a8c6d1626ce2f120039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653c1408c1d132a05a5648ffd53ca2c6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a653c1408c1d132a05a5648ffd53ca2c6">basic</a>(x)&#160;&#160;&#160;((<a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>)(x))</td></tr>
<tr class="memdesc:a653c1408c1d132a05a5648ffd53ca2c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts to BasicValue.  <a href="#a653c1408c1d132a05a5648ffd53ca2c6">More...</a><br /></td></tr>
<tr class="separator:a653c1408c1d132a05a5648ffd53ca2c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dbd4f0825e46d22010c39d92a5f6e60"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a7dbd4f0825e46d22010c39d92a5f6e60">bool_colr_enum</a>(x)&#160;&#160;&#160;(x &lt; 0 ? false: true)</td></tr>
<tr class="memdesc:a7dbd4f0825e46d22010c39d92a5f6e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the "truthiness" of the enums used in ColrC (BasicValue, ExtendedValue function-returns, StyleValue, ColorType, ArgType).  <a href="#a7dbd4f0825e46d22010c39d92a5f6e60">More...</a><br /></td></tr>
<tr class="separator:a7dbd4f0825e46d22010c39d92a5f6e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e75d15b6f6536e745f66563c4ba6c3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab0e75d15b6f6536e745f66563c4ba6c3">CODE_ANY_LEN</a>&#160;&#160;&#160;46</td></tr>
<tr class="memdesc:ab0e75d15b6f6536e745f66563c4ba6c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length in chars for any possible escape code mixture for one complete style (one of each: fore, back, and style).  <a href="#ab0e75d15b6f6536e745f66563c4ba6c3">More...</a><br /></td></tr>
<tr class="separator:ab0e75d15b6f6536e745f66563c4ba6c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef6ad74c493fe40e199341072fabefe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a4ef6ad74c493fe40e199341072fabefe">CODE_LEN</a>&#160;&#160;&#160;14</td></tr>
<tr class="memdesc:a4ef6ad74c493fe40e199341072fabefe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length for a basic fore/back escape code, including `'\0'`.  <a href="#a4ef6ad74c493fe40e199341072fabefe">More...</a><br /></td></tr>
<tr class="separator:a4ef6ad74c493fe40e199341072fabefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9837a2915a770865032578914efb8621"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a9837a2915a770865032578914efb8621">CODE_LEN_MIN</a>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:a9837a2915a770865032578914efb8621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum length for the shortest basic fore/back escape code, including `'\0'`.  <a href="#a9837a2915a770865032578914efb8621">More...</a><br /></td></tr>
<tr class="separator:a9837a2915a770865032578914efb8621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add86801c90ad7bd8359242a2c1ef1297"><td class="memItemLeft" align="right" valign="top"><a id="add86801c90ad7bd8359242a2c1ef1297"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#add86801c90ad7bd8359242a2c1ef1297">CODE_RESET_ALL</a>&#160;&#160;&#160;&quot;\x1b[0m&quot;</td></tr>
<tr class="memdesc:add86801c90ad7bd8359242a2c1ef1297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience definition, because this is used a lot. <br /></td></tr>
<tr class="separator:add86801c90ad7bd8359242a2c1ef1297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ebf8c77257c07264f5fe53bcdc878c"><td class="memItemLeft" align="right" valign="top"><a id="a44ebf8c77257c07264f5fe53bcdc878c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a44ebf8c77257c07264f5fe53bcdc878c">CODE_RESET_BACK</a>&#160;&#160;&#160;&quot;\x1b[49m&quot;</td></tr>
<tr class="memdesc:a44ebf8c77257c07264f5fe53bcdc878c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience definition for resetting the back color. <br /></td></tr>
<tr class="separator:a44ebf8c77257c07264f5fe53bcdc878c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85075f2c59ebdeda8491a69867d303a"><td class="memItemLeft" align="right" valign="top"><a id="ab85075f2c59ebdeda8491a69867d303a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab85075f2c59ebdeda8491a69867d303a">CODE_RESET_FORE</a>&#160;&#160;&#160;&quot;\x1b[39m&quot;</td></tr>
<tr class="memdesc:ab85075f2c59ebdeda8491a69867d303a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience definition for resetting the fore color. <br /></td></tr>
<tr class="separator:ab85075f2c59ebdeda8491a69867d303a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c138529b05543ba04e6cdbdb5033f0"><td class="memItemLeft" align="right" valign="top"><a id="ae9c138529b05543ba04e6cdbdb5033f0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ae9c138529b05543ba04e6cdbdb5033f0">CODE_RESET_LEN</a>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:ae9c138529b05543ba04e6cdbdb5033f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of CODE_RESET_ALL, including `'\0'`. <br /></td></tr>
<tr class="separator:ae9c138529b05543ba04e6cdbdb5033f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad50e6b68284102d5270834e02652af37"><td class="memItemLeft" align="right" valign="top"><a id="ad50e6b68284102d5270834e02652af37"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ad50e6b68284102d5270834e02652af37">CODE_RGB_LEN</a>&#160;&#160;&#160;20</td></tr>
<tr class="memdesc:ad50e6b68284102d5270834e02652af37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length in chars for an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> fore/back escape code, including `'\0'`. <br /></td></tr>
<tr class="separator:ad50e6b68284102d5270834e02652af37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffdc16cef9af954c4d62d29ba8d7961"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a3ffdc16cef9af954c4d62d29ba8d7961">CODE_RGB_LEN_MIN</a>&#160;&#160;&#160;14</td></tr>
<tr class="memdesc:a3ffdc16cef9af954c4d62d29ba8d7961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum length for the shortest <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> fore/back escape code, including `'\0'`.  <a href="#a3ffdc16cef9af954c4d62d29ba8d7961">More...</a><br /></td></tr>
<tr class="separator:a3ffdc16cef9af954c4d62d29ba8d7961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af77ec93393736fa98be724385d61614d"><td class="memItemLeft" align="right" valign="top"><a id="af77ec93393736fa98be724385d61614d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#af77ec93393736fa98be724385d61614d">CODEX_LEN</a>&#160;&#160;&#160;12</td></tr>
<tr class="memdesc:af77ec93393736fa98be724385d61614d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length for an extended fore/back escape code, including `'\0'`. <br /></td></tr>
<tr class="separator:af77ec93393736fa98be724385d61614d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37730bc0c16d2d698f3d539add30483b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a37730bc0c16d2d698f3d539add30483b">CODEX_LEN_MIN</a>&#160;&#160;&#160;10</td></tr>
<tr class="memdesc:a37730bc0c16d2d698f3d539add30483b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum length for the shortest extended fore/back escape code, including `'\0'`.  <a href="#a37730bc0c16d2d698f3d539add30483b">More...</a><br /></td></tr>
<tr class="separator:a37730bc0c16d2d698f3d539add30483b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8903c150d5b0912b2f797f9235978f8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aa8903c150d5b0912b2f797f9235978f8">color_arg</a>(type,  x)</td></tr>
<tr class="memdesc:aa8903c150d5b0912b2f797f9235978f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a correct <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct according to the type of it's second argument.  <a href="#aa8903c150d5b0912b2f797f9235978f8">More...</a><br /></td></tr>
<tr class="separator:aa8903c150d5b0912b2f797f9235978f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaddb0f34c1374c29a8b7629ac40ca8b"><td class="memItemLeft" align="right" valign="top"><a id="aaaddb0f34c1374c29a8b7629ac40ca8b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aaaddb0f34c1374c29a8b7629ac40ca8b">COLOR_INVALID</a>&#160;&#160;&#160;(-2)</td></tr>
<tr class="memdesc:aaaddb0f34c1374c29a8b7629ac40ca8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible error return value for <a class="el" href="colr_8h.html#a4163ac65dca3e222525808b80a40b733" title="Convert named argument to an actual BasicValue enum value. ">BasicValue_from_str()</a>, <a class="el" href="colr_8h.html#a2e859d542a8aa0939e4f76b1f33cb5f8" title="Converts a known name, integer string (0-255), or a hex string (char*), into an ExtendedValue suitabl...">ExtendedValue_from_str()</a>, and colorname_to_rgb(). <br /></td></tr>
<tr class="separator:aaaddb0f34c1374c29a8b7629ac40ca8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b950e341a1ce7dd9b3325c53c50cfc"><td class="memItemLeft" align="right" valign="top"><a id="ab8b950e341a1ce7dd9b3325c53c50cfc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab8b950e341a1ce7dd9b3325c53c50cfc">COLOR_INVALID_RANGE</a>&#160;&#160;&#160;(-3)</td></tr>
<tr class="memdesc:ab8b950e341a1ce7dd9b3325c53c50cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible error return value for <a class="el" href="colr_8h.html#a98c9e50fe14ad0c82bcf1a62699c05de" title="Convert an RGB string (char*) into an RGB value. ">RGB_from_str()</a>. <br /></td></tr>
<tr class="separator:ab8b950e341a1ce7dd9b3325c53c50cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5557ed18d83facb69dd68b30629c37e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab5557ed18d83facb69dd68b30629c37e">COLOR_LEN</a>&#160;&#160;&#160;30</td></tr>
<tr class="memdesc:ab5557ed18d83facb69dd68b30629c37e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length in chars for any combination of basic/extended escape codes for one complete style (one of each: fore, back, style).  <a href="#ab5557ed18d83facb69dd68b30629c37e">More...</a><br /></td></tr>
<tr class="separator:ab5557ed18d83facb69dd68b30629c37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631e5b639fc75363670dbd912c42abb3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a631e5b639fc75363670dbd912c42abb3">color_name_is_invalid</a>(x)&#160;&#160;&#160;<a class="el" href="colr_8h.html#adc223f6fda6296396e9ecddcc68d4aec">ColorType_is_invalid</a>(<a class="el" href="colr_8h.html#afa75deef059c002134a88dbbdc18fd49">ColorType_from_str</a>(x))</td></tr>
<tr class="memdesc:a631e5b639fc75363670dbd912c42abb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro for checking if a color name is invalid.  <a href="#a631e5b639fc75363670dbd912c42abb3">More...</a><br /></td></tr>
<tr class="separator:a631e5b639fc75363670dbd912c42abb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8da162275a03adc210cd90c0e2b923d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ad8da162275a03adc210cd90c0e2b923d">color_name_is_valid</a>(x)&#160;&#160;&#160;<a class="el" href="colr_8h.html#a5a5883d43e3206584ad048908720afb2">ColorType_is_valid</a>(<a class="el" href="colr_8h.html#afa75deef059c002134a88dbbdc18fd49">ColorType_from_str</a>(x))</td></tr>
<tr class="memdesc:ad8da162275a03adc210cd90c0e2b923d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro for checking if a color name is valid.  <a href="#ad8da162275a03adc210cd90c0e2b923d">More...</a><br /></td></tr>
<tr class="separator:ad8da162275a03adc210cd90c0e2b923d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbb9166f2a4d79e48dd5b11c3eb258b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a9dbb9166f2a4d79e48dd5b11c3eb258b">COLOR_RGB_LEN</a>&#160;&#160;&#160;26</td></tr>
<tr class="memdesc:a9dbb9166f2a4d79e48dd5b11c3eb258b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length in chars added to a rgb colorized string.  <a href="#a9dbb9166f2a4d79e48dd5b11c3eb258b">More...</a><br /></td></tr>
<tr class="separator:a9dbb9166f2a4d79e48dd5b11c3eb258b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb7445c534661e32283d2119beb45d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a4eb7445c534661e32283d2119beb45d6">color_val</a>(x)</td></tr>
<tr class="memdesc:a4eb7445c534661e32283d2119beb45d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a correct <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> struct according to the type of it's first argument.  <a href="#a4eb7445c534661e32283d2119beb45d6">More...</a><br /></td></tr>
<tr class="separator:a4eb7445c534661e32283d2119beb45d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22fa09afcaf087080075551d293a72fd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a22fa09afcaf087080075551d293a72fd">COLORARG_MARKER</a>&#160;&#160;&#160;UINT32_MAX</td></tr>
<tr class="memdesc:a22fa09afcaf087080075551d293a72fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marker for the <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct, for identifying a void pointer as a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>.  <a href="#a22fa09afcaf087080075551d293a72fd">More...</a><br /></td></tr>
<tr class="separator:a22fa09afcaf087080075551d293a72fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf2f23aa571eaa38d355336226d7786"><td class="memItemLeft" align="right" valign="top"><a id="acdf2f23aa571eaa38d355336226d7786"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#acdf2f23aa571eaa38d355336226d7786">COLORJUSTIFY_MARKER</a>&#160;&#160;&#160;(UINT32_MAX - 30)</td></tr>
<tr class="memdesc:acdf2f23aa571eaa38d355336226d7786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marker for the <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> struct, for identifying a void pointer as a <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a>. <br /></td></tr>
<tr class="separator:acdf2f23aa571eaa38d355336226d7786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151438a6f14e82e457ceaf7a168862d5"><td class="memItemLeft" align="right" valign="top"><a id="a151438a6f14e82e457ceaf7a168862d5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a151438a6f14e82e457ceaf7a168862d5">COLORLASTARG_MARKER</a>&#160;&#160;&#160;(UINT32_MAX - 20)</td></tr>
<tr class="memdesc:a151438a6f14e82e457ceaf7a168862d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marker for the _ColrLastArg_s struct, for identifying a void pointer as a _ColrLastArg_s. <br /></td></tr>
<tr class="separator:a151438a6f14e82e457ceaf7a168862d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52621ac08e9c03962778231b3c25d705"><td class="memItemLeft" align="right" valign="top"><a id="a52621ac08e9c03962778231b3c25d705"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a52621ac08e9c03962778231b3c25d705">COLORRESULT_MARKER</a>&#160;&#160;&#160;(UINT32_MAX - 40)</td></tr>
<tr class="memdesc:a52621ac08e9c03962778231b3c25d705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marker for the <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> struct, for identifying a void pointer as a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>. <br /></td></tr>
<tr class="separator:a52621ac08e9c03962778231b3c25d705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3756a551f1f8e5dfb56f6ab41d9e07"><td class="memItemLeft" align="right" valign="top"><a id="afc3756a551f1f8e5dfb56f6ab41d9e07"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#afc3756a551f1f8e5dfb56f6ab41d9e07">COLORTEXT_MARKER</a>&#160;&#160;&#160;(UINT32_MAX - 50)</td></tr>
<tr class="memdesc:afc3756a551f1f8e5dfb56f6ab41d9e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marker for the <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> struct, for identifying a void pointer as a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>. <br /></td></tr>
<tr class="separator:afc3756a551f1f8e5dfb56f6ab41d9e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7678f7f1092db91a932c03c231310ed3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a7678f7f1092db91a932c03c231310ed3">ColorValue_has</a>(cval,  val)</td></tr>
<tr class="memdesc:a7678f7f1092db91a932c03c231310ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the current ColorValue_has_&lt;type&gt; function for the given value.  <a href="#a7678f7f1092db91a932c03c231310ed3">More...</a><br /></td></tr>
<tr class="separator:a7678f7f1092db91a932c03c231310ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1c77f81a0fd49f7895598cbd9ac76c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(text, ...)&#160;&#160;&#160;<a class="el" href="colr_8h.html#a8e04de932a4cf712ac91e794bdc3f8db">ColorText_to_ptr</a>(<a class="el" href="colr_8h.html#ad4702d6ddc409a93a0b42c8f6141d2f2">ColorText_from_values</a>(text, __VA_ARGS__, _ColrLastArg))</td></tr>
<tr class="memdesc:ade1c77f81a0fd49f7895598cbd9ac76c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a heap-allocated <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> struct that can be used by itself, or with the <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, <a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465" title="Like colr_cat(), but returns an allocated ColorResult that the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros will automatically free(). ">Colr_cat()</a>, and <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> macros.  <a href="#ade1c77f81a0fd49f7895598cbd9ac76c">More...</a><br /></td></tr>
<tr class="separator:ade1c77f81a0fd49f7895598cbd9ac76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753093cd4c872eed4b77feaa7816212b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a753093cd4c872eed4b77feaa7816212b">colr</a>(text, ...)&#160;&#160;&#160;<a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa">colr_cat</a>(<a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(text, __VA_ARGS__))</td></tr>
<tr class="memdesc:a753093cd4c872eed4b77feaa7816212b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an allocated string directly from <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a> arguments.  <a href="#a753093cd4c872eed4b77feaa7816212b">More...</a><br /></td></tr>
<tr class="separator:a753093cd4c872eed4b77feaa7816212b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7703119ac7aeb47276700319e4b97a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a8a7703119ac7aeb47276700319e4b97a">colr_alloc_len</a>(x)</td></tr>
<tr class="memdesc:a8a7703119ac7aeb47276700319e4b97a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of bytes needed to allocate an escape code string based on the color type.  <a href="#a8a7703119ac7aeb47276700319e4b97a">More...</a><br /></td></tr>
<tr class="separator:a8a7703119ac7aeb47276700319e4b97a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af297a2286435a423e01edae98c561c7b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#af297a2286435a423e01edae98c561c7b">colr_asprintf</a>(...)&#160;&#160;&#160;<a class="el" href="colr_8h.html#a04ebe7aa43eab3e7e0bd9d769d2074ac">colr_printf_macro</a>(asprintf, __VA_ARGS__)</td></tr>
<tr class="memdesc:af297a2286435a423e01edae98c561c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure <a class="el" href="colr_8h.html#aaaf134ca9a2188d83171fe91948354d9" title="Registers COLR_FMT_CHAR to handle Colr objects in the printf-family functions. ">colr_printf_register()</a> has been called, and then call <code>asprintf</code>.  <a href="#af297a2286435a423e01edae98c561c7b">More...</a><br /></td></tr>
<tr class="separator:af297a2286435a423e01edae98c561c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c6a8a9f484ac09c39e5f76bba61f465"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465">Colr_cat</a>(...)&#160;&#160;&#160;<a class="el" href="colr_8h.html#a5f5304067f9d673ce5b86ddba2a8807b">ColorResult_to_ptr</a>(<a class="el" href="colr_8h.html#af752035c362c7c9ddb2e7f2f2305d509">ColorResult_new</a>(<a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa">colr_cat</a>(__VA_ARGS__)))</td></tr>
<tr class="memdesc:a9c6a8a9f484ac09c39e5f76bba61f465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, but returns an allocated <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> that the <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a>, <a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465" title="Like colr_cat(), but returns an allocated ColorResult that the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros will automatically free(). ">Colr_cat()</a>, and <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> macros will automatically <code>free()</code>.  <a href="#a9c6a8a9f484ac09c39e5f76bba61f465">More...</a><br /></td></tr>
<tr class="separator:a9c6a8a9f484ac09c39e5f76bba61f465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2c8bf2819cb36b1a34396a65b51faa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa">colr_cat</a>(...)&#160;&#160;&#160;<a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join</a>(&quot;&quot;, __VA_ARGS__, _ColrLastArg)</td></tr>
<tr class="memdesc:a8e2c8bf2819cb36b1a34396a65b51faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointers, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> pointers, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointers, and strings into one long string.  <a href="#a8e2c8bf2819cb36b1a34396a65b51faa">More...</a><br /></td></tr>
<tr class="separator:a8e2c8bf2819cb36b1a34396a65b51faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac52a4a5dbfd4f87ffd84e538eab9c29"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aac52a4a5dbfd4f87ffd84e538eab9c29">Colr_center</a>(text,  justwidth, ...)</td></tr>
<tr class="memdesc:aac52a4a5dbfd4f87ffd84e538eab9c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the JustifyMethod for a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> while allocating it.  <a href="#aac52a4a5dbfd4f87ffd84e538eab9c29">More...</a><br /></td></tr>
<tr class="separator:aac52a4a5dbfd4f87ffd84e538eab9c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a7201e4a897fbc28286fbefbd1eea6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a12a7201e4a897fbc28286fbefbd1eea6">Colr_center_char</a>(text,  justwidth,  c, ...)</td></tr>
<tr class="memdesc:a12a7201e4a897fbc28286fbefbd1eea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the JustifyMethod for a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> while allocating it.  <a href="#a12a7201e4a897fbc28286fbefbd1eea6">More...</a><br /></td></tr>
<tr class="separator:a12a7201e4a897fbc28286fbefbd1eea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36af8aa0f01eaa780da182e856923faa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a36af8aa0f01eaa780da182e856923faa">colr_eq</a>(a,  b)</td></tr>
<tr class="memdesc:a36af8aa0f01eaa780da182e856923faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the &lt;type&gt;_eq functions for the supported types.  <a href="#a36af8aa0f01eaa780da182e856923faa">More...</a><br /></td></tr>
<tr class="separator:a36af8aa0f01eaa780da182e856923faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32d4a29c94182c208d20b8deb2e1d5b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aa32d4a29c94182c208d20b8deb2e1d5b">colr_example</a>(x)</td></tr>
<tr class="memdesc:aa32d4a29c94182c208d20b8deb2e1d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the &lt;type&gt;_example functions for the supported types.  <a href="#aa32d4a29c94182c208d20b8deb2e1d5b">More...</a><br /></td></tr>
<tr class="separator:aa32d4a29c94182c208d20b8deb2e1d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8e5e059e18f6620effbedea737f2de"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#abe8e5e059e18f6620effbedea737f2de">COLR_FMT</a>&#160;&#160;&#160;&quot;R&quot;</td></tr>
<tr class="memdesc:abe8e5e059e18f6620effbedea737f2de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format character string suitable for use in the printf-family of functions.  <a href="#abe8e5e059e18f6620effbedea737f2de">More...</a><br /></td></tr>
<tr class="separator:abe8e5e059e18f6620effbedea737f2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e52b69648464f974dad9a620097ca43"><td class="memItemLeft" align="right" valign="top"><a id="a6e52b69648464f974dad9a620097ca43"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a6e52b69648464f974dad9a620097ca43">COLR_FMT_CHAR</a>&#160;&#160;&#160;<a class="el" href="colr_8h.html#abe8e5e059e18f6620effbedea737f2de">COLR_FMT</a>[0]</td></tr>
<tr class="memdesc:a6e52b69648464f974dad9a620097ca43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Character used in printf format strings for Colr objects. <br /></td></tr>
<tr class="separator:a6e52b69648464f974dad9a620097ca43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37cb5d89d0c1910a2e70093a88a2b83"><td class="memItemLeft" align="right" valign="top"><a id="af37cb5d89d0c1910a2e70093a88a2b83"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#af37cb5d89d0c1910a2e70093a88a2b83">COLR_FMT_MOD_ESC</a>&#160;&#160;&#160;&quot;/&quot;</td></tr>
<tr class="memdesc:af37cb5d89d0c1910a2e70093a88a2b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifier for Colr printf character to produce escaped output. <br /></td></tr>
<tr class="separator:af37cb5d89d0c1910a2e70093a88a2b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6366706d8b90ad1f6fc611648ba8b50"><td class="memItemLeft" align="right" valign="top"><a id="ad6366706d8b90ad1f6fc611648ba8b50"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ad6366706d8b90ad1f6fc611648ba8b50">COLR_FMT_MOD_ESC_CHAR</a>&#160;&#160;&#160;<a class="el" href="colr_8h.html#af37cb5d89d0c1910a2e70093a88a2b83">COLR_FMT_MOD_ESC</a>[0]</td></tr>
<tr class="memdesc:ad6366706d8b90ad1f6fc611648ba8b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifier for Colr printf character to produce escaped output, in char form. <br /></td></tr>
<tr class="separator:ad6366706d8b90ad1f6fc611648ba8b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd8ae4170dc11decd1dfb47fdb56c9d7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#afd8ae4170dc11decd1dfb47fdb56c9d7">colr_fprintf</a>(...)&#160;&#160;&#160;<a class="el" href="colr_8h.html#a04ebe7aa43eab3e7e0bd9d769d2074ac">colr_printf_macro</a>(fprintf, __VA_ARGS__)</td></tr>
<tr class="memdesc:afd8ae4170dc11decd1dfb47fdb56c9d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure <a class="el" href="colr_8h.html#aaaf134ca9a2188d83171fe91948354d9" title="Registers COLR_FMT_CHAR to handle Colr objects in the printf-family functions. ">colr_printf_register()</a> has been called, and then call <code>fprintf</code>.  <a href="#afd8ae4170dc11decd1dfb47fdb56c9d7">More...</a><br /></td></tr>
<tr class="separator:afd8ae4170dc11decd1dfb47fdb56c9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76eae619668e01987653932a7492fd94"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a76eae619668e01987653932a7492fd94">colr_free</a>(x)</td></tr>
<tr class="memdesc:a76eae619668e01987653932a7492fd94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the &lt;type&gt;_free functions for the supported types.  <a href="#a76eae619668e01987653932a7492fd94">More...</a><br /></td></tr>
<tr class="separator:a76eae619668e01987653932a7492fd94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895123a02eb0dce3192ae0d9a02f42ab"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a895123a02eb0dce3192ae0d9a02f42ab">COLR_GNU</a></td></tr>
<tr class="memdesc:a895123a02eb0dce3192ae0d9a02f42ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined when <code>__GNUC__</code> is available, to enable <a href="https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html">statement-expressions </a> and <a href="https://www.gnu.org/software/libc/manual/html_node/Customizing-Printf.html">register_printf_specifier </a>.  <a href="#a895123a02eb0dce3192ae0d9a02f42ab">More...</a><br /></td></tr>
<tr class="separator:a895123a02eb0dce3192ae0d9a02f42ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a2343bcb22f4216d3fff12bd18bb93"><td class="memItemLeft" align="right" valign="top"><a id="a08a2343bcb22f4216d3fff12bd18bb93"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a08a2343bcb22f4216d3fff12bd18bb93">COLR_HASH_SEED</a>&#160;&#160;&#160;5381</td></tr>
<tr class="memdesc:a08a2343bcb22f4216d3fff12bd18bb93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seed value for <a class="el" href="colr_8h.html#adf5a3149704b14b85a0236d9940fb4e7" title="Hash a string using djb2. ">colr_str_hash()</a>. <br /></td></tr>
<tr class="separator:a08a2343bcb22f4216d3fff12bd18bb93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0819ea3109493d7fe1656a7cadaca7d5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a0819ea3109493d7fe1656a7cadaca7d5">colr_is_empty</a>(x)</td></tr>
<tr class="memdesc:a0819ea3109493d7fe1656a7cadaca7d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the &lt;type&gt;is_empty functions for the supported types.  <a href="#a0819ea3109493d7fe1656a7cadaca7d5">More...</a><br /></td></tr>
<tr class="separator:a0819ea3109493d7fe1656a7cadaca7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2982e773789d3f819036212694afed5e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a2982e773789d3f819036212694afed5e">colr_is_invalid</a>(x)</td></tr>
<tr class="memdesc:a2982e773789d3f819036212694afed5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the &lt;type&gt;is_invalid functions for the supported types.  <a href="#a2982e773789d3f819036212694afed5e">More...</a><br /></td></tr>
<tr class="separator:a2982e773789d3f819036212694afed5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8909ecf2f0be1bbc70ab33667578134e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a8909ecf2f0be1bbc70ab33667578134e">colr_is_valid</a>(x)</td></tr>
<tr class="memdesc:a8909ecf2f0be1bbc70ab33667578134e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the &lt;type&gt;is_valid functions for the supported types.  <a href="#a8909ecf2f0be1bbc70ab33667578134e">More...</a><br /></td></tr>
<tr class="separator:a8909ecf2f0be1bbc70ab33667578134e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b95dc82c67a2ec94053e207b0b87594"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a9b95dc82c67a2ec94053e207b0b87594">colr_is_valid_mblen</a>(x)&#160;&#160;&#160;((x) &amp;&amp; ((x) != (size_t)-1) &amp;&amp; ((x) != (size_t)-2))</td></tr>
<tr class="memdesc:a9b95dc82c67a2ec94053e207b0b87594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks return values from <code>mbrlen()</code> and <a class="el" href="colr_8h.html#ade675256d9e88682d4bebdcc4a57f86f" title="Like mbrlen, except it will return the length of the next N (length) multibyte characters in bytes...">colr_mb_len()</a>.  <a href="#a9b95dc82c67a2ec94053e207b0b87594">More...</a><br /></td></tr>
<tr class="separator:a9b95dc82c67a2ec94053e207b0b87594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b56172c3a4f77092b0b476359a2a746"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a3b56172c3a4f77092b0b476359a2a746">colr_istr_either</a>(s1,  s2,  s3)</td></tr>
<tr class="memdesc:a3b56172c3a4f77092b0b476359a2a746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro for <code>!strcasecmp(s1, s2) || !strcasecmp(s1, s3)</code>.  <a href="#a3b56172c3a4f77092b0b476359a2a746">More...</a><br /></td></tr>
<tr class="separator:a3b56172c3a4f77092b0b476359a2a746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94e5767e40ff1d9a5236b890c20cc95"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ad94e5767e40ff1d9a5236b890c20cc95">colr_istr_eq</a>(s1,  s2)</td></tr>
<tr class="memdesc:ad94e5767e40ff1d9a5236b890c20cc95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro for <code>!strcasecmp(s1, s2)</code>.  <a href="#ad94e5767e40ff1d9a5236b890c20cc95">More...</a><br /></td></tr>
<tr class="separator:ad94e5767e40ff1d9a5236b890c20cc95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d87ca8cb5460146965bd85ec82f293e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e">Colr_join</a>(joiner, ...)&#160;&#160;&#160;<a class="el" href="colr_8h.html#aebecaca8dfed9f43418cb2c6b214eef3">ColrResult</a>(<a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0">colr_join</a>(joiner, __VA_ARGS__))</td></tr>
<tr class="memdesc:a4d87ca8cb5460146965bd85ec82f293e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joins Colr objects and strings, exactly like <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, but returns an allocated <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> that the <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a>, <a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465" title="Like colr_cat(), but returns an allocated ColorResult that the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros will automatically free(). ">Colr_cat()</a>, and <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> macros will automatically <code>free()</code> for you.  <a href="#a4d87ca8cb5460146965bd85ec82f293e">More...</a><br /></td></tr>
<tr class="separator:a4d87ca8cb5460146965bd85ec82f293e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8cc35d2d3a15c9c22ebb0a0835c92f0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0">colr_join</a>(joiner, ...)&#160;&#160;&#160;<a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join</a>(joiner, __VA_ARGS__, _ColrLastArg)</td></tr>
<tr class="memdesc:ae8cc35d2d3a15c9c22ebb0a0835c92f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointers, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointers, and strings by another <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointer, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointer, or string.  <a href="#ae8cc35d2d3a15c9c22ebb0a0835c92f0">More...</a><br /></td></tr>
<tr class="separator:ae8cc35d2d3a15c9c22ebb0a0835c92f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf0fb81bc7b69d881907cae8a302bd9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a0cf0fb81bc7b69d881907cae8a302bd9">colr_length</a>(x)</td></tr>
<tr class="memdesc:a0cf0fb81bc7b69d881907cae8a302bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the &lt;type&gt;_length functions for the supported types.  <a href="#a0cf0fb81bc7b69d881907cae8a302bd9">More...</a><br /></td></tr>
<tr class="separator:a0cf0fb81bc7b69d881907cae8a302bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373daeb0be048e4631ab04c445414362"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a373daeb0be048e4631ab04c445414362">Colr_ljust</a>(text,  justwidth, ...)</td></tr>
<tr class="memdesc:a373daeb0be048e4631ab04c445414362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the JustifyMethod for a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> while allocating it.  <a href="#a373daeb0be048e4631ab04c445414362">More...</a><br /></td></tr>
<tr class="separator:a373daeb0be048e4631ab04c445414362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b7b18de61f45afd19ca506ccc33779"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a78b7b18de61f45afd19ca506ccc33779">Colr_ljust_char</a>(text,  justwidth,  c, ...)</td></tr>
<tr class="memdesc:a78b7b18de61f45afd19ca506ccc33779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the JustifyMethod for a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> while allocating it.  <a href="#a78b7b18de61f45afd19ca506ccc33779">More...</a><br /></td></tr>
<tr class="separator:a78b7b18de61f45afd19ca506ccc33779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2011f1f6c35bc63ca0cb23b9b893f61"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#af2011f1f6c35bc63ca0cb23b9b893f61">colr_max</a>(a,  b)&#160;&#160;&#160;(a &gt; b ? a : b)</td></tr>
<tr class="memdesc:af2011f1f6c35bc63ca0cb23b9b893f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for <code>(a &gt; b ? a : b)</code>.  <a href="#af2011f1f6c35bc63ca0cb23b9b893f61">More...</a><br /></td></tr>
<tr class="separator:af2011f1f6c35bc63ca0cb23b9b893f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85593e2253c99264904a467f1427e599"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a85593e2253c99264904a467f1427e599">colr_print</a>(...)</td></tr>
<tr class="memdesc:a85593e2253c99264904a467f1427e599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a string from a <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a> call, print it to stdout (without a newline), and free it.  <a href="#a85593e2253c99264904a467f1427e599">More...</a><br /></td></tr>
<tr class="separator:a85593e2253c99264904a467f1427e599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c188d16f60b7e296bd71ac95d8ec508"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a7c188d16f60b7e296bd71ac95d8ec508">colr_printf</a>(...)&#160;&#160;&#160;<a class="el" href="colr_8h.html#a04ebe7aa43eab3e7e0bd9d769d2074ac">colr_printf_macro</a>(printf, __VA_ARGS__)</td></tr>
<tr class="memdesc:a7c188d16f60b7e296bd71ac95d8ec508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure <a class="el" href="colr_8h.html#aaaf134ca9a2188d83171fe91948354d9" title="Registers COLR_FMT_CHAR to handle Colr objects in the printf-family functions. ">colr_printf_register()</a> has been called, and then call <code>printf</code>.  <a href="#a7c188d16f60b7e296bd71ac95d8ec508">More...</a><br /></td></tr>
<tr class="separator:a7c188d16f60b7e296bd71ac95d8ec508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ebe7aa43eab3e7e0bd9d769d2074ac"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a04ebe7aa43eab3e7e0bd9d769d2074ac">colr_printf_macro</a>(func, ...)</td></tr>
<tr class="memdesc:a04ebe7aa43eab3e7e0bd9d769d2074ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls one of the printf-family functions, with format warnings disabled for the call, and returns the result.  <a href="#a04ebe7aa43eab3e7e0bd9d769d2074ac">More...</a><br /></td></tr>
<tr class="separator:a04ebe7aa43eab3e7e0bd9d769d2074ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af050c0377cbd1960fa057dc160da3c34"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#af050c0377cbd1960fa057dc160da3c34">colr_puts</a>(...)</td></tr>
<tr class="memdesc:af050c0377cbd1960fa057dc160da3c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a string from a <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a> call, print it (with a newline), and free it.  <a href="#af050c0377cbd1960fa057dc160da3c34">More...</a><br /></td></tr>
<tr class="separator:af050c0377cbd1960fa057dc160da3c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4559cb7ed508a538687727ccd4586ccb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb">colr_replace</a>(s,  target,  repl)</td></tr>
<tr class="memdesc:a4559cb7ed508a538687727ccd4586ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a substring in <code>s</code> with another string, <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> string, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> string, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> string.  <a href="#a4559cb7ed508a538687727ccd4586ccb">More...</a><br /></td></tr>
<tr class="separator:a4559cb7ed508a538687727ccd4586ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca60a944b824cd8049451792904c2eb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a1ca60a944b824cd8049451792904c2eb">colr_replace_all</a>(s,  target,  repl)</td></tr>
<tr class="memdesc:a1ca60a944b824cd8049451792904c2eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all substrings in <code>s</code> with another string, <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> string, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> string, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> string.  <a href="#a1ca60a944b824cd8049451792904c2eb">More...</a><br /></td></tr>
<tr class="separator:a1ca60a944b824cd8049451792904c2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2262af7b2b1e9281272c63c85b9e7357"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357">colr_replace_re</a>(s,  target,  repl,  flags)</td></tr>
<tr class="memdesc:a2262af7b2b1e9281272c63c85b9e7357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a regex pattern string (<code>char*</code>) in <code>s</code> with another string, <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> string, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> string, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> string.  <a href="#a2262af7b2b1e9281272c63c85b9e7357">More...</a><br /></td></tr>
<tr class="separator:a2262af7b2b1e9281272c63c85b9e7357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34553de01998eff17512d7ef1e9f3fa0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a34553de01998eff17512d7ef1e9f3fa0">colr_replace_re_all</a>(s,  target,  repl,  flags)</td></tr>
<tr class="memdesc:a34553de01998eff17512d7ef1e9f3fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all matches to a regex pattern string (<code>char*</code>) in <code>s</code> with another string, <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> string, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> string, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> string.  <a href="#a34553de01998eff17512d7ef1e9f3fa0">More...</a><br /></td></tr>
<tr class="separator:a34553de01998eff17512d7ef1e9f3fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ef824dd213274fb239526269315543"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ac1ef824dd213274fb239526269315543">colr_repr</a>(x)</td></tr>
<tr class="memdesc:ac1ef824dd213274fb239526269315543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms several ColrC objects into their string representations.  <a href="#ac1ef824dd213274fb239526269315543">More...</a><br /></td></tr>
<tr class="separator:ac1ef824dd213274fb239526269315543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba613f3915a178c3eb981e072d53ef72"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aba613f3915a178c3eb981e072d53ef72">Colr_rjust</a>(text,  justwidth, ...)</td></tr>
<tr class="memdesc:aba613f3915a178c3eb981e072d53ef72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the JustifyMethod for a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> while allocating it.  <a href="#aba613f3915a178c3eb981e072d53ef72">More...</a><br /></td></tr>
<tr class="separator:aba613f3915a178c3eb981e072d53ef72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3699ee65e44b71b4d4165fd167c746bb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a3699ee65e44b71b4d4165fd167c746bb">Colr_rjust_char</a>(text,  justwidth,  c, ...)</td></tr>
<tr class="memdesc:a3699ee65e44b71b4d4165fd167c746bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the JustifyMethod for a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> while allocating it.  <a href="#a3699ee65e44b71b4d4165fd167c746bb">More...</a><br /></td></tr>
<tr class="separator:a3699ee65e44b71b4d4165fd167c746bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d1de0d75fddd284223749e7c13408a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#af3d1de0d75fddd284223749e7c13408a">colr_snprintf</a>(...)&#160;&#160;&#160;<a class="el" href="colr_8h.html#a04ebe7aa43eab3e7e0bd9d769d2074ac">colr_printf_macro</a>(snprintf, __VA_ARGS__)</td></tr>
<tr class="memdesc:af3d1de0d75fddd284223749e7c13408a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure <a class="el" href="colr_8h.html#aaaf134ca9a2188d83171fe91948354d9" title="Registers COLR_FMT_CHAR to handle Colr objects in the printf-family functions. ">colr_printf_register()</a> has been called, and then call <code>snprintf</code>.  <a href="#af3d1de0d75fddd284223749e7c13408a">More...</a><br /></td></tr>
<tr class="separator:af3d1de0d75fddd284223749e7c13408a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58aca09bd7892f8c6b3255454ae2ff07"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a58aca09bd7892f8c6b3255454ae2ff07">colr_sprintf</a>(...)&#160;&#160;&#160;<a class="el" href="colr_8h.html#a04ebe7aa43eab3e7e0bd9d769d2074ac">colr_printf_macro</a>(sprintf, __VA_ARGS__)</td></tr>
<tr class="memdesc:a58aca09bd7892f8c6b3255454ae2ff07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure <a class="el" href="colr_8h.html#aaaf134ca9a2188d83171fe91948354d9" title="Registers COLR_FMT_CHAR to handle Colr objects in the printf-family functions. ">colr_printf_register()</a> has been called, and then call <code>sprintf</code>.  <a href="#a58aca09bd7892f8c6b3255454ae2ff07">More...</a><br /></td></tr>
<tr class="separator:a58aca09bd7892f8c6b3255454ae2ff07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeaf33a4617bbd5de036a160d784fb83"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#afeaf33a4617bbd5de036a160d784fb83">colr_str_either</a>(s1,  s2,  s3)&#160;&#160;&#160;(<a class="el" href="colr_8h.html#aa3efb8eb9314481b0692a75079e4a3f4">colr_str_eq</a>(s1, s2) || <a class="el" href="colr_8h.html#aa3efb8eb9314481b0692a75079e4a3f4">colr_str_eq</a>(s1, s3))</td></tr>
<tr class="memdesc:afeaf33a4617bbd5de036a160d784fb83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro for <code>!strcmp(s1, s2) || !strcmp(s1, s3)</code>.  <a href="#afeaf33a4617bbd5de036a160d784fb83">More...</a><br /></td></tr>
<tr class="separator:afeaf33a4617bbd5de036a160d784fb83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3efb8eb9314481b0692a75079e4a3f4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aa3efb8eb9314481b0692a75079e4a3f4">colr_str_eq</a>(s1,  s2)</td></tr>
<tr class="memdesc:aa3efb8eb9314481b0692a75079e4a3f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro for <code>!strcmp(s1, s2)</code>.  <a href="#aa3efb8eb9314481b0692a75079e4a3f4">More...</a><br /></td></tr>
<tr class="separator:aa3efb8eb9314481b0692a75079e4a3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790e5a9bd0b3ca7cd7d428007f6a21b9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a790e5a9bd0b3ca7cd7d428007f6a21b9">colr_to_str</a>(x)</td></tr>
<tr class="memdesc:a790e5a9bd0b3ca7cd7d428007f6a21b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the &lt;type&gt;_to_str functions for the supported types.  <a href="#a790e5a9bd0b3ca7cd7d428007f6a21b9">More...</a><br /></td></tr>
<tr class="separator:a790e5a9bd0b3ca7cd7d428007f6a21b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b8d77765654a95ec8684fcfd763261"><td class="memItemLeft" align="right" valign="top"><a id="ac1b8d77765654a95ec8684fcfd763261"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ac1b8d77765654a95ec8684fcfd763261">COLR_VERSION</a>&#160;&#160;&#160;&quot;0.3.6&quot;</td></tr>
<tr class="memdesc:ac1b8d77765654a95ec8684fcfd763261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current version for ColrC. <br /></td></tr>
<tr class="separator:ac1b8d77765654a95ec8684fcfd763261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc8cf2eac15c7c27983616d23b10ed6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a1dc8cf2eac15c7c27983616d23b10ed6">Colra</a>(text, ...)&#160;&#160;&#160;<a class="el" href="colr_8h.html#ad4702d6ddc409a93a0b42c8f6141d2f2">ColorText_from_values</a>(text, __VA_ARGS__, _ColrLastArg)</td></tr>
<tr class="memdesc:a1dc8cf2eac15c7c27983616d23b10ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an initialized stack-allocated <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.  <a href="#a1dc8cf2eac15c7c27983616d23b10ed6">More...</a><br /></td></tr>
<tr class="separator:a1dc8cf2eac15c7c27983616d23b10ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebecaca8dfed9f43418cb2c6b214eef3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aebecaca8dfed9f43418cb2c6b214eef3">ColrResult</a>(s)&#160;&#160;&#160;<a class="el" href="colr_8h.html#a5f5304067f9d673ce5b86ddba2a8807b">ColorResult_to_ptr</a>(<a class="el" href="colr_8h.html#af752035c362c7c9ddb2e7f2f2305d509">ColorResult_new</a>(s))</td></tr>
<tr class="memdesc:aebecaca8dfed9f43418cb2c6b214eef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps an allocated string in a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, which marks it as "freeable" in the colr macros.  <a href="#aebecaca8dfed9f43418cb2c6b214eef3">More...</a><br /></td></tr>
<tr class="separator:aebecaca8dfed9f43418cb2c6b214eef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ff4fc6d17b53b60202be55bd0732c5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a37ff4fc6d17b53b60202be55bd0732c5">ext</a>(x)&#160;&#160;&#160;((<a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>)x)</td></tr>
<tr class="memdesc:a37ff4fc6d17b53b60202be55bd0732c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts to ExtendedValue (<code>unsigned char</code>).  <a href="#a37ff4fc6d17b53b60202be55bd0732c5">More...</a><br /></td></tr>
<tr class="separator:a37ff4fc6d17b53b60202be55bd0732c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c79297600d8ab15a495843d63db54d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aa3c79297600d8ab15a495843d63db54d">ext_hex</a>(s)&#160;&#160;&#160;<a class="el" href="colr_8h.html#affaeebdd3dad2cf0d5e14a7870c1e4f6">ext_hex_or</a>(s, <a class="el" href="colr_8h.html#a37ff4fc6d17b53b60202be55bd0732c5">ext</a>(0))</td></tr>
<tr class="memdesc:aa3c79297600d8ab15a495843d63db54d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="colr_8h.html#a8fe812f8e76e4baed394ee9adf46b3df" title="Use RGB_from_hex_default() to create an RGB value. ">hex()</a>, but force a conversion to the closest ExtendedValue (256-colors).  <a href="#aa3c79297600d8ab15a495843d63db54d">More...</a><br /></td></tr>
<tr class="separator:aa3c79297600d8ab15a495843d63db54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affaeebdd3dad2cf0d5e14a7870c1e4f6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#affaeebdd3dad2cf0d5e14a7870c1e4f6">ext_hex_or</a>(s,  default_value)&#160;&#160;&#160;<a class="el" href="colr_8h.html#a757be189530b4925c84df25742374485">ExtendedValue_from_hex_default</a>(s, default_value)</td></tr>
<tr class="memdesc:affaeebdd3dad2cf0d5e14a7870c1e4f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="colr_8h.html#ab55724d1f9877f698cf8591df92b8887" title="Use RGB_from_hex_default() to create an RGB value. ">hex_or()</a>, but force a conversion to the closest ExtendedValue (256-colors).  <a href="#affaeebdd3dad2cf0d5e14a7870c1e4f6">More...</a><br /></td></tr>
<tr class="separator:affaeebdd3dad2cf0d5e14a7870c1e4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6501099f0501e2faa18ebfc9a74105"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ace6501099f0501e2faa18ebfc9a74105">EXT_INVALID</a>&#160;&#160;&#160;<a class="el" href="colr_8h.html#aaaddb0f34c1374c29a8b7629ac40ca8b">COLOR_INVALID</a></td></tr>
<tr class="memdesc:ace6501099f0501e2faa18ebfc9a74105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for COLOR_INVALID.  <a href="#ace6501099f0501e2faa18ebfc9a74105">More...</a><br /></td></tr>
<tr class="separator:ace6501099f0501e2faa18ebfc9a74105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f95f31a14a8e3404651866911ea089"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a29f95f31a14a8e3404651866911ea089">EXT_INVALID_RANGE</a>&#160;&#160;&#160;<a class="el" href="colr_8h.html#ab8b950e341a1ce7dd9b3325c53c50cfc">COLOR_INVALID_RANGE</a></td></tr>
<tr class="memdesc:a29f95f31a14a8e3404651866911ea089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible error return value for <a class="el" href="colr_8h.html#a2e859d542a8aa0939e4f76b1f33cb5f8" title="Converts a known name, integer string (0-255), or a hex string (char*), into an ExtendedValue suitabl...">ExtendedValue_from_str()</a> or <a class="el" href="colr_8h.html#aaabf63956f397a0fe628313622ba5cde" title="Convert an escape-code string (char*) to an ExtendedValue. ">ExtendedValue_from_esc()</a>.  <a href="#a29f95f31a14a8e3404651866911ea089">More...</a><br /></td></tr>
<tr class="separator:a29f95f31a14a8e3404651866911ea089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3d47951e17cbf856902e11e4efa2e6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#add3d47951e17cbf856902e11e4efa2e6">ext_rgb</a>(r,  g,  b)&#160;&#160;&#160;<a class="el" href="colr_8h.html#a1548d9fc5f3e00a7b5d834eb1e12ff93">ExtendedValue_from_RGB</a>((<a class="el" href="colr_8h.html#structRGB">RGB</a>){.red=r, .green=g, .blue=b})</td></tr>
<tr class="memdesc:add3d47951e17cbf856902e11e4efa2e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the closest matching ExtendedValue from separate red, green, and blue values.  <a href="#add3d47951e17cbf856902e11e4efa2e6">More...</a><br /></td></tr>
<tr class="separator:add3d47951e17cbf856902e11e4efa2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0605394ac51b9927ec4a71e99365028e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a0605394ac51b9927ec4a71e99365028e">ext_RGB</a>(rgbval)&#160;&#160;&#160;<a class="el" href="colr_8h.html#a1548d9fc5f3e00a7b5d834eb1e12ff93">ExtendedValue_from_RGB</a>(rgbval)</td></tr>
<tr class="memdesc:a0605394ac51b9927ec4a71e99365028e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the closest matching ExtendedValue from an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.  <a href="#a0605394ac51b9927ec4a71e99365028e">More...</a><br /></td></tr>
<tr class="separator:a0605394ac51b9927ec4a71e99365028e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d8b61303404007a3224be0f8296c3f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(x)&#160;&#160;&#160;<a class="el" href="colr_8h.html#afb5ac0bd012b8162cea125ad0d9e8bf0">ColorArg_to_ptr</a>(<a class="el" href="colr_8h.html#a3cc38de52ea52344113083ba4d90088e">fore_arg</a>(x))</td></tr>
<tr class="memdesc:a19d8b61303404007a3224be0f8296c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a fore color suitable for use with the <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a>, <a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465" title="Like colr_cat(), but returns an allocated ColorResult that the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros will automatically free(). ">Colr_cat()</a>, and <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> macros.  <a href="#a19d8b61303404007a3224be0f8296c3f">More...</a><br /></td></tr>
<tr class="separator:a19d8b61303404007a3224be0f8296c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc38de52ea52344113083ba4d90088e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a3cc38de52ea52344113083ba4d90088e">fore_arg</a>(x)</td></tr>
<tr class="memdesc:a3cc38de52ea52344113083ba4d90088e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses ColorArg_from_&lt;type&gt; to build a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> with the appropriate color type, based on the type of it's argument.  <a href="#a3cc38de52ea52344113083ba4d90088e">More...</a><br /></td></tr>
<tr class="separator:a3cc38de52ea52344113083ba4d90088e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e27cd8b78fc357be02c4dbf6a6c9096"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a0e27cd8b78fc357be02c4dbf6a6c9096">fore_str</a>(x)&#160;&#160;&#160;<a class="el" href="colr_8h.html#ad1d3aaca5e543f8fefbd863a959c9d67">ColorArg_to_esc</a>(<a class="el" href="colr_8h.html#a3cc38de52ea52344113083ba4d90088e">fore_arg</a>(x))</td></tr>
<tr class="memdesc:a0e27cd8b78fc357be02c4dbf6a6c9096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return just the escape code string for a fore color.  <a href="#a0e27cd8b78fc357be02c4dbf6a6c9096">More...</a><br /></td></tr>
<tr class="separator:a0e27cd8b78fc357be02c4dbf6a6c9096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ab6c47eae67006285e33f1edd84278"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ad0ab6c47eae67006285e33f1edd84278">fore_str_static</a>(x)</td></tr>
<tr class="memdesc:ad0ab6c47eae67006285e33f1edd84278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a stack-allocated escape code string (<code>char*</code>) for a fore color.  <a href="#ad0ab6c47eae67006285e33f1edd84278">More...</a><br /></td></tr>
<tr class="separator:ad0ab6c47eae67006285e33f1edd84278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe812f8e76e4baed394ee9adf46b3df"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a8fe812f8e76e4baed394ee9adf46b3df">hex</a>(s)&#160;&#160;&#160;<a class="el" href="colr_8h.html#ab55724d1f9877f698cf8591df92b8887">hex_or</a>(s, <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>(0, 0, 0))</td></tr>
<tr class="memdesc:a8fe812f8e76e4baed394ee9adf46b3df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use <a class="el" href="colr_8h.html#a6133112d9c73a8b56995e16e1af62d3b" title="Convert a hex color into an RGB value, but use a default value when errors occur. ...">RGB_from_hex_default()</a> to create an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.  <a href="#a8fe812f8e76e4baed394ee9adf46b3df">More...</a><br /></td></tr>
<tr class="separator:a8fe812f8e76e4baed394ee9adf46b3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55724d1f9877f698cf8591df92b8887"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab55724d1f9877f698cf8591df92b8887">hex_or</a>(s,  default_rgb)&#160;&#160;&#160;<a class="el" href="colr_8h.html#a6133112d9c73a8b56995e16e1af62d3b">RGB_from_hex_default</a>(s, default_rgb)</td></tr>
<tr class="memdesc:ab55724d1f9877f698cf8591df92b8887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use <a class="el" href="colr_8h.html#a6133112d9c73a8b56995e16e1af62d3b" title="Convert a hex color into an RGB value, but use a default value when errors occur. ...">RGB_from_hex_default()</a> to create an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.  <a href="#ab55724d1f9877f698cf8591df92b8887">More...</a><br /></td></tr>
<tr class="separator:ab55724d1f9877f698cf8591df92b8887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a08fc1383c7260a31698864d52fee2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a80a08fc1383c7260a31698864d52fee2">if_not_asprintf</a>(...)&#160;&#160;&#160;if (asprintf(__VA_ARGS__) &lt; 1)</td></tr>
<tr class="memdesc:a80a08fc1383c7260a31698864d52fee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro for checking asprintf's return value.  <a href="#a80a08fc1383c7260a31698864d52fee2">More...</a><br /></td></tr>
<tr class="separator:a80a08fc1383c7260a31698864d52fee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa2460e32327ade49189c95740bc1b5"><td class="memItemLeft" align="right" valign="top"><a id="a1fa2460e32327ade49189c95740bc1b5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a1fa2460e32327ade49189c95740bc1b5">NC</a>&#160;&#160;&#160;<a class="el" href="colr_8h.html#add86801c90ad7bd8359242a2c1ef1297">CODE_RESET_ALL</a></td></tr>
<tr class="memdesc:a1fa2460e32327ade49189c95740bc1b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for CODE_RESET_ALL, stands for "No Color". <br /></td></tr>
<tr class="separator:a1fa2460e32327ade49189c95740bc1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a650ed7bed617e54aa77f7b2907675137"><td class="memItemLeft" align="right" valign="top"><a id="a650ed7bed617e54aa77f7b2907675137"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a650ed7bed617e54aa77f7b2907675137">NCNL</a>&#160;&#160;&#160;<a class="el" href="colr_8h.html#add86801c90ad7bd8359242a2c1ef1297">CODE_RESET_ALL</a> &quot;\n&quot;</td></tr>
<tr class="memdesc:a650ed7bed617e54aa77f7b2907675137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for <code>CODE_RESET_ALL "\n"</code>, stands for "No Color, New Line". <br /></td></tr>
<tr class="separator:a650ed7bed617e54aa77f7b2907675137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa7a1b0351d0bdbdf9fd5f882673d57"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>(r,  g,  b)&#160;&#160;&#160;((<a class="el" href="colr_8h.html#structRGB">RGB</a>){.red=r, .green=g, .blue=b})</td></tr>
<tr class="memdesc:a6fa7a1b0351d0bdbdf9fd5f882673d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an anonymous <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct for use in function calls.  <a href="#a6fa7a1b0351d0bdbdf9fd5f882673d57">More...</a><br /></td></tr>
<tr class="separator:a6fa7a1b0351d0bdbdf9fd5f882673d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7592d374ee178fd8ac19d8dabbb83662"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662">style</a>(x)&#160;&#160;&#160;<a class="el" href="colr_8h.html#afb5ac0bd012b8162cea125ad0d9e8bf0">ColorArg_to_ptr</a>(<a class="el" href="colr_8h.html#a53683a9e279942578e46768be25587d0">style_arg</a>(x))</td></tr>
<tr class="memdesc:a7592d374ee178fd8ac19d8dabbb83662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a style suitable for use with the <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a>, <a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465" title="Like colr_cat(), but returns an allocated ColorResult that the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros will automatically free(). ">Colr_cat()</a>, and <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> macros.  <a href="#a7592d374ee178fd8ac19d8dabbb83662">More...</a><br /></td></tr>
<tr class="separator:a7592d374ee178fd8ac19d8dabbb83662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53683a9e279942578e46768be25587d0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a53683a9e279942578e46768be25587d0">style_arg</a>(x)</td></tr>
<tr class="memdesc:a53683a9e279942578e46768be25587d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses ColorArg_from_StyleValue to build a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> with the appropriate color type/value.  <a href="#a53683a9e279942578e46768be25587d0">More...</a><br /></td></tr>
<tr class="separator:a53683a9e279942578e46768be25587d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83d14a355d35b7af90deb99ad3b7601"><td class="memItemLeft" align="right" valign="top"><a id="ac83d14a355d35b7af90deb99ad3b7601"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ac83d14a355d35b7af90deb99ad3b7601">STYLE_LEN</a>&#160;&#160;&#160;6</td></tr>
<tr class="memdesc:ac83d14a355d35b7af90deb99ad3b7601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length for a style escape code, including `'\0'`. <br /></td></tr>
<tr class="separator:ac83d14a355d35b7af90deb99ad3b7601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd8134cf00ddafc463dbce4010439af"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a5fd8134cf00ddafc463dbce4010439af">STYLE_LEN_MIN</a>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:a5fd8134cf00ddafc463dbce4010439af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum length for the shortest style escape code, including `'\0'`.  <a href="#a5fd8134cf00ddafc463dbce4010439af">More...</a><br /></td></tr>
<tr class="separator:a5fd8134cf00ddafc463dbce4010439af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf65d4f2956611639be470c5313af423"><td class="memItemLeft" align="right" valign="top"><a id="aaf65d4f2956611639be470c5313af423"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aaf65d4f2956611639be470c5313af423">STYLE_MAX_VALUE</a>&#160;&#160;&#160;((<a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>)OVERLINE)</td></tr>
<tr class="memdesc:aaf65d4f2956611639be470c5313af423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value allowed for a StyleValue. <br /></td></tr>
<tr class="separator:aaf65d4f2956611639be470c5313af423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad378024e623ea8fdd0a2b061e59b546d"><td class="memItemLeft" align="right" valign="top"><a id="ad378024e623ea8fdd0a2b061e59b546d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ad378024e623ea8fdd0a2b061e59b546d">STYLE_MIN_VALUE</a>&#160;&#160;&#160;((<a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>)STYLE_INVALID_RANGE)</td></tr>
<tr class="memdesc:ad378024e623ea8fdd0a2b061e59b546d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum value allowed for a StyleValue. <br /></td></tr>
<tr class="separator:ad378024e623ea8fdd0a2b061e59b546d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab307d323b317da4b6f4d24ee1929b354"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab307d323b317da4b6f4d24ee1929b354">style_str</a>(x)&#160;&#160;&#160;<a class="el" href="colr_8h.html#ad1d3aaca5e543f8fefbd863a959c9d67">ColorArg_to_esc</a>(<a class="el" href="colr_8h.html#a53683a9e279942578e46768be25587d0">style_arg</a>(x))</td></tr>
<tr class="memdesc:ab307d323b317da4b6f4d24ee1929b354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return just the escape code string for a style.  <a href="#ab307d323b317da4b6f4d24ee1929b354">More...</a><br /></td></tr>
<tr class="separator:ab307d323b317da4b6f4d24ee1929b354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb829be51382b5422286a8606a7ff4fc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#adb829be51382b5422286a8606a7ff4fc">style_str_static</a>(x)</td></tr>
<tr class="memdesc:adb829be51382b5422286a8606a7ff4fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A less-flexible <a class="el" href="colr_8h.html#ab307d323b317da4b6f4d24ee1929b354" title="Return just the escape code string for a style. ">style_str()</a> that returns a static escape code string for a style.  <a href="#adb829be51382b5422286a8606a7ff4fc">More...</a><br /></td></tr>
<tr class="separator:adb829be51382b5422286a8606a7ff4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5da78a4dc69dfce7a6d4d459e657e85"><td class="memItemLeft" align="right" valign="top"><a id="ab5da78a4dc69dfce7a6d4d459e657e85"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab5da78a4dc69dfce7a6d4d459e657e85">WCODE_RESET_ALL</a>&#160;&#160;&#160;L&quot;\x1b[0m&quot;</td></tr>
<tr class="memdesc:ab5da78a4dc69dfce7a6d4d459e657e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience definition for wide chars. <br /></td></tr>
<tr class="separator:ab5da78a4dc69dfce7a6d4d459e657e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c3a4a860e470401760270819c5438c"><td class="memItemLeft" align="right" valign="top"><a id="a91c3a4a860e470401760270819c5438c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a91c3a4a860e470401760270819c5438c">WCODE_RESET_BACK</a>&#160;&#160;&#160;L&quot;\x1b[49m&quot;</td></tr>
<tr class="memdesc:a91c3a4a860e470401760270819c5438c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience definition for resetting the back color. <br /></td></tr>
<tr class="separator:a91c3a4a860e470401760270819c5438c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5357c5e28ee880fd58f44e4462a39db"><td class="memItemLeft" align="right" valign="top"><a id="af5357c5e28ee880fd58f44e4462a39db"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#af5357c5e28ee880fd58f44e4462a39db">WCODE_RESET_FORE</a>&#160;&#160;&#160;L&quot;\x1b[39m&quot;</td></tr>
<tr class="memdesc:af5357c5e28ee880fd58f44e4462a39db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience definition for resetting the fore color. <br /></td></tr>
<tr class="separator:af5357c5e28ee880fd58f44e4462a39db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d2ceec58f8075f06e09f277c8893ae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ad1d2ceec58f8075f06e09f277c8893ae">while_colr_va_arg</a>(ap,  vartype,  x)&#160;&#160;&#160;while (x = va_arg(ap, vartype), !<a class="el" href="colr_8h.html#af64af11f4992c8143cb722772df98c98">_colr_is_last_arg</a>(x))</td></tr>
<tr class="memdesc:ad1d2ceec58f8075f06e09f277c8893ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a while-loop over a <code>va_list</code>, where the last argument is expected to be _ColrLastArg, or a pointer to a _ColrLastArg_s with the same values as _ColrLastArg.  <a href="#ad1d2ceec58f8075f06e09f277c8893ae">More...</a><br /></td></tr>
<tr class="separator:ad1d2ceec58f8075f06e09f277c8893ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776e776cd944dea88b370a8204be5df4"><td class="memItemLeft" align="right" valign="top"><a id="a776e776cd944dea88b370a8204be5df4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a776e776cd944dea88b370a8204be5df4">WNC</a>&#160;&#160;&#160;<a class="el" href="colr_8h.html#ab5da78a4dc69dfce7a6d4d459e657e85">WCODE_RESET_ALL</a></td></tr>
<tr class="memdesc:a776e776cd944dea88b370a8204be5df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for WCODE_RESET_ALL, stands for "Wide No Color". <br /></td></tr>
<tr class="separator:a776e776cd944dea88b370a8204be5df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b2d3f481b1045baa8ae605d41dfb95"><td class="memItemLeft" align="right" valign="top"><a id="a21b2d3f481b1045baa8ae605d41dfb95"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a21b2d3f481b1045baa8ae605d41dfb95">WNCNL</a>&#160;&#160;&#160;<a class="el" href="colr_8h.html#ab5da78a4dc69dfce7a6d4d459e657e85">WCODE_RESET_ALL</a> L&quot;\n&quot;</td></tr>
<tr class="memdesc:a21b2d3f481b1045baa8ae605d41dfb95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for <code>WCODE_RESET_ALL "\n"</code>, stands for "Wide No Color, New Line". <br /></td></tr>
<tr class="separator:a21b2d3f481b1045baa8ae605d41dfb95"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a6dda29f582a062546ef8733d8b7d8a94"><td class="memItemLeft" align="right" valign="top"><a id="a6dda29f582a062546ef8733d8b7d8a94"></a>
typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a></td></tr>
<tr class="memdesc:a6dda29f582a062546ef8733d8b7d8a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience <code>typedef</code> for clarity when dealing with extended (256) colors. <br /></td></tr>
<tr class="separator:a6dda29f582a062546ef8733d8b7d8a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7762bf1f9efebc6bf59e685cf97f3990"><td class="memItemLeft" align="right" valign="top"><a id="a7762bf1f9efebc6bf59e685cf97f3990"></a>
typedef char *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a7762bf1f9efebc6bf59e685cf97f3990">rainbow_creator</a>) (const char *s, double freq, size_t offset, size_t spread)</td></tr>
<tr class="memdesc:a7762bf1f9efebc6bf59e685cf97f3990"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function type that knows how to create rainbowized text. <br /></td></tr>
<tr class="separator:a7762bf1f9efebc6bf59e685cf97f3990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc966460db21ff6c35f23fcf6abe541e"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#adc966460db21ff6c35f23fcf6abe541e">RGB_fmter</a>) (char *out, <a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:adc966460db21ff6c35f23fcf6abe541e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function type that knows how to fill a string with an rgb escape code.  <a href="#adc966460db21ff6c35f23fcf6abe541e">More...</a><br /></td></tr>
<tr class="separator:adc966460db21ff6c35f23fcf6abe541e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a58d8da4a4f5529031f00c7a6b9eeb5e1"><td class="memItemLeft" align="right" valign="top"><a id="a58d8da4a4f5529031f00c7a6b9eeb5e1"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> { <br />
&#160;&#160;<b>ARGTYPE_NONE</b> = -1, 
<br />
&#160;&#160;<b>FORE</b> = 0, 
<br />
&#160;&#160;<b>BACK</b> = 1, 
<br />
&#160;&#160;<b>STYLE</b> = 2
<br />
 }<tr class="memdesc:a58d8da4a4f5529031f00c7a6b9eeb5e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Argument types (fore, back, style). <br /></td></tr>
</td></tr>
<tr class="separator:a58d8da4a4f5529031f00c7a6b9eeb5e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c061fbfddd43dfe324486dc86cb92ee"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> { <br />
&#160;&#160;<b>BASIC_INVALID_RANGE</b> = COLOR_INVALID_RANGE, 
<br />
&#160;&#160;<b>BASIC_INVALID</b> = COLOR_INVALID, 
<br />
&#160;&#160;<b>BASIC_NONE</b> = -1, 
<br />
&#160;&#160;<b>BLACK</b> = 0, 
<br />
&#160;&#160;<b>RED</b> = 1, 
<br />
&#160;&#160;<b>GREEN</b> = 2, 
<br />
&#160;&#160;<b>YELLOW</b> = 3, 
<br />
&#160;&#160;<b>BLUE</b> = 4, 
<br />
&#160;&#160;<b>MAGENTA</b> = 5, 
<br />
&#160;&#160;<b>CYAN</b> = 6, 
<br />
&#160;&#160;<b>WHITE</b> = 7, 
<br />
&#160;&#160;<b>UNUSED</b> = 8, 
<br />
&#160;&#160;<b>RESET</b> = 9, 
<br />
&#160;&#160;<b>LIGHTBLACK</b> = 10, 
<br />
&#160;&#160;<b>LIGHTRED</b> = 11, 
<br />
&#160;&#160;<b>LIGHTGREEN</b> = 12, 
<br />
&#160;&#160;<b>LIGHTYELLOW</b> = 13, 
<br />
&#160;&#160;<b>LIGHTBLUE</b> = 14, 
<br />
&#160;&#160;<b>LIGHTMAGENTA</b> = 15, 
<br />
&#160;&#160;<b>LIGHTCYAN</b> = 16, 
<br />
&#160;&#160;<b>LIGHTWHITE</b> = 17
<br />
 }<tr class="memdesc:a0c061fbfddd43dfe324486dc86cb92ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic color values, with a few convenience values for extended colors.  <a href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a0c061fbfddd43dfe324486dc86cb92ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a3fe0b966f944fd659a98be170045f"><td class="memItemLeft" align="right" valign="top"><a id="af1a3fe0b966f944fd659a98be170045f"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#af1a3fe0b966f944fd659a98be170045f">ColorJustifyMethod</a> { <br />
&#160;&#160;<b>JUST_NONE</b> = -1, 
<br />
&#160;&#160;<b>JUST_LEFT</b> = 0, 
<br />
&#160;&#160;<b>JUST_RIGHT</b> = 1, 
<br />
&#160;&#160;<b>JUST_CENTER</b> = 2
<br />
 }<tr class="memdesc:af1a3fe0b966f944fd659a98be170045f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Justification style for ColorTexts. <br /></td></tr>
</td></tr>
<tr class="separator:af1a3fe0b966f944fd659a98be170045f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e133660cf9d4bcd1cb6a49e3ec16f83"><td class="memItemLeft" align="right" valign="top"><a id="a5e133660cf9d4bcd1cb6a49e3ec16f83"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> { <br />
&#160;&#160;<b>TYPE_NONE</b> = -6, 
<br />
&#160;&#160;<b>TYPE_INVALID_STYLE</b> = -5, 
<br />
&#160;&#160;<b>TYPE_INVALID_RGB_RANGE</b> = -4, 
<br />
&#160;&#160;<b>TYPE_INVALID_EXT_RANGE</b> = COLOR_INVALID_RANGE, 
<br />
&#160;&#160;<b>TYPE_INVALID</b> = COLOR_INVALID, 
<br />
&#160;&#160;<b>TYPE_BASIC</b> = 0, 
<br />
&#160;&#160;<b>TYPE_EXTENDED</b> = 1, 
<br />
&#160;&#160;<b>TYPE_RGB</b> = 2, 
<br />
&#160;&#160;<b>TYPE_STYLE</b> = 3
<br />
 }<tr class="memdesc:a5e133660cf9d4bcd1cb6a49e3ec16f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Color/Style code types. Used with <a class="el" href="colr_8h.html#afa75deef059c002134a88dbbdc18fd49" title="Determine which type of color value is desired by name. ">ColorType_from_str()</a> and <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>. <br /></td></tr>
</td></tr>
<tr class="separator:a5e133660cf9d4bcd1cb6a49e3ec16f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85224ec2507f33b1985f4cdd0adfe0e6"><td class="memItemLeft" align="right" valign="top"><a id="a85224ec2507f33b1985f4cdd0adfe0e6"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a> { <br />
&#160;&#160;<b>STYLE_INVALID_RANGE</b> = COLOR_INVALID_RANGE, 
<br />
&#160;&#160;<b>STYLE_INVALID</b> = COLOR_INVALID, 
<br />
&#160;&#160;<b>STYLE_NONE</b> = -1, 
<br />
&#160;&#160;<b>RESET_ALL</b> = 0, 
<br />
&#160;&#160;<b>BRIGHT</b> = 1, 
<br />
&#160;&#160;<b>DIM</b> = 2, 
<br />
&#160;&#160;<b>ITALIC</b> = 3, 
<br />
&#160;&#160;<b>UNDERLINE</b> = 4, 
<br />
&#160;&#160;<b>FLASH</b> = 5, 
<br />
&#160;&#160;<b>HIGHLIGHT</b> = 7, 
<br />
&#160;&#160;<b>STRIKETHRU</b> = 9, 
<br />
&#160;&#160;<b>NORMAL</b> = 22, 
<br />
&#160;&#160;<b>FRAME</b> = 51, 
<br />
&#160;&#160;<b>ENCIRCLE</b> = 52, 
<br />
&#160;&#160;<b>OVERLINE</b> = 53
<br />
 }<tr class="memdesc:a85224ec2507f33b1985f4cdd0adfe0e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Style values. <br /></td></tr>
</td></tr>
<tr class="separator:a85224ec2507f33b1985f4cdd0adfe0e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aaa888f1b31eb40ec7d252d3ee9175d76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aaa888f1b31eb40ec7d252d3ee9175d76">_colr_free</a> (void *p)</td></tr>
<tr class="memdesc:aaa888f1b31eb40ec7d252d3ee9175d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls Colr <code>*_free()</code> functions for Colr objects, otherwise just calls <code>free()</code>.  <a href="#aaa888f1b31eb40ec7d252d3ee9175d76">More...</a><br /></td></tr>
<tr class="separator:aaa888f1b31eb40ec7d252d3ee9175d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64af11f4992c8143cb722772df98c98"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#af64af11f4992c8143cb722772df98c98">_colr_is_last_arg</a> (void *p)</td></tr>
<tr class="memdesc:af64af11f4992c8143cb722772df98c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a void pointer is _ColrLastArg (the last-arg-marker).  <a href="#af64af11f4992c8143cb722772df98c98">More...</a><br /></td></tr>
<tr class="separator:af64af11f4992c8143cb722772df98c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4227a65824fdd699a25d3200706c9e9e"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join</a> (void *joinerp,...)</td></tr>
<tr class="memdesc:a4227a65824fdd699a25d3200706c9e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joins ColorArgs, ColorTexts, and strings (<code>char*</code>) into one long string separated by it's first argument.  <a href="#a4227a65824fdd699a25d3200706c9e9e">More...</a><br /></td></tr>
<tr class="separator:a4227a65824fdd699a25d3200706c9e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d47ac6ee2a59e1c976cf2838545aa25"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a6d47ac6ee2a59e1c976cf2838545aa25">_colr_join_array_length</a> (void *ps)</td></tr>
<tr class="memdesc:a6d47ac6ee2a59e1c976cf2838545aa25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the length of a <code>NULL</code>-terminated array of strings (<code>char*</code>), <code><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a></code>s, <code><a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a></code>s, or <code><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a></code>s.  <a href="#a6d47ac6ee2a59e1c976cf2838545aa25">More...</a><br /></td></tr>
<tr class="separator:a6d47ac6ee2a59e1c976cf2838545aa25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49c3a33d328ebaf2b0564d5a9b1d4ec"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ac49c3a33d328ebaf2b0564d5a9b1d4ec">_colr_join_arrayn_size</a> (void *joinerp, void *ps, size_t count)</td></tr>
<tr class="memdesc:ac49c3a33d328ebaf2b0564d5a9b1d4ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size in bytes needed to join an array of strings (<code>char*</code>), <code><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a></code>s, <code><a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a></code>s, or <code><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a></code>s by another string (<code>char*</code>), <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.  <a href="#ac49c3a33d328ebaf2b0564d5a9b1d4ec">More...</a><br /></td></tr>
<tr class="separator:ac49c3a33d328ebaf2b0564d5a9b1d4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a051ef4cd2e7200a31f9de48766b4c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a91a051ef4cd2e7200a31f9de48766b4c">_colr_join_size</a> (void *joinerp, va_list args)</td></tr>
<tr class="memdesc:a91a051ef4cd2e7200a31f9de48766b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse arguments, just as in <a class="el" href="colr_8c.html#a4227a65824fdd699a25d3200706c9e9e" title="Joins ColorArgs, ColorTexts, and strings (char*) into one long string separated by it&#39;s first argumen...">_colr_join()</a>, but only return the size needed to allocate the resulting string.  <a href="#a91a051ef4cd2e7200a31f9de48766b4c">More...</a><br /></td></tr>
<tr class="separator:a91a051ef4cd2e7200a31f9de48766b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0be451277fc7e39aee0aa409c9d3f0c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab0be451277fc7e39aee0aa409c9d3f0c">_colr_ptr_length</a> (void *p)</td></tr>
<tr class="memdesc:ab0be451277fc7e39aee0aa409c9d3f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size, in bytes, needed to convert a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, or string (<code>char*</code>) into a string.  <a href="#ab0be451277fc7e39aee0aa409c9d3f0c">More...</a><br /></td></tr>
<tr class="separator:ab0be451277fc7e39aee0aa409c9d3f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30cac3017a6ea8c78277882554c9419f"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a30cac3017a6ea8c78277882554c9419f">_colr_ptr_repr</a> (void *p)</td></tr>
<tr class="memdesc:a30cac3017a6ea8c78277882554c9419f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine what kind of pointer is being passed, and call the appropriate &lt;type&gt;_repr function to obtain an allocated string representation.  <a href="#a30cac3017a6ea8c78277882554c9419f">More...</a><br /></td></tr>
<tr class="separator:a30cac3017a6ea8c78277882554c9419f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d97f9b535a69642b926b38dce30b180"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a0d97f9b535a69642b926b38dce30b180">_colr_ptr_to_str</a> (void *p)</td></tr>
<tr class="memdesc:a0d97f9b535a69642b926b38dce30b180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine what kind of pointer is being passed, and call the appropriate &lt;type&gt;_to_str function to obtain an allocated string.  <a href="#a0d97f9b535a69642b926b38dce30b180">More...</a><br /></td></tr>
<tr class="separator:a0d97f9b535a69642b926b38dce30b180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88ca919420f2df896b7973401641ab4"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab88ca919420f2df896b7973401641ab4">_rainbow</a> (<a class="el" href="colr_8h.html#adc966460db21ff6c35f23fcf6abe541e">RGB_fmter</a> fmter, const char *s, double freq, size_t offset, size_t spread)</td></tr>
<tr class="memdesc:ab88ca919420f2df896b7973401641ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles multibyte character string (<code>char*</code>) conversion and character iteration for all of the rainbow_ functions.  <a href="#ab88ca919420f2df896b7973401641ab4">More...</a><br /></td></tr>
<tr class="separator:ab88ca919420f2df896b7973401641ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d1fc130eeaf6ed62066e25478cb433"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a69d1fc130eeaf6ed62066e25478cb433">ArgType_eq</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> a, <a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> b)</td></tr>
<tr class="memdesc:a69d1fc130eeaf6ed62066e25478cb433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ArgTypes.  <a href="#a69d1fc130eeaf6ed62066e25478cb433">More...</a><br /></td></tr>
<tr class="separator:a69d1fc130eeaf6ed62066e25478cb433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01ccaf04c71fc2474da94b050236572"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ad01ccaf04c71fc2474da94b050236572">ArgType_repr</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type)</td></tr>
<tr class="memdesc:ad01ccaf04c71fc2474da94b050236572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation of a ArgType.  <a href="#ad01ccaf04c71fc2474da94b050236572">More...</a><br /></td></tr>
<tr class="separator:ad01ccaf04c71fc2474da94b050236572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b270bebb1a01212b7e44e52f61f94be"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a2b270bebb1a01212b7e44e52f61f94be">ArgType_to_str</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type)</td></tr>
<tr class="memdesc:a2b270bebb1a01212b7e44e52f61f94be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a human-friendly string (<code>char*</code>) from an ArgType.  <a href="#a2b270bebb1a01212b7e44e52f61f94be">More...</a><br /></td></tr>
<tr class="separator:a2b270bebb1a01212b7e44e52f61f94be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17bf46ac385e41b729d07a65dd506cba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a17bf46ac385e41b729d07a65dd506cba">BasicValue_eq</a> (<a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> a, <a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> b)</td></tr>
<tr class="memdesc:a17bf46ac385e41b729d07a65dd506cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two BasicValues.  <a href="#a17bf46ac385e41b729d07a65dd506cba">More...</a><br /></td></tr>
<tr class="separator:a17bf46ac385e41b729d07a65dd506cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481b2cb2526e58b2fdb2e52a722d987b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a481b2cb2526e58b2fdb2e52a722d987b">BasicValue_from_esc</a> (const char *s)</td></tr>
<tr class="memdesc:a481b2cb2526e58b2fdb2e52a722d987b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an escape-code string (<code>char*</code>) to an actual BasicValue enum value.  <a href="#a481b2cb2526e58b2fdb2e52a722d987b">More...</a><br /></td></tr>
<tr class="separator:a481b2cb2526e58b2fdb2e52a722d987b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4163ac65dca3e222525808b80a40b733"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a4163ac65dca3e222525808b80a40b733">BasicValue_from_str</a> (const char *arg)</td></tr>
<tr class="memdesc:a4163ac65dca3e222525808b80a40b733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert named argument to an actual BasicValue enum value.  <a href="#a4163ac65dca3e222525808b80a40b733">More...</a><br /></td></tr>
<tr class="separator:a4163ac65dca3e222525808b80a40b733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6332bbd16e746a02491eee70c13d0735"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a6332bbd16e746a02491eee70c13d0735">BasicValue_is_invalid</a> (<a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> bval)</td></tr>
<tr class="memdesc:a6332bbd16e746a02491eee70c13d0735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a BasicValue is invalid.  <a href="#a6332bbd16e746a02491eee70c13d0735">More...</a><br /></td></tr>
<tr class="separator:a6332bbd16e746a02491eee70c13d0735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e4c8a4789232c78b9ef17e292839ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a29e4c8a4789232c78b9ef17e292839ca">BasicValue_is_valid</a> (<a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> bval)</td></tr>
<tr class="memdesc:a29e4c8a4789232c78b9ef17e292839ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a BasicValue is valid.  <a href="#a29e4c8a4789232c78b9ef17e292839ca">More...</a><br /></td></tr>
<tr class="separator:a29e4c8a4789232c78b9ef17e292839ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc0d9917621cab5b3efd162b7dc5a8c"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a1bc0d9917621cab5b3efd162b7dc5a8c">BasicValue_repr</a> (<a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> bval)</td></tr>
<tr class="memdesc:a1bc0d9917621cab5b3efd162b7dc5a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation of a BasicValue.  <a href="#a1bc0d9917621cab5b3efd162b7dc5a8c">More...</a><br /></td></tr>
<tr class="separator:a1bc0d9917621cab5b3efd162b7dc5a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a78ebb45cb53792d4c658bade99a70"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a71a78ebb45cb53792d4c658bade99a70">BasicValue_to_ansi</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type, <a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> bval)</td></tr>
<tr class="memdesc:a71a78ebb45cb53792d4c658bade99a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a fore/back BasicValue to the actual ansi code number.  <a href="#a71a78ebb45cb53792d4c658bade99a70">More...</a><br /></td></tr>
<tr class="separator:a71a78ebb45cb53792d4c658bade99a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ea2f6c1adea8535ae629051e74ced0"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a83ea2f6c1adea8535ae629051e74ced0">BasicValue_to_str</a> (<a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> bval)</td></tr>
<tr class="memdesc:a83ea2f6c1adea8535ae629051e74ced0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a human-friendly string (<code>char*</code>) representation for a BasicValue.  <a href="#a83ea2f6c1adea8535ae629051e74ced0">More...</a><br /></td></tr>
<tr class="separator:a83ea2f6c1adea8535ae629051e74ced0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af838f8479681d809beb868b2e1b547e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#af838f8479681d809beb868b2e1b547e7">ColorArg_empty</a> (void)</td></tr>
<tr class="memdesc:af838f8479681d809beb868b2e1b547e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> with ARGTYPE_NONE and ColorValue.type.TYPE_NONE.  <a href="#af838f8479681d809beb868b2e1b547e7">More...</a><br /></td></tr>
<tr class="separator:af838f8479681d809beb868b2e1b547e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb62efc0182d6f6107055eeda961a628"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#acb62efc0182d6f6107055eeda961a628">ColorArg_eq</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> a, <a class="el" href="colr_8h.html#structColorArg">ColorArg</a> b)</td></tr>
<tr class="memdesc:acb62efc0182d6f6107055eeda961a628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> structs.  <a href="#acb62efc0182d6f6107055eeda961a628">More...</a><br /></td></tr>
<tr class="separator:acb62efc0182d6f6107055eeda961a628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54ab1879f6de8ca2fcb4702250741f5"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aa54ab1879f6de8ca2fcb4702250741f5">ColorArg_example</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> carg, bool colorized)</td></tr>
<tr class="memdesc:aa54ab1879f6de8ca2fcb4702250741f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a string (<code>char*</code>) representation of a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> with a stylized type/name using escape codes built from the <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s values.  <a href="#aa54ab1879f6de8ca2fcb4702250741f5">More...</a><br /></td></tr>
<tr class="separator:aa54ab1879f6de8ca2fcb4702250741f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1163a9c866767fb7fcb734d3c0d9b7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aa1163a9c866767fb7fcb734d3c0d9b7c">ColorArg_free</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *p)</td></tr>
<tr class="memdesc:aa1163a9c866767fb7fcb734d3c0d9b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free allocated memory for a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>.  <a href="#aa1163a9c866767fb7fcb734d3c0d9b7c">More...</a><br /></td></tr>
<tr class="separator:aa1163a9c866767fb7fcb734d3c0d9b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad49f4597388e6bdb896ff28334cd5e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aad49f4597388e6bdb896ff28334cd5e6">ColorArg_from_BasicValue</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type, <a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> value)</td></tr>
<tr class="memdesc:aad49f4597388e6bdb896ff28334cd5e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit version of ColorArg_from_value that only handles BasicValues.  <a href="#aad49f4597388e6bdb896ff28334cd5e6">More...</a><br /></td></tr>
<tr class="separator:aad49f4597388e6bdb896ff28334cd5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e9640f37dd85cde0b6f25c0b705912"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a70e9640f37dd85cde0b6f25c0b705912">ColorArg_from_esc</a> (const char *s)</td></tr>
<tr class="memdesc:a70e9640f37dd85cde0b6f25c0b705912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an escape-code string (<code>char*</code>) into a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>.  <a href="#a70e9640f37dd85cde0b6f25c0b705912">More...</a><br /></td></tr>
<tr class="separator:a70e9640f37dd85cde0b6f25c0b705912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed30e2a4b30ab5e3cf49608a3c410cc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aed30e2a4b30ab5e3cf49608a3c410cc5">ColorArg_from_ExtendedValue</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type, <a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a> value)</td></tr>
<tr class="memdesc:aed30e2a4b30ab5e3cf49608a3c410cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit version of ColorArg_from_value that only handles ExtendedValues.  <a href="#aed30e2a4b30ab5e3cf49608a3c410cc5">More...</a><br /></td></tr>
<tr class="separator:aed30e2a4b30ab5e3cf49608a3c410cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa24bba74e99aa66ed41839576e57856"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aaa24bba74e99aa66ed41839576e57856">ColorArg_from_RGB</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type, <a class="el" href="colr_8h.html#structRGB">RGB</a> value)</td></tr>
<tr class="memdesc:aaa24bba74e99aa66ed41839576e57856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit version of ColorArg_from_value that only handles <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> structs.  <a href="#aaa24bba74e99aa66ed41839576e57856">More...</a><br /></td></tr>
<tr class="separator:aaa24bba74e99aa66ed41839576e57856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62406b058b948941a8906475924536a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aa62406b058b948941a8906475924536a">ColorArg_from_str</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type, const char *colorname)</td></tr>
<tr class="memdesc:aa62406b058b948941a8906475924536a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> (fore, back, or style value) from a known color name/style.  <a href="#aa62406b058b948941a8906475924536a">More...</a><br /></td></tr>
<tr class="separator:aa62406b058b948941a8906475924536a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf63bcee395dca3ca29dc324e3d7c8f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#acf63bcee395dca3ca29dc324e3d7c8f2">ColorArg_from_StyleValue</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type, <a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a> value)</td></tr>
<tr class="memdesc:acf63bcee395dca3ca29dc324e3d7c8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit version of ColorArg_from_value that only handles StyleValues.  <a href="#acf63bcee395dca3ca29dc324e3d7c8f2">More...</a><br /></td></tr>
<tr class="separator:acf63bcee395dca3ca29dc324e3d7c8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a5aa762bd5802872faf571aa32ea35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a89a5aa762bd5802872faf571aa32ea35">ColorArg_from_value</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type, <a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> colrtype, void *p)</td></tr>
<tr class="memdesc:a89a5aa762bd5802872faf571aa32ea35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used with the color_arg macro to dynamically create a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> based on it's argument type.  <a href="#a89a5aa762bd5802872faf571aa32ea35">More...</a><br /></td></tr>
<tr class="separator:a89a5aa762bd5802872faf571aa32ea35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752355c2d96d35688d3756558f8421ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a752355c2d96d35688d3756558f8421ba">ColorArg_is_empty</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> carg)</td></tr>
<tr class="memdesc:a752355c2d96d35688d3756558f8421ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> is an empty placeholder.  <a href="#a752355c2d96d35688d3756558f8421ba">More...</a><br /></td></tr>
<tr class="separator:a752355c2d96d35688d3756558f8421ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b4906cfb08588005536db1250dc899"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a66b4906cfb08588005536db1250dc899">ColorArg_is_invalid</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> carg)</td></tr>
<tr class="memdesc:a66b4906cfb08588005536db1250dc899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> holds an invalid value.  <a href="#a66b4906cfb08588005536db1250dc899">More...</a><br /></td></tr>
<tr class="separator:a66b4906cfb08588005536db1250dc899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15f3a714a6383123d3fb24ade173e29"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ad15f3a714a6383123d3fb24ade173e29">ColorArg_is_ptr</a> (void *p)</td></tr>
<tr class="memdesc:ad15f3a714a6383123d3fb24ade173e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a void pointer to see if it contains a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct.  <a href="#ad15f3a714a6383123d3fb24ade173e29">More...</a><br /></td></tr>
<tr class="separator:ad15f3a714a6383123d3fb24ade173e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e446f65d6987d52522a1755c909d421"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a1e446f65d6987d52522a1755c909d421">ColorArg_is_valid</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> carg)</td></tr>
<tr class="memdesc:a1e446f65d6987d52522a1755c909d421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> holds a valid value.  <a href="#a1e446f65d6987d52522a1755c909d421">More...</a><br /></td></tr>
<tr class="separator:a1e446f65d6987d52522a1755c909d421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaff727006f4c057aab75e55bfb473c4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#adaff727006f4c057aab75e55bfb473c4">ColorArg_length</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> carg)</td></tr>
<tr class="memdesc:adaff727006f4c057aab75e55bfb473c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length in bytes needed to allocate a string (<code>char*</code>) built with <a class="el" href="colr_8c.html#ad1d3aaca5e543f8fefbd863a959c9d67" title="Converts a ColorArg into an escape code string (char*). ">ColorArg_to_esc()</a>.  <a href="#adaff727006f4c057aab75e55bfb473c4">More...</a><br /></td></tr>
<tr class="separator:adaff727006f4c057aab75e55bfb473c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af692f2357d46b9cee45bb114f2a4a2"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a5af692f2357d46b9cee45bb114f2a4a2">ColorArg_repr</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> carg)</td></tr>
<tr class="memdesc:a5af692f2357d46b9cee45bb114f2a4a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation for a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>.  <a href="#a5af692f2357d46b9cee45bb114f2a4a2">More...</a><br /></td></tr>
<tr class="separator:a5af692f2357d46b9cee45bb114f2a4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d3aaca5e543f8fefbd863a959c9d67"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ad1d3aaca5e543f8fefbd863a959c9d67">ColorArg_to_esc</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> carg)</td></tr>
<tr class="memdesc:ad1d3aaca5e543f8fefbd863a959c9d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> into an escape code string (<code>char*</code>).  <a href="#ad1d3aaca5e543f8fefbd863a959c9d67">More...</a><br /></td></tr>
<tr class="separator:ad1d3aaca5e543f8fefbd863a959c9d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf3d02ff1292f2aaa605522665ae564"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#abaf3d02ff1292f2aaa605522665ae564">ColorArg_to_esc_s</a> (char *dest, <a class="el" href="colr_8h.html#structColorArg">ColorArg</a> carg)</td></tr>
<tr class="memdesc:abaf3d02ff1292f2aaa605522665ae564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> into an escape code string (<code>char*</code>) and fills the destination string.  <a href="#abaf3d02ff1292f2aaa605522665ae564">More...</a><br /></td></tr>
<tr class="separator:abaf3d02ff1292f2aaa605522665ae564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5ac0bd012b8162cea125ad0d9e8bf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#afb5ac0bd012b8162cea125ad0d9e8bf0">ColorArg_to_ptr</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> carg)</td></tr>
<tr class="memdesc:afb5ac0bd012b8162cea125ad0d9e8bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> into memory and returns the pointer.  <a href="#afb5ac0bd012b8162cea125ad0d9e8bf0">More...</a><br /></td></tr>
<tr class="separator:afb5ac0bd012b8162cea125ad0d9e8bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c5256623852632a4ba040e3447431c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a32c5256623852632a4ba040e3447431c">ColorArgs_array_free</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> **ps)</td></tr>
<tr class="memdesc:a32c5256623852632a4ba040e3447431c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an allocated array of ColorArgs, including the array itself.  <a href="#a32c5256623852632a4ba040e3447431c">More...</a><br /></td></tr>
<tr class="separator:a32c5256623852632a4ba040e3447431c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e16f30e878a6fb53ed9af5f8fdd674a"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a4e16f30e878a6fb53ed9af5f8fdd674a">ColorArgs_array_repr</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> **lst)</td></tr>
<tr class="memdesc:a4e16f30e878a6fb53ed9af5f8fdd674a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string representation for an array of <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointers.  <a href="#a4e16f30e878a6fb53ed9af5f8fdd674a">More...</a><br /></td></tr>
<tr class="separator:a4e16f30e878a6fb53ed9af5f8fdd674a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4897abe50811762a84ee409c0c2d300f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a4897abe50811762a84ee409c0c2d300f">ColorArgs_from_str</a> (const char *s, bool unique)</td></tr>
<tr class="memdesc:a4897abe50811762a84ee409c0c2d300f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an array of ColorArgs from escape-codes found in a string (<code>char*</code>).  <a href="#a4897abe50811762a84ee409c0c2d300f">More...</a><br /></td></tr>
<tr class="separator:a4897abe50811762a84ee409c0c2d300f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11e9457ca4e8f5be0e29351b49b6844"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ae11e9457ca4e8f5be0e29351b49b6844">ColorJustify_empty</a> (void)</td></tr>
<tr class="memdesc:ae11e9457ca4e8f5be0e29351b49b6844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an "empty" <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a>, with JUST_NONE set.  <a href="#ae11e9457ca4e8f5be0e29351b49b6844">More...</a><br /></td></tr>
<tr class="separator:ae11e9457ca4e8f5be0e29351b49b6844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71656e616aef4bbb3c278d43c4a326e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab71656e616aef4bbb3c278d43c4a326e">ColorJustify_eq</a> (<a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a> a, <a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a> b)</td></tr>
<tr class="memdesc:ab71656e616aef4bbb3c278d43c4a326e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> structs.  <a href="#ab71656e616aef4bbb3c278d43c4a326e">More...</a><br /></td></tr>
<tr class="separator:ab71656e616aef4bbb3c278d43c4a326e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f193b6e6a20c63caecc1d9b53c89fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a34f193b6e6a20c63caecc1d9b53c89fb">ColorJustify_is_empty</a> (<a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a> cjust)</td></tr>
<tr class="memdesc:a34f193b6e6a20c63caecc1d9b53c89fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> is "empty".  <a href="#a34f193b6e6a20c63caecc1d9b53c89fb">More...</a><br /></td></tr>
<tr class="separator:a34f193b6e6a20c63caecc1d9b53c89fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4a7a21151993343ef96a068c6d5018"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a7d4a7a21151993343ef96a068c6d5018">ColorJustify_new</a> (<a class="el" href="colr_8h.html#af1a3fe0b966f944fd659a98be170045f">ColorJustifyMethod</a> method, int width, char padchar)</td></tr>
<tr class="memdesc:a7d4a7a21151993343ef96a068c6d5018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a>.  <a href="#a7d4a7a21151993343ef96a068c6d5018">More...</a><br /></td></tr>
<tr class="separator:a7d4a7a21151993343ef96a068c6d5018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c35f6b47cc737744487d14d20241656"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a6c35f6b47cc737744487d14d20241656">ColorJustify_repr</a> (<a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a> cjust)</td></tr>
<tr class="memdesc:a6c35f6b47cc737744487d14d20241656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation for a <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a>.  <a href="#a6c35f6b47cc737744487d14d20241656">More...</a><br /></td></tr>
<tr class="separator:a6c35f6b47cc737744487d14d20241656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf78eeb364553d130055d93e9892cd9c"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#adf78eeb364553d130055d93e9892cd9c">ColorJustifyMethod_repr</a> (<a class="el" href="colr_8h.html#af1a3fe0b966f944fd659a98be170045f">ColorJustifyMethod</a> meth)</td></tr>
<tr class="memdesc:adf78eeb364553d130055d93e9892cd9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation for a ColorJustifyMethod.  <a href="#adf78eeb364553d130055d93e9892cd9c">More...</a><br /></td></tr>
<tr class="separator:adf78eeb364553d130055d93e9892cd9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b59e832f322e617a89ca14046cc41d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a5b59e832f322e617a89ca14046cc41d2">ColorResult_empty</a> (void)</td></tr>
<tr class="memdesc:a5b59e832f322e617a89ca14046cc41d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> with <code>.result=NULL</code> and <code>.length=-1</code>, with the appropriate struct marker.  <a href="#a5b59e832f322e617a89ca14046cc41d2">More...</a><br /></td></tr>
<tr class="separator:a5b59e832f322e617a89ca14046cc41d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb35d2507389c11d6ffe2adc6876efcc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#afb35d2507389c11d6ffe2adc6876efcc">ColorResult_eq</a> (<a class="el" href="colr_8h.html#structColorResult">ColorResult</a> a, <a class="el" href="colr_8h.html#structColorResult">ColorResult</a> b)</td></tr>
<tr class="memdesc:afb35d2507389c11d6ffe2adc6876efcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ColorResults.  <a href="#afb35d2507389c11d6ffe2adc6876efcc">More...</a><br /></td></tr>
<tr class="separator:afb35d2507389c11d6ffe2adc6876efcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b70c6de9b2351424100bd742b1f1a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a27b70c6de9b2351424100bd742b1f1a8">ColorResult_free</a> (<a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *p)</td></tr>
<tr class="memdesc:a27b70c6de9b2351424100bd742b1f1a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free allocated memory for a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> and it's <code>.result</code> member.  <a href="#a27b70c6de9b2351424100bd742b1f1a8">More...</a><br /></td></tr>
<tr class="separator:a27b70c6de9b2351424100bd742b1f1a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5fe635f26119c3a341b5dfe23abc97"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#afd5fe635f26119c3a341b5dfe23abc97">ColorResult_is_ptr</a> (void *p)</td></tr>
<tr class="memdesc:afd5fe635f26119c3a341b5dfe23abc97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a void pointer to see if it contains a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> struct.  <a href="#afd5fe635f26119c3a341b5dfe23abc97">More...</a><br /></td></tr>
<tr class="separator:afd5fe635f26119c3a341b5dfe23abc97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5169ef5d27a9c14bb765f7e7b70c9e2b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a5169ef5d27a9c14bb765f7e7b70c9e2b">ColorResult_length</a> (<a class="el" href="colr_8h.html#structColorResult">ColorResult</a> cres)</td></tr>
<tr class="memdesc:a5169ef5d27a9c14bb765f7e7b70c9e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the length in bytes (including the null-terminator), that is needed to store the return from <a class="el" href="colr_8c.html#af5174a576892401ea59b737558f27d8b" title="Convert a ColorResult into a string (char*). ">ColorResult_to_str()</a> (<code>.result</code>).  <a href="#a5169ef5d27a9c14bb765f7e7b70c9e2b">More...</a><br /></td></tr>
<tr class="separator:a5169ef5d27a9c14bb765f7e7b70c9e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af752035c362c7c9ddb2e7f2f2305d509"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#af752035c362c7c9ddb2e7f2f2305d509">ColorResult_new</a> (char *s)</td></tr>
<tr class="memdesc:af752035c362c7c9ddb2e7f2f2305d509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a new <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> with an allocated string (<code>char*</code>).  <a href="#af752035c362c7c9ddb2e7f2f2305d509">More...</a><br /></td></tr>
<tr class="separator:af752035c362c7c9ddb2e7f2f2305d509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0b90c57e8c4c475d9e0f517f3a0d42"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aae0b90c57e8c4c475d9e0f517f3a0d42">ColorResult_repr</a> (<a class="el" href="colr_8h.html#structColorResult">ColorResult</a> cres)</td></tr>
<tr class="memdesc:aae0b90c57e8c4c475d9e0f517f3a0d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a string representation for a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>.  <a href="#aae0b90c57e8c4c475d9e0f517f3a0d42">More...</a><br /></td></tr>
<tr class="separator:aae0b90c57e8c4c475d9e0f517f3a0d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5304067f9d673ce5b86ddba2a8807b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a5f5304067f9d673ce5b86ddba2a8807b">ColorResult_to_ptr</a> (<a class="el" href="colr_8h.html#structColorResult">ColorResult</a> cres)</td></tr>
<tr class="memdesc:a5f5304067f9d673ce5b86ddba2a8807b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory for a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, fill it, and return it.  <a href="#a5f5304067f9d673ce5b86ddba2a8807b">More...</a><br /></td></tr>
<tr class="separator:a5f5304067f9d673ce5b86ddba2a8807b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5174a576892401ea59b737558f27d8b"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#af5174a576892401ea59b737558f27d8b">ColorResult_to_str</a> (<a class="el" href="colr_8h.html#structColorResult">ColorResult</a> cres)</td></tr>
<tr class="memdesc:af5174a576892401ea59b737558f27d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> into a string (<code>char*</code>).  <a href="#af5174a576892401ea59b737558f27d8b">More...</a><br /></td></tr>
<tr class="separator:af5174a576892401ea59b737558f27d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341b4033c31c58e412ff15280185c6bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorText">ColorText</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a341b4033c31c58e412ff15280185c6bd">ColorText_empty</a> (void)</td></tr>
<tr class="memdesc:a341b4033c31c58e412ff15280185c6bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an "empty" <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> with pointers set to <code>NULL</code>.  <a href="#a341b4033c31c58e412ff15280185c6bd">More...</a><br /></td></tr>
<tr class="separator:a341b4033c31c58e412ff15280185c6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901e5738358a739629cc3aaccab3e73f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a901e5738358a739629cc3aaccab3e73f">ColorText_free</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> *p)</td></tr>
<tr class="memdesc:a901e5738358a739629cc3aaccab3e73f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> and it's ColorArgs.  <a href="#a901e5738358a739629cc3aaccab3e73f">More...</a><br /></td></tr>
<tr class="separator:a901e5738358a739629cc3aaccab3e73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4979a2ec9d5fb442ba025c6f2efc4864"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a4979a2ec9d5fb442ba025c6f2efc4864">ColorText_free_args</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> *p)</td></tr>
<tr class="memdesc:a4979a2ec9d5fb442ba025c6f2efc4864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> members of a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.  <a href="#a4979a2ec9d5fb442ba025c6f2efc4864">More...</a><br /></td></tr>
<tr class="separator:a4979a2ec9d5fb442ba025c6f2efc4864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4702d6ddc409a93a0b42c8f6141d2f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorText">ColorText</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ad4702d6ddc409a93a0b42c8f6141d2f2">ColorText_from_values</a> (char *text,...)</td></tr>
<tr class="memdesc:ad4702d6ddc409a93a0b42c8f6141d2f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> from 1 mandatory string (<code>char*</code>), and optional fore, back, and style args (pointers to ColorArgs).  <a href="#ad4702d6ddc409a93a0b42c8f6141d2f2">More...</a><br /></td></tr>
<tr class="separator:ad4702d6ddc409a93a0b42c8f6141d2f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f65430500d003575c547eb667330b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a93f65430500d003575c547eb667330b0">ColorText_has_arg</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> ctext, <a class="el" href="colr_8h.html#structColorArg">ColorArg</a> carg)</td></tr>
<tr class="memdesc:a93f65430500d003575c547eb667330b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> has a certain <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> value set.  <a href="#a93f65430500d003575c547eb667330b0">More...</a><br /></td></tr>
<tr class="separator:a93f65430500d003575c547eb667330b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b38987063bb127bb34761961d7f678"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a93b38987063bb127bb34761961d7f678">ColorText_has_args</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> ctext)</td></tr>
<tr class="memdesc:a93b38987063bb127bb34761961d7f678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> has any argument values set.  <a href="#a93b38987063bb127bb34761961d7f678">More...</a><br /></td></tr>
<tr class="separator:a93b38987063bb127bb34761961d7f678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac846e583415e832b9090270020320b9f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ac846e583415e832b9090270020320b9f">ColorText_is_empty</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> ctext)</td></tr>
<tr class="memdesc:ac846e583415e832b9090270020320b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> has no usable values.  <a href="#ac846e583415e832b9090270020320b9f">More...</a><br /></td></tr>
<tr class="separator:ac846e583415e832b9090270020320b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6eb8832110b943c3a3a17627a50288"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a1d6eb8832110b943c3a3a17627a50288">ColorText_is_ptr</a> (void *p)</td></tr>
<tr class="memdesc:a1d6eb8832110b943c3a3a17627a50288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a void pointer to see if it contains a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> struct.  <a href="#a1d6eb8832110b943c3a3a17627a50288">More...</a><br /></td></tr>
<tr class="separator:a1d6eb8832110b943c3a3a17627a50288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412833a097b050c8ee99874c733bd030"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a412833a097b050c8ee99874c733bd030">ColorText_length</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> ctext)</td></tr>
<tr class="memdesc:a412833a097b050c8ee99874c733bd030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length in bytes needed to allocate a string (<code>char*</code>) built with <a class="el" href="colr_8c.html#ae305b33e0a44b956ccf4123aa4f1a033" title="Stringifies a ColorText struct, creating a mix of escape codes and text. ">ColorText_to_str()</a> with the current <code>text</code>, <code>fore</code>, <code>back</code>, and <code>style</code> members.  <a href="#a412833a097b050c8ee99874c733bd030">More...</a><br /></td></tr>
<tr class="separator:a412833a097b050c8ee99874c733bd030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65363a3601cd9cfcdc7fc40722d5d3c3"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a65363a3601cd9cfcdc7fc40722d5d3c3">ColorText_repr</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> ctext)</td></tr>
<tr class="memdesc:a65363a3601cd9cfcdc7fc40722d5d3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a string (<code>char*</code>) representation for a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.  <a href="#a65363a3601cd9cfcdc7fc40722d5d3c3">More...</a><br /></td></tr>
<tr class="separator:a65363a3601cd9cfcdc7fc40722d5d3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab408d87cce896acccb75357acca8ade4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab408d87cce896acccb75357acca8ade4">ColorText_set_just</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> *ctext, <a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a> cjust)</td></tr>
<tr class="memdesc:ab408d87cce896acccb75357acca8ade4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> method for a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, and return the <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.  <a href="#ab408d87cce896acccb75357acca8ade4">More...</a><br /></td></tr>
<tr class="separator:ab408d87cce896acccb75357acca8ade4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880b39cd2ce9b622dbe7790a162d88f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a880b39cd2ce9b622dbe7790a162d88f7">ColorText_set_values</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> *ctext, char *text,...)</td></tr>
<tr class="memdesc:a880b39cd2ce9b622dbe7790a162d88f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an existing <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> from 1 mandatory string (<code>char*</code>), and optional fore, back, and style args (pointers to ColorArgs).  <a href="#a880b39cd2ce9b622dbe7790a162d88f7">More...</a><br /></td></tr>
<tr class="separator:a880b39cd2ce9b622dbe7790a162d88f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e04de932a4cf712ac91e794bdc3f8db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a8e04de932a4cf712ac91e794bdc3f8db">ColorText_to_ptr</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> ctext)</td></tr>
<tr class="memdesc:a8e04de932a4cf712ac91e794bdc3f8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> into allocated memory and returns the pointer.  <a href="#a8e04de932a4cf712ac91e794bdc3f8db">More...</a><br /></td></tr>
<tr class="separator:a8e04de932a4cf712ac91e794bdc3f8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae305b33e0a44b956ccf4123aa4f1a033"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ae305b33e0a44b956ccf4123aa4f1a033">ColorText_to_str</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> ctext)</td></tr>
<tr class="memdesc:ae305b33e0a44b956ccf4123aa4f1a033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stringifies a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> struct, creating a mix of escape codes and text.  <a href="#ae305b33e0a44b956ccf4123aa4f1a033">More...</a><br /></td></tr>
<tr class="separator:ae305b33e0a44b956ccf4123aa4f1a033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e3483ae4add048424177fdc2b97b71"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a29e3483ae4add048424177fdc2b97b71">ColorType_eq</a> (<a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> a, <a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> b)</td></tr>
<tr class="memdesc:a29e3483ae4add048424177fdc2b97b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ColorTypes.  <a href="#a29e3483ae4add048424177fdc2b97b71">More...</a><br /></td></tr>
<tr class="separator:a29e3483ae4add048424177fdc2b97b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa75deef059c002134a88dbbdc18fd49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#afa75deef059c002134a88dbbdc18fd49">ColorType_from_str</a> (const char *arg)</td></tr>
<tr class="memdesc:afa75deef059c002134a88dbbdc18fd49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine which type of color value is desired by name.  <a href="#afa75deef059c002134a88dbbdc18fd49">More...</a><br /></td></tr>
<tr class="separator:afa75deef059c002134a88dbbdc18fd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc223f6fda6296396e9ecddcc68d4aec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#adc223f6fda6296396e9ecddcc68d4aec">ColorType_is_invalid</a> (<a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> type)</td></tr>
<tr class="memdesc:adc223f6fda6296396e9ecddcc68d4aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if a ColorType value is considered invalid.  <a href="#adc223f6fda6296396e9ecddcc68d4aec">More...</a><br /></td></tr>
<tr class="separator:adc223f6fda6296396e9ecddcc68d4aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5883d43e3206584ad048908720afb2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a5a5883d43e3206584ad048908720afb2">ColorType_is_valid</a> (<a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> type)</td></tr>
<tr class="memdesc:a5a5883d43e3206584ad048908720afb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if a ColorType value is considered valid.  <a href="#a5a5883d43e3206584ad048908720afb2">More...</a><br /></td></tr>
<tr class="separator:a5a5883d43e3206584ad048908720afb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a291ca6d28f9f430794413b76b7b094ed"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a291ca6d28f9f430794413b76b7b094ed">ColorType_repr</a> (<a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> type)</td></tr>
<tr class="memdesc:a291ca6d28f9f430794413b76b7b094ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation of a ColorType.  <a href="#a291ca6d28f9f430794413b76b7b094ed">More...</a><br /></td></tr>
<tr class="separator:a291ca6d28f9f430794413b76b7b094ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb73415f467b040d4b0f8f1ef5e95312"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#acb73415f467b040d4b0f8f1ef5e95312">ColorType_to_str</a> (<a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> type)</td></tr>
<tr class="memdesc:acb73415f467b040d4b0f8f1ef5e95312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a human-friendly string (<code>char*</code>) representation for a ColorType.  <a href="#acb73415f467b040d4b0f8f1ef5e95312">More...</a><br /></td></tr>
<tr class="separator:acb73415f467b040d4b0f8f1ef5e95312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce7c54ad0e31ecf6d790c5770c2b66b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a5ce7c54ad0e31ecf6d790c5770c2b66b">ColorValue_empty</a> (void)</td></tr>
<tr class="memdesc:a5ce7c54ad0e31ecf6d790c5770c2b66b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an "empty" <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>.  <a href="#a5ce7c54ad0e31ecf6d790c5770c2b66b">More...</a><br /></td></tr>
<tr class="separator:a5ce7c54ad0e31ecf6d790c5770c2b66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf57e195301864cec80739e7e0f3000c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#adf57e195301864cec80739e7e0f3000c">ColorValue_eq</a> (<a class="el" href="colr_8h.html#structColorValue">ColorValue</a> a, <a class="el" href="colr_8h.html#structColorValue">ColorValue</a> b)</td></tr>
<tr class="memdesc:adf57e195301864cec80739e7e0f3000c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> structs.  <a href="#adf57e195301864cec80739e7e0f3000c">More...</a><br /></td></tr>
<tr class="separator:adf57e195301864cec80739e7e0f3000c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b5fc81980cbbfb425c7756eb8f0d0a"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a89b5fc81980cbbfb425c7756eb8f0d0a">ColorValue_example</a> (<a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval)</td></tr>
<tr class="memdesc:a89b5fc81980cbbfb425c7756eb8f0d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a string (<code>char*</code>) representation of a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> with a human-friendly type/name.  <a href="#a89b5fc81980cbbfb425c7756eb8f0d0a">More...</a><br /></td></tr>
<tr class="separator:a89b5fc81980cbbfb425c7756eb8f0d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af308e8dcd4a1d47a05736882d5a9698d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#af308e8dcd4a1d47a05736882d5a9698d">ColorValue_from_esc</a> (const char *s)</td></tr>
<tr class="memdesc:af308e8dcd4a1d47a05736882d5a9698d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an escape-code string (<code>char*</code>) into a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>.  <a href="#af308e8dcd4a1d47a05736882d5a9698d">More...</a><br /></td></tr>
<tr class="separator:af308e8dcd4a1d47a05736882d5a9698d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c63f5f62e11d5f375a3824b12c80608"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a7c63f5f62e11d5f375a3824b12c80608">ColorValue_from_str</a> (const char *s)</td></tr>
<tr class="memdesc:a7c63f5f62e11d5f375a3824b12c80608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> from a known color name, or <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> string (<code>char*</code>).  <a href="#a7c63f5f62e11d5f375a3824b12c80608">More...</a><br /></td></tr>
<tr class="separator:a7c63f5f62e11d5f375a3824b12c80608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7fedbceb4f751d0d30034c0ef1dca8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aca7fedbceb4f751d0d30034c0ef1dca8">ColorValue_from_value</a> (<a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> type, void *p)</td></tr>
<tr class="memdesc:aca7fedbceb4f751d0d30034c0ef1dca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used with the color_val macro to dynamically create a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> based on it's argument type.  <a href="#aca7fedbceb4f751d0d30034c0ef1dca8">More...</a><br /></td></tr>
<tr class="separator:aca7fedbceb4f751d0d30034c0ef1dca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711a955406cde9716797bf61ab43a7a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a711a955406cde9716797bf61ab43a7a7">ColorValue_has_BasicValue</a> (<a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval, <a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> bval)</td></tr>
<tr class="memdesc:a711a955406cde9716797bf61ab43a7a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has a BasicValue set.  <a href="#a711a955406cde9716797bf61ab43a7a7">More...</a><br /></td></tr>
<tr class="separator:a711a955406cde9716797bf61ab43a7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11dc047d1defc4de2239a45667b45f85"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a11dc047d1defc4de2239a45667b45f85">ColorValue_has_ExtendedValue</a> (<a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval, <a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a> eval)</td></tr>
<tr class="memdesc:a11dc047d1defc4de2239a45667b45f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has a ExtendedValue set.  <a href="#a11dc047d1defc4de2239a45667b45f85">More...</a><br /></td></tr>
<tr class="separator:a11dc047d1defc4de2239a45667b45f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6908a961d4165a458be1aa64f082a45"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab6908a961d4165a458be1aa64f082a45">ColorValue_has_RGB</a> (<a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval, <a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:ab6908a961d4165a458be1aa64f082a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has a <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value set.  <a href="#ab6908a961d4165a458be1aa64f082a45">More...</a><br /></td></tr>
<tr class="separator:ab6908a961d4165a458be1aa64f082a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fbfa502deb1f2bb920b74b9f4867fcf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a3fbfa502deb1f2bb920b74b9f4867fcf">ColorValue_has_StyleValue</a> (<a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval, <a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a> sval)</td></tr>
<tr class="memdesc:a3fbfa502deb1f2bb920b74b9f4867fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has a StyleValue set.  <a href="#a3fbfa502deb1f2bb920b74b9f4867fcf">More...</a><br /></td></tr>
<tr class="separator:a3fbfa502deb1f2bb920b74b9f4867fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48005bb1589a7ebeef413ccee2a7c2a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a48005bb1589a7ebeef413ccee2a7c2a1">ColorValue_is_empty</a> (<a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval)</td></tr>
<tr class="memdesc:a48005bb1589a7ebeef413ccee2a7c2a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> is an empty placeholder.  <a href="#a48005bb1589a7ebeef413ccee2a7c2a1">More...</a><br /></td></tr>
<tr class="separator:a48005bb1589a7ebeef413ccee2a7c2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22fcf30338eb777592421543885f74e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a22fcf30338eb777592421543885f74e0">ColorValue_is_invalid</a> (<a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval)</td></tr>
<tr class="memdesc:a22fcf30338eb777592421543885f74e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> holds an invalid value.  <a href="#a22fcf30338eb777592421543885f74e0">More...</a><br /></td></tr>
<tr class="separator:a22fcf30338eb777592421543885f74e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7183410b61d12a99dda3f76c2705497"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ac7183410b61d12a99dda3f76c2705497">ColorValue_is_valid</a> (<a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval)</td></tr>
<tr class="memdesc:ac7183410b61d12a99dda3f76c2705497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> holds a valid value.  <a href="#ac7183410b61d12a99dda3f76c2705497">More...</a><br /></td></tr>
<tr class="separator:ac7183410b61d12a99dda3f76c2705497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af891527249f068cfcef057313c522a42"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#af891527249f068cfcef057313c522a42">ColorValue_length</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type, <a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval)</td></tr>
<tr class="memdesc:af891527249f068cfcef057313c522a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length in bytes needed to allocate a string (<code>char*</code>) built with <a class="el" href="colr_8c.html#ab62d1c5cc30bb9211de8b5321be5c3ee" title="Converts a ColorValue into an escape code string (char*). ">ColorValue_to_esc()</a> with the specified ArgType and <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>.  <a href="#af891527249f068cfcef057313c522a42">More...</a><br /></td></tr>
<tr class="separator:af891527249f068cfcef057313c522a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95cf6ab7c565726eeb7c276d734193f6"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a95cf6ab7c565726eeb7c276d734193f6">ColorValue_repr</a> (<a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval)</td></tr>
<tr class="memdesc:a95cf6ab7c565726eeb7c276d734193f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation of a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>.  <a href="#a95cf6ab7c565726eeb7c276d734193f6">More...</a><br /></td></tr>
<tr class="separator:a95cf6ab7c565726eeb7c276d734193f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62d1c5cc30bb9211de8b5321be5c3ee"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab62d1c5cc30bb9211de8b5321be5c3ee">ColorValue_to_esc</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type, <a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval)</td></tr>
<tr class="memdesc:ab62d1c5cc30bb9211de8b5321be5c3ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> into an escape code string (<code>char*</code>).  <a href="#ab62d1c5cc30bb9211de8b5321be5c3ee">More...</a><br /></td></tr>
<tr class="separator:ab62d1c5cc30bb9211de8b5321be5c3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebcf95faa1465843b6510d534d0311a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aebcf95faa1465843b6510d534d0311a0">ColorValue_to_esc_s</a> (char *dest, <a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type, <a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval)</td></tr>
<tr class="memdesc:aebcf95faa1465843b6510d534d0311a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> into an escape code string (<code>char*</code>) and fills the destination string.  <a href="#aebcf95faa1465843b6510d534d0311a0">More...</a><br /></td></tr>
<tr class="separator:aebcf95faa1465843b6510d534d0311a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc40c0187b5a18c21428e18434e8e0df"><td class="memItemLeft" align="right" valign="top">regmatch_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#afc40c0187b5a18c21428e18434e8e0df">colr_alloc_regmatch</a> (regmatch_t match)</td></tr>
<tr class="memdesc:afc40c0187b5a18c21428e18434e8e0df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates space for a regmatch_t, initializes it, and returns a pointer to it.  <a href="#afc40c0187b5a18c21428e18434e8e0df">More...</a><br /></td></tr>
<tr class="separator:afc40c0187b5a18c21428e18434e8e0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10030070daafdee7124638adfc5469d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a10030070daafdee7124638adfc5469d8">colr_append_reset</a> (char *s)</td></tr>
<tr class="memdesc:a10030070daafdee7124638adfc5469d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends CODE_RESET_ALL to a string (<code>char*</code>), but makes sure to do it before any newlines.  <a href="#a10030070daafdee7124638adfc5469d8">More...</a><br /></td></tr>
<tr class="separator:a10030070daafdee7124638adfc5469d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1ea562310969b7efa8711a843f103c"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a7f1ea562310969b7efa8711a843f103c">colr_char_escape_char</a> (const char c)</td></tr>
<tr class="memdesc:a7f1ea562310969b7efa8711a843f103c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the char needed to represent an escape sequence in C.  <a href="#a7f1ea562310969b7efa8711a843f103c">More...</a><br /></td></tr>
<tr class="separator:a7f1ea562310969b7efa8711a843f103c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38331775450608b94c5ecfeec28f9363"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a38331775450608b94c5ecfeec28f9363">colr_char_in_str</a> (const char *s, const char c)</td></tr>
<tr class="memdesc:a38331775450608b94c5ecfeec28f9363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a character exists in the given string (<code>char*</code>).  <a href="#a38331775450608b94c5ecfeec28f9363">More...</a><br /></td></tr>
<tr class="separator:a38331775450608b94c5ecfeec28f9363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4fed7123927027262875834964b0a94"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab4fed7123927027262875834964b0a94">colr_char_is_code_end</a> (const char c)</td></tr>
<tr class="memdesc:ab4fed7123927027262875834964b0a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a character is suitable for an escape code ending.  <a href="#ab4fed7123927027262875834964b0a94">More...</a><br /></td></tr>
<tr class="separator:ab4fed7123927027262875834964b0a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78a98cb101d4d5f18df0023b3109013"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#af78a98cb101d4d5f18df0023b3109013">colr_char_repr</a> (char c)</td></tr>
<tr class="memdesc:af78a98cb101d4d5f18df0023b3109013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation for a char.  <a href="#af78a98cb101d4d5f18df0023b3109013">More...</a><br /></td></tr>
<tr class="separator:af78a98cb101d4d5f18df0023b3109013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ef4700a46e78c2bed1132428a610fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a67ef4700a46e78c2bed1132428a610fb">colr_char_should_escape</a> (const char c)</td></tr>
<tr class="memdesc:a67ef4700a46e78c2bed1132428a610fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if an ascii character has an escape sequence in C.  <a href="#a67ef4700a46e78c2bed1132428a610fb">More...</a><br /></td></tr>
<tr class="separator:a67ef4700a46e78c2bed1132428a610fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe470aae91128e4529563c90c214e3a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#adfe470aae91128e4529563c90c214e3a">colr_check_marker</a> (uint32_t marker, void *p)</td></tr>
<tr class="memdesc:adfe470aae91128e4529563c90c214e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks an unsigned int against the individual bytes behind a pointer's value.  <a href="#adfe470aae91128e4529563c90c214e3a">More...</a><br /></td></tr>
<tr class="separator:adfe470aae91128e4529563c90c214e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8963c87ccb1c39bdd4481bb81810ba78"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a8963c87ccb1c39bdd4481bb81810ba78">colr_empty_str</a> (void)</td></tr>
<tr class="memdesc:a8963c87ccb1c39bdd4481bb81810ba78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates an empty string (<code>char*</code>).  <a href="#a8963c87ccb1c39bdd4481bb81810ba78">More...</a><br /></td></tr>
<tr class="separator:a8963c87ccb1c39bdd4481bb81810ba78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e72a18762c87886173dd0a0dc37887"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a67e72a18762c87886173dd0a0dc37887">colr_free_re_matches</a> (regmatch_t **matches)</td></tr>
<tr class="memdesc:a67e72a18762c87886173dd0a0dc37887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an array of allocated <code>regmatch_t</code>, like the return from <a class="el" href="colr_8c.html#a37cd9a8f2748629e68e9c41ffca557a9" title="Returns all regmatch_t matches for regex pattern in a string (char*). ">colr_re_matches()</a>.  <a href="#a67e72a18762c87886173dd0a0dc37887">More...</a><br /></td></tr>
<tr class="separator:a67e72a18762c87886173dd0a0dc37887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701126bd27c90fafa46152d9f9327b2f"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a701126bd27c90fafa46152d9f9327b2f">colr_join_array</a> (void *joinerp, void *ps)</td></tr>
<tr class="memdesc:a701126bd27c90fafa46152d9f9327b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join an array of strings (<code>char*</code>), <code><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a></code>s, or <code><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a></code>s by another string (<code>char*</code>), <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.  <a href="#a701126bd27c90fafa46152d9f9327b2f">More...</a><br /></td></tr>
<tr class="separator:a701126bd27c90fafa46152d9f9327b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71fcf08ad36d4424790e275d973445fc"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a71fcf08ad36d4424790e275d973445fc">colr_join_arrayn</a> (void *joinerp, void *ps, size_t count)</td></tr>
<tr class="memdesc:a71fcf08ad36d4424790e275d973445fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join an array of strings (<code>char*</code>), <code><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a></code>s, or <code><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a></code>s by another string (<code>char*</code>), <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.  <a href="#a71fcf08ad36d4424790e275d973445fc">More...</a><br /></td></tr>
<tr class="separator:a71fcf08ad36d4424790e275d973445fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade675256d9e88682d4bebdcc4a57f86f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ade675256d9e88682d4bebdcc4a57f86f">colr_mb_len</a> (const char *s, size_t length)</td></tr>
<tr class="memdesc:ade675256d9e88682d4bebdcc4a57f86f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>mbrlen</code>, except it will return the length of the next N (<code>length</code>) multibyte characters in bytes.  <a href="#ade675256d9e88682d4bebdcc4a57f86f">More...</a><br /></td></tr>
<tr class="separator:ade675256d9e88682d4bebdcc4a57f86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c359a48f811316d765b7abef1ea8f4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a34c359a48f811316d765b7abef1ea8f4">colr_printf_handler</a> (FILE *fp, const struct printf_info *info, const void *const *args)</td></tr>
<tr class="memdesc:a34c359a48f811316d765b7abef1ea8f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles printing with printf for Colr objects.  <a href="#a34c359a48f811316d765b7abef1ea8f4">More...</a><br /></td></tr>
<tr class="separator:a34c359a48f811316d765b7abef1ea8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95619a7f5eeb0158dfb969ae9a26a6bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a95619a7f5eeb0158dfb969ae9a26a6bb">colr_printf_info</a> (const struct printf_info *info, size_t n, int *argtypes, int *sz)</td></tr>
<tr class="memdesc:a95619a7f5eeb0158dfb969ae9a26a6bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles the arg count/size for the Colr printf handler.  <a href="#a95619a7f5eeb0158dfb969ae9a26a6bb">More...</a><br /></td></tr>
<tr class="separator:a95619a7f5eeb0158dfb969ae9a26a6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf134ca9a2188d83171fe91948354d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aaaf134ca9a2188d83171fe91948354d9">colr_printf_register</a> (void)</td></tr>
<tr class="memdesc:aaaf134ca9a2188d83171fe91948354d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers COLR_FMT_CHAR to handle Colr objects in the printf-family functions.  <a href="#aaaf134ca9a2188d83171fe91948354d9">More...</a><br /></td></tr>
<tr class="separator:aaaf134ca9a2188d83171fe91948354d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37cd9a8f2748629e68e9c41ffca557a9"><td class="memItemLeft" align="right" valign="top">regmatch_t **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a37cd9a8f2748629e68e9c41ffca557a9">colr_re_matches</a> (const char *s, regex_t *repattern)</td></tr>
<tr class="memdesc:a37cd9a8f2748629e68e9c41ffca557a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all <code>regmatch_t</code> matches for regex pattern in a string (<code>char*</code>).  <a href="#a37cd9a8f2748629e68e9c41ffca557a9">More...</a><br /></td></tr>
<tr class="separator:a37cd9a8f2748629e68e9c41ffca557a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180c1ac4711df9fb025639c966f84727"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a180c1ac4711df9fb025639c966f84727">colr_set_locale</a> (void)</td></tr>
<tr class="memdesc:a180c1ac4711df9fb025639c966f84727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the locale to <code>(LC_ALL, "")</code> if it hasn't already been set.  <a href="#a180c1ac4711df9fb025639c966f84727">More...</a><br /></td></tr>
<tr class="separator:a180c1ac4711df9fb025639c966f84727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b98f363fb0873cfb7e60e99191647a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a1b98f363fb0873cfb7e60e99191647a6">colr_str_array_contains</a> (char **lst, const char *s)</td></tr>
<tr class="memdesc:a1b98f363fb0873cfb7e60e99191647a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a string (<code>char*</code>) is in an array of strings (<code>char**</code>, where the last element is <code>NULL</code>).  <a href="#a1b98f363fb0873cfb7e60e99191647a6">More...</a><br /></td></tr>
<tr class="separator:a1b98f363fb0873cfb7e60e99191647a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90384ff3082ad86bf5eb0923ac9a644a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a90384ff3082ad86bf5eb0923ac9a644a">colr_str_array_free</a> (char **ps)</td></tr>
<tr class="memdesc:a90384ff3082ad86bf5eb0923ac9a644a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an allocated array of strings, including the array itself.  <a href="#a90384ff3082ad86bf5eb0923ac9a644a">More...</a><br /></td></tr>
<tr class="separator:a90384ff3082ad86bf5eb0923ac9a644a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a8345393e635e1c5e148473bdce292d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a1a8345393e635e1c5e148473bdce292d">colr_str_center</a> (const char *s, int width, const char padchar)</td></tr>
<tr class="memdesc:a1a8345393e635e1c5e148473bdce292d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Center-justifies a string (<code>char*</code>), ignoring escape codes when measuring the width.  <a href="#a1a8345393e635e1c5e148473bdce292d">More...</a><br /></td></tr>
<tr class="separator:a1a8345393e635e1c5e148473bdce292d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e3ecc4a6c4bcaad1217df9200d271e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ad5e3ecc4a6c4bcaad1217df9200d271e">colr_str_char_count</a> (const char *s, const char c)</td></tr>
<tr class="memdesc:ad5e3ecc4a6c4bcaad1217df9200d271e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of characters (<code>c</code>) that are found in a string (<code>char*</code>) (<code>s</code>).  <a href="#ad5e3ecc4a6c4bcaad1217df9200d271e">More...</a><br /></td></tr>
<tr class="separator:ad5e3ecc4a6c4bcaad1217df9200d271e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae479b42d955b24cc1ddf572b9282a624"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ae479b42d955b24cc1ddf572b9282a624">colr_str_char_lcount</a> (const char *s, const char c)</td></tr>
<tr class="memdesc:ae479b42d955b24cc1ddf572b9282a624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of characters (<code>c</code>) that are found at the beginning of a string (<code>char*</code>) (<code>s</code>).  <a href="#ae479b42d955b24cc1ddf572b9282a624">More...</a><br /></td></tr>
<tr class="separator:ae479b42d955b24cc1ddf572b9282a624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566857db0f22ad4a1ba17ee3a56cf174"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a566857db0f22ad4a1ba17ee3a56cf174">colr_str_chars_lcount</a> (const char *restrict s, const char *restrict chars)</td></tr>
<tr class="memdesc:a566857db0f22ad4a1ba17ee3a56cf174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of characters that are found at the beginning of a string (<code>char*</code>) (<code>s</code>), where the character can be any of <code>chars</code>.  <a href="#a566857db0f22ad4a1ba17ee3a56cf174">More...</a><br /></td></tr>
<tr class="separator:a566857db0f22ad4a1ba17ee3a56cf174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa991b64a363bd5e6f1a722ed0759338"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#afa991b64a363bd5e6f1a722ed0759338">colr_str_code_count</a> (const char *s)</td></tr>
<tr class="memdesc:afa991b64a363bd5e6f1a722ed0759338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of escape-codes in a string (<code>char*</code>).  <a href="#afa991b64a363bd5e6f1a722ed0759338">More...</a><br /></td></tr>
<tr class="separator:afa991b64a363bd5e6f1a722ed0759338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6fa8ad1635fcff75ee1213a975dba4d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab6fa8ad1635fcff75ee1213a975dba4d">colr_str_code_len</a> (const char *s)</td></tr>
<tr class="memdesc:ab6fa8ad1635fcff75ee1213a975dba4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of bytes that make up all the escape-codes in a string (<code>char*</code>).  <a href="#ab6fa8ad1635fcff75ee1213a975dba4d">More...</a><br /></td></tr>
<tr class="separator:ab6fa8ad1635fcff75ee1213a975dba4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb3c15e839f5c16d3e7cd001d32aee6"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a4fb3c15e839f5c16d3e7cd001d32aee6">colr_str_copy</a> (char *restrict dest, const char *restrict src, size_t length)</td></tr>
<tr class="memdesc:a4fb3c15e839f5c16d3e7cd001d32aee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a string (<code>char*</code>) like strncpy, but ensures null-termination.  <a href="#a4fb3c15e839f5c16d3e7cd001d32aee6">More...</a><br /></td></tr>
<tr class="separator:a4fb3c15e839f5c16d3e7cd001d32aee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd712bd8253271f0c88158db791c8bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a7dd712bd8253271f0c88158db791c8bf">colr_str_ends_with</a> (const char *restrict s, const char *restrict suffix)</td></tr>
<tr class="memdesc:a7dd712bd8253271f0c88158db791c8bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if one string (<code>char*</code>) ends with another.  <a href="#a7dd712bd8253271f0c88158db791c8bf">More...</a><br /></td></tr>
<tr class="separator:a7dd712bd8253271f0c88158db791c8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6292cbb8bd9f3d19bb0bd05a4d7b0bea"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a6292cbb8bd9f3d19bb0bd05a4d7b0bea">colr_str_get_codes</a> (const char *s, bool unique)</td></tr>
<tr class="memdesc:a6292cbb8bd9f3d19bb0bd05a4d7b0bea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an array of escape-codes from a string (<code>char*</code>).  <a href="#a6292cbb8bd9f3d19bb0bd05a4d7b0bea">More...</a><br /></td></tr>
<tr class="separator:a6292cbb8bd9f3d19bb0bd05a4d7b0bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9f4cbe1e806316e063206dfb610476"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a8b9f4cbe1e806316e063206dfb610476">colr_str_has_codes</a> (const char *s)</td></tr>
<tr class="memdesc:a8b9f4cbe1e806316e063206dfb610476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a string (<code>char*</code>) has ANSI escape codes in it.  <a href="#a8b9f4cbe1e806316e063206dfb610476">More...</a><br /></td></tr>
<tr class="separator:a8b9f4cbe1e806316e063206dfb610476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5a3149704b14b85a0236d9940fb4e7"><td class="memItemLeft" align="right" valign="top">ColrHash&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#adf5a3149704b14b85a0236d9940fb4e7">colr_str_hash</a> (const char *s)</td></tr>
<tr class="memdesc:adf5a3149704b14b85a0236d9940fb4e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash a string using <a href="http://www.cse.yorku.ca/~oz/hash.html">djb2</a>.  <a href="#adf5a3149704b14b85a0236d9940fb4e7">More...</a><br /></td></tr>
<tr class="separator:adf5a3149704b14b85a0236d9940fb4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc3f370843b64e92fb7d79e7989b5c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a3dc3f370843b64e92fb7d79e7989b5c3">colr_str_is_all</a> (const char *s, const char c)</td></tr>
<tr class="memdesc:a3dc3f370843b64e92fb7d79e7989b5c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a string (<code>char*</code>) consists of only one character, possibly repeated.  <a href="#a3dc3f370843b64e92fb7d79e7989b5c3">More...</a><br /></td></tr>
<tr class="separator:a3dc3f370843b64e92fb7d79e7989b5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b2971301b5247769b08f5ed08564fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a85b2971301b5247769b08f5ed08564fb">colr_str_is_codes</a> (const char *s)</td></tr>
<tr class="memdesc:a85b2971301b5247769b08f5ed08564fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a string (<code>char*</code>) is composed entirely of escape codes.  <a href="#a85b2971301b5247769b08f5ed08564fb">More...</a><br /></td></tr>
<tr class="separator:a85b2971301b5247769b08f5ed08564fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5492da225ade4fd8fe71989826348b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#af5492da225ade4fd8fe71989826348b4">colr_str_is_digits</a> (const char *s)</td></tr>
<tr class="memdesc:af5492da225ade4fd8fe71989826348b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all characters in a string (<code>char*</code>) are digits.  <a href="#af5492da225ade4fd8fe71989826348b4">More...</a><br /></td></tr>
<tr class="separator:af5492da225ade4fd8fe71989826348b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eedebae47b5d22dda709f833f23a256"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a5eedebae47b5d22dda709f833f23a256">colr_str_ljust</a> (const char *s, int width, const char padchar)</td></tr>
<tr class="memdesc:a5eedebae47b5d22dda709f833f23a256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-justifies a string (<code>char*</code>), ignoring escape codes when measuring the width.  <a href="#a5eedebae47b5d22dda709f833f23a256">More...</a><br /></td></tr>
<tr class="separator:a5eedebae47b5d22dda709f833f23a256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116ec26960e79456dbf9cf7f40ffe0d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a116ec26960e79456dbf9cf7f40ffe0d7">colr_str_lower</a> (char *s)</td></tr>
<tr class="memdesc:a116ec26960e79456dbf9cf7f40ffe0d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string (<code>char*</code>) into lower case in place.  <a href="#a116ec26960e79456dbf9cf7f40ffe0d7">More...</a><br /></td></tr>
<tr class="separator:a116ec26960e79456dbf9cf7f40ffe0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ffd3ec364c8d0c0e96a0723b7aa46f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a35ffd3ec364c8d0c0e96a0723b7aa46f">colr_str_lstrip</a> (char *restrict dest, const char *restrict s, size_t length, const char c)</td></tr>
<tr class="memdesc:a35ffd3ec364c8d0c0e96a0723b7aa46f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strip a leading character from a string (<code>char*</code>), filling another string (<code>char*</code>) with the result.  <a href="#a35ffd3ec364c8d0c0e96a0723b7aa46f">More...</a><br /></td></tr>
<tr class="separator:a35ffd3ec364c8d0c0e96a0723b7aa46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060dc0f80eade56563d6942339c2859e"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a060dc0f80eade56563d6942339c2859e">colr_str_lstrip_char</a> (const char *s, const char c)</td></tr>
<tr class="memdesc:a060dc0f80eade56563d6942339c2859e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strips a leading character from a string (<code>char*</code>), and allocates a new string with the result.  <a href="#a060dc0f80eade56563d6942339c2859e">More...</a><br /></td></tr>
<tr class="separator:a060dc0f80eade56563d6942339c2859e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af502be785bdb221c2dc1a47fece1fc5f"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#af502be785bdb221c2dc1a47fece1fc5f">colr_str_lstrip_chars</a> (const char *restrict s, const char *restrict chars)</td></tr>
<tr class="memdesc:af502be785bdb221c2dc1a47fece1fc5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes certain characters from the start of a string (<code>char*</code>) and allocates a new string with the result.  <a href="#af502be785bdb221c2dc1a47fece1fc5f">More...</a><br /></td></tr>
<tr class="separator:af502be785bdb221c2dc1a47fece1fc5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab473f70278850994e1b7b9c8008353fa"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab473f70278850994e1b7b9c8008353fa">colr_str_mb_len</a> (const char *s)</td></tr>
<tr class="memdesc:ab473f70278850994e1b7b9c8008353fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of characters in a string (<code>char*</code>), taking into account possibly multibyte characters.  <a href="#ab473f70278850994e1b7b9c8008353fa">More...</a><br /></td></tr>
<tr class="separator:ab473f70278850994e1b7b9c8008353fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037a0245a39d7ff5cfba5f779d0eb251"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a037a0245a39d7ff5cfba5f779d0eb251">colr_str_noncode_len</a> (const char *s)</td></tr>
<tr class="memdesc:a037a0245a39d7ff5cfba5f779d0eb251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of string (<code>char*</code>), ignoring escape codes and the the null-terminator.  <a href="#a037a0245a39d7ff5cfba5f779d0eb251">More...</a><br /></td></tr>
<tr class="separator:a037a0245a39d7ff5cfba5f779d0eb251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2144034980aea6427fbc9bdf70e5b8c3"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a2144034980aea6427fbc9bdf70e5b8c3">colr_str_replace</a> (const char *restrict s, const char *restrict target, const char *restrict repl)</td></tr>
<tr class="memdesc:a2144034980aea6427fbc9bdf70e5b8c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the first substring found in a string (<code>char*</code>).  <a href="#a2144034980aea6427fbc9bdf70e5b8c3">More...</a><br /></td></tr>
<tr class="separator:a2144034980aea6427fbc9bdf70e5b8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb81a3339840e1f527463eaddf994d8e"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#abb81a3339840e1f527463eaddf994d8e">colr_str_replace_all</a> (const char *restrict s, const char *restrict target, const char *restrict repl)</td></tr>
<tr class="memdesc:abb81a3339840e1f527463eaddf994d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the first substring found in a string (<code>char*</code>).  <a href="#abb81a3339840e1f527463eaddf994d8e">More...</a><br /></td></tr>
<tr class="separator:abb81a3339840e1f527463eaddf994d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c01a492bcbda6cf93705bff0cb0dbe"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#af7c01a492bcbda6cf93705bff0cb0dbe">colr_str_replace_all_ColorArg</a> (const char *restrict s, const char *restrict target, <a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *repl)</td></tr>
<tr class="memdesc:af7c01a492bcbda6cf93705bff0cb0dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all substrings in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string result.  <a href="#af7c01a492bcbda6cf93705bff0cb0dbe">More...</a><br /></td></tr>
<tr class="separator:af7c01a492bcbda6cf93705bff0cb0dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53fa120c1074c836f65b4aace67d0c83"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a53fa120c1074c836f65b4aace67d0c83">colr_str_replace_all_ColorResult</a> (const char *restrict s, const char *restrict target, <a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *repl)</td></tr>
<tr class="memdesc:a53fa120c1074c836f65b4aace67d0c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all substrings in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>'s string result.  <a href="#a53fa120c1074c836f65b4aace67d0c83">More...</a><br /></td></tr>
<tr class="separator:a53fa120c1074c836f65b4aace67d0c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73789c11eaeb5a36b5f97556103a108d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a73789c11eaeb5a36b5f97556103a108d">colr_str_replace_all_ColorText</a> (const char *restrict s, const char *restrict target, <a class="el" href="colr_8h.html#structColorText">ColorText</a> *repl)</td></tr>
<tr class="memdesc:a73789c11eaeb5a36b5f97556103a108d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all substrings in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string result.  <a href="#a73789c11eaeb5a36b5f97556103a108d">More...</a><br /></td></tr>
<tr class="separator:a73789c11eaeb5a36b5f97556103a108d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420403f3115f43c5e6356deee5644e84"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a420403f3115f43c5e6356deee5644e84">colr_str_replace_cnt</a> (const char *restrict s, const char *restrict target, const char *restrict repl, int count)</td></tr>
<tr class="memdesc:a420403f3115f43c5e6356deee5644e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces one or more substrings in a string (<code>char*</code>).  <a href="#a420403f3115f43c5e6356deee5644e84">More...</a><br /></td></tr>
<tr class="separator:a420403f3115f43c5e6356deee5644e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b61a4cadcf73e21eee109623695bad"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aa8b61a4cadcf73e21eee109623695bad">colr_str_replace_ColorArg</a> (const char *restrict s, const char *restrict target, <a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *repl)</td></tr>
<tr class="memdesc:aa8b61a4cadcf73e21eee109623695bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a substring in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string result.  <a href="#aa8b61a4cadcf73e21eee109623695bad">More...</a><br /></td></tr>
<tr class="separator:aa8b61a4cadcf73e21eee109623695bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136d15edf2f804c89cee619bb811ef3a"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a136d15edf2f804c89cee619bb811ef3a">colr_str_replace_ColorResult</a> (const char *restrict s, const char *restrict target, <a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *repl)</td></tr>
<tr class="memdesc:a136d15edf2f804c89cee619bb811ef3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a substring in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>'s string result.  <a href="#a136d15edf2f804c89cee619bb811ef3a">More...</a><br /></td></tr>
<tr class="separator:a136d15edf2f804c89cee619bb811ef3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee8d79a90917974ee4537705e34fd76"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aaee8d79a90917974ee4537705e34fd76">colr_str_replace_ColorText</a> (const char *restrict s, const char *restrict target, <a class="el" href="colr_8h.html#structColorText">ColorText</a> *repl)</td></tr>
<tr class="memdesc:aaee8d79a90917974ee4537705e34fd76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a substring in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string result.  <a href="#aaee8d79a90917974ee4537705e34fd76">More...</a><br /></td></tr>
<tr class="separator:aaee8d79a90917974ee4537705e34fd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09db8190822ff7e7e712399680325e6a"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a09db8190822ff7e7e712399680325e6a">colr_str_replace_re</a> (const char *restrict s, const char *restrict pattern, const char *restrict repl, int re_flags)</td></tr>
<tr class="memdesc:a09db8190822ff7e7e712399680325e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces a substring from a regex pattern string (<code>char*</code>) in a string (<code>char*</code>).  <a href="#a09db8190822ff7e7e712399680325e6a">More...</a><br /></td></tr>
<tr class="separator:a09db8190822ff7e7e712399680325e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232c65d12eb09d598eeb64490f39371c"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a232c65d12eb09d598eeb64490f39371c">colr_str_replace_re_all</a> (const char *restrict s, const char *restrict pattern, const char *restrict repl, int re_flags)</td></tr>
<tr class="memdesc:a232c65d12eb09d598eeb64490f39371c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all substrings from a regex pattern string (<code>char*</code>) in a string (<code>char*</code>).  <a href="#a232c65d12eb09d598eeb64490f39371c">More...</a><br /></td></tr>
<tr class="separator:a232c65d12eb09d598eeb64490f39371c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577e45a5c233dd1b4774a9034b17e3eb"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a577e45a5c233dd1b4774a9034b17e3eb">colr_str_replace_re_all_ColorArg</a> (const char *restrict s, const char *restrict pattern, <a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *repl, int re_flags)</td></tr>
<tr class="memdesc:a577e45a5c233dd1b4774a9034b17e3eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all substrings from a regex pattern string (<code>char*</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string result.  <a href="#a577e45a5c233dd1b4774a9034b17e3eb">More...</a><br /></td></tr>
<tr class="separator:a577e45a5c233dd1b4774a9034b17e3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e18a36736e5451529e80443cfb7b1fc"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a3e18a36736e5451529e80443cfb7b1fc">colr_str_replace_re_all_ColorResult</a> (const char *restrict s, const char *restrict pattern, <a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *repl, int re_flags)</td></tr>
<tr class="memdesc:a3e18a36736e5451529e80443cfb7b1fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all substrings from a regex pattern string (<code>char*</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>'s string result.  <a href="#a3e18a36736e5451529e80443cfb7b1fc">More...</a><br /></td></tr>
<tr class="separator:a3e18a36736e5451529e80443cfb7b1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747e31fa3d8961e0bdd11eabd673accc"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a747e31fa3d8961e0bdd11eabd673accc">colr_str_replace_re_all_ColorText</a> (const char *restrict s, const char *restrict pattern, <a class="el" href="colr_8h.html#structColorText">ColorText</a> *repl, int re_flags)</td></tr>
<tr class="memdesc:a747e31fa3d8961e0bdd11eabd673accc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all substrings from a regex pattern string (<code>char*</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string result.  <a href="#a747e31fa3d8961e0bdd11eabd673accc">More...</a><br /></td></tr>
<tr class="separator:a747e31fa3d8961e0bdd11eabd673accc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d58bde53845d6ab2c54e4ba0c68a3d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a78d58bde53845d6ab2c54e4ba0c68a3d">colr_str_replace_re_ColorArg</a> (const char *restrict s, const char *restrict pattern, <a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *repl, int re_flags)</td></tr>
<tr class="memdesc:a78d58bde53845d6ab2c54e4ba0c68a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace substrings from a regex pattern string (<code>char*</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string result.  <a href="#a78d58bde53845d6ab2c54e4ba0c68a3d">More...</a><br /></td></tr>
<tr class="separator:a78d58bde53845d6ab2c54e4ba0c68a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0376bed13e55acaca37e52c382044e1d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a0376bed13e55acaca37e52c382044e1d">colr_str_replace_re_ColorResult</a> (const char *restrict s, const char *restrict pattern, <a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *repl, int re_flags)</td></tr>
<tr class="memdesc:a0376bed13e55acaca37e52c382044e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace substrings from a regex pattern string (<code>char*</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>'s string result.  <a href="#a0376bed13e55acaca37e52c382044e1d">More...</a><br /></td></tr>
<tr class="separator:a0376bed13e55acaca37e52c382044e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d6a10f70b435559656bbad0090d92d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab8d6a10f70b435559656bbad0090d92d">colr_str_replace_re_ColorText</a> (const char *restrict s, const char *restrict pattern, <a class="el" href="colr_8h.html#structColorText">ColorText</a> *repl, int re_flags)</td></tr>
<tr class="memdesc:ab8d6a10f70b435559656bbad0090d92d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace substrings from a regex pattern string (<code>char*</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string result.  <a href="#ab8d6a10f70b435559656bbad0090d92d">More...</a><br /></td></tr>
<tr class="separator:ab8d6a10f70b435559656bbad0090d92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fbc36f0f7aba3aa0616437f937efd20"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a2fbc36f0f7aba3aa0616437f937efd20">colr_str_replace_re_match</a> (const char *restrict s, regmatch_t *match, const char *restrict repl)</td></tr>
<tr class="memdesc:a2fbc36f0f7aba3aa0616437f937efd20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces substrings from a single regex match (<code>regmatch_t*</code>) in a string (<code>char*</code>).  <a href="#a2fbc36f0f7aba3aa0616437f937efd20">More...</a><br /></td></tr>
<tr class="separator:a2fbc36f0f7aba3aa0616437f937efd20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4cbd6a8fd3cef76f07b705b09d2a54"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a0d4cbd6a8fd3cef76f07b705b09d2a54">colr_str_replace_re_match_ColorArg</a> (const char *restrict s, regmatch_t *match, <a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *repl)</td></tr>
<tr class="memdesc:a0d4cbd6a8fd3cef76f07b705b09d2a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace substrings from a regex match (<code>regmatch_t*</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string result.  <a href="#a0d4cbd6a8fd3cef76f07b705b09d2a54">More...</a><br /></td></tr>
<tr class="separator:a0d4cbd6a8fd3cef76f07b705b09d2a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac092f944961dddc6574a6c55e6e878b0"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ac092f944961dddc6574a6c55e6e878b0">colr_str_replace_re_match_ColorResult</a> (const char *restrict s, regmatch_t *match, <a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *repl)</td></tr>
<tr class="memdesc:ac092f944961dddc6574a6c55e6e878b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace substrings from a regex match (<code>regmatch_t*</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>'s string result.  <a href="#ac092f944961dddc6574a6c55e6e878b0">More...</a><br /></td></tr>
<tr class="separator:ac092f944961dddc6574a6c55e6e878b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d954398333472c1436f9bc051f46392"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a4d954398333472c1436f9bc051f46392">colr_str_replace_re_match_ColorText</a> (const char *restrict s, regmatch_t *match, <a class="el" href="colr_8h.html#structColorText">ColorText</a> *repl)</td></tr>
<tr class="memdesc:a4d954398333472c1436f9bc051f46392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace substrings from a regex match (<code>regmatch_t*</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string result.  <a href="#a4d954398333472c1436f9bc051f46392">More...</a><br /></td></tr>
<tr class="separator:a4d954398333472c1436f9bc051f46392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205182bbcbf99a3faa1b207a28721c87"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a205182bbcbf99a3faa1b207a28721c87">colr_str_replace_re_match_i</a> (const char *restrict ref, char *target, regmatch_t *match, const char *restrict repl)</td></tr>
<tr class="memdesc:a205182bbcbf99a3faa1b207a28721c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces substrings from a regex match (<code>regmatch_t*</code>) in a string (<code>char*</code>).  <a href="#a205182bbcbf99a3faa1b207a28721c87">More...</a><br /></td></tr>
<tr class="separator:a205182bbcbf99a3faa1b207a28721c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c72d363d7f87e2a7546202b439557e1"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a8c72d363d7f87e2a7546202b439557e1">colr_str_replace_re_matches</a> (const char *restrict s, regmatch_t **matches, const char *restrict repl)</td></tr>
<tr class="memdesc:a8c72d363d7f87e2a7546202b439557e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces substrings from an array of regex match (<code>regmatch_t*</code>) in a string (<code>char*</code>).  <a href="#a8c72d363d7f87e2a7546202b439557e1">More...</a><br /></td></tr>
<tr class="separator:a8c72d363d7f87e2a7546202b439557e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b2cdee697818e2f9f38ec7eac98bcb"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a75b2cdee697818e2f9f38ec7eac98bcb">colr_str_replace_re_matches_ColorArg</a> (const char *restrict s, regmatch_t **matches, <a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *repl)</td></tr>
<tr class="memdesc:a75b2cdee697818e2f9f38ec7eac98bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace substrings from an array of regex matches (<code>regmatch_t**</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string result.  <a href="#a75b2cdee697818e2f9f38ec7eac98bcb">More...</a><br /></td></tr>
<tr class="separator:a75b2cdee697818e2f9f38ec7eac98bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4bb71015338108d86fcf47317cc5ff"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a4d4bb71015338108d86fcf47317cc5ff">colr_str_replace_re_matches_ColorResult</a> (const char *restrict s, regmatch_t **matches, <a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *repl)</td></tr>
<tr class="memdesc:a4d4bb71015338108d86fcf47317cc5ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace substrings from an array of regex matches (<code>regmatch_t**</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>'s string result.  <a href="#a4d4bb71015338108d86fcf47317cc5ff">More...</a><br /></td></tr>
<tr class="separator:a4d4bb71015338108d86fcf47317cc5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4fe38cc205cbd49b2f8477744574294"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aa4fe38cc205cbd49b2f8477744574294">colr_str_replace_re_matches_ColorText</a> (const char *restrict s, regmatch_t **matches, <a class="el" href="colr_8h.html#structColorText">ColorText</a> *repl)</td></tr>
<tr class="memdesc:aa4fe38cc205cbd49b2f8477744574294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace substrings from an array of regex matches (<code>regmatch_t**</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string result.  <a href="#aa4fe38cc205cbd49b2f8477744574294">More...</a><br /></td></tr>
<tr class="separator:aa4fe38cc205cbd49b2f8477744574294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63621c6749d8219112ff51ebf0ecb22a"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a63621c6749d8219112ff51ebf0ecb22a">colr_str_replace_re_pat</a> (const char *restrict s, regex_t *repattern, const char *restrict repl)</td></tr>
<tr class="memdesc:a63621c6749d8219112ff51ebf0ecb22a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces regex patterns in a string (<code>char*</code>).  <a href="#a63621c6749d8219112ff51ebf0ecb22a">More...</a><br /></td></tr>
<tr class="separator:a63621c6749d8219112ff51ebf0ecb22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd19623913d27e2d9a5af3496a478c2b"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#afd19623913d27e2d9a5af3496a478c2b">colr_str_replace_re_pat_all</a> (const char *restrict s, regex_t *repattern, const char *restrict repl)</td></tr>
<tr class="memdesc:afd19623913d27e2d9a5af3496a478c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all matches to a regex pattern in a string (<code>char*</code>).  <a href="#afd19623913d27e2d9a5af3496a478c2b">More...</a><br /></td></tr>
<tr class="separator:afd19623913d27e2d9a5af3496a478c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090ba95c4560134ef9c2807eff6a0ea1"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a090ba95c4560134ef9c2807eff6a0ea1">colr_str_replace_re_pat_all_ColorArg</a> (const char *restrict s, regex_t *repattern, <a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *repl)</td></tr>
<tr class="memdesc:a090ba95c4560134ef9c2807eff6a0ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all matches to a regex pattern in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string result.  <a href="#a090ba95c4560134ef9c2807eff6a0ea1">More...</a><br /></td></tr>
<tr class="separator:a090ba95c4560134ef9c2807eff6a0ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af083c2e1867ecaad0ae38a1324c915ac"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#af083c2e1867ecaad0ae38a1324c915ac">colr_str_replace_re_pat_all_ColorResult</a> (const char *restrict s, regex_t *repattern, <a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *repl)</td></tr>
<tr class="memdesc:af083c2e1867ecaad0ae38a1324c915ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all matches to a regex pattern in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>'s string result.  <a href="#af083c2e1867ecaad0ae38a1324c915ac">More...</a><br /></td></tr>
<tr class="separator:af083c2e1867ecaad0ae38a1324c915ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c4a5c34b26473dc45f93ce2c66faf1"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab9c4a5c34b26473dc45f93ce2c66faf1">colr_str_replace_re_pat_all_ColorText</a> (const char *restrict s, regex_t *repattern, <a class="el" href="colr_8h.html#structColorText">ColorText</a> *repl)</td></tr>
<tr class="memdesc:ab9c4a5c34b26473dc45f93ce2c66faf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all matches to a regex pattern in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string result.  <a href="#ab9c4a5c34b26473dc45f93ce2c66faf1">More...</a><br /></td></tr>
<tr class="separator:ab9c4a5c34b26473dc45f93ce2c66faf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adecbe2f1e87613b6f4a51158325dd4f7"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#adecbe2f1e87613b6f4a51158325dd4f7">colr_str_replace_re_pat_ColorArg</a> (const char *restrict s, regex_t *repattern, <a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *repl)</td></tr>
<tr class="memdesc:adecbe2f1e87613b6f4a51158325dd4f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace regex patterns in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string result.  <a href="#adecbe2f1e87613b6f4a51158325dd4f7">More...</a><br /></td></tr>
<tr class="separator:adecbe2f1e87613b6f4a51158325dd4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd756c82acab9505343b614d52c0b19"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#abcd756c82acab9505343b614d52c0b19">colr_str_replace_re_pat_ColorResult</a> (const char *restrict s, regex_t *repattern, <a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *repl)</td></tr>
<tr class="memdesc:abcd756c82acab9505343b614d52c0b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace regex patterns in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>'s string result.  <a href="#abcd756c82acab9505343b614d52c0b19">More...</a><br /></td></tr>
<tr class="separator:abcd756c82acab9505343b614d52c0b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8b04b6d851f26304183d1111b8f0dc"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a6f8b04b6d851f26304183d1111b8f0dc">colr_str_replace_re_pat_ColorText</a> (const char *restrict s, regex_t *repattern, <a class="el" href="colr_8h.html#structColorText">ColorText</a> *repl)</td></tr>
<tr class="memdesc:a6f8b04b6d851f26304183d1111b8f0dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace regex patterns in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string result.  <a href="#a6f8b04b6d851f26304183d1111b8f0dc">More...</a><br /></td></tr>
<tr class="separator:a6f8b04b6d851f26304183d1111b8f0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196ad91a69cfbeb27a5266ffc93ed353"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a196ad91a69cfbeb27a5266ffc93ed353">colr_str_repr</a> (const char *s)</td></tr>
<tr class="memdesc:a196ad91a69cfbeb27a5266ffc93ed353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string (<code>char*</code>) into a representation of a string, by wrapping it in quotes and escaping characters that need escaping.  <a href="#a196ad91a69cfbeb27a5266ffc93ed353">More...</a><br /></td></tr>
<tr class="separator:a196ad91a69cfbeb27a5266ffc93ed353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc75e3bf729168f9ac204ef0a1708d46"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#acc75e3bf729168f9ac204ef0a1708d46">colr_str_rjust</a> (const char *s, int width, const char padchar)</td></tr>
<tr class="memdesc:acc75e3bf729168f9ac204ef0a1708d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right-justifies a string (<code>char*</code>), ignoring escape codes when measuring the width.  <a href="#acc75e3bf729168f9ac204ef0a1708d46">More...</a><br /></td></tr>
<tr class="separator:acc75e3bf729168f9ac204ef0a1708d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23328cead6a65d7b3ef2c2ca48d11ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ac23328cead6a65d7b3ef2c2ca48d11ce">colr_str_starts_with</a> (const char *restrict s, const char *restrict prefix)</td></tr>
<tr class="memdesc:ac23328cead6a65d7b3ef2c2ca48d11ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a string (<code>char*</code>) for a certain prefix substring.  <a href="#ac23328cead6a65d7b3ef2c2ca48d11ce">More...</a><br /></td></tr>
<tr class="separator:ac23328cead6a65d7b3ef2c2ca48d11ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b13b04dc178d0990ab2ae403ee64e0"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab0b13b04dc178d0990ab2ae403ee64e0">colr_str_strip_codes</a> (const char *s)</td></tr>
<tr class="memdesc:ab0b13b04dc178d0990ab2ae403ee64e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strips escape codes from a string (<code>char*</code>), resulting in a new allocated string.  <a href="#ab0b13b04dc178d0990ab2ae403ee64e0">More...</a><br /></td></tr>
<tr class="separator:ab0b13b04dc178d0990ab2ae403ee64e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b847e10db135f7ebc89031b3a7ad56"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ae9b847e10db135f7ebc89031b3a7ad56">colr_str_to_lower</a> (const char *s)</td></tr>
<tr class="memdesc:ae9b847e10db135f7ebc89031b3a7ad56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new lowercase version of a string (<code>char*</code>).  <a href="#ae9b847e10db135f7ebc89031b3a7ad56">More...</a><br /></td></tr>
<tr class="separator:ae9b847e10db135f7ebc89031b3a7ad56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ebdcd3c6e598a244292c7605452e9d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab2ebdcd3c6e598a244292c7605452e9d">colr_supports_rgb</a> (void)</td></tr>
<tr class="memdesc:ab2ebdcd3c6e598a244292c7605452e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the current environment support <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> (True Colors).  <a href="#ab2ebdcd3c6e598a244292c7605452e9d">More...</a><br /></td></tr>
<tr class="separator:ab2ebdcd3c6e598a244292c7605452e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2aab28fe264005a5d17b888b542610b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ac2aab28fe264005a5d17b888b542610b">colr_supports_rgb_static</a> (void)</td></tr>
<tr class="memdesc:ac2aab28fe264005a5d17b888b542610b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="colr_8c.html#ab2ebdcd3c6e598a244292c7605452e9d" title="Determine whether the current environment support RGB (True Colors). ">colr_supports_rgb()</a>, but the environment is only checked on the first call.  <a href="#ac2aab28fe264005a5d17b888b542610b">More...</a><br /></td></tr>
<tr class="separator:ac2aab28fe264005a5d17b888b542610b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c11bb5b3b1bb2848bb16aee39763b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structTermSize">TermSize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ae4c11bb5b3b1bb2848bb16aee39763b2">colr_term_size</a> (void)</td></tr>
<tr class="memdesc:ae4c11bb5b3b1bb2848bb16aee39763b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to retrieve the row/column size of the terminal and returns a <a class="el" href="colr_8h.html#structTermSize" title="Holds a terminal size, usually retrieved with colr_term_size(). ">TermSize</a>.  <a href="#ae4c11bb5b3b1bb2848bb16aee39763b2">More...</a><br /></td></tr>
<tr class="separator:ae4c11bb5b3b1bb2848bb16aee39763b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d7b7bf1080742eeb588ba70ce9ea77"><td class="memItemLeft" align="right" valign="top">struct winsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ae7d7b7bf1080742eeb588ba70ce9ea77">colr_win_size</a> (void)</td></tr>
<tr class="memdesc:ae7d7b7bf1080742eeb588ba70ce9ea77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to retrieve a <code>winsize</code> struct from an <code>ioctl</code> call.  <a href="#ae7d7b7bf1080742eeb588ba70ce9ea77">More...</a><br /></td></tr>
<tr class="separator:ae7d7b7bf1080742eeb588ba70ce9ea77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2c53ebede7f97645f671401bfe356d"><td class="memItemLeft" align="right" valign="top">struct winsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#afc2c53ebede7f97645f671401bfe356d">colr_win_size_env</a> (void)</td></tr>
<tr class="memdesc:afc2c53ebede7f97645f671401bfe356d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get window/terminal size using the environment variables <code>LINES</code>, <code>COLUMNS</code>, or <code>COLS</code>.  <a href="#afc2c53ebede7f97645f671401bfe356d">More...</a><br /></td></tr>
<tr class="separator:afc2c53ebede7f97645f671401bfe356d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac847d91a396ae6babc0bd46e6386a701"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ac847d91a396ae6babc0bd46e6386a701">ExtendedValue_eq</a> (<a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a> a, <a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a> b)</td></tr>
<tr class="memdesc:ac847d91a396ae6babc0bd46e6386a701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ExtendedValues.  <a href="#ac847d91a396ae6babc0bd46e6386a701">More...</a><br /></td></tr>
<tr class="separator:ac847d91a396ae6babc0bd46e6386a701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b464ee51d75d7f45ddd5926a7c9cf5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#af0b464ee51d75d7f45ddd5926a7c9cf5">ExtendedValue_from_BasicValue</a> (<a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> bval)</td></tr>
<tr class="memdesc:af0b464ee51d75d7f45ddd5926a7c9cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a BasicValue into an ExtendedValue.  <a href="#af0b464ee51d75d7f45ddd5926a7c9cf5">More...</a><br /></td></tr>
<tr class="separator:af0b464ee51d75d7f45ddd5926a7c9cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabf63956f397a0fe628313622ba5cde"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aaabf63956f397a0fe628313622ba5cde">ExtendedValue_from_esc</a> (const char *s)</td></tr>
<tr class="memdesc:aaabf63956f397a0fe628313622ba5cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an escape-code string (<code>char*</code>) to an ExtendedValue.  <a href="#aaabf63956f397a0fe628313622ba5cde">More...</a><br /></td></tr>
<tr class="separator:aaabf63956f397a0fe628313622ba5cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0632d78965000b1e50068a64e335133b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a0632d78965000b1e50068a64e335133b">ExtendedValue_from_hex</a> (const char *hexstr)</td></tr>
<tr class="memdesc:a0632d78965000b1e50068a64e335133b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an ExtendedValue from a hex string (<code>char*</code>).  <a href="#a0632d78965000b1e50068a64e335133b">More...</a><br /></td></tr>
<tr class="separator:a0632d78965000b1e50068a64e335133b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757be189530b4925c84df25742374485"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a757be189530b4925c84df25742374485">ExtendedValue_from_hex_default</a> (const char *hexstr, <a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a> default_value)</td></tr>
<tr class="memdesc:a757be189530b4925c84df25742374485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an ExtendedValue from a hex string (<code>char*</code>), but return a default value if the hex string is invalid.  <a href="#a757be189530b4925c84df25742374485">More...</a><br /></td></tr>
<tr class="separator:a757be189530b4925c84df25742374485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1548d9fc5f3e00a7b5d834eb1e12ff93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a1548d9fc5f3e00a7b5d834eb1e12ff93">ExtendedValue_from_RGB</a> (<a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:a1548d9fc5f3e00a7b5d834eb1e12ff93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value into the closest matching ExtendedValue.  <a href="#a1548d9fc5f3e00a7b5d834eb1e12ff93">More...</a><br /></td></tr>
<tr class="separator:a1548d9fc5f3e00a7b5d834eb1e12ff93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e859d542a8aa0939e4f76b1f33cb5f8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a2e859d542a8aa0939e4f76b1f33cb5f8">ExtendedValue_from_str</a> (const char *arg)</td></tr>
<tr class="memdesc:a2e859d542a8aa0939e4f76b1f33cb5f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a known name, integer string (0-255), or a hex string (<code>char*</code>), into an ExtendedValue suitable for the extended-value-based functions.  <a href="#a2e859d542a8aa0939e4f76b1f33cb5f8">More...</a><br /></td></tr>
<tr class="separator:a2e859d542a8aa0939e4f76b1f33cb5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669c8872f6b44a047470d33eb5d8b765"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a669c8872f6b44a047470d33eb5d8b765">ExtendedValue_is_invalid</a> (int eval)</td></tr>
<tr class="memdesc:a669c8872f6b44a047470d33eb5d8b765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether an integer is an invalid ExtendedValue.  <a href="#a669c8872f6b44a047470d33eb5d8b765">More...</a><br /></td></tr>
<tr class="separator:a669c8872f6b44a047470d33eb5d8b765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b43e6ee55b05d9b73950794f2dd53a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a6b43e6ee55b05d9b73950794f2dd53a4">ExtendedValue_is_valid</a> (int eval)</td></tr>
<tr class="memdesc:a6b43e6ee55b05d9b73950794f2dd53a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether an integer is a valid ExtendedValue.  <a href="#a6b43e6ee55b05d9b73950794f2dd53a4">More...</a><br /></td></tr>
<tr class="separator:a6b43e6ee55b05d9b73950794f2dd53a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa45baebc38756a40e7084f8198999902"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aa45baebc38756a40e7084f8198999902">ExtendedValue_repr</a> (int eval)</td></tr>
<tr class="memdesc:aa45baebc38756a40e7084f8198999902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation of a ExtendedValue.  <a href="#aa45baebc38756a40e7084f8198999902">More...</a><br /></td></tr>
<tr class="separator:aa45baebc38756a40e7084f8198999902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e334d6b9145fca9717fe5a2aeb542fe"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a4e334d6b9145fca9717fe5a2aeb542fe">ExtendedValue_to_str</a> (<a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a> eval)</td></tr>
<tr class="memdesc:a4e334d6b9145fca9717fe5a2aeb542fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a human-friendly string (<code>char*</code>) from an ExtendedValue's actual value, suitable for use with <a class="el" href="colr_8c.html#a2e859d542a8aa0939e4f76b1f33cb5f8" title="Converts a known name, integer string (0-255), or a hex string (char*), into an ExtendedValue suitabl...">ExtendedValue_from_str()</a>.  <a href="#a4e334d6b9145fca9717fe5a2aeb542fe">More...</a><br /></td></tr>
<tr class="separator:a4e334d6b9145fca9717fe5a2aeb542fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29032483aea8cb25d6b90750767ffc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ae29032483aea8cb25d6b90750767ffc1">format_bg</a> (char *out, <a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> value)</td></tr>
<tr class="memdesc:ae29032483aea8cb25d6b90750767ffc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for a background color.  <a href="#ae29032483aea8cb25d6b90750767ffc1">More...</a><br /></td></tr>
<tr class="separator:ae29032483aea8cb25d6b90750767ffc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97257ad40619df6a6c190890ff2873c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a97257ad40619df6a6c190890ff2873c4">format_bg_RGB</a> (char *out, <a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:a97257ad40619df6a6c190890ff2873c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for a true color (rgb) background color using values from an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct.  <a href="#a97257ad40619df6a6c190890ff2873c4">More...</a><br /></td></tr>
<tr class="separator:a97257ad40619df6a6c190890ff2873c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185cec167afe41b6401206659d2d406c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a185cec167afe41b6401206659d2d406c">format_bg_RGB_term</a> (char *out, <a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:a185cec167afe41b6401206659d2d406c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for a true color (rgb) fore color using an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct's values, approximating 256-color values.  <a href="#a185cec167afe41b6401206659d2d406c">More...</a><br /></td></tr>
<tr class="separator:a185cec167afe41b6401206659d2d406c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4853b53fa18d26741ab7178606e5724"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aa4853b53fa18d26741ab7178606e5724">format_bgx</a> (char *out, unsigned char num)</td></tr>
<tr class="memdesc:aa4853b53fa18d26741ab7178606e5724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for an extended background color.  <a href="#aa4853b53fa18d26741ab7178606e5724">More...</a><br /></td></tr>
<tr class="separator:aa4853b53fa18d26741ab7178606e5724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6027d93e8768f3c152edafd92e757801"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a6027d93e8768f3c152edafd92e757801">format_fg</a> (char *out, <a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> value)</td></tr>
<tr class="memdesc:a6027d93e8768f3c152edafd92e757801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for a fore color.  <a href="#a6027d93e8768f3c152edafd92e757801">More...</a><br /></td></tr>
<tr class="separator:a6027d93e8768f3c152edafd92e757801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3391a0cd6b6f73d9d39f8179fc0eb0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aa3391a0cd6b6f73d9d39f8179fc0eb0b">format_fg_RGB</a> (char *out, <a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:aa3391a0cd6b6f73d9d39f8179fc0eb0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for a true color (rgb) fore color using an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct's values.  <a href="#aa3391a0cd6b6f73d9d39f8179fc0eb0b">More...</a><br /></td></tr>
<tr class="separator:aa3391a0cd6b6f73d9d39f8179fc0eb0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4661c576a4da879b8d4a2c525a42ad78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a4661c576a4da879b8d4a2c525a42ad78">format_fg_RGB_term</a> (char *out, <a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:a4661c576a4da879b8d4a2c525a42ad78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for a true color (rgb) fore color using an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct's values, approximating 256-color values.  <a href="#a4661c576a4da879b8d4a2c525a42ad78">More...</a><br /></td></tr>
<tr class="separator:a4661c576a4da879b8d4a2c525a42ad78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd2cf68768c59fc3ed5c31b93590c53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#acfd2cf68768c59fc3ed5c31b93590c53">format_fgx</a> (char *out, unsigned char num)</td></tr>
<tr class="memdesc:acfd2cf68768c59fc3ed5c31b93590c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for an extended fore color.  <a href="#acfd2cf68768c59fc3ed5c31b93590c53">More...</a><br /></td></tr>
<tr class="separator:acfd2cf68768c59fc3ed5c31b93590c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aec8e6a80b4ca158df2ad20e3e6a59e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a6aec8e6a80b4ca158df2ad20e3e6a59e">format_style</a> (char *out, <a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a> <a class="el" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662">style</a>)</td></tr>
<tr class="memdesc:a6aec8e6a80b4ca158df2ad20e3e6a59e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for a style.  <a href="#a6aec8e6a80b4ca158df2ad20e3e6a59e">More...</a><br /></td></tr>
<tr class="separator:a6aec8e6a80b4ca158df2ad20e3e6a59e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39e0b3981b4f0a8a113c6949bc8b103"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab39e0b3981b4f0a8a113c6949bc8b103">rainbow_bg</a> (const char *s, double freq, size_t offset, size_t spread)</td></tr>
<tr class="memdesc:ab39e0b3981b4f0a8a113c6949bc8b103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rainbow-ize some text using rgb back colors, lolcat style.  <a href="#ab39e0b3981b4f0a8a113c6949bc8b103">More...</a><br /></td></tr>
<tr class="separator:ab39e0b3981b4f0a8a113c6949bc8b103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf264c63c394f9ecb19cd8565cda7197"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#adf264c63c394f9ecb19cd8565cda7197">rainbow_bg_term</a> (const char *s, double freq, size_t offset, size_t spread)</td></tr>
<tr class="memdesc:adf264c63c394f9ecb19cd8565cda7197"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is exactly like <a class="el" href="colr_8c.html#ab39e0b3981b4f0a8a113c6949bc8b103" title="Rainbow-ize some text using rgb back colors, lolcat style. ">rainbow_bg()</a>, except it uses colors that are closer to the standard 256-color values.  <a href="#adf264c63c394f9ecb19cd8565cda7197">More...</a><br /></td></tr>
<tr class="separator:adf264c63c394f9ecb19cd8565cda7197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50eca5901ca237550cf4129237a3411"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ac50eca5901ca237550cf4129237a3411">rainbow_fg</a> (const char *s, double freq, size_t offset, size_t spread)</td></tr>
<tr class="memdesc:ac50eca5901ca237550cf4129237a3411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rainbow-ize some text using rgb fore colors, lolcat style.  <a href="#ac50eca5901ca237550cf4129237a3411">More...</a><br /></td></tr>
<tr class="separator:ac50eca5901ca237550cf4129237a3411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a24d379435d64d1212858b173e6f9a7"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a5a24d379435d64d1212858b173e6f9a7">rainbow_fg_term</a> (const char *s, double freq, size_t offset, size_t spread)</td></tr>
<tr class="memdesc:a5a24d379435d64d1212858b173e6f9a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is exactly like <a class="el" href="colr_8c.html#ac50eca5901ca237550cf4129237a3411" title="Rainbow-ize some text using rgb fore colors, lolcat style. ">rainbow_fg()</a>, except it uses colors that are closer to the standard 256-color values.  <a href="#a5a24d379435d64d1212858b173e6f9a7">More...</a><br /></td></tr>
<tr class="separator:a5a24d379435d64d1212858b173e6f9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3580f33d058571dffd8e5ff789c49296"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a3580f33d058571dffd8e5ff789c49296">rainbow_step</a> (double freq, size_t offset)</td></tr>
<tr class="memdesc:a3580f33d058571dffd8e5ff789c49296"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single step in rainbow-izing produces the next color in the "rainbow" as an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.  <a href="#a3580f33d058571dffd8e5ff789c49296">More...</a><br /></td></tr>
<tr class="separator:a3580f33d058571dffd8e5ff789c49296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d649fff907b84a625db3fc3b3ae545e"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a0d649fff907b84a625db3fc3b3ae545e">RGB_average</a> (<a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:a0d649fff907b84a625db3fc3b3ae545e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the average for an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.  <a href="#a0d649fff907b84a625db3fc3b3ae545e">More...</a><br /></td></tr>
<tr class="separator:a0d649fff907b84a625db3fc3b3ae545e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b5f73b8aa9d72216d7386221418ae1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ad4b5f73b8aa9d72216d7386221418ae1">RGB_eq</a> (<a class="el" href="colr_8h.html#structRGB">RGB</a> a, <a class="el" href="colr_8h.html#structRGB">RGB</a> b)</td></tr>
<tr class="memdesc:ad4b5f73b8aa9d72216d7386221418ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> structs.  <a href="#ad4b5f73b8aa9d72216d7386221418ae1">More...</a><br /></td></tr>
<tr class="separator:ad4b5f73b8aa9d72216d7386221418ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5fbdea47463b284cbc9b1242ace4f1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ac5fbdea47463b284cbc9b1242ace4f1e">RGB_from_BasicValue</a> (<a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> bval)</td></tr>
<tr class="memdesc:ac5fbdea47463b284cbc9b1242ace4f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value from a known BasicValue.  <a href="#ac5fbdea47463b284cbc9b1242ace4f1e">More...</a><br /></td></tr>
<tr class="separator:ac5fbdea47463b284cbc9b1242ace4f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252adee47cc218a9208f16cb0ff42bfe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a252adee47cc218a9208f16cb0ff42bfe">RGB_from_esc</a> (const char *s, <a class="el" href="colr_8h.html#structRGB">RGB</a> *<a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:a252adee47cc218a9208f16cb0ff42bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an escape-code string (<code>char*</code>) to an actual <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.  <a href="#a252adee47cc218a9208f16cb0ff42bfe">More...</a><br /></td></tr>
<tr class="separator:a252adee47cc218a9208f16cb0ff42bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab857a1ddce9743c1ef6d54d39e890275"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab857a1ddce9743c1ef6d54d39e890275">RGB_from_ExtendedValue</a> (<a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a> eval)</td></tr>
<tr class="memdesc:ab857a1ddce9743c1ef6d54d39e890275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value from a known ExtendedValue.  <a href="#ab857a1ddce9743c1ef6d54d39e890275">More...</a><br /></td></tr>
<tr class="separator:ab857a1ddce9743c1ef6d54d39e890275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33884dcde034819c5e6749667247194"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ad33884dcde034819c5e6749667247194">RGB_from_hex</a> (const char *hexstr, <a class="el" href="colr_8h.html#structRGB">RGB</a> *<a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:ad33884dcde034819c5e6749667247194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a hex color into an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.  <a href="#ad33884dcde034819c5e6749667247194">More...</a><br /></td></tr>
<tr class="separator:ad33884dcde034819c5e6749667247194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6133112d9c73a8b56995e16e1af62d3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a6133112d9c73a8b56995e16e1af62d3b">RGB_from_hex_default</a> (const char *hexstr, <a class="el" href="colr_8h.html#structRGB">RGB</a> default_value)</td></tr>
<tr class="memdesc:a6133112d9c73a8b56995e16e1af62d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a hex color into an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value, but use a default value when errors occur.  <a href="#a6133112d9c73a8b56995e16e1af62d3b">More...</a><br /></td></tr>
<tr class="separator:a6133112d9c73a8b56995e16e1af62d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c9e50fe14ad0c82bcf1a62699c05de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a98c9e50fe14ad0c82bcf1a62699c05de">RGB_from_str</a> (const char *arg, <a class="el" href="colr_8h.html#structRGB">RGB</a> *<a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:a98c9e50fe14ad0c82bcf1a62699c05de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> string (<code>char*</code>) into an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.  <a href="#a98c9e50fe14ad0c82bcf1a62699c05de">More...</a><br /></td></tr>
<tr class="separator:a98c9e50fe14ad0c82bcf1a62699c05de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ce6e92a3b495166213e203ad3ab846"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a49ce6e92a3b495166213e203ad3ab846">RGB_grayscale</a> (<a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:a49ce6e92a3b495166213e203ad3ab846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grayscale version of an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.  <a href="#a49ce6e92a3b495166213e203ad3ab846">More...</a><br /></td></tr>
<tr class="separator:a49ce6e92a3b495166213e203ad3ab846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958e45854d69e8b59859244ce791673c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a958e45854d69e8b59859244ce791673c">RGB_inverted</a> (<a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:a958e45854d69e8b59859244ce791673c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a copy of an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value, with the colors "inverted" (like highlighting text in the terminal).  <a href="#a958e45854d69e8b59859244ce791673c">More...</a><br /></td></tr>
<tr class="separator:a958e45854d69e8b59859244ce791673c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd85b5c5b79142c8656a065c58e4509e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#abd85b5c5b79142c8656a065c58e4509e">RGB_monochrome</a> (<a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:abd85b5c5b79142c8656a065c58e4509e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value into either black or white, depending on it's average grayscale value.  <a href="#abd85b5c5b79142c8656a065c58e4509e">More...</a><br /></td></tr>
<tr class="separator:abd85b5c5b79142c8656a065c58e4509e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd28864afbcfa4a344e4596130645177"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#afd28864afbcfa4a344e4596130645177">RGB_repr</a> (<a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:afd28864afbcfa4a344e4596130645177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation for an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.  <a href="#afd28864afbcfa4a344e4596130645177">More...</a><br /></td></tr>
<tr class="separator:afd28864afbcfa4a344e4596130645177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e4feb89e009f00cfe7e74a55fab56f"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a95e4feb89e009f00cfe7e74a55fab56f">RGB_to_hex</a> (<a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:a95e4feb89e009f00cfe7e74a55fab56f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value into a hex string (<code>char*</code>).  <a href="#a95e4feb89e009f00cfe7e74a55fab56f">More...</a><br /></td></tr>
<tr class="separator:a95e4feb89e009f00cfe7e74a55fab56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d2f9a1133c8a955f0a551870d7ebe8"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a16d2f9a1133c8a955f0a551870d7ebe8">RGB_to_str</a> (<a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:a16d2f9a1133c8a955f0a551870d7ebe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value into a human-friendly <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> string (<code>char*</code>) suitable for input to <a class="el" href="colr_8c.html#a98c9e50fe14ad0c82bcf1a62699c05de" title="Convert an RGB string (char*) into an RGB value. ">RGB_from_str()</a>.  <a href="#a16d2f9a1133c8a955f0a551870d7ebe8">More...</a><br /></td></tr>
<tr class="separator:a16d2f9a1133c8a955f0a551870d7ebe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4576c531151e398b7ecede2e30df70d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab4576c531151e398b7ecede2e30df70d">RGB_to_term_RGB</a> (<a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:ab4576c531151e398b7ecede2e30df70d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value into it's nearest terminal-friendly <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.  <a href="#ab4576c531151e398b7ecede2e30df70d">More...</a><br /></td></tr>
<tr class="separator:ab4576c531151e398b7ecede2e30df70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32bf31475b0f6264b45438bd5c09ee7d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a32bf31475b0f6264b45438bd5c09ee7d">StyleValue_eq</a> (<a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a> a, <a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a> b)</td></tr>
<tr class="memdesc:a32bf31475b0f6264b45438bd5c09ee7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two StyleValues.  <a href="#a32bf31475b0f6264b45438bd5c09ee7d">More...</a><br /></td></tr>
<tr class="separator:a32bf31475b0f6264b45438bd5c09ee7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4fd7f8901569c053bd29f2035c69b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a9f4fd7f8901569c053bd29f2035c69b7">StyleValue_from_esc</a> (const char *s)</td></tr>
<tr class="memdesc:a9f4fd7f8901569c053bd29f2035c69b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an escape-code string (<code>char*</code>) to an actual StyleValue enum value.  <a href="#a9f4fd7f8901569c053bd29f2035c69b7">More...</a><br /></td></tr>
<tr class="separator:a9f4fd7f8901569c053bd29f2035c69b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca63735ad2cbc6475d4af83dc7c1a9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a4ca63735ad2cbc6475d4af83dc7c1a9b">StyleValue_from_str</a> (const char *arg)</td></tr>
<tr class="memdesc:a4ca63735ad2cbc6475d4af83dc7c1a9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a named argument to actual StyleValue enum value.  <a href="#a4ca63735ad2cbc6475d4af83dc7c1a9b">More...</a><br /></td></tr>
<tr class="separator:a4ca63735ad2cbc6475d4af83dc7c1a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f8126147490f88283a53e9ef48d33f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a3f8126147490f88283a53e9ef48d33f0">StyleValue_is_invalid</a> (<a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a> sval)</td></tr>
<tr class="memdesc:a3f8126147490f88283a53e9ef48d33f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a StyleValue is invalid.  <a href="#a3f8126147490f88283a53e9ef48d33f0">More...</a><br /></td></tr>
<tr class="separator:a3f8126147490f88283a53e9ef48d33f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6598b05bc5c742fbb94b47d8a3213a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a2d6598b05bc5c742fbb94b47d8a3213a">StyleValue_is_valid</a> (<a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a> sval)</td></tr>
<tr class="memdesc:a2d6598b05bc5c742fbb94b47d8a3213a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a StyleValue is valid.  <a href="#a2d6598b05bc5c742fbb94b47d8a3213a">More...</a><br /></td></tr>
<tr class="separator:a2d6598b05bc5c742fbb94b47d8a3213a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b74664587dd3c0e981603ee75c331b"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a24b74664587dd3c0e981603ee75c331b">StyleValue_repr</a> (<a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a> sval)</td></tr>
<tr class="memdesc:a24b74664587dd3c0e981603ee75c331b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation of a StyleValue.  <a href="#a24b74664587dd3c0e981603ee75c331b">More...</a><br /></td></tr>
<tr class="separator:a24b74664587dd3c0e981603ee75c331b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac767fb032c9617e2830cc5e13e66c400"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ac767fb032c9617e2830cc5e13e66c400">StyleValue_to_str</a> (<a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a> sval)</td></tr>
<tr class="memdesc:ac767fb032c9617e2830cc5e13e66c400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a human-friendly string (<code>char*</code>) representation for a StyleValue.  <a href="#ac767fb032c9617e2830cc5e13e66c400">More...</a><br /></td></tr>
<tr class="separator:ac767fb032c9617e2830cc5e13e66c400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b4ed49acc5d806f161a3b31f5bf023"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a41b4ed49acc5d806f161a3b31f5bf023">TermSize_repr</a> (<a class="el" href="colr_8h.html#structTermSize">TermSize</a> ts)</td></tr>
<tr class="memdesc:a41b4ed49acc5d806f161a3b31f5bf023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a string (<code>char*</code>) representation for a <a class="el" href="colr_8h.html#structTermSize" title="Holds a terminal size, usually retrieved with colr_term_size(). ">TermSize</a>.  <a href="#a41b4ed49acc5d806f161a3b31f5bf023">More...</a><br /></td></tr>
<tr class="separator:a41b4ed49acc5d806f161a3b31f5bf023"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a62b38c28aba614d1bd1706d6099df0e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a62b38c28aba614d1bd1706d6099df0e6">colr_printf_esc_mod</a></td></tr>
<tr class="memdesc:a62b38c28aba614d1bd1706d6099df0e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer to test for the presence of the "escaped output modifier" in colr_printf_handler.  <a href="#a62b38c28aba614d1bd1706d6099df0e6">More...</a><br /></td></tr>
<tr class="separator:a62b38c28aba614d1bd1706d6099df0e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Declarations for ColrC functions, enums, structs, etc. </p>
<p>Common macros and definitions are found here in <a class="el" href="colr_8h.html" title="Declarations for ColrC functions, enums, structs, etc. ">colr.h</a>, however the functions are documented in <a class="el" href="colr_8c.html" title="Implements everything in the colr.h header. ">colr.c</a>.</p>
</div><hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structBasicInfo" id="structBasicInfo"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structBasicInfo">&#9670;&nbsp;</a></span>BasicInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct BasicInfo</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Holds a known color name and it's <code>BasicValue</code>. </p>
<p>This is used for the <code>basic_names</code> array in <a class="el" href="colr_8c.html" title="Implements everything in the colr.h header. ">colr.c</a>. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ad02167bf204991552d918c44c3b82482"></a>char *</td>
<td class="fieldname">
name</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a184c878a0f9fe130891970d15e3238d0"></a><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a></td>
<td class="fieldname">
value</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structColorArg" id="structColorArg"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structColorArg">&#9670;&nbsp;</a></span>ColorArg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ColorArg</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Holds an ArgType, and a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>. </p>
</div><div class="dynheader">
Collaboration diagram for ColorArg:</div>
<div class="dyncontent">
<div class="center"><img src="structColorArg__coll__graph.png" border="0" usemap="#ColorArg_coll__map" alt="Collaboration graph"/></div>
<map name="ColorArg_coll__map" id="ColorArg_coll__map">
<area shape="rect" id="node2" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. " alt="" coords="5,95,89,121"/>
<area shape="rect" id="node3" href="colr_8h.html#structRGB" title="Container for RGB values. " alt="" coords="22,5,73,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a4313fce1154b6316ecdc591081ea898c"></a>uint32_t</td>
<td class="fieldname">
marker</td>
<td class="fielddoc">
A marker used to inspect void pointers and determine if they are ColorArgs. </td></tr>
<tr><td class="fieldtype">
<a id="a4d1de8b30570b3f8de977e2530382c49"></a><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
Fore, back, style, invalid. </td></tr>
<tr><td class="fieldtype">
<a id="ad947d9d54ef7ab11b84a36b6cd3a3426"></a><a class="el" href="colr_8h.html#structColorValue">ColorValue</a></td>
<td class="fieldname">
value</td>
<td class="fielddoc">
Color type and value. </td></tr>
</table>

</div>
</div>
<a name="structColorJustify" id="structColorJustify"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structColorJustify">&#9670;&nbsp;</a></span>ColorJustify</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ColorJustify</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Holds a string justification method, width, and padding character for ColorTexts. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a8b69f5659eb4a3de2776056a0b6e582d"></a>uint32_t</td>
<td class="fieldname">
marker</td>
<td class="fielddoc">
A marker used to inspect void pointers and determine if they are ColorJustifys. </td></tr>
<tr><td class="fieldtype">
<a id="a0d0ae3eed868d6fe94c60e4f757a7412"></a><a class="el" href="colr_8h.html#af1a3fe0b966f944fd659a98be170045f">ColorJustifyMethod</a></td>
<td class="fieldname">
method</td>
<td class="fielddoc">
The justification method, can be JUST_NONE. </td></tr>
<tr><td class="fieldtype">
<a id="a7972e067cc39f0cc113993a7dfd2b6df"></a>char</td>
<td class="fieldname">
padchar</td>
<td class="fielddoc">
The desired padding character, or <code>0</code> to use the default (`' '`). </td></tr>
<tr><td class="fieldtype">
<a id="a74010f20f8a60fe77dc5c62e13f0c3fb"></a>int</td>
<td class="fieldname">
width</td>
<td class="fielddoc">
The desired width for the final string, or <code>0</code> to use <a class="el" href="colr_8c.html#ae4c11bb5b3b1bb2848bb16aee39763b2" title="Attempts to retrieve the row/column size of the terminal and returns a TermSize. ">colr_term_size()</a>. </td></tr>
</table>

</div>
</div>
<a name="structColorNameData" id="structColorNameData"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structColorNameData">&#9670;&nbsp;</a></span>ColorNameData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ColorNameData</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Holds info about a known color name, like it's ExtendedValue and it's <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value. </p>
<p>Some of the names have the same ExtendedValue, and not all ExtendedValues have names.</p>
<p>This is used in the colr_name_data array. </p>
</div><div class="dynheader">
Collaboration diagram for ColorNameData:</div>
<div class="dyncontent">
<div class="center"><img src="structColorNameData__coll__graph.png" border="0" usemap="#ColorNameData_coll__map" alt="Collaboration graph"/></div>
<map name="ColorNameData_coll__map" id="ColorNameData_coll__map">
<area shape="rect" id="node2" href="colr_8h.html#structRGB" title="Container for RGB values. " alt="" coords="37,5,87,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a784696b7478fb97d410f78ea092f453f"></a><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a></td>
<td class="fieldname">
ext</td>
<td class="fielddoc">
ExtendedValue (256-colors) for the color. </td></tr>
<tr><td class="fieldtype">
<a id="a9155ebcbb6235c8a7c00398c1d69242a"></a>char *</td>
<td class="fieldname">
name</td>
<td class="fielddoc">
The known name of the color. </td></tr>
<tr><td class="fieldtype">
<a id="a64702b0ae877daffb159a3a1c0d1512e"></a><a class="el" href="colr_8h.html#structRGB">RGB</a></td>
<td class="fieldname">
rgb</td>
<td class="fielddoc">
<a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> (TrueColor) for the color. </td></tr>
</table>

</div>
</div>
<a name="structColorResult" id="structColorResult"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structColorResult">&#9670;&nbsp;</a></span>ColorResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ColorResult</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Holds a string (<code>char*</code>) that was definitely allocated by Colr. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ColorResult_example_8c-example.html#_a7">ColorResult_example.c</a>.</dd>
</dl></div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a0a5baad3c433202b081b6f6f9b56f505"></a>size_t</td>
<td class="fieldname">
length</td>
<td class="fielddoc">
A length in bytes for the string result. <p>Set when the <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> is initialized with a string (<a class="el" href="colr_8c.html#af752035c362c7c9ddb2e7f2f2305d509" title="Initialize a new ColorResult with an allocated string (char*). ">ColorResult_new()</a>). Initially set to <code>-1</code>. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a72840fb917078278f359bb25e564c9fe"></a>uint32_t</td>
<td class="fieldname">
marker</td>
<td class="fielddoc">
A marker used to inspect void pointers and determine if they are ColorResults. </td></tr>
<tr><td class="fieldtype">
<a id="a76db0a3e637710f9c4ee3eae7fd9cb7a"></a>char *</td>
<td class="fieldname">
result</td>
<td class="fielddoc">
A string (<code>char*</code>) result from one of the colr functions. </td></tr>
</table>

</div>
</div>
<a name="unionColorStructMarker" id="unionColorStructMarker"></a>
<h2 class="memtitle"><span class="permalink"><a href="#unionColorStructMarker">&#9670;&nbsp;</a></span>ColorStructMarker</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union ColorStructMarker</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Breaks down Colr struct markers, such as COLORARG_MARKER, into individual bytes. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a2d22f09822b1b05b93d38e966e970682"></a>struct <a class="el" href="colr_8h.html#structColorStructMarker_8bytes">ColorStructMarker</a></td>
<td class="fieldname">
bytes</td>
<td class="fielddoc">
Individual bytes that make up the marker. </td></tr>
<tr><td class="fieldtype">
<a id="acadc27e4240aca80cfb2903e71b3588a"></a>uint32_t</td>
<td class="fieldname">
marker</td>
<td class="fielddoc">
The actual uint32_t marker value. </td></tr>
</table>

</div>
</div>
<a name="structColorStructMarker_8bytes" id="structColorStructMarker_8bytes"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structColorStructMarker_8bytes">&#9670;&nbsp;</a></span>ColorStructMarker.bytes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ColorStructMarker.bytes</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Individual bytes that make up the marker. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="aedbab45572c72a5d9440b40bcc0500c0"></a>uint8_t</td>
<td class="fieldname">
b1</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="afbfba2e45c2045dc5cab22a5afe83d9d"></a>uint8_t</td>
<td class="fieldname">
b2</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a7a6f150b83091ce20c89368641f9a137"></a>uint8_t</td>
<td class="fieldname">
b3</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a3dfe563103ab11bec75bb5081e7a1dbe"></a>uint8_t</td>
<td class="fieldname">
b4</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structColorText" id="structColorText"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structColorText">&#9670;&nbsp;</a></span>ColorText</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ColorText</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Holds a string of text, and optional fore, back, and style ColorArgs. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="colr_join_example_8c-example.html#_a8">colr_join_example.c</a>, and <a class="el" href="simple_example_8c-example.html#_a12">simple_example.c</a>.</dd>
</dl></div><div class="dynheader">
Collaboration diagram for ColorText:</div>
<div class="dyncontent">
<div class="center"><img src="structColorText__coll__graph.png" border="0" usemap="#ColorText_coll__map" alt="Collaboration graph"/></div>
<map name="ColorText_coll__map" id="ColorText_coll__map">
<area shape="rect" id="node2" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. " alt="" coords="11,184,83,211"/>
<area shape="rect" id="node3" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. " alt="" coords="5,95,89,121"/>
<area shape="rect" id="node4" href="colr_8h.html#structRGB" title="Container for RGB values. " alt="" coords="22,5,73,32"/>
<area shape="rect" id="node5" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ..." alt="" coords="107,184,198,211"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ae9b8a112de055f9d7826a50b4cdf4e4a"></a><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *</td>
<td class="fieldname">
back</td>
<td class="fielddoc">
<a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> for back color. Can be <code>NULL</code>. </td></tr>
<tr><td class="fieldtype">
<a id="a788a3311c550c543c8ef345a5e90e757"></a><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *</td>
<td class="fieldname">
fore</td>
<td class="fielddoc">
<a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> for fore color. Can be <code>NULL</code>. </td></tr>
<tr><td class="fieldtype">
<a id="a36047003e9e4322bf432db68b39d0663"></a><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a></td>
<td class="fieldname">
just</td>
<td class="fielddoc">
<a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> info, set to JUST_NONE by default. </td></tr>
<tr><td class="fieldtype">
<a id="a2f56d6257751c46d60a825c8dae91a66"></a>uint32_t</td>
<td class="fieldname">
marker</td>
<td class="fielddoc">
A marker used to inspect void pointers and determine if they are ColorTexts. </td></tr>
<tr><td class="fieldtype">
<a id="aa9f47920503d771d3bd80435b3ef2d6f"></a><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *</td>
<td class="fieldname">
style</td>
<td class="fielddoc">
<a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> for style value. Can be <code>NULL</code>. </td></tr>
<tr><td class="fieldtype">
<a id="aad9a63ccc1c0361fb44ef27b932b2765"></a>char *</td>
<td class="fieldname">
text</td>
<td class="fielddoc">
Text to colorize. </td></tr>
</table>

</div>
</div>
<a name="structColorValue" id="structColorValue"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structColorValue">&#9670;&nbsp;</a></span>ColorValue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ColorValue</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Holds a color type and it's value. </p>
<p>The <code>.type</code> member must always match the type of color value it is holding.</p>
<p>This is internal. It's used to make the final interface easier to use. You probably shouldn't be using it. </p>
</div><div class="dynheader">
Collaboration diagram for ColorValue:</div>
<div class="dyncontent">
<div class="center"><img src="structColorValue__coll__graph.png" border="0" usemap="#ColorValue_coll__map" alt="Collaboration graph"/></div>
<map name="ColorValue_coll__map" id="ColorValue_coll__map">
<area shape="rect" id="node2" href="colr_8h.html#structRGB" title="Container for RGB values. " alt="" coords="22,5,73,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="abc2bf486addb5900c648b2dc3b2c472f"></a><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a></td>
<td class="fieldname">
basic</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a01592c0494ac1323caa73fd1cd21b3e3"></a><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a></td>
<td class="fieldname">
ext</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a6a5f2a470e1db3e0f6ebb340eeed183c"></a><a class="el" href="colr_8h.html#structRGB">RGB</a></td>
<td class="fieldname">
rgb</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a901e7250a4768f40407d758a9b40766e"></a><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a></td>
<td class="fieldname">
style</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="aaa27aca3ef590be3930e4ff16ad7775d"></a><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structExtendedInfo" id="structExtendedInfo"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structExtendedInfo">&#9670;&nbsp;</a></span>ExtendedInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ExtendedInfo</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Holds a known color name and it's <code>ExtendedValue</code>. </p>
<p>This is used for the <code>basic_names</code> array in <a class="el" href="colr_8c.html" title="Implements everything in the colr.h header. ">colr.c</a>. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ac61ae9cfb3398cfa8c71ea0a010bcf8c"></a>char *</td>
<td class="fieldname">
name</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a9e3a963de5460df97e31452dc0da39e9"></a><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a></td>
<td class="fieldname">
value</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structRGB" id="structRGB"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structRGB">&#9670;&nbsp;</a></span>RGB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct RGB</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Container for <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> values. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a233b293e05afb1f665bccf5e755a1015"></a>unsigned char</td>
<td class="fieldname">
blue</td>
<td class="fielddoc">
Blue value for a color. </td></tr>
<tr><td class="fieldtype">
<a id="aa79ef354ee37a3d4009f88c6df3ff89c"></a>unsigned char</td>
<td class="fieldname">
green</td>
<td class="fielddoc">
Green value for a color. </td></tr>
<tr><td class="fieldtype">
<a id="a27a7ad87f1e966cb05761741e57b06d2"></a>unsigned char</td>
<td class="fieldname">
red</td>
<td class="fielddoc">
Red value for a color. </td></tr>
</table>

</div>
</div>
<a name="structStyleInfo" id="structStyleInfo"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structStyleInfo">&#9670;&nbsp;</a></span>StyleInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct StyleInfo</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Holds a known style name and it's <code>StyleValue</code>. </p>
<p>This is used for the <code>style_names</code> array in <a class="el" href="colr_8c.html" title="Implements everything in the colr.h header. ">colr.c</a>. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a722b87ccd4114d29b1f3fda3667de2d0"></a>char *</td>
<td class="fieldname">
name</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a976533eec4bc1529dd6e29541dbb9aaf"></a><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a></td>
<td class="fieldname">
value</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structTermSize" id="structTermSize"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structTermSize">&#9670;&nbsp;</a></span>TermSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct TermSize</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Holds a terminal size, usually retrieved with <a class="el" href="colr_8c.html#ae4c11bb5b3b1bb2848bb16aee39763b2" title="Attempts to retrieve the row/column size of the terminal and returns a TermSize. ">colr_term_size()</a>. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a9a5b60ff7d19d434ea08ee742e3d6711"></a>unsigned short</td>
<td class="fieldname">
columns</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a65143bf24ee18a8aabbf71e9f854d405"></a>unsigned short</td>
<td class="fieldname">
rows</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ab7f29d345901a016f81f020ca4326c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f29d345901a016f81f020ca4326c61">&#9670;&nbsp;</a></span>alloc_basic</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define alloc_basic</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;calloc(<a class="el" href="colr_8h.html#a4ef6ad74c493fe40e199341072fabefe">CODE_LEN</a>, sizeof(char))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate enough for a basic code. </p>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">Pointer to the allocated string, or NULL on error.</p>
<p class="enddd"><em>You must <code>free()</code> the memory allocated by this function.</em> </p>
</dd></dl>

</div>
</div>
<a id="a27c2b2b2835220a22a3b02e18febda40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27c2b2b2835220a22a3b02e18febda40">&#9670;&nbsp;</a></span>alloc_extended</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define alloc_extended</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;calloc(<a class="el" href="colr_8h.html#af77ec93393736fa98be724385d61614d">CODEX_LEN</a>, sizeof(char))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate enough for an extended code. </p>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">Pointer to the allocated string, or NULL on error.</p>
<p class="enddd"><em>You must <code>free()</code> the memory allocated by this function.</em> </p>
</dd></dl>

</div>
</div>
<a id="ade4f7e3d0a7c1d9b991b0a33a995d6e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade4f7e3d0a7c1d9b991b0a33a995d6e5">&#9670;&nbsp;</a></span>alloc_rgb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define alloc_rgb</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;calloc(<a class="el" href="colr_8h.html#ad50e6b68284102d5270834e02652af37">CODE_RGB_LEN</a>, sizeof(char))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate enough for an rgb code. </p>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">Pointer to the allocated string, or NULL on error.</p>
<p class="enddd"><em>You must <code>free()</code> the memory allocated by this function.</em> </p>
</dd></dl>

</div>
</div>
<a id="a6af1a91e97e7aed226ab0cdc6ce205f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6af1a91e97e7aed226ab0cdc6ce205f8">&#9670;&nbsp;</a></span>alloc_style</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define alloc_style</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;calloc(<a class="el" href="colr_8h.html#ac83d14a355d35b7af90deb99ad3b7601">STYLE_LEN</a>, sizeof(char))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate enough for a style code. </p>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">Pointer to the allocated string, or NULL on error.</p>
<p class="enddd"><em>You must <code>free()</code> the memory allocated by this function.</em> </p>
</dd></dl>

</div>
</div>
<a id="a6e247a378d2359d2d6efa4af5e3cd03b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e247a378d2359d2d6efa4af5e3cd03b">&#9670;&nbsp;</a></span>asprintf_or_return</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define asprintf_or_return</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">retval, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#a80a08fc1383c7260a31698864d52fee2">if_not_asprintf</a>(__VA_ARGS__) return retval</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro for bailing out of a function when asprintf fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">retval</td><td>Value to return if the asprintf fails. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Arguments for asprintf. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a83ea2f6c1adea8535ae629051e74ced0">BasicValue_to_str()</a>, <a class="el" href="colr_8h.html#a5af692f2357d46b9cee45bb114f2a4a2">ColorArg_repr()</a>, <a class="el" href="colr_8h.html#a4e16f30e878a6fb53ed9af5f8fdd674a">ColorArgs_array_repr()</a>, <a class="el" href="colr_8h.html#a6c35f6b47cc737744487d14d20241656">ColorJustify_repr()</a>, <a class="el" href="colr_8h.html#a65363a3601cd9cfcdc7fc40722d5d3c3">ColorText_repr()</a>, <a class="el" href="colr_8h.html#af78a98cb101d4d5f18df0023b3109013">colr_char_repr()</a>, <a class="el" href="colr_8h.html#a1a8345393e635e1c5e148473bdce292d">colr_str_center()</a>, <a class="el" href="colr_8h.html#a5eedebae47b5d22dda709f833f23a256">colr_str_ljust()</a>, <a class="el" href="colr_8h.html#a2fbc36f0f7aba3aa0616437f937efd20">colr_str_replace_re_match()</a>, <a class="el" href="colr_8h.html#a196ad91a69cfbeb27a5266ffc93ed353">colr_str_repr()</a>, <a class="el" href="colr_8h.html#acc75e3bf729168f9ac204ef0a1708d46">colr_str_rjust()</a>, <a class="el" href="colr_8h.html#aa45baebc38756a40e7084f8198999902">ExtendedValue_repr()</a>, <a class="el" href="colr_8h.html#a4e334d6b9145fca9717fe5a2aeb542fe">ExtendedValue_to_str()</a>, <a class="el" href="colr_8h.html#afd28864afbcfa4a344e4596130645177">RGB_repr()</a>, <a class="el" href="colr_8h.html#a95e4feb89e009f00cfe7e74a55fab56f">RGB_to_hex()</a>, <a class="el" href="colr_8h.html#a16d2f9a1133c8a955f0a551870d7ebe8">RGB_to_str()</a>, <a class="el" href="colr_8h.html#ac767fb032c9617e2830cc5e13e66c400">StyleValue_to_str()</a>, and <a class="el" href="colr_8h.html#a41b4ed49acc5d806f161a3b31f5bf023">TermSize_repr()</a>.</p>

</div>
</div>
<a id="a947915cd251af5099f6a9232836b12d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947915cd251af5099f6a9232836b12d8">&#9670;&nbsp;</a></span>back</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define back</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#afb5ac0bd012b8162cea125ad0d9e8bf0">ColorArg_to_ptr</a>(<a class="el" href="colr_8h.html#aeba419af1d4c23615eb844db37e46ee6">back_arg</a>(x))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a back color suitable for use with the <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a>, <a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465" title="Like colr_cat(), but returns an allocated ColorResult that the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros will automatically free(). ">Colr_cat()</a>, and <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> macros. </p>
<p>Technically, this macro accepts BasicValues, ExtendedValues, or <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> structs. However, for some of these you should be using the macros that create those things.</p>
<p>BasicValues can be used by their names (RED, YELLOW, etc.).</p>
<p>ExtendedValues can be created on the fly with <a class="el" href="colr_8h.html#a37ff4fc6d17b53b60202be55bd0732c5" title="Casts to ExtendedValue (unsigned char). ">ext()</a>.</p>
<p><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> structs can be easily created with <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57" title="Creates an anonymous RGB struct for use in function calls. ">rgb()</a>.</p>
<p>Color names (<code>char*</code>) can be passed to generate the appropriate color value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A BasicValue, ExtendedValue, or <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct to use for the color value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a heap-allocated <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct.<br />
 If used inside of the <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a>, <a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465" title="Like colr_cat(), but returns an allocated ColorResult that the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros will automatically free(). ">Colr_cat()</a>, and <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> macros, <em>they will <code>free()</code> the result</em>. Otherwise, <em>you are responsible for calling <code>free()</code></em>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#aeba419af1d4c23615eb844db37e46ee6" title="Uses ColorArg_from_&lt;type&gt; to build a ColorArg with the appropriate color type, based on the type of i...">back_arg</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a5f85c3a1434551be3846414be3d1bdb9" title="Return just the escape code string for a back color. ">back_str</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a753093cd4c872eed4b77feaa7816212b" title="Create an allocated string directly from Colr() arguments. ">colr</a> </dd>
<dd>
<a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="back_example_8c-example.html#a2">back_example.c</a>, <a class="el" href="ColorResult_example_8c-example.html#a6">ColorResult_example.c</a>, <a class="el" href="Colr_example_8c-example.html#a9">Colr_example.c</a>, <a class="el" href="fore_example_8c-example.html#a5">fore_example.c</a>, and <a class="el" href="simple_example_8c-example.html#a8">simple_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="aeba419af1d4c23615eb844db37e46ee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba419af1d4c23615eb844db37e46ee6">&#9670;&nbsp;</a></span>back_arg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define back_arg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_Generic( \</div><div class="line">        (x), \</div><div class="line">        <span class="keywordtype">char</span>* : <a class="code" href="colr_8h.html#aa62406b058b948941a8906475924536a">ColorArg_from_str</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structRGB">RGB</a>: <a class="code" href="colr_8h.html#aaa24bba74e99aa66ed41839576e57856">ColorArg_from_RGB</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>: <a class="code" href="colr_8h.html#aad49f4597388e6bdb896ff28334cd5e6">ColorArg_from_BasicValue</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>: <a class="code" href="colr_8h.html#aed30e2a4b30ab5e3cf49608a3c410cc5">ColorArg_from_ExtendedValue</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>: <a class="code" href="colr_8h.html#acf63bcee395dca3ca29dc324e3d7c8f2">ColorArg_from_StyleValue</a> \</div><div class="line">    )(BACK, x)</div><div class="ttc" id="colr_8h_html_aa62406b058b948941a8906475924536a"><div class="ttname"><a href="colr_8h.html#aa62406b058b948941a8906475924536a">ColorArg_from_str</a></div><div class="ttdeci">ColorArg ColorArg_from_str(ArgType type, const char *colorname)</div><div class="ttdoc">Build a ColorArg (fore, back, or style value) from a known color name/style. </div><div class="ttdef"><b>Definition:</b> colr.c:5196</div></div>
<div class="ttc" id="colr_8h_html_aed30e2a4b30ab5e3cf49608a3c410cc5"><div class="ttname"><a href="colr_8h.html#aed30e2a4b30ab5e3cf49608a3c410cc5">ColorArg_from_ExtendedValue</a></div><div class="ttdeci">ColorArg ColorArg_from_ExtendedValue(ArgType type, ExtendedValue value)</div><div class="ttdoc">Explicit version of ColorArg_from_value that only handles ExtendedValues. </div><div class="ttdef"><b>Definition:</b> colr.c:5095</div></div>
<div class="ttc" id="colr_8h_html_a0c061fbfddd43dfe324486dc86cb92ee"><div class="ttname"><a href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a></div><div class="ttdeci">BasicValue</div><div class="ttdoc">Basic color values, with a few convenience values for extended colors. </div><div class="ttdef"><b>Definition:</b> colr.h:2456</div></div>
<div class="ttc" id="colr_8h_html_aaa24bba74e99aa66ed41839576e57856"><div class="ttname"><a href="colr_8h.html#aaa24bba74e99aa66ed41839576e57856">ColorArg_from_RGB</a></div><div class="ttdeci">ColorArg ColorArg_from_RGB(ArgType type, RGB value)</div><div class="ttdoc">Explicit version of ColorArg_from_value that only handles RGB structs. </div><div class="ttdef"><b>Definition:</b> colr.c:5118</div></div>
<div class="ttc" id="colr_8h_html_acf63bcee395dca3ca29dc324e3d7c8f2"><div class="ttname"><a href="colr_8h.html#acf63bcee395dca3ca29dc324e3d7c8f2">ColorArg_from_StyleValue</a></div><div class="ttdeci">ColorArg ColorArg_from_StyleValue(ArgType type, StyleValue value)</div><div class="ttdoc">Explicit version of ColorArg_from_value that only handles StyleValues. </div><div class="ttdef"><b>Definition:</b> colr.c:5235</div></div>
<div class="ttc" id="colr_8h_html_structRGB"><div class="ttname"><a href="colr_8h.html#structRGB">RGB</a></div><div class="ttdoc">Container for RGB values. </div><div class="ttdef"><b>Definition:</b> colr.h:2535</div></div>
<div class="ttc" id="colr_8h_html_aad49f4597388e6bdb896ff28334cd5e6"><div class="ttname"><a href="colr_8h.html#aad49f4597388e6bdb896ff28334cd5e6">ColorArg_from_BasicValue</a></div><div class="ttdeci">ColorArg ColorArg_from_BasicValue(ArgType type, BasicValue value)</div><div class="ttdoc">Explicit version of ColorArg_from_value that only handles BasicValues. </div><div class="ttdef"><b>Definition:</b> colr.c:5072</div></div>
<div class="ttc" id="colr_8h_html_a6dda29f582a062546ef8733d8b7d8a94"><div class="ttname"><a href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a></div><div class="ttdeci">unsigned char ExtendedValue</div><div class="ttdoc">Convenience typedef for clarity when dealing with extended (256) colors. </div><div class="ttdef"><b>Definition:</b> colr.h:2532</div></div>
<div class="ttc" id="colr_8h_html_a85224ec2507f33b1985f4cdd0adfe0e6"><div class="ttname"><a href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a></div><div class="ttdeci">StyleValue</div><div class="ttdoc">Style values. </div><div class="ttdef"><b>Definition:</b> colr.h:2549</div></div>
</div><!-- fragment -->
<p>Uses ColorArg_from_&lt;type&gt; to build a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> with the appropriate color type, based on the type of it's argument. </p>
<p>Uses <code>_Generic</code> (C11 standard) to dynamically create a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>. This is used by the <a class="el" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8" title="Create a back color suitable for use with the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros. ">back()</a> macro.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td><code>BasicValue</code>, <code>Extended</code> (<code>unsigned char</code>), <code><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a></code> struct, or string (color name) for back color. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> with the BACK type set, and it's <code>.value.type</code> set for the appropriate color type/value.<br />
 For invalid values the <code>.value.type</code> may be set to TYPE_INVALID.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8" title="Create a back color suitable for use with the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros. ">back</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a5f85c3a1434551be3846414be3d1bdb9" title="Return just the escape code string for a back color. ">back_str</a> </dd></dl>

</div>
</div>
<a id="a5f85c3a1434551be3846414be3d1bdb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f85c3a1434551be3846414be3d1bdb9">&#9670;&nbsp;</a></span>back_str</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define back_str</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#ad1d3aaca5e543f8fefbd863a959c9d67">ColorArg_to_esc</a>(<a class="el" href="colr_8h.html#aeba419af1d4c23615eb844db37e46ee6">back_arg</a>(x))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return just the escape code string for a back color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A BasicValue, ExtendedValue, or <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string.</p>
<p class="enddd"><em>You must <code>free()</code> the memory allocated by this function.</em> </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8" title="Create a back color suitable for use with the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros. ">back</a> </dd>
<dd>
<a class="el" href="colr_8h.html#aeba419af1d4c23615eb844db37e46ee6" title="Uses ColorArg_from_&lt;type&gt; to build a ColorArg with the appropriate color type, based on the type of i...">back_arg</a> </dd></dl>

</div>
</div>
<a id="a686865036c288a8c6d1626ce2f120039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a686865036c288a8c6d1626ce2f120039">&#9670;&nbsp;</a></span>back_str_static</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define back_str_static</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">__extension__ ({ \</div><div class="line">        __typeof(x) _bss_val = x; \</div><div class="line">        ColorArg _bss_carg = <a class="code" href="colr_8h.html#aeba419af1d4c23615eb844db37e46ee6">back_arg</a>(_bss_val); \</div><div class="line">        size_t _bss_len = <a class="code" href="colr_8h.html#adaff727006f4c057aab75e55bfb473c4">ColorArg_length</a>(_bss_carg); \</div><div class="line">        char* _bss_codes = alloca(_bss_len); \</div><div class="line">        ColorArg_to_esc_s(_bss_codes, _bss_carg); \</div><div class="line">        _bss_codes; \</div><div class="line">    })</div><div class="ttc" id="colr_8h_html_aeba419af1d4c23615eb844db37e46ee6"><div class="ttname"><a href="colr_8h.html#aeba419af1d4c23615eb844db37e46ee6">back_arg</a></div><div class="ttdeci">#define back_arg(x)</div><div class="ttdoc">Uses ColorArg_from_&lt;type&gt; to build a ColorArg with the appropriate color type, based on the type of i...</div><div class="ttdef"><b>Definition:</b> colr.h:476</div></div>
<div class="ttc" id="colr_8h_html_adaff727006f4c057aab75e55bfb473c4"><div class="ttname"><a href="colr_8h.html#adaff727006f4c057aab75e55bfb473c4">ColorArg_length</a></div><div class="ttdeci">size_t ColorArg_length(ColorArg carg)</div><div class="ttdoc">Returns the length in bytes needed to allocate a string (char*) built with ColorArg_to_esc(). </div><div class="ttdef"><b>Definition:</b> colr.c:5342</div></div>
</div><!-- fragment -->
<p>Creates a stack-allocated escape code string (<code>char*</code>) for a back color. </p>
<p>These are not constant strings, but they are stored on the stack. A <a href="https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html">Statement Expression</a> is used to build a string of the correct length and content using <a class="el" href="colr_8h.html#abaf3d02ff1292f2aaa605522665ae564" title="Converts a ColorArg into an escape code string (char*) and fills the destination string. ">ColorArg_to_esc_s()</a>.</p>
<dl class="section attention"><dt>Attention</dt><dd>This feature uses a GNU extension, and is only available when COLR_GNU is defined. See the documentation for COLR_GNU. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This uses <a href="https://linux.die.net/man/3/alloca"><code>alloca</code></a> to reserve space on the stack inside of a <a href="https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html">Statement Expression</a>. A <a href="https://gcc.gnu.org/onlinedocs/gcc/Variable-Length.html">Variable Length Array</a> will not work inside of a statement expression. If the call causes a stack overflow, program behavior is undefined. See previous links, and <a href="https://stackoverflow.com/questions/1018853/why-is-the-use-of-alloca-not-considered-good-practice" title="Why is alloca considered bad practice?">here</a>.</dd></dl>
<p>You can also create stack-allocated escape code strings using <a class="el" href="colr_8h.html#ae29032483aea8cb25d6b90750767ffc1" title="Create an escape code for a background color. ">format_bg()</a>, <a class="el" href="colr_8h.html#aa4853b53fa18d26741ab7178606e5724" title="Create an escape code for an extended background color. ">format_bgx()</a>, <a class="el" href="colr_8h.html#a97257ad40619df6a6c190890ff2873c4" title="Create an escape code for a true color (rgb) background color using values from an RGB struct...">format_bg_RGB()</a>, and <a class="el" href="colr_8h.html#a185cec167afe41b6401206659d2d406c" title="Create an escape code for a true color (rgb) fore color using an RGB struct&#39;s values, approximating 256-color values. ">format_bg_RGB_term()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A BasicValue, ExtendedValue, or <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A stack-allocated escape code string.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a686865036c288a8c6d1626ce2f120039" title="Creates a stack-allocated escape code string (char*) for a back color. ">back_str_static</a> </dd>
<dd>
<a class="el" href="colr_8h.html#adb829be51382b5422286a8606a7ff4fc" title="A less-flexible style_str() that returns a static escape code string for a style. ...">style_str_static</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a6027d93e8768f3c152edafd92e757801" title="Create an escape code for a fore color. ">format_fg</a> </dd>
<dd>
<a class="el" href="colr_8h.html#ae29032483aea8cb25d6b90750767ffc1" title="Create an escape code for a background color. ">format_bg</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#back_str_static-example" id="back_str_static-example" class="diamond-bullet">&#160;</a> back_str_static example: </div><div class="fragment"><div class="line"><span class="comment">// This results in a call to sprintf(), to format an extended escape code.</span></div><div class="line"><span class="comment">// The string is stored on the stack.</span></div><div class="line"><span class="keywordtype">char</span>* backwhite = <a class="code" href="colr_8h.html#a686865036c288a8c6d1626ce2f120039">back_str_static</a>(WHITE);</div><div class="line"><span class="keywordtype">char</span>* foreblue = <a class="code" href="colr_8h.html#ad0ab6c47eae67006285e33f1edd84278">fore_str_static</a>(BLUE);</div><div class="line">printf(<span class="stringliteral">&quot;%s%sBlue on White.&quot;</span> <a class="code" href="colr_8h.html#a650ed7bed617e54aa77f7b2907675137">NCNL</a>, backwhite, foreblue);</div><div class="line"></div><div class="line"><a class="code" href="colr_8h.html#structRGB">RGB</a> rgbval = <a class="code" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>(255, 34, 0);</div><div class="line">printf(<span class="stringliteral">&quot;%sA reddish.&quot;</span> <a class="code" href="colr_8h.html#a650ed7bed617e54aa77f7b2907675137">NCNL</a>, <a class="code" href="colr_8h.html#a686865036c288a8c6d1626ce2f120039">back_str_static</a>(rgbval));</div><div class="line"></div><div class="line">printf(<span class="stringliteral">&quot;%sAquaMarine.&quot;</span> <a class="code" href="colr_8h.html#a650ed7bed617e54aa77f7b2907675137">NCNL</a>, <a class="code" href="colr_8h.html#a686865036c288a8c6d1626ce2f120039">back_str_static</a>(<span class="stringliteral">&quot;aquamarine&quot;</span>));</div></div><!-- fragment --> </div> 
</div>
</div>
<a id="a653c1408c1d132a05a5648ffd53ca2c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a653c1408c1d132a05a5648ffd53ca2c6">&#9670;&nbsp;</a></span>basic</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define basic</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;((<a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>)(x))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts to BasicValue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Value to case to <code>BasicValue</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A BasicValue.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f" title="Create a fore color suitable for use with the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros. ">fore</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8" title="Create a back color suitable for use with the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros. ">back</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a753093cd4c872eed4b77feaa7816212b" title="Create an allocated string directly from Colr() arguments. ">colr</a> </dd>
<dd>
<a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr</a> </dd></dl>

</div>
</div>
<a id="a7dbd4f0825e46d22010c39d92a5f6e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dbd4f0825e46d22010c39d92a5f6e60">&#9670;&nbsp;</a></span>bool_colr_enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bool_colr_enum</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(x &lt; 0 ? false: true)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the "truthiness" of the enums used in ColrC (BasicValue, ExtendedValue function-returns, StyleValue, ColorType, ArgType). </p>
<p>Any value less than <code>0</code> is considered false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>An enum to convert to boolean. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the value is considered valid, or non-empty. </td></tr>
    <tr><td class="paramname">false</td><td>if the value is considered invalid, or empty. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a66b4906cfb08588005536db1250dc899">ColorArg_is_invalid()</a>, <a class="el" href="colr_8h.html#a1e446f65d6987d52522a1755c909d421">ColorArg_is_valid()</a>, <a class="el" href="colr_8h.html#adc223f6fda6296396e9ecddcc68d4aec">ColorType_is_invalid()</a>, <a class="el" href="colr_8h.html#a5a5883d43e3206584ad048908720afb2">ColorType_is_valid()</a>, <a class="el" href="colr_8h.html#a22fcf30338eb777592421543885f74e0">ColorValue_is_invalid()</a>, and <a class="el" href="colr_8h.html#ac7183410b61d12a99dda3f76c2705497">ColorValue_is_valid()</a>.</p>

</div>
</div>
<a id="ab0e75d15b6f6536e745f66563c4ba6c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0e75d15b6f6536e745f66563c4ba6c3">&#9670;&nbsp;</a></span>CODE_ANY_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CODE_ANY_LEN&#160;&#160;&#160;46</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum length in chars for any possible escape code mixture for one complete style (one of each: fore, back, and style). </p>
<p>(basically <code>(CODE_RGB_LEN * 2) + STYLE_LEN</code> since rgb codes are the longest). </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="colr_printf_example_8c-example.html#a4">colr_printf_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="a4ef6ad74c493fe40e199341072fabefe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef6ad74c493fe40e199341072fabefe">&#9670;&nbsp;</a></span>CODE_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CODE_LEN&#160;&#160;&#160;14</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum length for a basic fore/back escape code, including `'\0'`. </p>
<p>Keep in mind that BasicValue actually has some "light" colors (104). </p>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ae29032483aea8cb25d6b90750767ffc1">format_bg()</a>, and <a class="el" href="colr_8h.html#a6027d93e8768f3c152edafd92e757801">format_fg()</a>.</p>

</div>
</div>
<a id="a9837a2915a770865032578914efb8621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9837a2915a770865032578914efb8621">&#9670;&nbsp;</a></span>CODE_LEN_MIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CODE_LEN_MIN&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum length for the shortest basic fore/back escape code, including `'\0'`. </p>
<p>Use CODE_LEN for allocation. </p>

</div>
</div>
<a id="a3ffdc16cef9af954c4d62d29ba8d7961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ffdc16cef9af954c4d62d29ba8d7961">&#9670;&nbsp;</a></span>CODE_RGB_LEN_MIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CODE_RGB_LEN_MIN&#160;&#160;&#160;14</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum length for the shortest <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> fore/back escape code, including `'\0'`. </p>
<p>Use CODE_RGB_LEN for allocation. </p>

</div>
</div>
<a id="a37730bc0c16d2d698f3d539add30483b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37730bc0c16d2d698f3d539add30483b">&#9670;&nbsp;</a></span>CODEX_LEN_MIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CODEX_LEN_MIN&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum length for the shortest extended fore/back escape code, including `'\0'`. </p>
<p>Use CODEX_LEN for allocation. </p>

</div>
</div>
<a id="aa8903c150d5b0912b2f797f9235978f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8903c150d5b0912b2f797f9235978f8">&#9670;&nbsp;</a></span>color_arg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define color_arg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_Generic( \</div><div class="line">        (x), \</div><div class="line">        <span class="keywordtype">char</span>*: <a class="code" href="colr_8h.html#aa62406b058b948941a8906475924536a">ColorArg_from_str</a>(type, x), \</div><div class="line">        <a class="code" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>: <a class="code" href="colr_8h.html#a89a5aa762bd5802872faf571aa32ea35">ColorArg_from_value</a>(type, TYPE_BASIC, &amp;x), \</div><div class="line">        <a class="code" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>: <a class="code" href="colr_8h.html#a89a5aa762bd5802872faf571aa32ea35">ColorArg_from_value</a>(type, TYPE_EXTENDED, &amp;x), \</div><div class="line">        <a class="code" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>: <a class="code" href="colr_8h.html#a89a5aa762bd5802872faf571aa32ea35">ColorArg_from_value</a>(type, TYPE_STYLE, &amp;x), \</div><div class="line">        <a class="code" href="colr_8h.html#structRGB">RGB</a>: <a class="code" href="colr_8h.html#a89a5aa762bd5802872faf571aa32ea35">ColorArg_from_value</a>(type, TYPE_RGB, &amp;x) \</div><div class="line">    )</div><div class="ttc" id="colr_8h_html_aa62406b058b948941a8906475924536a"><div class="ttname"><a href="colr_8h.html#aa62406b058b948941a8906475924536a">ColorArg_from_str</a></div><div class="ttdeci">ColorArg ColorArg_from_str(ArgType type, const char *colorname)</div><div class="ttdoc">Build a ColorArg (fore, back, or style value) from a known color name/style. </div><div class="ttdef"><b>Definition:</b> colr.c:5196</div></div>
<div class="ttc" id="colr_8h_html_a0c061fbfddd43dfe324486dc86cb92ee"><div class="ttname"><a href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a></div><div class="ttdeci">BasicValue</div><div class="ttdoc">Basic color values, with a few convenience values for extended colors. </div><div class="ttdef"><b>Definition:</b> colr.h:2456</div></div>
<div class="ttc" id="colr_8h_html_a89a5aa762bd5802872faf571aa32ea35"><div class="ttname"><a href="colr_8h.html#a89a5aa762bd5802872faf571aa32ea35">ColorArg_from_value</a></div><div class="ttdeci">ColorArg ColorArg_from_value(ArgType type, ColorType colrtype, void *p)</div><div class="ttdoc">Used with the color_arg macro to dynamically create a ColorArg based on it&amp;#39;s argument type...</div><div class="ttdef"><b>Definition:</b> colr.c:5262</div></div>
<div class="ttc" id="colr_8h_html_structRGB"><div class="ttname"><a href="colr_8h.html#structRGB">RGB</a></div><div class="ttdoc">Container for RGB values. </div><div class="ttdef"><b>Definition:</b> colr.h:2535</div></div>
<div class="ttc" id="colr_8h_html_a6dda29f582a062546ef8733d8b7d8a94"><div class="ttname"><a href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a></div><div class="ttdeci">unsigned char ExtendedValue</div><div class="ttdoc">Convenience typedef for clarity when dealing with extended (256) colors. </div><div class="ttdef"><b>Definition:</b> colr.h:2532</div></div>
<div class="ttc" id="colr_8h_html_a85224ec2507f33b1985f4cdd0adfe0e6"><div class="ttname"><a href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a></div><div class="ttdeci">StyleValue</div><div class="ttdoc">Style values. </div><div class="ttdef"><b>Definition:</b> colr.h:2549</div></div>
</div><!-- fragment -->
<p>Builds a correct <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct according to the type of it's second argument. </p>
<p>Uses <code>_Generic</code> (C11 standard) to dynamically create a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td><code>ArgType</code> (<code>FORE</code>, <code>BACK</code>, <code>STYLE</code>) to build the <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td><code>BasicValue</code>, <code>Extended</code> (<code>unsigned char</code>). or <code><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a></code> value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ColorArg_from_value(type, [appropriate type], x) </dd></dl>

</div>
</div>
<a id="ab5557ed18d83facb69dd68b30629c37e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5557ed18d83facb69dd68b30629c37e">&#9670;&nbsp;</a></span>COLOR_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define COLOR_LEN&#160;&#160;&#160;30</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum length in chars for any combination of basic/extended escape codes for one complete style (one of each: fore, back, style). </p>
<p>Should be <code>(CODEX_LEN * 2) + STYLE_LEN</code>. Allocating for a string that will be colorized must account for this. </p>

</div>
</div>
<a id="a631e5b639fc75363670dbd912c42abb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a631e5b639fc75363670dbd912c42abb3">&#9670;&nbsp;</a></span>color_name_is_invalid</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define color_name_is_invalid</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#adc223f6fda6296396e9ecddcc68d4aec">ColorType_is_invalid</a>(<a class="el" href="colr_8h.html#afa75deef059c002134a88dbbdc18fd49">ColorType_from_str</a>(x))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro for checking if a color name is invalid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>string (<code>char*</code>) to check (a name, hex-string, rgb-string, or integer-string). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the name is an invalid color name, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#ad8da162275a03adc210cd90c0e2b923d" title="Convenience macro for checking if a color name is valid. ">color_name_is_valid</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#color_name_is_invalid-example" id="color_name_is_invalid-example" class="diamond-bullet">&#160;</a> color_name_is_invalid example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* names[] = {</div><div class="line">    <span class="comment">// Valid names:</span></div><div class="line">    <span class="stringliteral">&quot;red&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;lightblue&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;127&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;123,54,67&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;#ff0000&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;#fff&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;aliceblue&quot;</span>,</div><div class="line">    <span class="comment">// Invalid names:</span></div><div class="line">    <span class="stringliteral">&quot;NOTACOLOR&quot;</span>,</div><div class="line">    <span class="comment">// Invalid range (not 0-255):</span></div><div class="line">    <span class="stringliteral">&quot;345&quot;</span>,</div><div class="line">    <span class="comment">// Bad RGB strings:</span></div><div class="line">    <span class="stringliteral">&quot;1;&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;1;2;&quot;</span>,</div><div class="line">    <span class="comment">// Bad RGB ranges:</span></div><div class="line">    <span class="stringliteral">&quot;345;345;345&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;-1;0;0&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;0;0;256&quot;</span>,</div><div class="line">};</div><div class="line"><span class="keywordtype">size_t</span> names_len = <span class="keyword">sizeof</span>(names) / <span class="keyword">sizeof</span>(names[0]);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; names_len; i++) {</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="colr_8h.html#a631e5b639fc75363670dbd912c42abb3">color_name_is_invalid</a>(names[i])) {</div><div class="line">        printf(<span class="stringliteral">&quot;Invalid name: %s\n&quot;</span>, names[i]);</div><div class="line">    } <span class="keywordflow">else</span>  {</div><div class="line">        printf(<span class="stringliteral">&quot;  Valid name: %s\n&quot;</span>, names[i]);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> </div> 
</div>
</div>
<a id="ad8da162275a03adc210cd90c0e2b923d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8da162275a03adc210cd90c0e2b923d">&#9670;&nbsp;</a></span>color_name_is_valid</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define color_name_is_valid</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#a5a5883d43e3206584ad048908720afb2">ColorType_is_valid</a>(<a class="el" href="colr_8h.html#afa75deef059c002134a88dbbdc18fd49">ColorType_from_str</a>(x))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro for checking if a color name is valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>string (<code>char*</code>) to check (a name, hex-string, rgb-string, or integer-string). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the name is a valid color name, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a631e5b639fc75363670dbd912c42abb3" title="Convenience macro for checking if a color name is invalid. ">color_name_is_invalid</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#color_name_is_valid-example" id="color_name_is_valid-example" class="diamond-bullet">&#160;</a> color_name_is_valid example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* names[] = {</div><div class="line">    <span class="comment">// Valid names:</span></div><div class="line">    <span class="stringliteral">&quot;red&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;lightblue&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;127&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;123,54,67&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;#ff0000&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;#fff&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;aliceblue&quot;</span>,</div><div class="line">    <span class="comment">// Invalid names:</span></div><div class="line">    <span class="stringliteral">&quot;NOTACOLOR&quot;</span>,</div><div class="line">    <span class="comment">// Invalid range (not 0-255):</span></div><div class="line">    <span class="stringliteral">&quot;345&quot;</span>,</div><div class="line">    <span class="comment">// Bad RGB strings:</span></div><div class="line">    <span class="stringliteral">&quot;1;&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;1;2;&quot;</span>,</div><div class="line">    <span class="comment">// Bad RGB ranges:</span></div><div class="line">    <span class="stringliteral">&quot;345;345;345&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;-1;0;0&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;0;0;256&quot;</span>,</div><div class="line">};</div><div class="line"><span class="keywordtype">size_t</span> names_len = <span class="keyword">sizeof</span>(names) / <span class="keyword">sizeof</span>(names[0]);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; names_len; i++) {</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="colr_8h.html#ad8da162275a03adc210cd90c0e2b923d">color_name_is_valid</a>(names[i])) {</div><div class="line">        printf(<span class="stringliteral">&quot;  Valid name: %s\n&quot;</span>, names[i]);</div><div class="line">    } <span class="keywordflow">else</span>  {</div><div class="line">        printf(<span class="stringliteral">&quot;Invalid name: %s\n&quot;</span>, names[i]);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> </div> 
</div>
</div>
<a id="a9dbb9166f2a4d79e48dd5b11c3eb258b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dbb9166f2a4d79e48dd5b11c3eb258b">&#9670;&nbsp;</a></span>COLOR_RGB_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define COLOR_RGB_LEN&#160;&#160;&#160;26</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum length in chars added to a rgb colorized string. </p>
<p>Should be <code>CODE_RGB_LEN + STYLE_LEN</code> Allocating for a string that will be colorized with rgb values must account for this. </p>

</div>
</div>
<a id="a4eb7445c534661e32283d2119beb45d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eb7445c534661e32283d2119beb45d6">&#9670;&nbsp;</a></span>color_val</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define color_val</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_Generic( \</div><div class="line">        (x), \</div><div class="line">        <a class="code" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>: <a class="code" href="colr_8h.html#aca7fedbceb4f751d0d30034c0ef1dca8">ColorValue_from_value</a>(TYPE_BASIC, &amp;x), \</div><div class="line">        <a class="code" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>: <a class="code" href="colr_8h.html#aca7fedbceb4f751d0d30034c0ef1dca8">ColorValue_from_value</a>(TYPE_EXTENDED, &amp;x), \</div><div class="line">        <a class="code" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>: <a class="code" href="colr_8h.html#aca7fedbceb4f751d0d30034c0ef1dca8">ColorValue_from_value</a>(TYPE_STYLE, &amp;x), \</div><div class="line">        <a class="code" href="colr_8h.html#structRGB">RGB</a>: <a class="code" href="colr_8h.html#aca7fedbceb4f751d0d30034c0ef1dca8">ColorValue_from_value</a>(TYPE_RGB, &amp;x) \</div><div class="line">    )</div><div class="ttc" id="colr_8h_html_a0c061fbfddd43dfe324486dc86cb92ee"><div class="ttname"><a href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a></div><div class="ttdeci">BasicValue</div><div class="ttdoc">Basic color values, with a few convenience values for extended colors. </div><div class="ttdef"><b>Definition:</b> colr.h:2456</div></div>
<div class="ttc" id="colr_8h_html_structRGB"><div class="ttname"><a href="colr_8h.html#structRGB">RGB</a></div><div class="ttdoc">Container for RGB values. </div><div class="ttdef"><b>Definition:</b> colr.h:2535</div></div>
<div class="ttc" id="colr_8h_html_a6dda29f582a062546ef8733d8b7d8a94"><div class="ttname"><a href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a></div><div class="ttdeci">unsigned char ExtendedValue</div><div class="ttdoc">Convenience typedef for clarity when dealing with extended (256) colors. </div><div class="ttdef"><b>Definition:</b> colr.h:2532</div></div>
<div class="ttc" id="colr_8h_html_a85224ec2507f33b1985f4cdd0adfe0e6"><div class="ttname"><a href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a></div><div class="ttdeci">StyleValue</div><div class="ttdoc">Style values. </div><div class="ttdef"><b>Definition:</b> colr.h:2549</div></div>
<div class="ttc" id="colr_8h_html_aca7fedbceb4f751d0d30034c0ef1dca8"><div class="ttname"><a href="colr_8h.html#aca7fedbceb4f751d0d30034c0ef1dca8">ColorValue_from_value</a></div><div class="ttdeci">ColorValue ColorValue_from_value(ColorType type, void *p)</div><div class="ttdoc">Used with the color_val macro to dynamically create a ColorValue based on it&amp;#39;s argument type...</div><div class="ttdef"><b>Definition:</b> colr.c:6736</div></div>
</div><!-- fragment -->
<p>Builds a correct <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> struct according to the type of it's first argument. </p>
<p>Uses <code>_Generic</code> (C11 standard) to dynamically create a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td><code>BasicValue</code>, <code>Extended</code> (<code>unsigned char</code>). or <code><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a></code> value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ColorValue_from_value([appropriate type], x) </dd></dl>

</div>
</div>
<a id="a22fa09afcaf087080075551d293a72fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22fa09afcaf087080075551d293a72fd">&#9670;&nbsp;</a></span>COLORARG_MARKER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define COLORARG_MARKER&#160;&#160;&#160;UINT32_MAX</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marker for the <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct, for identifying a void pointer as a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>. </p>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#af838f8479681d809beb868b2e1b547e7">ColorArg_empty()</a>, <a class="el" href="colr_8h.html#aad49f4597388e6bdb896ff28334cd5e6">ColorArg_from_BasicValue()</a>, <a class="el" href="colr_8h.html#a70e9640f37dd85cde0b6f25c0b705912">ColorArg_from_esc()</a>, <a class="el" href="colr_8h.html#aed30e2a4b30ab5e3cf49608a3c410cc5">ColorArg_from_ExtendedValue()</a>, <a class="el" href="colr_8h.html#aaa24bba74e99aa66ed41839576e57856">ColorArg_from_RGB()</a>, <a class="el" href="colr_8h.html#acf63bcee395dca3ca29dc324e3d7c8f2">ColorArg_from_StyleValue()</a>, <a class="el" href="colr_8h.html#a89a5aa762bd5802872faf571aa32ea35">ColorArg_from_value()</a>, <a class="el" href="colr_8h.html#ad15f3a714a6383123d3fb24ade173e29">ColorArg_is_ptr()</a>, and <a class="el" href="colr_8h.html#afb5ac0bd012b8162cea125ad0d9e8bf0">ColorArg_to_ptr()</a>.</p>

</div>
</div>
<a id="a7678f7f1092db91a932c03c231310ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7678f7f1092db91a932c03c231310ed3">&#9670;&nbsp;</a></span>ColorValue_has</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ColorValue_has</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cval, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">val&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_Generic( \</div><div class="line">        (val), \</div><div class="line">        <a class="code" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>: <a class="code" href="colr_8h.html#a711a955406cde9716797bf61ab43a7a7">ColorValue_has_BasicValue</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>: <a class="code" href="colr_8h.html#a11dc047d1defc4de2239a45667b45f85">ColorValue_has_ExtendedValue</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>: <a class="code" href="colr_8h.html#a3fbfa502deb1f2bb920b74b9f4867fcf">ColorValue_has_StyleValue</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structRGB">RGB</a>: <a class="code" href="colr_8h.html#ab6908a961d4165a458be1aa64f082a45">ColorValue_has_RGB</a> \</div><div class="line">    )(cval, val)</div><div class="ttc" id="colr_8h_html_a0c061fbfddd43dfe324486dc86cb92ee"><div class="ttname"><a href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a></div><div class="ttdeci">BasicValue</div><div class="ttdoc">Basic color values, with a few convenience values for extended colors. </div><div class="ttdef"><b>Definition:</b> colr.h:2456</div></div>
<div class="ttc" id="colr_8h_html_a11dc047d1defc4de2239a45667b45f85"><div class="ttname"><a href="colr_8h.html#a11dc047d1defc4de2239a45667b45f85">ColorValue_has_ExtendedValue</a></div><div class="ttdeci">bool ColorValue_has_ExtendedValue(ColorValue cval, ExtendedValue eval)</div><div class="ttdoc">Checks to see if a ColorValue has a ExtendedValue set. </div><div class="ttdef"><b>Definition:</b> colr.c:6795</div></div>
<div class="ttc" id="colr_8h_html_structRGB"><div class="ttname"><a href="colr_8h.html#structRGB">RGB</a></div><div class="ttdoc">Container for RGB values. </div><div class="ttdef"><b>Definition:</b> colr.h:2535</div></div>
<div class="ttc" id="colr_8h_html_a6dda29f582a062546ef8733d8b7d8a94"><div class="ttname"><a href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a></div><div class="ttdeci">unsigned char ExtendedValue</div><div class="ttdoc">Convenience typedef for clarity when dealing with extended (256) colors. </div><div class="ttdef"><b>Definition:</b> colr.h:2532</div></div>
<div class="ttc" id="colr_8h_html_a3fbfa502deb1f2bb920b74b9f4867fcf"><div class="ttname"><a href="colr_8h.html#a3fbfa502deb1f2bb920b74b9f4867fcf">ColorValue_has_StyleValue</a></div><div class="ttdeci">bool ColorValue_has_StyleValue(ColorValue cval, StyleValue sval)</div><div class="ttdoc">Checks to see if a ColorValue has a StyleValue set. </div><div class="ttdef"><b>Definition:</b> colr.c:6808</div></div>
<div class="ttc" id="colr_8h_html_a711a955406cde9716797bf61ab43a7a7"><div class="ttname"><a href="colr_8h.html#a711a955406cde9716797bf61ab43a7a7">ColorValue_has_BasicValue</a></div><div class="ttdeci">bool ColorValue_has_BasicValue(ColorValue cval, BasicValue bval)</div><div class="ttdoc">Checks to see if a ColorValue has a BasicValue set. </div><div class="ttdef"><b>Definition:</b> colr.c:6782</div></div>
<div class="ttc" id="colr_8h_html_ab6908a961d4165a458be1aa64f082a45"><div class="ttname"><a href="colr_8h.html#ab6908a961d4165a458be1aa64f082a45">ColorValue_has_RGB</a></div><div class="ttdeci">bool ColorValue_has_RGB(ColorValue cval, RGB rgb)</div><div class="ttdoc">Checks to see if a ColorValue has a RGB value set. </div><div class="ttdef"><b>Definition:</b> colr.c:6821</div></div>
<div class="ttc" id="colr_8h_html_a85224ec2507f33b1985f4cdd0adfe0e6"><div class="ttname"><a href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a></div><div class="ttdeci">StyleValue</div><div class="ttdoc">Style values. </div><div class="ttdef"><b>Definition:</b> colr.h:2549</div></div>
</div><!-- fragment -->
<p>Call the current ColorValue_has_&lt;type&gt; function for the given value. </p>
<p>Given the correct type of value, this will check to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has the correct <code>.type</code> set for the value, and the values match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td>The <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>A BasicValue, ExtendedValue, StyleValue, or <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has the correct <code>.type</code> and it's value matches <code>val</code>, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a711a955406cde9716797bf61ab43a7a7" title="Checks to see if a ColorValue has a BasicValue set. ">ColorValue_has_BasicValue</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a11dc047d1defc4de2239a45667b45f85" title="Checks to see if a ColorValue has a ExtendedValue set. ">ColorValue_has_ExtendedValue</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a3fbfa502deb1f2bb920b74b9f4867fcf" title="Checks to see if a ColorValue has a StyleValue set. ">ColorValue_has_StyleValue</a> </dd>
<dd>
<a class="el" href="colr_8h.html#ab6908a961d4165a458be1aa64f082a45" title="Checks to see if a ColorValue has a RGB value set. ">ColorValue_has_RGB</a> </dd></dl>

</div>
</div>
<a id="ade1c77f81a0fd49f7895598cbd9ac76c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade1c77f81a0fd49f7895598cbd9ac76c">&#9670;&nbsp;</a></span>Colr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Colr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">text, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#a8e04de932a4cf712ac91e794bdc3f8db">ColorText_to_ptr</a>(<a class="el" href="colr_8h.html#ad4702d6ddc409a93a0b42c8f6141d2f2">ColorText_from_values</a>(text, __VA_ARGS__, _ColrLastArg))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a heap-allocated <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> struct that can be used by itself, or with the <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, <a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465" title="Like colr_cat(), but returns an allocated ColorResult that the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros will automatically free(). ">Colr_cat()</a>, and <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> macros. </p>
<p>You must <code>free()</code> the resulting <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> struct using <a class="el" href="colr_8h.html#a901e5738358a739629cc3aaccab3e73f" title="Frees a ColorText and it&#39;s ColorArgs. ">ColorText_free()</a>, unless you pass it to <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, which will <code>free()</code> it for you.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>String to colorize/style. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>No more than 3 <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointers for fore, back, and style in any order.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.</p>
<p class="enddd">If used inside of the <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a>, <a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465" title="Like colr_cat(), but returns an allocated ColorResult that the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros will automatically free(). ">Colr_cat()</a>, and <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> macros, <em>they will <code>free()</code> the result</em>. Otherwise, <em>you are responsible for calling <code>free()</code></em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a1dc8cf2eac15c7c27983616d23b10ed6" title="Returns an initialized stack-allocated ColorText. ">Colra</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="back_example_8c-example.html#a9">back_example.c</a>, <a class="el" href="ColorResult_example_8c-example.html#a3">ColorResult_example.c</a>, <a class="el" href="colr_cat_example_8c-example.html#a1">colr_cat_example.c</a>, <a class="el" href="Colr_example_8c-example.html#a1">Colr_example.c</a>, <a class="el" href="colr_join_example_8c-example.html#a1">colr_join_example.c</a>, <a class="el" href="colr_printf_example_8c-example.html#a1">colr_printf_example.c</a>, <a class="el" href="colr_replace_all_example_8c-example.html#a1">colr_replace_all_example.c</a>, <a class="el" href="colr_replace_example_8c-example.html#a1">colr_replace_example.c</a>, <a class="el" href="colr_replace_re_all_example_8c-example.html#a1">colr_replace_re_all_example.c</a>, <a class="el" href="colr_replace_re_example_8c-example.html#a1">colr_replace_re_example.c</a>, <a class="el" href="fore_example_8c-example.html#a4">fore_example.c</a>, <a class="el" href="simple_example_8c-example.html#a2">simple_example.c</a>, and <a class="el" href="style_example_8c-example.html#a2">style_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="a753093cd4c872eed4b77feaa7816212b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a753093cd4c872eed4b77feaa7816212b">&#9670;&nbsp;</a></span>colr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">text, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa">colr_cat</a>(<a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(text, __VA_ARGS__))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an allocated string directly from <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a> arguments. </p>
<p>This is a wrapper around <code>colr_cat(Colr(text, ...))</code>, which will automatically <code>free()</code> the <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, and return a string that you are responsible for.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>String to colorize/style. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td><p class="starttd">No more than 3 <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointers for fore, back, and style in any order.</p>
<p class="endtd"><em><a class="el" href="colr_8h.html#a76eae619668e01987653932a7492fd94" title="Calls the &lt;type&gt;_free functions for the supported types. ">colr_free()</a> will be called on any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointer passed to this function</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ColorResult_example_8c-example.html#a5">ColorResult_example.c</a>, <a class="el" href="Colr_example_8c-example.html#a8">Colr_example.c</a>, and <a class="el" href="simple_example_8c-example.html#a10">simple_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="a8a7703119ac7aeb47276700319e4b97a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a7703119ac7aeb47276700319e4b97a">&#9670;&nbsp;</a></span>colr_alloc_len</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_alloc_len</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_Generic( \</div><div class="line">        (x), \</div><div class="line">        <a class="code" href="colr_8h.html#structRGB">RGB</a>: <a class="code" href="colr_8h.html#ad50e6b68284102d5270834e02652af37">CODE_RGB_LEN</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>: <a class="code" href="colr_8h.html#a4ef6ad74c493fe40e199341072fabefe">CODE_LEN</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>: <a class="code" href="colr_8h.html#af77ec93393736fa98be724385d61614d">CODEX_LEN</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>: <a class="code" href="colr_8h.html#ac83d14a355d35b7af90deb99ad3b7601">STYLE_LEN</a> \</div><div class="line">    )</div><div class="ttc" id="colr_8h_html_a0c061fbfddd43dfe324486dc86cb92ee"><div class="ttname"><a href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a></div><div class="ttdeci">BasicValue</div><div class="ttdoc">Basic color values, with a few convenience values for extended colors. </div><div class="ttdef"><b>Definition:</b> colr.h:2456</div></div>
<div class="ttc" id="colr_8h_html_ad50e6b68284102d5270834e02652af37"><div class="ttname"><a href="colr_8h.html#ad50e6b68284102d5270834e02652af37">CODE_RGB_LEN</a></div><div class="ttdeci">#define CODE_RGB_LEN</div><div class="ttdoc">Maximum length in chars for an RGB fore/back escape code, including `&amp;#39;\0&amp;#39;`. </div><div class="ttdef"><b>Definition:</b> colr.h:233</div></div>
<div class="ttc" id="colr_8h_html_a4ef6ad74c493fe40e199341072fabefe"><div class="ttname"><a href="colr_8h.html#a4ef6ad74c493fe40e199341072fabefe">CODE_LEN</a></div><div class="ttdeci">#define CODE_LEN</div><div class="ttdoc">Maximum length for a basic fore/back escape code, including `&amp;#39;\0&amp;#39;`. </div><div class="ttdef"><b>Definition:</b> colr.h:202</div></div>
<div class="ttc" id="colr_8h_html_ac83d14a355d35b7af90deb99ad3b7601"><div class="ttname"><a href="colr_8h.html#ac83d14a355d35b7af90deb99ad3b7601">STYLE_LEN</a></div><div class="ttdeci">#define STYLE_LEN</div><div class="ttdoc">Maximum length for a style escape code, including `&amp;#39;\0&amp;#39;`. </div><div class="ttdef"><b>Definition:</b> colr.h:218</div></div>
<div class="ttc" id="colr_8h_html_structRGB"><div class="ttname"><a href="colr_8h.html#structRGB">RGB</a></div><div class="ttdoc">Container for RGB values. </div><div class="ttdef"><b>Definition:</b> colr.h:2535</div></div>
<div class="ttc" id="colr_8h_html_a6dda29f582a062546ef8733d8b7d8a94"><div class="ttname"><a href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a></div><div class="ttdeci">unsigned char ExtendedValue</div><div class="ttdoc">Convenience typedef for clarity when dealing with extended (256) colors. </div><div class="ttdef"><b>Definition:</b> colr.h:2532</div></div>
<div class="ttc" id="colr_8h_html_af77ec93393736fa98be724385d61614d"><div class="ttname"><a href="colr_8h.html#af77ec93393736fa98be724385d61614d">CODEX_LEN</a></div><div class="ttdeci">#define CODEX_LEN</div><div class="ttdoc">Maximum length for an extended fore/back escape code, including `&amp;#39;\0&amp;#39;`. </div><div class="ttdef"><b>Definition:</b> colr.h:210</div></div>
<div class="ttc" id="colr_8h_html_a85224ec2507f33b1985f4cdd0adfe0e6"><div class="ttname"><a href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a></div><div class="ttdeci">StyleValue</div><div class="ttdoc">Style values. </div><div class="ttdef"><b>Definition:</b> colr.h:2549</div></div>
</div><!-- fragment -->
<p>Return the number of bytes needed to allocate an escape code string based on the color type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A BasicValue, ExtendedValue, <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value, or StyleValue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes needed to allocate a string using the color value. </dd></dl>

</div>
</div>
<a id="af297a2286435a423e01edae98c561c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af297a2286435a423e01edae98c561c7b">&#9670;&nbsp;</a></span>colr_asprintf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_asprintf</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#a04ebe7aa43eab3e7e0bd9d769d2074ac">colr_printf_macro</a>(asprintf, __VA_ARGS__)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure <a class="el" href="colr_8h.html#aaaf134ca9a2188d83171fe91948354d9" title="Registers COLR_FMT_CHAR to handle Colr objects in the printf-family functions. ">colr_printf_register()</a> has been called, and then call <code>asprintf</code>. </p>
<p>Will call <code>free()</code> on any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointer, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> pointer, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointer, or the strings created by them.</p>
<dl class="section attention"><dt>Attention</dt><dd>This feature uses a GNU extension, and is only available when COLR_GNU is defined. See the documentation for COLR_GNU.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td><p class="starttd">Arguments for `asprintf</p>
<p class="endtd"><em><a class="el" href="colr_8h.html#a76eae619668e01987653932a7492fd94" title="Calls the &lt;type&gt;_free functions for the supported types. ">colr_free()</a> will be called on any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointer passed to this function</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Same as <code>asprintf</code>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="colr_printf_example_8c-example.html#a7">colr_printf_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="a9c6a8a9f484ac09c39e5f76bba61f465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c6a8a9f484ac09c39e5f76bba61f465">&#9670;&nbsp;</a></span>Colr_cat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Colr_cat</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#a5f5304067f9d673ce5b86ddba2a8807b">ColorResult_to_ptr</a>(<a class="el" href="colr_8h.html#af752035c362c7c9ddb2e7f2f2305d509">ColorResult_new</a>(<a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa">colr_cat</a>(__VA_ARGS__)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, but returns an allocated <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> that the <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a>, <a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465" title="Like colr_cat(), but returns an allocated ColorResult that the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros will automatically free(). ">Colr_cat()</a>, and <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> macros will automatically <code>free()</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td><p class="starttd">Arguments for <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, to concatenate.</p>
<p class="endtd"><em><a class="el" href="colr_8h.html#a76eae619668e01987653932a7492fd94" title="Calls the &lt;type&gt;_free functions for the supported types. ">colr_free()</a> will be called on any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointer passed to this function</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> with all arguments joined together.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p><em>If allocation fails, <code>NULL</code> is returned</em>.</p>
<p class="enddd">If used inside of the <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a>, <a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465" title="Like colr_cat(), but returns an allocated ColorResult that the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros will automatically free(). ">Colr_cat()</a>, and <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> macros, <em>they will <code>free()</code> the result</em>. Otherwise, <em>you are responsible for calling <code>free()</code></em>. </p>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="colr_cat_example_8c-example.html#a9">colr_cat_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="a8e2c8bf2819cb36b1a34396a65b51faa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e2c8bf2819cb36b1a34396a65b51faa">&#9670;&nbsp;</a></span>colr_cat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_cat</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join</a>(&quot;&quot;, __VA_ARGS__, _ColrLastArg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointers, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> pointers, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointers, and strings into one long string. </p>
<p>To build the <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointers, it is better to use the <a class="el" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f" title="Create a fore color suitable for use with the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros. ">fore()</a>, <a class="el" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8" title="Create a back color suitable for use with the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros. ">back()</a>, and <a class="el" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662" title="Create a style suitable for use with the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros. ">style()</a> macros. The ColorArgs are heap allocated, but <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a> will free() them for you.</p>
<p>To build the <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointers, it is better to use the <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a> macro, along with the <a class="el" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f" title="Create a fore color suitable for use with the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros. ">fore()</a>, <a class="el" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8" title="Create a back color suitable for use with the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros. ">back()</a>, and <a class="el" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662" title="Create a style suitable for use with the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros. ">style()</a> macros. The ColorTexts are heap allocated, but <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a> will free() them for you.</p>
<p>You can use <a class="el" href="colr_8h.html#aebecaca8dfed9f43418cb2c6b214eef3" title="Wraps an allocated string in a ColorResult, which marks it as &quot;freeable&quot; in the colr macros...">ColrResult()</a> to wrap any <em>allocated</em> string and <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a> will free it for you. Do not wrap static/stack-allocated strings. It will result in an "invalid free". The result of <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> is an allocated <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, like <a class="el" href="colr_8h.html#aebecaca8dfed9f43418cb2c6b214eef3" title="Wraps an allocated string in a ColorResult, which marks it as &quot;freeable&quot; in the colr macros...">ColrResult()</a> returns.</p>
<p>If you do not want the colr macros to free your Colr-based structs/strings for you, then you will have to call <a class="el" href="colr_8h.html#a790e5a9bd0b3ca7cd7d428007f6a21b9" title="Calls the &lt;type&gt;_to_str functions for the supported types. ">colr_to_str()</a> on the structs and build or join the resulting strings yourself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td><p class="starttd">One or more <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointers, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> pointers, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointers, or strings to join.</p>
<p class="endtd"><em><a class="el" href="colr_8h.html#a76eae619668e01987653932a7492fd94" title="Calls the &lt;type&gt;_free functions for the supported types. ">colr_free()</a> will be called on any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointer passed to this function</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string result.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="back_example_8c-example.html#a0">back_example.c</a>, <a class="el" href="ColorResult_example_8c-example.html#a0">ColorResult_example.c</a>, <a class="el" href="colr_cat_example_8c-example.html#a0">colr_cat_example.c</a>, <a class="el" href="Colr_example_8c-example.html#a0">Colr_example.c</a>, <a class="el" href="fore_example_8c-example.html#a0">fore_example.c</a>, <a class="el" href="simple_example_8c-example.html#a11">simple_example.c</a>, and <a class="el" href="style_example_8c-example.html#a0">style_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="aac52a4a5dbfd4f87ffd84e538eab9c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac52a4a5dbfd4f87ffd84e538eab9c29">&#9670;&nbsp;</a></span>Colr_center</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Colr_center</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">text, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">justwidth, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="colr_8h.html#ab408d87cce896acccb75357acca8ade4">ColorText_set_just</a>( \</div><div class="line">        <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(text, __VA_ARGS__), \</div><div class="line">        (<a class="code" href="colr_8h.html#structColorJustify">ColorJustify</a>){.method=JUST_CENTER, .width=justwidth, .padchar=<span class="charliteral">&#39; &#39;</span>} \</div><div class="line">    )</div><div class="ttc" id="colr_8h_html_ab408d87cce896acccb75357acca8ade4"><div class="ttname"><a href="colr_8h.html#ab408d87cce896acccb75357acca8ade4">ColorText_set_just</a></div><div class="ttdeci">ColorText * ColorText_set_just(ColorText *ctext, ColorJustify cjust)</div><div class="ttdoc">Set the ColorJustify method for a ColorText, and return the ColorText. </div><div class="ttdef"><b>Definition:</b> colr.c:6189</div></div>
<div class="ttc" id="colr_8h_html_structColorJustify"><div class="ttname"><a href="colr_8h.html#structColorJustify">ColorJustify</a></div><div class="ttdoc">Holds a string justification method, width, and padding character for ColorTexts. ...</div><div class="ttdef"><b>Definition:</b> colr.h:2680</div></div>
<div class="ttc" id="colr_8h_html_ade1c77f81a0fd49f7895598cbd9ac76c"><div class="ttname"><a href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a></div><div class="ttdeci">#define Colr(text,...)</div><div class="ttdoc">Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...</div><div class="ttdef"><b>Definition:</b> colr.h:751</div></div>
</div><!-- fragment -->
<p>Sets the JustifyMethod for a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> while allocating it. </p>
<p>This is like <a class="el" href="colr_8h.html#a12a7201e4a897fbc28286fbefbd1eea6" title="Sets the JustifyMethod for a ColorText while allocating it. ">Colr_center_char()</a>, except is uses space as the default character.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>Text to colorize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">justwidth</td><td>Width for justification. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Fore, back, or style ColorArgs for <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.</p>
<p class="enddd">If used inside of the <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a>, <a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465" title="Like colr_cat(), but returns an allocated ColorResult that the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros will automatically free(). ">Colr_cat()</a>, and <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> macros, <em>they will <code>free()</code> the result</em>. Otherwise, <em>you are responsible for calling <code>free()</code></em>. </p>
</dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#Colr_center-example" id="Colr_center-example" class="diamond-bullet">&#160;</a> Colr_center example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* justified = <a class="code" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa">colr_cat</a>(<a class="code" href="colr_8h.html#aac52a4a5dbfd4f87ffd84e538eab9c29">Colr_center</a>(<span class="stringliteral">&quot;This.&quot;</span>, 9, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED), <a class="code" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8">back</a>(WHITE)));</div><div class="line">assert(justified);</div><div class="line"><span class="comment">// The string still has codes, but only 4 spaces were added.</span></div><div class="line">assert(<a class="code" href="colr_8c.html#ac23328cead6a65d7b3ef2c2ca48d11ce">colr_str_starts_with</a>(justified, <span class="stringliteral">&quot;  &quot;</span>));</div><div class="line">assert(<a class="code" href="colr_8c.html#a7dd712bd8253271f0c88158db791c8bf">colr_str_ends_with</a>(justified, <span class="stringliteral">&quot;  &quot;</span>));</div><div class="line"><span class="comment">// It was &quot;justified&quot; to 9 characters long, but it is well over that.</span></div><div class="line">assert(strlen(justified) &gt; 9);</div><div class="line">printf(<span class="stringliteral">&quot;&#39;%s&#39;\n&quot;</span>, justified);</div><div class="line">free(justified);</div></div><!-- fragment --> </div> <dl><dt><b>Examples: </b></dt><dd><a class="el" href="Colr_example_8c-example.html#a3">Colr_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="a12a7201e4a897fbc28286fbefbd1eea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12a7201e4a897fbc28286fbefbd1eea6">&#9670;&nbsp;</a></span>Colr_center_char</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Colr_center_char</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">text, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">justwidth, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="colr_8h.html#ab408d87cce896acccb75357acca8ade4">ColorText_set_just</a>( \</div><div class="line">        <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(text, __VA_ARGS__), \</div><div class="line">        (<a class="code" href="colr_8h.html#structColorJustify">ColorJustify</a>){.method=JUST_CENTER, .width=justwidth, .padchar=c} \</div><div class="line">    )</div><div class="ttc" id="colr_8h_html_ab408d87cce896acccb75357acca8ade4"><div class="ttname"><a href="colr_8h.html#ab408d87cce896acccb75357acca8ade4">ColorText_set_just</a></div><div class="ttdeci">ColorText * ColorText_set_just(ColorText *ctext, ColorJustify cjust)</div><div class="ttdoc">Set the ColorJustify method for a ColorText, and return the ColorText. </div><div class="ttdef"><b>Definition:</b> colr.c:6189</div></div>
<div class="ttc" id="colr_8h_html_structColorJustify"><div class="ttname"><a href="colr_8h.html#structColorJustify">ColorJustify</a></div><div class="ttdoc">Holds a string justification method, width, and padding character for ColorTexts. ...</div><div class="ttdef"><b>Definition:</b> colr.h:2680</div></div>
<div class="ttc" id="colr_8h_html_ade1c77f81a0fd49f7895598cbd9ac76c"><div class="ttname"><a href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a></div><div class="ttdeci">#define Colr(text,...)</div><div class="ttdoc">Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...</div><div class="ttdef"><b>Definition:</b> colr.h:751</div></div>
</div><!-- fragment -->
<p>Sets the JustifyMethod for a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> while allocating it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>Text to colorize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">justwidth</td><td>Width for justification. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The character to pad with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Fore, back, or style ColorArgs for <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.</p>
<p class="enddd">If used inside of the <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a>, <a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465" title="Like colr_cat(), but returns an allocated ColorResult that the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros will automatically free(). ">Colr_cat()</a>, and <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> macros, <em>they will <code>free()</code> the result</em>. Otherwise, <em>you are responsible for calling <code>free()</code></em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#aac52a4a5dbfd4f87ffd84e538eab9c29" title="Sets the JustifyMethod for a ColorText while allocating it. ">Colr_center</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#Colr_center_char-example" id="Colr_center_char-example" class="diamond-bullet">&#160;</a> Colr_center_char example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* justified = <a class="code" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa">colr_cat</a>(<a class="code" href="colr_8h.html#a12a7201e4a897fbc28286fbefbd1eea6">Colr_center_char</a>(<span class="stringliteral">&quot;This.&quot;</span>, 8, <span class="charliteral">&#39; &#39;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED), <a class="code" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8">back</a>(WHITE)));</div><div class="line">assert(justified);</div><div class="line"><span class="comment">// The string still has codes, but only 2 spaces were prepended, and 1 appended.</span></div><div class="line">assert(<a class="code" href="colr_8c.html#ac23328cead6a65d7b3ef2c2ca48d11ce">colr_str_starts_with</a>(justified, <span class="stringliteral">&quot;  &quot;</span>));</div><div class="line">assert(<a class="code" href="colr_8c.html#a7dd712bd8253271f0c88158db791c8bf">colr_str_ends_with</a>(justified, <span class="stringliteral">&quot; &quot;</span>));</div><div class="line"><span class="comment">// It was &quot;justified&quot; to 8 characters long, but it is well over that.</span></div><div class="line">assert(strlen(justified) &gt; 8);</div><div class="line">printf(<span class="stringliteral">&quot;&#39;%s&#39;\n&quot;</span>, justified);</div><div class="line">free(justified);</div></div><!-- fragment --> </div> 
</div>
</div>
<a id="a36af8aa0f01eaa780da182e856923faa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36af8aa0f01eaa780da182e856923faa">&#9670;&nbsp;</a></span>colr_eq</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_eq</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_Generic( \</div><div class="line">        (a), \</div><div class="line">        <a class="code" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>: <a class="code" href="colr_8h.html#a69d1fc130eeaf6ed62066e25478cb433">ArgType_eq</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>: <a class="code" href="colr_8h.html#a17bf46ac385e41b729d07a65dd506cba">BasicValue_eq</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorArg">ColorArg</a>: <a class="code" href="colr_8h.html#acb62efc0182d6f6107055eeda961a628">ColorArg_eq</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorJustify">ColorJustify</a>: <a class="code" href="colr_8h.html#ab71656e616aef4bbb3c278d43c4a326e">ColorJustify_eq</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>: <a class="code" href="colr_8h.html#a29e3483ae4add048424177fdc2b97b71">ColorType_eq</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorValue">ColorValue</a>: <a class="code" href="colr_8h.html#adf57e195301864cec80739e7e0f3000c">ColorValue_eq</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>: <a class="code" href="colr_8h.html#ac847d91a396ae6babc0bd46e6386a701">ExtendedValue_eq</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structRGB">RGB</a>: <a class="code" href="colr_8h.html#ad4b5f73b8aa9d72216d7386221418ae1">RGB_eq</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>: <a class="code" href="colr_8h.html#a32bf31475b0f6264b45438bd5c09ee7d">StyleValue_eq</a> \</div><div class="line">    )(a, b)</div><div class="ttc" id="colr_8h_html_acb62efc0182d6f6107055eeda961a628"><div class="ttname"><a href="colr_8h.html#acb62efc0182d6f6107055eeda961a628">ColorArg_eq</a></div><div class="ttdeci">bool ColorArg_eq(ColorArg a, ColorArg b)</div><div class="ttdoc">Compares two ColorArg structs. </div><div class="ttdef"><b>Definition:</b> colr.c:4944</div></div>
<div class="ttc" id="colr_8h_html_structColorValue"><div class="ttname"><a href="colr_8h.html#structColorValue">ColorValue</a></div><div class="ttdoc">Holds a color type and it&amp;#39;s value. </div><div class="ttdef"><b>Definition:</b> colr.h:2712</div></div>
<div class="ttc" id="colr_8h_html_a69d1fc130eeaf6ed62066e25478cb433"><div class="ttname"><a href="colr_8h.html#a69d1fc130eeaf6ed62066e25478cb433">ArgType_eq</a></div><div class="ttdeci">bool ArgType_eq(ArgType a, ArgType b)</div><div class="ttdoc">Compares two ArgTypes. </div><div class="ttdef"><b>Definition:</b> colr.c:4851</div></div>
<div class="ttc" id="colr_8h_html_structColorJustify"><div class="ttname"><a href="colr_8h.html#structColorJustify">ColorJustify</a></div><div class="ttdoc">Holds a string justification method, width, and padding character for ColorTexts. ...</div><div class="ttdef"><b>Definition:</b> colr.h:2680</div></div>
<div class="ttc" id="colr_8h_html_a0c061fbfddd43dfe324486dc86cb92ee"><div class="ttname"><a href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a></div><div class="ttdeci">BasicValue</div><div class="ttdoc">Basic color values, with a few convenience values for extended colors. </div><div class="ttdef"><b>Definition:</b> colr.h:2456</div></div>
<div class="ttc" id="colr_8h_html_a58d8da4a4f5529031f00c7a6b9eeb5e1"><div class="ttname"><a href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a></div><div class="ttdeci">ArgType</div><div class="ttdoc">Argument types (fore, back, style). </div><div class="ttdef"><b>Definition:</b> colr.h:2593</div></div>
<div class="ttc" id="colr_8h_html_a29e3483ae4add048424177fdc2b97b71"><div class="ttname"><a href="colr_8h.html#a29e3483ae4add048424177fdc2b97b71">ColorType_eq</a></div><div class="ttdeci">bool ColorType_eq(ColorType a, ColorType b)</div><div class="ttdoc">Compares two ColorTypes. </div><div class="ttdef"><b>Definition:</b> colr.c:6332</div></div>
<div class="ttc" id="colr_8h_html_ab71656e616aef4bbb3c278d43c4a326e"><div class="ttname"><a href="colr_8h.html#ab71656e616aef4bbb3c278d43c4a326e">ColorJustify_eq</a></div><div class="ttdeci">bool ColorJustify_eq(ColorJustify a, ColorJustify b)</div><div class="ttdoc">Compares two ColorJustify structs. </div><div class="ttdef"><b>Definition:</b> colr.c:5675</div></div>
<div class="ttc" id="colr_8h_html_adf57e195301864cec80739e7e0f3000c"><div class="ttname"><a href="colr_8h.html#adf57e195301864cec80739e7e0f3000c">ColorValue_eq</a></div><div class="ttdeci">bool ColorValue_eq(ColorValue a, ColorValue b)</div><div class="ttdoc">Compares two ColorValue structs. </div><div class="ttdef"><b>Definition:</b> colr.c:6550</div></div>
<div class="ttc" id="colr_8h_html_a32bf31475b0f6264b45438bd5c09ee7d"><div class="ttname"><a href="colr_8h.html#a32bf31475b0f6264b45438bd5c09ee7d">StyleValue_eq</a></div><div class="ttdeci">bool StyleValue_eq(StyleValue a, StyleValue b)</div><div class="ttdoc">Compares two StyleValues. </div><div class="ttdef"><b>Definition:</b> colr.c:8123</div></div>
<div class="ttc" id="colr_8h_html_ac847d91a396ae6babc0bd46e6386a701"><div class="ttname"><a href="colr_8h.html#ac847d91a396ae6babc0bd46e6386a701">ExtendedValue_eq</a></div><div class="ttdeci">bool ExtendedValue_eq(ExtendedValue a, ExtendedValue b)</div><div class="ttdoc">Compares two ExtendedValues. </div><div class="ttdef"><b>Definition:</b> colr.c:7389</div></div>
<div class="ttc" id="colr_8h_html_structColorArg"><div class="ttname"><a href="colr_8h.html#structColorArg">ColorArg</a></div><div class="ttdoc">Holds an ArgType, and a ColorValue. </div><div class="ttdef"><b>Definition:</b> colr.h:2737</div></div>
<div class="ttc" id="colr_8h_html_ad4b5f73b8aa9d72216d7386221418ae1"><div class="ttname"><a href="colr_8h.html#ad4b5f73b8aa9d72216d7386221418ae1">RGB_eq</a></div><div class="ttdeci">bool RGB_eq(RGB a, RGB b)</div><div class="ttdoc">Compare two RGB structs. </div><div class="ttdef"><b>Definition:</b> colr.c:7689</div></div>
<div class="ttc" id="colr_8h_html_structRGB"><div class="ttname"><a href="colr_8h.html#structRGB">RGB</a></div><div class="ttdoc">Container for RGB values. </div><div class="ttdef"><b>Definition:</b> colr.h:2535</div></div>
<div class="ttc" id="colr_8h_html_a5e133660cf9d4bcd1cb6a49e3ec16f83"><div class="ttname"><a href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a></div><div class="ttdeci">ColorType</div><div class="ttdoc">Color/Style code types. Used with ColorType_from_str() and ColorValue. </div><div class="ttdef"><b>Definition:</b> colr.h:2625</div></div>
<div class="ttc" id="colr_8h_html_a6dda29f582a062546ef8733d8b7d8a94"><div class="ttname"><a href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a></div><div class="ttdeci">unsigned char ExtendedValue</div><div class="ttdoc">Convenience typedef for clarity when dealing with extended (256) colors. </div><div class="ttdef"><b>Definition:</b> colr.h:2532</div></div>
<div class="ttc" id="colr_8h_html_a85224ec2507f33b1985f4cdd0adfe0e6"><div class="ttname"><a href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a></div><div class="ttdeci">StyleValue</div><div class="ttdoc">Style values. </div><div class="ttdef"><b>Definition:</b> colr.h:2549</div></div>
<div class="ttc" id="colr_8h_html_a17bf46ac385e41b729d07a65dd506cba"><div class="ttname"><a href="colr_8h.html#a17bf46ac385e41b729d07a65dd506cba">BasicValue_eq</a></div><div class="ttdeci">bool BasicValue_eq(BasicValue a, BasicValue b)</div><div class="ttdoc">Compares two BasicValues. </div><div class="ttdef"><b>Definition:</b> colr.c:7171</div></div>
</div><!-- fragment -->
<p>Calls the &lt;type&gt;_eq functions for the supported types. </p>
<p>The types for <code>a</code> and <code>b</code> must be the same.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First supported type to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second supported type to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the values are equal, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="aa32d4a29c94182c208d20b8deb2e1d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa32d4a29c94182c208d20b8deb2e1d5b">&#9670;&nbsp;</a></span>colr_example</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_example</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_Generic( \</div><div class="line">        (x), \</div><div class="line">        <a class="code" href="colr_8h.html#structColorArg">ColorArg</a>: <a class="code" href="colr_8h.html#aa54ab1879f6de8ca2fcb4702250741f5">ColorArg_example</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorValue">ColorValue</a>: <a class="code" href="colr_8h.html#a89b5fc81980cbbfb425c7756eb8f0d0a">ColorValue_example</a> \</div><div class="line">    )(x)</div><div class="ttc" id="colr_8h_html_structColorValue"><div class="ttname"><a href="colr_8h.html#structColorValue">ColorValue</a></div><div class="ttdoc">Holds a color type and it&amp;#39;s value. </div><div class="ttdef"><b>Definition:</b> colr.h:2712</div></div>
<div class="ttc" id="colr_8h_html_aa54ab1879f6de8ca2fcb4702250741f5"><div class="ttname"><a href="colr_8h.html#aa54ab1879f6de8ca2fcb4702250741f5">ColorArg_example</a></div><div class="ttdeci">char * ColorArg_example(ColorArg carg, bool colorized)</div><div class="ttdoc">Create a string (char*) representation of a ColorArg with a stylized type/name using escape codes bui...</div><div class="ttdef"><b>Definition:</b> colr.c:4981</div></div>
<div class="ttc" id="colr_8h_html_a89b5fc81980cbbfb425c7756eb8f0d0a"><div class="ttname"><a href="colr_8h.html#a89b5fc81980cbbfb425c7756eb8f0d0a">ColorValue_example</a></div><div class="ttdeci">char * ColorValue_example(ColorValue cval)</div><div class="ttdoc">Create a string (char*) representation of a ColorValue with a human-friendly type/name. </div><div class="ttdef"><b>Definition:</b> colr.c:6572</div></div>
<div class="ttc" id="colr_8h_html_structColorArg"><div class="ttname"><a href="colr_8h.html#structColorArg">ColorArg</a></div><div class="ttdoc">Holds an ArgType, and a ColorValue. </div><div class="ttdef"><b>Definition:</b> colr.h:2737</div></div>
</div><!-- fragment -->
<p>Calls the &lt;type&gt;_example functions for the supported types. </p>
<p>This is used to create a human-friendly representation for ColorArgs or ColorValues.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A supported type to get an example string for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>

</div>
</div>
<a id="abe8e5e059e18f6620effbedea737f2de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe8e5e059e18f6620effbedea737f2de">&#9670;&nbsp;</a></span>COLR_FMT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define COLR_FMT&#160;&#160;&#160;&quot;R&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format character string suitable for use in the printf-family of functions. </p>
<p>This can be defined to any single-char string before including <a class="el" href="colr_8h.html" title="Declarations for ColrC functions, enums, structs, etc. ">colr.h</a> if you don't want to use the default value. </p>

</div>
</div>
<a id="afd8ae4170dc11decd1dfb47fdb56c9d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd8ae4170dc11decd1dfb47fdb56c9d7">&#9670;&nbsp;</a></span>colr_fprintf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_fprintf</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#a04ebe7aa43eab3e7e0bd9d769d2074ac">colr_printf_macro</a>(fprintf, __VA_ARGS__)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure <a class="el" href="colr_8h.html#aaaf134ca9a2188d83171fe91948354d9" title="Registers COLR_FMT_CHAR to handle Colr objects in the printf-family functions. ">colr_printf_register()</a> has been called, and then call <code>fprintf</code>. </p>
<p>Will call <code>free()</code> on any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointer, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> pointer, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointer, or the strings created by them.</p>
<dl class="section attention"><dt>Attention</dt><dd>This feature uses a GNU extension, and is only available when COLR_GNU is defined. See the documentation for COLR_GNU.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td><p class="starttd">Arguments for <code>fprintf</code>.</p>
<p class="endtd"><em><a class="el" href="colr_8h.html#a76eae619668e01987653932a7492fd94" title="Calls the &lt;type&gt;_free functions for the supported types. ">colr_free()</a> will be called on any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointer passed to this function</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Same as <code>fprintf</code>. </dd></dl>

</div>
</div>
<a id="a76eae619668e01987653932a7492fd94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76eae619668e01987653932a7492fd94">&#9670;&nbsp;</a></span>colr_free</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_free</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_Generic( \</div><div class="line">        (x), \</div><div class="line">        <a class="code" href="colr_8h.html#structColorArg">ColorArg</a>*: <a class="code" href="colr_8h.html#aa1163a9c866767fb7fcb734d3c0d9b7c">ColorArg_free</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorArg">ColorArg</a>**: <a class="code" href="colr_8h.html#a32c5256623852632a4ba040e3447431c">ColorArgs_array_free</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorResult">ColorResult</a>*: <a class="code" href="colr_8h.html#a27b70c6de9b2351424100bd742b1f1a8">ColorResult_free</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorText">ColorText</a>*: <a class="code" href="colr_8h.html#a901e5738358a739629cc3aaccab3e73f">ColorText_free</a>, \</div><div class="line">        regmatch_t**: <a class="code" href="colr_8h.html#a67e72a18762c87886173dd0a0dc37887">colr_free_re_matches</a>, \</div><div class="line">        <span class="keywordflow">default</span>: <a class="code" href="colr_8h.html#aaa888f1b31eb40ec7d252d3ee9175d76">_colr_free</a> \</div><div class="line">    )(x)</div><div class="ttc" id="colr_8h_html_aa1163a9c866767fb7fcb734d3c0d9b7c"><div class="ttname"><a href="colr_8h.html#aa1163a9c866767fb7fcb734d3c0d9b7c">ColorArg_free</a></div><div class="ttdeci">void ColorArg_free(ColorArg *p)</div><div class="ttdoc">Free allocated memory for a ColorArg. </div><div class="ttdef"><b>Definition:</b> colr.c:5055</div></div>
<div class="ttc" id="colr_8h_html_a27b70c6de9b2351424100bd742b1f1a8"><div class="ttname"><a href="colr_8h.html#a27b70c6de9b2351424100bd742b1f1a8">ColorResult_free</a></div><div class="ttdeci">void ColorResult_free(ColorResult *p)</div><div class="ttdoc">Free allocated memory for a ColorResult and it&amp;#39;s .result member. </div><div class="ttdef"><b>Definition:</b> colr.c:5825</div></div>
<div class="ttc" id="colr_8h_html_a67e72a18762c87886173dd0a0dc37887"><div class="ttname"><a href="colr_8h.html#a67e72a18762c87886173dd0a0dc37887">colr_free_re_matches</a></div><div class="ttdeci">void colr_free_re_matches(regmatch_t **matches)</div><div class="ttdoc">Free an array of allocated regmatch_t, like the return from colr_re_matches(). </div><div class="ttdef"><b>Definition:</b> colr.c:1093</div></div>
<div class="ttc" id="colr_8h_html_aaa888f1b31eb40ec7d252d3ee9175d76"><div class="ttname"><a href="colr_8h.html#aaa888f1b31eb40ec7d252d3ee9175d76">_colr_free</a></div><div class="ttdeci">void _colr_free(void *p)</div><div class="ttdoc">Calls Colr *_free() functions for Colr objects, otherwise just calls free(). </div><div class="ttdef"><b>Definition:</b> colr.c:4316</div></div>
<div class="ttc" id="colr_8h_html_a901e5738358a739629cc3aaccab3e73f"><div class="ttname"><a href="colr_8h.html#a901e5738358a739629cc3aaccab3e73f">ColorText_free</a></div><div class="ttdeci">void ColorText_free(ColorText *p)</div><div class="ttdoc">Frees a ColorText and it&amp;#39;s ColorArgs. </div><div class="ttdef"><b>Definition:</b> colr.c:5966</div></div>
<div class="ttc" id="colr_8h_html_structColorResult"><div class="ttname"><a href="colr_8h.html#structColorResult">ColorResult</a></div><div class="ttdoc">Holds a string (char*) that was definitely allocated by Colr. </div><div class="ttdef"><b>Definition:</b> colr.h:2747</div></div>
<div class="ttc" id="colr_8h_html_structColorArg"><div class="ttname"><a href="colr_8h.html#structColorArg">ColorArg</a></div><div class="ttdoc">Holds an ArgType, and a ColorValue. </div><div class="ttdef"><b>Definition:</b> colr.h:2737</div></div>
<div class="ttc" id="colr_8h_html_structColorText"><div class="ttname"><a href="colr_8h.html#structColorText">ColorText</a></div><div class="ttdoc">Holds a string of text, and optional fore, back, and style ColorArgs. </div><div class="ttdef"><b>Definition:</b> colr.h:2759</div></div>
<div class="ttc" id="colr_8h_html_a32c5256623852632a4ba040e3447431c"><div class="ttname"><a href="colr_8h.html#a32c5256623852632a4ba040e3447431c">ColorArgs_array_free</a></div><div class="ttdeci">void ColorArgs_array_free(ColorArg **ps)</div><div class="ttdoc">Free an allocated array of ColorArgs, including the array itself. </div><div class="ttdef"><b>Definition:</b> colr.c:5475</div></div>
</div><!-- fragment -->
<p>Calls the &lt;type&gt;_free functions for the supported types. </p>
<p>If the type is not supported, a plain <code>free(x)</code> is used.</p>
<p>Colr objects that have a &lt;type&gt;_free function will be properly released, even through a <code>void</code> pointer (as long as the <code>.marker</code> member is set, which it will be if it was created by the Colr functions/macros).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A pointer to a supported type to free. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ColorResult_example_8c-example.html#a12">ColorResult_example.c</a>, <a class="el" href="colr_join_example_8c-example.html#a11">colr_join_example.c</a>, and <a class="el" href="colr_replace_all_example_8c-example.html#a7">colr_replace_all_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="a895123a02eb0dce3192ae0d9a02f42ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a895123a02eb0dce3192ae0d9a02f42ab">&#9670;&nbsp;</a></span>COLR_GNU</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define COLR_GNU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defined when <code>__GNUC__</code> is available, to enable <a href="https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html">statement-expressions </a> and <a href="https://www.gnu.org/software/libc/manual/html_node/Customizing-Printf.html">register_printf_specifier </a>. </p>
<p>There isn't a lot of information available for <code>register_printf_specifier</code> right now. There are a couple of <a href="https://lib.void.so/define-your-own-custom-conversion-specifiers-for-printf-example/">tutorials </a> out there. No <a href="https://www.kernel.org/doc/man-pages/missing_pages.html">man pages </a> though. It <a href="https://fossies.org/diffs/glibc/2.26_vs_2.27/stdio-common/reg-printf.c-diff.html">looks like </a> it was introduced in <code>glibc-2.27</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a686865036c288a8c6d1626ce2f120039" title="Creates a stack-allocated escape code string (char*) for a back color. ">back_str_static</a> </dd>
<dd>
<a class="el" href="colr_8h.html#ad0ab6c47eae67006285e33f1edd84278" title="Creates a stack-allocated escape code string (char*) for a fore color. ">fore_str_static</a> </dd>
<dd>
<a class="el" href="colr_8h.html#af297a2286435a423e01edae98c561c7b" title="Ensure colr_printf_register() has been called, and then call asprintf. ">colr_asprintf</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a7c188d16f60b7e296bd71ac95d8ec508" title="Ensure colr_printf_register() has been called, and then call printf. ">colr_printf</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a34c359a48f811316d765b7abef1ea8f4" title="Handles printing with printf for Colr objects. ">colr_printf_handler</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a95619a7f5eeb0158dfb969ae9a26a6bb" title="Handles the arg count/size for the Colr printf handler. ">colr_printf_info</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a04ebe7aa43eab3e7e0bd9d769d2074ac" title="Calls one of the printf-family functions, with format warnings disabled for the call, and returns the result. ">colr_printf_macro</a> </dd>
<dd>
<a class="el" href="colr_8h.html#aaaf134ca9a2188d83171fe91948354d9" title="Registers COLR_FMT_CHAR to handle Colr objects in the printf-family functions. ">colr_printf_register</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a58aca09bd7892f8c6b3255454ae2ff07" title="Ensure colr_printf_register() has been called, and then call sprintf. ">colr_sprintf</a> </dd>
<dd>
<a class="el" href="colr_8h.html#af3d1de0d75fddd284223749e7c13408a" title="Ensure colr_printf_register() has been called, and then call snprintf. ">colr_snprintf</a> </dd></dl>

</div>
</div>
<a id="a0819ea3109493d7fe1656a7cadaca7d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0819ea3109493d7fe1656a7cadaca7d5">&#9670;&nbsp;</a></span>colr_is_empty</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_is_empty</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_Generic( \</div><div class="line">        (x), \</div><div class="line">        <a class="code" href="colr_8h.html#structColorArg">ColorArg</a>: <a class="code" href="colr_8h.html#a752355c2d96d35688d3756558f8421ba">ColorArg_is_empty</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorJustify">ColorJustify</a>: <a class="code" href="colr_8h.html#a34f193b6e6a20c63caecc1d9b53c89fb">ColorJustify_is_empty</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorText">ColorText</a>: <a class="code" href="colr_8h.html#ac846e583415e832b9090270020320b9f">ColorText_is_empty</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorValue">ColorValue</a>: <a class="code" href="colr_8h.html#a48005bb1589a7ebeef413ccee2a7c2a1">ColorValue_is_empty</a> \</div><div class="line">    )(x)</div><div class="ttc" id="colr_8h_html_structColorValue"><div class="ttname"><a href="colr_8h.html#structColorValue">ColorValue</a></div><div class="ttdoc">Holds a color type and it&amp;#39;s value. </div><div class="ttdef"><b>Definition:</b> colr.h:2712</div></div>
<div class="ttc" id="colr_8h_html_a752355c2d96d35688d3756558f8421ba"><div class="ttname"><a href="colr_8h.html#a752355c2d96d35688d3756558f8421ba">ColorArg_is_empty</a></div><div class="ttdeci">bool ColorArg_is_empty(ColorArg carg)</div><div class="ttdoc">Checks to see if a ColorArg is an empty placeholder. </div><div class="ttdef"><b>Definition:</b> colr.c:5287</div></div>
<div class="ttc" id="colr_8h_html_structColorJustify"><div class="ttname"><a href="colr_8h.html#structColorJustify">ColorJustify</a></div><div class="ttdoc">Holds a string justification method, width, and padding character for ColorTexts. ...</div><div class="ttdef"><b>Definition:</b> colr.h:2680</div></div>
<div class="ttc" id="colr_8h_html_ac846e583415e832b9090270020320b9f"><div class="ttname"><a href="colr_8h.html#ac846e583415e832b9090270020320b9f">ColorText_is_empty</a></div><div class="ttdeci">bool ColorText_is_empty(ColorText ctext)</div><div class="ttdoc">Checks to see if a ColorText has no usable values. </div><div class="ttdef"><b>Definition:</b> colr.c:6082</div></div>
<div class="ttc" id="colr_8h_html_structColorArg"><div class="ttname"><a href="colr_8h.html#structColorArg">ColorArg</a></div><div class="ttdoc">Holds an ArgType, and a ColorValue. </div><div class="ttdef"><b>Definition:</b> colr.h:2737</div></div>
<div class="ttc" id="colr_8h_html_structColorText"><div class="ttname"><a href="colr_8h.html#structColorText">ColorText</a></div><div class="ttdoc">Holds a string of text, and optional fore, back, and style ColorArgs. </div><div class="ttdef"><b>Definition:</b> colr.h:2759</div></div>
<div class="ttc" id="colr_8h_html_a34f193b6e6a20c63caecc1d9b53c89fb"><div class="ttname"><a href="colr_8h.html#a34f193b6e6a20c63caecc1d9b53c89fb">ColorJustify_is_empty</a></div><div class="ttdeci">bool ColorJustify_is_empty(ColorJustify cjust)</div><div class="ttdoc">Checks to see if a ColorJustify is &quot;empty&quot;. </div><div class="ttdef"><b>Definition:</b> colr.c:5695</div></div>
<div class="ttc" id="colr_8h_html_a48005bb1589a7ebeef413ccee2a7c2a1"><div class="ttname"><a href="colr_8h.html#a48005bb1589a7ebeef413ccee2a7c2a1">ColorValue_is_empty</a></div><div class="ttdeci">bool ColorValue_is_empty(ColorValue cval)</div><div class="ttdoc">Checks to see if a ColorValue is an empty placeholder. </div><div class="ttdef"><b>Definition:</b> colr.c:6835</div></div>
</div><!-- fragment -->
<p>Calls the &lt;type&gt;is_empty functions for the supported types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A supported type to build a string from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2982e773789d3f819036212694afed5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2982e773789d3f819036212694afed5e">&#9670;&nbsp;</a></span>colr_is_invalid</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_is_invalid</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_Generic( \</div><div class="line">        (x), \</div><div class="line">        <a class="code" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>: <a class="code" href="colr_8h.html#a6332bbd16e746a02491eee70c13d0735">BasicValue_is_invalid</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>: <a class="code" href="colr_8h.html#a669c8872f6b44a047470d33eb5d8b765">ExtendedValue_is_invalid</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>: <a class="code" href="colr_8h.html#a3f8126147490f88283a53e9ef48d33f0">StyleValue_is_invalid</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorArg">ColorArg</a>: <a class="code" href="colr_8h.html#a66b4906cfb08588005536db1250dc899">ColorArg_is_invalid</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>: <a class="code" href="colr_8h.html#adc223f6fda6296396e9ecddcc68d4aec">ColorType_is_invalid</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorValue">ColorValue</a>: <a class="code" href="colr_8h.html#a22fcf30338eb777592421543885f74e0">ColorValue_is_invalid</a> \</div><div class="line">    )(x)</div><div class="ttc" id="colr_8h_html_structColorValue"><div class="ttname"><a href="colr_8h.html#structColorValue">ColorValue</a></div><div class="ttdoc">Holds a color type and it&amp;#39;s value. </div><div class="ttdef"><b>Definition:</b> colr.h:2712</div></div>
<div class="ttc" id="colr_8h_html_a669c8872f6b44a047470d33eb5d8b765"><div class="ttname"><a href="colr_8h.html#a669c8872f6b44a047470d33eb5d8b765">ExtendedValue_is_invalid</a></div><div class="ttdeci">bool ExtendedValue_is_invalid(int eval)</div><div class="ttdoc">Determines whether an integer is an invalid ExtendedValue. </div><div class="ttdef"><b>Definition:</b> colr.c:7606</div></div>
<div class="ttc" id="colr_8h_html_a6332bbd16e746a02491eee70c13d0735"><div class="ttname"><a href="colr_8h.html#a6332bbd16e746a02491eee70c13d0735">BasicValue_is_invalid</a></div><div class="ttdeci">bool BasicValue_is_invalid(BasicValue bval)</div><div class="ttdoc">Determines whether a BasicValue is invalid. </div><div class="ttdef"><b>Definition:</b> colr.c:7234</div></div>
<div class="ttc" id="colr_8h_html_a0c061fbfddd43dfe324486dc86cb92ee"><div class="ttname"><a href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a></div><div class="ttdeci">BasicValue</div><div class="ttdoc">Basic color values, with a few convenience values for extended colors. </div><div class="ttdef"><b>Definition:</b> colr.h:2456</div></div>
<div class="ttc" id="colr_8h_html_a22fcf30338eb777592421543885f74e0"><div class="ttname"><a href="colr_8h.html#a22fcf30338eb777592421543885f74e0">ColorValue_is_invalid</a></div><div class="ttdeci">bool ColorValue_is_invalid(ColorValue cval)</div><div class="ttdoc">Checks to see if a ColorValue holds an invalid value. </div><div class="ttdef"><b>Definition:</b> colr.c:6846</div></div>
<div class="ttc" id="colr_8h_html_a66b4906cfb08588005536db1250dc899"><div class="ttname"><a href="colr_8h.html#a66b4906cfb08588005536db1250dc899">ColorArg_is_invalid</a></div><div class="ttdeci">bool ColorArg_is_invalid(ColorArg carg)</div><div class="ttdoc">Checks to see if a ColorArg holds an invalid value. </div><div class="ttdef"><b>Definition:</b> colr.c:5298</div></div>
<div class="ttc" id="colr_8h_html_structColorArg"><div class="ttname"><a href="colr_8h.html#structColorArg">ColorArg</a></div><div class="ttdoc">Holds an ArgType, and a ColorValue. </div><div class="ttdef"><b>Definition:</b> colr.h:2737</div></div>
<div class="ttc" id="colr_8h_html_adc223f6fda6296396e9ecddcc68d4aec"><div class="ttname"><a href="colr_8h.html#adc223f6fda6296396e9ecddcc68d4aec">ColorType_is_invalid</a></div><div class="ttdeci">bool ColorType_is_invalid(ColorType type)</div><div class="ttdoc">Check to see if a ColorType value is considered invalid. </div><div class="ttdef"><b>Definition:</b> colr.c:6411</div></div>
<div class="ttc" id="colr_8h_html_a5e133660cf9d4bcd1cb6a49e3ec16f83"><div class="ttname"><a href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a></div><div class="ttdeci">ColorType</div><div class="ttdoc">Color/Style code types. Used with ColorType_from_str() and ColorValue. </div><div class="ttdef"><b>Definition:</b> colr.h:2625</div></div>
<div class="ttc" id="colr_8h_html_a6dda29f582a062546ef8733d8b7d8a94"><div class="ttname"><a href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a></div><div class="ttdeci">unsigned char ExtendedValue</div><div class="ttdoc">Convenience typedef for clarity when dealing with extended (256) colors. </div><div class="ttdef"><b>Definition:</b> colr.h:2532</div></div>
<div class="ttc" id="colr_8h_html_a3f8126147490f88283a53e9ef48d33f0"><div class="ttname"><a href="colr_8h.html#a3f8126147490f88283a53e9ef48d33f0">StyleValue_is_invalid</a></div><div class="ttdeci">bool StyleValue_is_invalid(StyleValue sval)</div><div class="ttdoc">Determines whether a StyleValue is invalid. </div><div class="ttdef"><b>Definition:</b> colr.c:8184</div></div>
<div class="ttc" id="colr_8h_html_a85224ec2507f33b1985f4cdd0adfe0e6"><div class="ttname"><a href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a></div><div class="ttdeci">StyleValue</div><div class="ttdoc">Style values. </div><div class="ttdef"><b>Definition:</b> colr.h:2549</div></div>
</div><!-- fragment -->
<p>Calls the &lt;type&gt;is_invalid functions for the supported types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A supported type to build a string from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8909ecf2f0be1bbc70ab33667578134e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8909ecf2f0be1bbc70ab33667578134e">&#9670;&nbsp;</a></span>colr_is_valid</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_is_valid</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_Generic( \</div><div class="line">        (x), \</div><div class="line">        <a class="code" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>: <a class="code" href="colr_8h.html#a29e4c8a4789232c78b9ef17e292839ca">BasicValue_is_valid</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>: <a class="code" href="colr_8h.html#a6b43e6ee55b05d9b73950794f2dd53a4">ExtendedValue_is_valid</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>: <a class="code" href="colr_8h.html#a2d6598b05bc5c742fbb94b47d8a3213a">StyleValue_is_valid</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorArg">ColorArg</a>: <a class="code" href="colr_8h.html#a1e446f65d6987d52522a1755c909d421">ColorArg_is_valid</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>: <a class="code" href="colr_8h.html#a5a5883d43e3206584ad048908720afb2">ColorType_is_valid</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorValue">ColorValue</a>: <a class="code" href="colr_8h.html#ac7183410b61d12a99dda3f76c2705497">ColorValue_is_valid</a> \</div><div class="line">    )(x)</div><div class="ttc" id="colr_8h_html_a1e446f65d6987d52522a1755c909d421"><div class="ttname"><a href="colr_8h.html#a1e446f65d6987d52522a1755c909d421">ColorArg_is_valid</a></div><div class="ttdeci">bool ColorArg_is_valid(ColorArg carg)</div><div class="ttdoc">Checks to see if a ColorArg holds a valid value. </div><div class="ttdef"><b>Definition:</b> colr.c:5327</div></div>
<div class="ttc" id="colr_8h_html_structColorValue"><div class="ttname"><a href="colr_8h.html#structColorValue">ColorValue</a></div><div class="ttdoc">Holds a color type and it&amp;#39;s value. </div><div class="ttdef"><b>Definition:</b> colr.h:2712</div></div>
<div class="ttc" id="colr_8h_html_a0c061fbfddd43dfe324486dc86cb92ee"><div class="ttname"><a href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a></div><div class="ttdeci">BasicValue</div><div class="ttdoc">Basic color values, with a few convenience values for extended colors. </div><div class="ttdef"><b>Definition:</b> colr.h:2456</div></div>
<div class="ttc" id="colr_8h_html_a2d6598b05bc5c742fbb94b47d8a3213a"><div class="ttname"><a href="colr_8h.html#a2d6598b05bc5c742fbb94b47d8a3213a">StyleValue_is_valid</a></div><div class="ttdeci">bool StyleValue_is_valid(StyleValue sval)</div><div class="ttdoc">Determines whether a StyleValue is valid. </div><div class="ttdef"><b>Definition:</b> colr.c:8195</div></div>
<div class="ttc" id="colr_8h_html_a6b43e6ee55b05d9b73950794f2dd53a4"><div class="ttname"><a href="colr_8h.html#a6b43e6ee55b05d9b73950794f2dd53a4">ExtendedValue_is_valid</a></div><div class="ttdeci">bool ExtendedValue_is_valid(int eval)</div><div class="ttdoc">Determines whether an integer is a valid ExtendedValue. </div><div class="ttdef"><b>Definition:</b> colr.c:7617</div></div>
<div class="ttc" id="colr_8h_html_ac7183410b61d12a99dda3f76c2705497"><div class="ttname"><a href="colr_8h.html#ac7183410b61d12a99dda3f76c2705497">ColorValue_is_valid</a></div><div class="ttdeci">bool ColorValue_is_valid(ColorValue cval)</div><div class="ttdoc">Checks to see if a ColorValue holds a valid value. </div><div class="ttdef"><b>Definition:</b> colr.c:6857</div></div>
<div class="ttc" id="colr_8h_html_structColorArg"><div class="ttname"><a href="colr_8h.html#structColorArg">ColorArg</a></div><div class="ttdoc">Holds an ArgType, and a ColorValue. </div><div class="ttdef"><b>Definition:</b> colr.h:2737</div></div>
<div class="ttc" id="colr_8h_html_a5a5883d43e3206584ad048908720afb2"><div class="ttname"><a href="colr_8h.html#a5a5883d43e3206584ad048908720afb2">ColorType_is_valid</a></div><div class="ttdeci">bool ColorType_is_valid(ColorType type)</div><div class="ttdoc">Check to see if a ColorType value is considered valid. </div><div class="ttdef"><b>Definition:</b> colr.c:6422</div></div>
<div class="ttc" id="colr_8h_html_a5e133660cf9d4bcd1cb6a49e3ec16f83"><div class="ttname"><a href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a></div><div class="ttdeci">ColorType</div><div class="ttdoc">Color/Style code types. Used with ColorType_from_str() and ColorValue. </div><div class="ttdef"><b>Definition:</b> colr.h:2625</div></div>
<div class="ttc" id="colr_8h_html_a6dda29f582a062546ef8733d8b7d8a94"><div class="ttname"><a href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a></div><div class="ttdeci">unsigned char ExtendedValue</div><div class="ttdoc">Convenience typedef for clarity when dealing with extended (256) colors. </div><div class="ttdef"><b>Definition:</b> colr.h:2532</div></div>
<div class="ttc" id="colr_8h_html_a29e4c8a4789232c78b9ef17e292839ca"><div class="ttname"><a href="colr_8h.html#a29e4c8a4789232c78b9ef17e292839ca">BasicValue_is_valid</a></div><div class="ttdeci">bool BasicValue_is_valid(BasicValue bval)</div><div class="ttdoc">Determines whether a BasicValue is valid. </div><div class="ttdef"><b>Definition:</b> colr.c:7245</div></div>
<div class="ttc" id="colr_8h_html_a85224ec2507f33b1985f4cdd0adfe0e6"><div class="ttname"><a href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a></div><div class="ttdeci">StyleValue</div><div class="ttdoc">Style values. </div><div class="ttdef"><b>Definition:</b> colr.h:2549</div></div>
</div><!-- fragment -->
<p>Calls the &lt;type&gt;is_valid functions for the supported types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A supported type to build a string from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b95dc82c67a2ec94053e207b0b87594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b95dc82c67a2ec94053e207b0b87594">&#9670;&nbsp;</a></span>colr_is_valid_mblen</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_is_valid_mblen</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;((x) &amp;&amp; ((x) != (size_t)-1) &amp;&amp; ((x) != (size_t)-2))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks return values from <code>mbrlen()</code> and <a class="el" href="colr_8h.html#ade675256d9e88682d4bebdcc4a57f86f" title="Like mbrlen, except it will return the length of the next N (length) multibyte characters in bytes...">colr_mb_len()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A <code>size_t</code> return value to check, from <code>mbrlen()</code> or <a class="el" href="colr_8h.html#ade675256d9e88682d4bebdcc4a57f86f" title="Like mbrlen, except it will return the length of the next N (length) multibyte characters in bytes...">colr_mb_len()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if at least one valid multibyte character length was detected, otherwise <code>false</code>. Invalid/incomplete multibyte sequences, or empty/ <code>NULL</code> strings will cause this macro to return <code>false</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ab88ca919420f2df896b7973401641ab4">_rainbow()</a>, and <a class="el" href="colr_8h.html#ade675256d9e88682d4bebdcc4a57f86f">colr_mb_len()</a>.</p>

</div>
</div>
<a id="a3b56172c3a4f77092b0b476359a2a746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b56172c3a4f77092b0b476359a2a746">&#9670;&nbsp;</a></span>colr_istr_either</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_istr_either</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s3&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">        ((s1) &amp;&amp; (s2) &amp;&amp; (s3)) ? \</div><div class="line">            (<a class="code" href="colr_8h.html#ad94e5767e40ff1d9a5236b890c20cc95">colr_istr_eq</a>((s1), (s2)) || <a class="code" href="colr_8h.html#ad94e5767e40ff1d9a5236b890c20cc95">colr_istr_eq</a>((s1), (s3))) : \</div><div class="line">            <span class="keyword">false</span> \</div><div class="line">    )</div><div class="ttc" id="colr_8h_html_ad94e5767e40ff1d9a5236b890c20cc95"><div class="ttname"><a href="colr_8h.html#ad94e5767e40ff1d9a5236b890c20cc95">colr_istr_eq</a></div><div class="ttdeci">#define colr_istr_eq(s1, s2)</div><div class="ttdoc">Convenience macro for !strcasecmp(s1, s2). </div><div class="ttdef"><b>Definition:</b> colr.h:1266</div></div>
</div><!-- fragment -->
<p>Convenience macro for <code>!strcasecmp(s1, s2) || !strcasecmp(s1, s3)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s1</td><td>The string to compare against the other two strings. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s2</td><td>The first string to compare with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s3</td><td>The second string to compare with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if <code>s1</code> is equal to <code>s2</code> or <code>s3</code>, otherwise <code>0</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ab2ebdcd3c6e598a244292c7605452e9d">colr_supports_rgb()</a>.</p>

</div>
</div>
<a id="ad94e5767e40ff1d9a5236b890c20cc95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94e5767e40ff1d9a5236b890c20cc95">&#9670;&nbsp;</a></span>colr_istr_eq</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_istr_eq</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s2&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">        ((s1) &amp;&amp; (s2)) ? \</div><div class="line">            !strcasecmp((s1), (s2)) : \</div><div class="line">            false \</div><div class="line">    )</div></div><!-- fragment -->
<p>Convenience macro for <code>!strcasecmp(s1, s2)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s1</td><td>The first string to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s2</td><td>The second string to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if <code>s1</code> and <code>s2</code> are equal, otherwise <code>0</code>. </dd></dl>

</div>
</div>
<a id="a4d87ca8cb5460146965bd85ec82f293e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d87ca8cb5460146965bd85ec82f293e">&#9670;&nbsp;</a></span>Colr_join</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Colr_join</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">joiner, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#aebecaca8dfed9f43418cb2c6b214eef3">ColrResult</a>(<a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0">colr_join</a>(joiner, __VA_ARGS__))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Joins Colr objects and strings, exactly like <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, but returns an allocated <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> that the <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a>, <a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465" title="Like colr_cat(), but returns an allocated ColorResult that the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros will automatically free(). ">Colr_cat()</a>, and <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> macros will automatically <code>free()</code> for you. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">joiner</td><td>What to put between the other arguments. <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointer, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> pointer, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointer, or string (<code>char*</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td><p class="starttd">Other arguments to join, with <code>joiner</code> between them. <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointers, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> pointers, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointers, or strings, in any order.</p>
<p class="endtd"><em><a class="el" href="colr_8h.html#a76eae619668e01987653932a7492fd94" title="Calls the &lt;type&gt;_free functions for the supported types. ">colr_free()</a> will be called on any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointer passed to this function</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p><em>If allocation fails, <code>NULL</code> is returned</em>.</p>
<p class="enddd">If used inside of the <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a>, <a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465" title="Like colr_cat(), but returns an allocated ColorResult that the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros will automatically free(). ">Colr_cat()</a>, and <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> macros, <em>they will <code>free()</code> the result</em>. Otherwise, <em>you are responsible for calling <code>free()</code></em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> </dd>
<dd>
<a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a753093cd4c872eed4b77feaa7816212b" title="Create an allocated string directly from Colr() arguments. ">colr</a> </dd>
<dd>
<a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ColorResult_example_8c-example.html#a8">ColorResult_example.c</a>, <a class="el" href="colr_cat_example_8c-example.html#a5">colr_cat_example.c</a>, <a class="el" href="colr_join_example_8c-example.html#a7">colr_join_example.c</a>, <a class="el" href="colr_replace_all_example_8c-example.html#a3">colr_replace_all_example.c</a>, <a class="el" href="colr_replace_example_8c-example.html#a3">colr_replace_example.c</a>, <a class="el" href="colr_replace_re_all_example_8c-example.html#a3">colr_replace_re_all_example.c</a>, <a class="el" href="colr_replace_re_example_8c-example.html#a3">colr_replace_re_example.c</a>, and <a class="el" href="simple_example_8c-example.html#a1">simple_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="ae8cc35d2d3a15c9c22ebb0a0835c92f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8cc35d2d3a15c9c22ebb0a0835c92f0">&#9670;&nbsp;</a></span>colr_join</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_join</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">joiner, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join</a>(joiner, __VA_ARGS__, _ColrLastArg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointers, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointers, and strings by another <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointer, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointer, or string. </p>
<p>To build the <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointers, it is better to use the <a class="el" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f" title="Create a fore color suitable for use with the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros. ">fore()</a>, <a class="el" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8" title="Create a back color suitable for use with the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros. ">back()</a>, and <a class="el" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662" title="Create a style suitable for use with the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros. ">style()</a> macros. The ColorArgs are heap allocated, but <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a> will free() them for you.</p>
<p>To build the <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointers, it is better to use the <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a> macro, along with the <a class="el" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f" title="Create a fore color suitable for use with the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros. ">fore()</a>, <a class="el" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8" title="Create a back color suitable for use with the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros. ">back()</a>, and <a class="el" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662" title="Create a style suitable for use with the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros. ">style()</a> macros. The ColorTexts are heap allocated, but <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a> will free() them for you.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">joiner</td><td>What to put between the other arguments. <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointer, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointer, or string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Other arguments to join, with <code>joiner</code> between them. <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointers, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointers, or strings, in any order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string.</p>
<p class="enddd"><em>You must <code>free()</code> the memory allocated by this function.</em> </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a753093cd4c872eed4b77feaa7816212b" title="Create an allocated string directly from Colr() arguments. ">colr</a> </dd>
<dd>
<a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ColorResult_example_8c-example.html#a2">ColorResult_example.c</a>, <a class="el" href="colr_join_example_8c-example.html#a0">colr_join_example.c</a>, and <a class="el" href="simple_example_8c-example.html#a13">simple_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="a0cf0fb81bc7b69d881907cae8a302bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf0fb81bc7b69d881907cae8a302bd9">&#9670;&nbsp;</a></span>colr_length</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_length</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_Generic( \</div><div class="line">        (x), \</div><div class="line">        <a class="code" href="colr_8h.html#structColorArg">ColorArg</a>: <a class="code" href="colr_8h.html#adaff727006f4c057aab75e55bfb473c4">ColorArg_length</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorResult">ColorResult</a>: <a class="code" href="colr_8h.html#a5169ef5d27a9c14bb765f7e7b70c9e2b">ColorResult_length</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorText">ColorText</a>: <a class="code" href="colr_8h.html#a412833a097b050c8ee99874c733bd030">ColorText_length</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorValue">ColorValue</a>: <a class="code" href="colr_8h.html#af891527249f068cfcef057313c522a42">ColorValue_length</a>, \</div><div class="line">        <span class="keywordtype">void</span>*: <a class="code" href="colr_8h.html#ab0be451277fc7e39aee0aa409c9d3f0c">_colr_ptr_length</a> \</div><div class="line">    )(x)</div><div class="ttc" id="colr_8h_html_structColorValue"><div class="ttname"><a href="colr_8h.html#structColorValue">ColorValue</a></div><div class="ttdoc">Holds a color type and it&amp;#39;s value. </div><div class="ttdef"><b>Definition:</b> colr.h:2712</div></div>
<div class="ttc" id="colr_8h_html_af891527249f068cfcef057313c522a42"><div class="ttname"><a href="colr_8h.html#af891527249f068cfcef057313c522a42">ColorValue_length</a></div><div class="ttdeci">size_t ColorValue_length(ArgType type, ColorValue cval)</div><div class="ttdoc">Returns the length in bytes needed to allocate a string (char*) built with ColorValue_to_esc() with t...</div><div class="ttdef"><b>Definition:</b> colr.c:6872</div></div>
<div class="ttc" id="colr_8h_html_a412833a097b050c8ee99874c733bd030"><div class="ttname"><a href="colr_8h.html#a412833a097b050c8ee99874c733bd030">ColorText_length</a></div><div class="ttdeci">size_t ColorText_length(ColorText ctext)</div><div class="ttdoc">Returns the length in bytes needed to allocate a string (char*) built with ColorText_to_str() with th...</div><div class="ttdef"><b>Definition:</b> colr.c:6118</div></div>
<div class="ttc" id="colr_8h_html_ab0be451277fc7e39aee0aa409c9d3f0c"><div class="ttname"><a href="colr_8h.html#ab0be451277fc7e39aee0aa409c9d3f0c">_colr_ptr_length</a></div><div class="ttdeci">size_t _colr_ptr_length(void *p)</div><div class="ttdoc">Get the size, in bytes, needed to convert a ColorArg, ColorResult, ColorText, or string (char*) into ...</div><div class="ttdef"><b>Definition:</b> colr.c:4757</div></div>
<div class="ttc" id="colr_8h_html_adaff727006f4c057aab75e55bfb473c4"><div class="ttname"><a href="colr_8h.html#adaff727006f4c057aab75e55bfb473c4">ColorArg_length</a></div><div class="ttdeci">size_t ColorArg_length(ColorArg carg)</div><div class="ttdoc">Returns the length in bytes needed to allocate a string (char*) built with ColorArg_to_esc(). </div><div class="ttdef"><b>Definition:</b> colr.c:5342</div></div>
<div class="ttc" id="colr_8h_html_structColorResult"><div class="ttname"><a href="colr_8h.html#structColorResult">ColorResult</a></div><div class="ttdoc">Holds a string (char*) that was definitely allocated by Colr. </div><div class="ttdef"><b>Definition:</b> colr.h:2747</div></div>
<div class="ttc" id="colr_8h_html_structColorArg"><div class="ttname"><a href="colr_8h.html#structColorArg">ColorArg</a></div><div class="ttdoc">Holds an ArgType, and a ColorValue. </div><div class="ttdef"><b>Definition:</b> colr.h:2737</div></div>
<div class="ttc" id="colr_8h_html_a5169ef5d27a9c14bb765f7e7b70c9e2b"><div class="ttname"><a href="colr_8h.html#a5169ef5d27a9c14bb765f7e7b70c9e2b">ColorResult_length</a></div><div class="ttdeci">size_t ColorResult_length(ColorResult cres)</div><div class="ttdoc">Return the length in bytes (including the null-terminator), that is needed to store the return from C...</div><div class="ttdef"><b>Definition:</b> colr.c:5858</div></div>
<div class="ttc" id="colr_8h_html_structColorText"><div class="ttname"><a href="colr_8h.html#structColorText">ColorText</a></div><div class="ttdoc">Holds a string of text, and optional fore, back, and style ColorArgs. </div><div class="ttdef"><b>Definition:</b> colr.h:2759</div></div>
</div><!-- fragment -->
<p>Calls the &lt;type&gt;_length functions for the supported types. </p>
<p>If a <code>void</code> pointer is given, <a class="el" href="colr_8h.html#ab0be451277fc7e39aee0aa409c9d3f0c" title="Get the size, in bytes, needed to convert a ColorArg, ColorResult, ColorText, or string (char*) into ...">_colr_ptr_length()</a> is called on it to determine the length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A supported type to build a string from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a373daeb0be048e4631ab04c445414362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a373daeb0be048e4631ab04c445414362">&#9670;&nbsp;</a></span>Colr_ljust</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Colr_ljust</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">text, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">justwidth, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="colr_8h.html#ab408d87cce896acccb75357acca8ade4">ColorText_set_just</a>( \</div><div class="line">        <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(text, __VA_ARGS__), \</div><div class="line">        (<a class="code" href="colr_8h.html#structColorJustify">ColorJustify</a>){.method=JUST_LEFT, .width=justwidth, .padchar=<span class="charliteral">&#39; &#39;</span>} \</div><div class="line">    )</div><div class="ttc" id="colr_8h_html_ab408d87cce896acccb75357acca8ade4"><div class="ttname"><a href="colr_8h.html#ab408d87cce896acccb75357acca8ade4">ColorText_set_just</a></div><div class="ttdeci">ColorText * ColorText_set_just(ColorText *ctext, ColorJustify cjust)</div><div class="ttdoc">Set the ColorJustify method for a ColorText, and return the ColorText. </div><div class="ttdef"><b>Definition:</b> colr.c:6189</div></div>
<div class="ttc" id="colr_8h_html_structColorJustify"><div class="ttname"><a href="colr_8h.html#structColorJustify">ColorJustify</a></div><div class="ttdoc">Holds a string justification method, width, and padding character for ColorTexts. ...</div><div class="ttdef"><b>Definition:</b> colr.h:2680</div></div>
<div class="ttc" id="colr_8h_html_ade1c77f81a0fd49f7895598cbd9ac76c"><div class="ttname"><a href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a></div><div class="ttdeci">#define Colr(text,...)</div><div class="ttdoc">Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...</div><div class="ttdef"><b>Definition:</b> colr.h:751</div></div>
</div><!-- fragment -->
<p>Sets the JustifyMethod for a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> while allocating it. </p>
<p>This is like <a class="el" href="colr_8h.html#a78b7b18de61f45afd19ca506ccc33779" title="Sets the JustifyMethod for a ColorText while allocating it. ">Colr_ljust_char()</a>, except is uses space as the default character.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>Text to colorize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">justwidth</td><td>Width for justification. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Fore, back, or style ColorArgs for <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.</p>
<p class="enddd">If used inside of the <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a>, <a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465" title="Like colr_cat(), but returns an allocated ColorResult that the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros will automatically free(). ">Colr_cat()</a>, and <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> macros, <em>they will <code>free()</code> the result</em>. Otherwise, <em>you are responsible for calling <code>free()</code></em>. </p>
</dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#Colr_ljust-example" id="Colr_ljust-example" class="diamond-bullet">&#160;</a> Colr_ljust example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* justified = <a class="code" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa">colr_cat</a>(<a class="code" href="colr_8h.html#a373daeb0be048e4631ab04c445414362">Colr_ljust</a>(<span class="stringliteral">&quot;This.&quot;</span>, 8, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED), <a class="code" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8">back</a>(WHITE)));</div><div class="line">assert(justified);</div><div class="line"><span class="comment">// The string still has codes, but only 3 spaces were added.</span></div><div class="line">assert(<a class="code" href="colr_8c.html#a7dd712bd8253271f0c88158db791c8bf">colr_str_ends_with</a>(justified, <span class="stringliteral">&quot;   &quot;</span>));</div><div class="line"><span class="comment">// It was &quot;justified&quot; to 8 characters long, but it is well over that.</span></div><div class="line">assert(strlen(justified) &gt; 8);</div><div class="line">printf(<span class="stringliteral">&quot;&#39;%s&#39;\n&quot;</span>, justified);</div><div class="line">free(justified);</div></div><!-- fragment --> </div> <dl><dt><b>Examples: </b></dt><dd><a class="el" href="Colr_example_8c-example.html#a4">Colr_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="a78b7b18de61f45afd19ca506ccc33779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b7b18de61f45afd19ca506ccc33779">&#9670;&nbsp;</a></span>Colr_ljust_char</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Colr_ljust_char</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">text, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">justwidth, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="colr_8h.html#ab408d87cce896acccb75357acca8ade4">ColorText_set_just</a>( \</div><div class="line">        <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(text, __VA_ARGS__), \</div><div class="line">        (<a class="code" href="colr_8h.html#structColorJustify">ColorJustify</a>){.method=JUST_LEFT, .width=justwidth, .padchar=c} \</div><div class="line">    )</div><div class="ttc" id="colr_8h_html_ab408d87cce896acccb75357acca8ade4"><div class="ttname"><a href="colr_8h.html#ab408d87cce896acccb75357acca8ade4">ColorText_set_just</a></div><div class="ttdeci">ColorText * ColorText_set_just(ColorText *ctext, ColorJustify cjust)</div><div class="ttdoc">Set the ColorJustify method for a ColorText, and return the ColorText. </div><div class="ttdef"><b>Definition:</b> colr.c:6189</div></div>
<div class="ttc" id="colr_8h_html_structColorJustify"><div class="ttname"><a href="colr_8h.html#structColorJustify">ColorJustify</a></div><div class="ttdoc">Holds a string justification method, width, and padding character for ColorTexts. ...</div><div class="ttdef"><b>Definition:</b> colr.h:2680</div></div>
<div class="ttc" id="colr_8h_html_ade1c77f81a0fd49f7895598cbd9ac76c"><div class="ttname"><a href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a></div><div class="ttdeci">#define Colr(text,...)</div><div class="ttdoc">Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...</div><div class="ttdef"><b>Definition:</b> colr.h:751</div></div>
</div><!-- fragment -->
<p>Sets the JustifyMethod for a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> while allocating it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>Text to colorize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">justwidth</td><td>Width for justification. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The character to pad with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Fore, back, or style ColorArgs for <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.</p>
<p class="enddd">If used inside of the <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a>, <a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465" title="Like colr_cat(), but returns an allocated ColorResult that the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros will automatically free(). ">Colr_cat()</a>, and <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> macros, <em>they will <code>free()</code> the result</em>. Otherwise, <em>you are responsible for calling <code>free()</code></em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a373daeb0be048e4631ab04c445414362" title="Sets the JustifyMethod for a ColorText while allocating it. ">Colr_ljust</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#Colr_ljust_char-example" id="Colr_ljust_char-example" class="diamond-bullet">&#160;</a> Colr_ljust_char example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* justified = <a class="code" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa">colr_cat</a>(<a class="code" href="colr_8h.html#a78b7b18de61f45afd19ca506ccc33779">Colr_ljust_char</a>(<span class="stringliteral">&quot;This.&quot;</span>, 8, <span class="charliteral">&#39; &#39;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED), <a class="code" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8">back</a>(WHITE)));</div><div class="line">assert(justified);</div><div class="line"><span class="comment">// The string still has codes, but only 3 spaces were added.</span></div><div class="line">assert(<a class="code" href="colr_8c.html#a7dd712bd8253271f0c88158db791c8bf">colr_str_ends_with</a>(justified, <span class="stringliteral">&quot;   &quot;</span>));</div><div class="line"><span class="comment">// It was &quot;justified&quot; to 8 characters long, but it is well over that.</span></div><div class="line">assert(strlen(justified) &gt; 8);</div><div class="line">printf(<span class="stringliteral">&quot;&#39;%s&#39;\n&quot;</span>, justified);</div><div class="line">free(justified);</div></div><!-- fragment --> </div> 
</div>
</div>
<a id="af2011f1f6c35bc63ca0cb23b9b893f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2011f1f6c35bc63ca0cb23b9b893f61">&#9670;&nbsp;</a></span>colr_max</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_max</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(a &gt; b ? a : b)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro for <code>(a &gt; b ? a : b)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First value to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second value to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>a</code> if <code>a &gt; b</code>, otherwise <code>b</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a412833a097b050c8ee99874c733bd030">ColorText_length()</a>.</p>

</div>
</div>
<a id="a85593e2253c99264904a467f1427e599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85593e2253c99264904a467f1427e599">&#9670;&nbsp;</a></span>colr_print</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_print</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> { \</div><div class="line">        char* _c_p_s = <a class="code" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa">colr_cat</a>(__VA_ARGS__); \</div><div class="line">        if (!_c_p_s) <span class="keywordflow">break</span>; \</div><div class="line">        printf(<span class="stringliteral">&quot;%s&quot;</span>, _c_p_s); \</div><div class="line">        colr_free(_c_p_s); \</div><div class="line">    } <span class="keywordflow">while</span> (0)</div><div class="ttc" id="colr_8h_html_a8e2c8bf2819cb36b1a34396a65b51faa"><div class="ttname"><a href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa">colr_cat</a></div><div class="ttdeci">#define colr_cat(...)</div><div class="ttdoc">Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...</div><div class="ttdef"><b>Definition:</b> colr.h:1097</div></div>
</div><!-- fragment -->
<p>Create a string from a <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a> call, print it to stdout (without a newline), and free it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Arguments for <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c188d16f60b7e296bd71ac95d8ec508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c188d16f60b7e296bd71ac95d8ec508">&#9670;&nbsp;</a></span>colr_printf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_printf</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#a04ebe7aa43eab3e7e0bd9d769d2074ac">colr_printf_macro</a>(printf, __VA_ARGS__)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure <a class="el" href="colr_8h.html#aaaf134ca9a2188d83171fe91948354d9" title="Registers COLR_FMT_CHAR to handle Colr objects in the printf-family functions. ">colr_printf_register()</a> has been called, and then call <code>printf</code>. </p>
<p>Will call <code>free()</code> on any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointer, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> pointer, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointer, or the strings created by them.</p>
<dl class="section attention"><dt>Attention</dt><dd>This feature uses a GNU extension, and is only available when COLR_GNU is defined. See the documentation for COLR_GNU.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td><p class="starttd">Arguments for <code>printf</code>.</p>
<p class="endtd"><em><a class="el" href="colr_8h.html#a76eae619668e01987653932a7492fd94" title="Calls the &lt;type&gt;_free functions for the supported types. ">colr_free()</a> will be called on any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointer passed to this function</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Same as <code>printf</code>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="colr_printf_example_8c-example.html#a0">colr_printf_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="a04ebe7aa43eab3e7e0bd9d769d2074ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04ebe7aa43eab3e7e0bd9d769d2074ac">&#9670;&nbsp;</a></span>colr_printf_macro</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_printf_macro</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">func, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">__extension__({ \</div><div class="line">        _Pragma(<span class="stringliteral">&quot;GCC diagnostic push&quot;</span>); \</div><div class="line">        _Pragma(<span class="stringliteral">&quot;GCC diagnostic ignored \&quot;-Wformat=\&quot;&quot;</span>); \</div><div class="line">        _Pragma(<span class="stringliteral">&quot;GCC diagnostic ignored \&quot;-Wformat-extra-args\&quot;&quot;</span>); \</div><div class="line">        _Pragma(<span class="stringliteral">&quot;clang diagnostic push&quot;</span>); \</div><div class="line">        _Pragma(<span class="stringliteral">&quot;clang diagnostic ignored \&quot;-Wformat-invalid-specifier\&quot;&quot;</span>); \</div><div class="line">        colr_printf_register(); \</div><div class="line">        int _c_p_m_ret = func(__VA_ARGS__); \</div><div class="line">        _Pragma(<span class="stringliteral">&quot;clang diagnostic pop&quot;</span>); \</div><div class="line">        _Pragma(<span class="stringliteral">&quot;GCC diagnostic pop&quot;</span>); \</div><div class="line">        _c_p_m_ret; \</div><div class="line">    })</div></div><!-- fragment -->
<p>Calls one of the printf-family functions, with format warnings disabled for the call, and returns the result. </p>
<p>This function also ensures that <a class="el" href="colr_8h.html#aaaf134ca9a2188d83171fe91948354d9" title="Registers COLR_FMT_CHAR to handle Colr objects in the printf-family functions. ">colr_printf_register()</a> is called, which ensures that register_printf_specifier() is called one time.</p>
<dl class="section attention"><dt>Attention</dt><dd>This feature uses a GNU extension, and is only available when COLR_GNU is defined. See the documentation for COLR_GNU.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The standard printf function to call, with a return type of <code>int</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Arguments for the printf function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Same as <code>func(...)</code>. </dd></dl>

</div>
</div>
<a id="af050c0377cbd1960fa057dc160da3c34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af050c0377cbd1960fa057dc160da3c34">&#9670;&nbsp;</a></span>colr_puts</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_puts</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> { \</div><div class="line">        char* _c_p_s = <a class="code" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa">colr_cat</a>(__VA_ARGS__); \</div><div class="line">        if (!_c_p_s) <span class="keywordflow">break</span>; \</div><div class="line">        puts(_c_p_s); \</div><div class="line">        colr_free(_c_p_s); \</div><div class="line">    } <span class="keywordflow">while</span> (0)</div><div class="ttc" id="colr_8h_html_a8e2c8bf2819cb36b1a34396a65b51faa"><div class="ttname"><a href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa">colr_cat</a></div><div class="ttdeci">#define colr_cat(...)</div><div class="ttdoc">Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...</div><div class="ttdef"><b>Definition:</b> colr.h:1097</div></div>
</div><!-- fragment -->
<p>Create a string from a <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a> call, print it (with a newline), and free it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Arguments for <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="colr_cat_example_8c-example.html#a8">colr_cat_example.c</a>, <a class="el" href="colr_join_example_8c-example.html#a6">colr_join_example.c</a>, and <a class="el" href="simple_example_8c-example.html#a0">simple_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="a4559cb7ed508a538687727ccd4586ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4559cb7ed508a538687727ccd4586ccb">&#9670;&nbsp;</a></span>colr_replace</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_replace</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">target, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">repl&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a substring in <code>s</code> with another string, <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> string, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> string, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> string. </p>
<p>If a string (<code>char*</code>) is used as <code>target</code> and <code>repl</code>, this is just a wrapper around <a class="el" href="colr_8h.html#a2144034980aea6427fbc9bdf70e5b8c3" title="Replaces the first substring found in a string (char*). ">colr_str_replace()</a>.</p>
<p>If <code>target</code> is a string (<code>char*</code>), this is a plain string-replace.</p>
<p>If <code>target</code> is a regex pattern (<code>regex_t</code>), it's regex match (<code>regmatch_t</code>) will be used to find a target string to replace in <code>s</code>.</p>
<p>If <code>target</code> is a regex match (<code>regmatch_t</code>), it's offsets will be used to find a target string in <code>s</code>.</p>
<p>If <code>target</code> is a <code>NULL</code>-terminated array of regex matches (<code>regmatch_t**</code>), each match will be replaced in the target string, <code>s</code>.</p>
<p>There is no difference between <a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace()</a> and <a class="el" href="colr_8h.html#a1ca60a944b824cd8049451792904c2eb" title="Replace all substrings in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace_all()</a> when a <code>NULL</code>-terminated array of regex matches (<code>regmatch_t**</code>) is used.</p>
<p>If a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> is used as <code>repl</code>, the appropriate colr_str_replace_&lt;types&gt; function is called. The function will create a string of escape-codes/text to be used as a replacement.</p>
<p>If <code>repl</code> is <code>NULL</code>, then an empty string (<code>""</code>) is used as the replacement, which causes the <code>target</code> string to be removed.</p>
<p>If you would like to replace <b>all</b> occurrences of the substring, use <a class="el" href="colr_8h.html#a1ca60a944b824cd8049451792904c2eb" title="Replace all substrings in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace_all()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">The string to operate on.</p>
<p class="endtd"><em>Must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>A target string, regex pattern (<code>regex_t</code>), or regex match (<code>regmatch_t</code>) to replace in <code>s</code>. If a string is given, it <em>must be null-terminated</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td><p class="starttd">A string, <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to replace the target string with. If this is <code>NULL</code>, then an empty string is used (<code>""</code>) as the replacement.</p>
<p class="endtd"><em><a class="el" href="colr_8h.html#a76eae619668e01987653932a7492fd94" title="Calls the &lt;type&gt;_free functions for the supported types. ">colr_free()</a> will be called on any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointer passed to this function</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a1ca60a944b824cd8049451792904c2eb" title="Replace all substrings in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace_all</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a34553de01998eff17512d7ef1e9f3fa0" title="Replace all matches to a regex pattern string (char*) in s with another string, ColorArg string...">colr_replace_re_all</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2144034980aea6427fbc9bdf70e5b8c3" title="Replaces the first substring found in a string (char*). ">colr_str_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#aa8b61a4cadcf73e21eee109623695bad" title="Replace a substring in a string (char*) with a ColorArg&#39;s string result. ">colr_str_replace_ColorArg</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a136d15edf2f804c89cee619bb811ef3a" title="Replace a substring in a string (char*) with a ColorResult&#39;s string result. ">colr_str_replace_ColorResult</a> </dd>
<dd>
<a class="el" href="colr_8h.html#aaee8d79a90917974ee4537705e34fd76" title="Replace a substring in a string (char*) with a ColorText&#39;s string result. ">colr_str_replace_ColorText</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a63621c6749d8219112ff51ebf0ecb22a" title="Replaces regex patterns in a string (char*). ">colr_str_replace_re_pat</a> </dd>
<dd>
<a class="el" href="colr_8h.html#adecbe2f1e87613b6f4a51158325dd4f7" title="Replace regex patterns in a string (char*) with a ColorArg&#39;s string result. ">colr_str_replace_re_pat_ColorArg</a> </dd>
<dd>
<a class="el" href="colr_8h.html#abcd756c82acab9505343b614d52c0b19" title="Replace regex patterns in a string (char*) with a ColorResult&#39;s string result. ">colr_str_replace_re_pat_ColorResult</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a6f8b04b6d851f26304183d1111b8f0dc" title="Replace regex patterns in a string (char*) with a ColorText&#39;s string result. ">colr_str_replace_re_pat_ColorText</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2fbc36f0f7aba3aa0616437f937efd20" title="Replaces substrings from a single regex match (regmatch_t*) in a string (char*). ">colr_str_replace_re_match</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a0d4cbd6a8fd3cef76f07b705b09d2a54" title="Replace substrings from a regex match (regmatch_t*) in a string (char*) with a ColorArg&#39;s string resu...">colr_str_replace_re_match_ColorArg</a> </dd>
<dd>
<a class="el" href="colr_8h.html#ac092f944961dddc6574a6c55e6e878b0" title="Replace substrings from a regex match (regmatch_t*) in a string (char*) with a ColorResult&#39;s string r...">colr_str_replace_re_match_ColorResult</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a4d954398333472c1436f9bc051f46392" title="Replace substrings from a regex match (regmatch_t*) in a string (char*) with a ColorText&#39;s string res...">colr_str_replace_re_match_ColorText</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="colr_replace_example_8c-example.html#a0">colr_replace_example.c</a>, and <a class="el" href="simple_example_8c-example.html#a14">simple_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="a1ca60a944b824cd8049451792904c2eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca60a944b824cd8049451792904c2eb">&#9670;&nbsp;</a></span>colr_replace_all</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_replace_all</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">target, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">repl&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_Generic( \</div><div class="line">        (repl), \</div><div class="line">        <span class="keywordtype">char</span>*: _Generic( \</div><div class="line">            (target), \</div><div class="line">                <span class="keywordtype">char</span>* : <a class="code" href="colr_8h.html#abb81a3339840e1f527463eaddf994d8e">colr_str_replace_all</a>, \</div><div class="line">                regex_t* : <a class="code" href="colr_8h.html#afd19623913d27e2d9a5af3496a478c2b">colr_str_replace_re_pat_all</a>, \</div><div class="line">                regmatch_t** : <a class="code" href="colr_8h.html#a8c72d363d7f87e2a7546202b439557e1">colr_str_replace_re_matches</a> \</div><div class="line">            ), \</div><div class="line">        <a class="code" href="colr_8h.html#structColorArg">ColorArg</a>*: _Generic( \</div><div class="line">            (target), \</div><div class="line">                <span class="keywordtype">char</span>* : <a class="code" href="colr_8h.html#af7c01a492bcbda6cf93705bff0cb0dbe">colr_str_replace_all_ColorArg</a>, \</div><div class="line">                regex_t* : <a class="code" href="colr_8h.html#a090ba95c4560134ef9c2807eff6a0ea1">colr_str_replace_re_pat_all_ColorArg</a>, \</div><div class="line">                regmatch_t** : <a class="code" href="colr_8h.html#a75b2cdee697818e2f9f38ec7eac98bcb">colr_str_replace_re_matches_ColorArg</a> \</div><div class="line">            ), \</div><div class="line">        <a class="code" href="colr_8h.html#structColorResult">ColorResult</a>*: _Generic( \</div><div class="line">            (target), \</div><div class="line">                <span class="keywordtype">char</span>* : <a class="code" href="colr_8h.html#a53fa120c1074c836f65b4aace67d0c83">colr_str_replace_all_ColorResult</a>, \</div><div class="line">                regex_t* : <a class="code" href="colr_8h.html#af083c2e1867ecaad0ae38a1324c915ac">colr_str_replace_re_pat_all_ColorResult</a>, \</div><div class="line">                regmatch_t** : <a class="code" href="colr_8h.html#a4d4bb71015338108d86fcf47317cc5ff">colr_str_replace_re_matches_ColorResult</a> \</div><div class="line">            ), \</div><div class="line">        <a class="code" href="colr_8h.html#structColorText">ColorText</a>*: _Generic( \</div><div class="line">            (target), \</div><div class="line">                <span class="keywordtype">char</span>* : <a class="code" href="colr_8h.html#a73789c11eaeb5a36b5f97556103a108d">colr_str_replace_all_ColorText</a>, \</div><div class="line">                regex_t* : <a class="code" href="colr_8h.html#ab9c4a5c34b26473dc45f93ce2c66faf1">colr_str_replace_re_pat_all_ColorText</a>, \</div><div class="line">                regmatch_t** : <a class="code" href="colr_8h.html#aa4fe38cc205cbd49b2f8477744574294">colr_str_replace_re_matches_ColorText</a> \</div><div class="line">            ) \</div><div class="line">    )(s, target, repl)</div><div class="ttc" id="colr_8h_html_a73789c11eaeb5a36b5f97556103a108d"><div class="ttname"><a href="colr_8h.html#a73789c11eaeb5a36b5f97556103a108d">colr_str_replace_all_ColorText</a></div><div class="ttdeci">char * colr_str_replace_all_ColorText(const char *restrict s, const char *restrict target, ColorText *repl)</div><div class="ttdoc">Replace all substrings in a string (char*) with a ColorText&amp;#39;s string result. </div><div class="ttdef"><b>Definition:</b> colr.c:2580</div></div>
<div class="ttc" id="colr_8h_html_a53fa120c1074c836f65b4aace67d0c83"><div class="ttname"><a href="colr_8h.html#a53fa120c1074c836f65b4aace67d0c83">colr_str_replace_all_ColorResult</a></div><div class="ttdeci">char * colr_str_replace_all_ColorResult(const char *restrict s, const char *restrict target, ColorResult *repl)</div><div class="ttdoc">Replace all substrings in a string (char*) with a ColorResult&amp;#39;s string result. </div><div class="ttdef"><b>Definition:</b> colr.c:2553</div></div>
<div class="ttc" id="colr_8h_html_a4d4bb71015338108d86fcf47317cc5ff"><div class="ttname"><a href="colr_8h.html#a4d4bb71015338108d86fcf47317cc5ff">colr_str_replace_re_matches_ColorResult</a></div><div class="ttdeci">char * colr_str_replace_re_matches_ColorResult(const char *restrict s, regmatch_t **matches, ColorResult *repl)</div><div class="ttdoc">Replace substrings from an array of regex matches (regmatch_t**) in a string (char*) with a ColorResu...</div><div class="ttdef"><b>Definition:</b> colr.c:3409</div></div>
<div class="ttc" id="colr_8h_html_a75b2cdee697818e2f9f38ec7eac98bcb"><div class="ttname"><a href="colr_8h.html#a75b2cdee697818e2f9f38ec7eac98bcb">colr_str_replace_re_matches_ColorArg</a></div><div class="ttdeci">char * colr_str_replace_re_matches_ColorArg(const char *restrict s, regmatch_t **matches, ColorArg *repl)</div><div class="ttdoc">Replace substrings from an array of regex matches (regmatch_t**) in a string (char*) with a ColorArg&amp;#39;...</div><div class="ttdef"><b>Definition:</b> colr.c:3378</div></div>
<div class="ttc" id="colr_8h_html_afd19623913d27e2d9a5af3496a478c2b"><div class="ttname"><a href="colr_8h.html#afd19623913d27e2d9a5af3496a478c2b">colr_str_replace_re_pat_all</a></div><div class="ttdeci">char * colr_str_replace_re_pat_all(const char *restrict s, regex_t *repattern, const char *restrict repl)</div><div class="ttdoc">Replaces all matches to a regex pattern in a string (char*). </div><div class="ttdef"><b>Definition:</b> colr.c:3640</div></div>
<div class="ttc" id="colr_8h_html_af7c01a492bcbda6cf93705bff0cb0dbe"><div class="ttname"><a href="colr_8h.html#af7c01a492bcbda6cf93705bff0cb0dbe">colr_str_replace_all_ColorArg</a></div><div class="ttdeci">char * colr_str_replace_all_ColorArg(const char *restrict s, const char *restrict target, ColorArg *repl)</div><div class="ttdoc">Replace all substrings in a string (char*) with a ColorArg&amp;#39;s string result. </div><div class="ttdef"><b>Definition:</b> colr.c:2524</div></div>
<div class="ttc" id="colr_8h_html_abb81a3339840e1f527463eaddf994d8e"><div class="ttname"><a href="colr_8h.html#abb81a3339840e1f527463eaddf994d8e">colr_str_replace_all</a></div><div class="ttdeci">char * colr_str_replace_all(const char *restrict s, const char *restrict target, const char *restrict repl)</div><div class="ttdoc">Replaces the first substring found in a string (char*). </div><div class="ttdef"><b>Definition:</b> colr.c:2501</div></div>
<div class="ttc" id="colr_8h_html_af083c2e1867ecaad0ae38a1324c915ac"><div class="ttname"><a href="colr_8h.html#af083c2e1867ecaad0ae38a1324c915ac">colr_str_replace_re_pat_all_ColorResult</a></div><div class="ttdeci">char * colr_str_replace_re_pat_all_ColorResult(const char *restrict s, regex_t *repattern, ColorResult *repl)</div><div class="ttdoc">Replace all matches to a regex pattern in a string (char*) with a ColorResult&amp;#39;s string result...</div><div class="ttdef"><b>Definition:</b> colr.c:3705</div></div>
<div class="ttc" id="colr_8h_html_aa4fe38cc205cbd49b2f8477744574294"><div class="ttname"><a href="colr_8h.html#aa4fe38cc205cbd49b2f8477744574294">colr_str_replace_re_matches_ColorText</a></div><div class="ttdeci">char * colr_str_replace_re_matches_ColorText(const char *restrict s, regmatch_t **matches, ColorText *repl)</div><div class="ttdoc">Replace substrings from an array of regex matches (regmatch_t**) in a string (char*) with a ColorText...</div><div class="ttdef"><b>Definition:</b> colr.c:3439</div></div>
<div class="ttc" id="colr_8h_html_structColorResult"><div class="ttname"><a href="colr_8h.html#structColorResult">ColorResult</a></div><div class="ttdoc">Holds a string (char*) that was definitely allocated by Colr. </div><div class="ttdef"><b>Definition:</b> colr.h:2747</div></div>
<div class="ttc" id="colr_8h_html_structColorArg"><div class="ttname"><a href="colr_8h.html#structColorArg">ColorArg</a></div><div class="ttdoc">Holds an ArgType, and a ColorValue. </div><div class="ttdef"><b>Definition:</b> colr.h:2737</div></div>
<div class="ttc" id="colr_8h_html_ab9c4a5c34b26473dc45f93ce2c66faf1"><div class="ttname"><a href="colr_8h.html#ab9c4a5c34b26473dc45f93ce2c66faf1">colr_str_replace_re_pat_all_ColorText</a></div><div class="ttdeci">char * colr_str_replace_re_pat_all_ColorText(const char *restrict s, regex_t *repattern, ColorText *repl)</div><div class="ttdoc">Replace all matches to a regex pattern in a string (char*) with a ColorText&amp;#39;s string result...</div><div class="ttdef"><b>Definition:</b> colr.c:3734</div></div>
<div class="ttc" id="colr_8h_html_structColorText"><div class="ttname"><a href="colr_8h.html#structColorText">ColorText</a></div><div class="ttdoc">Holds a string of text, and optional fore, back, and style ColorArgs. </div><div class="ttdef"><b>Definition:</b> colr.h:2759</div></div>
<div class="ttc" id="colr_8h_html_a090ba95c4560134ef9c2807eff6a0ea1"><div class="ttname"><a href="colr_8h.html#a090ba95c4560134ef9c2807eff6a0ea1">colr_str_replace_re_pat_all_ColorArg</a></div><div class="ttdeci">char * colr_str_replace_re_pat_all_ColorArg(const char *restrict s, regex_t *repattern, ColorArg *repl)</div><div class="ttdoc">Replace all matches to a regex pattern in a string (char*) with a ColorArg&amp;#39;s string result...</div><div class="ttdef"><b>Definition:</b> colr.c:3675</div></div>
<div class="ttc" id="colr_8h_html_a8c72d363d7f87e2a7546202b439557e1"><div class="ttname"><a href="colr_8h.html#a8c72d363d7f87e2a7546202b439557e1">colr_str_replace_re_matches</a></div><div class="ttdeci">char * colr_str_replace_re_matches(const char *restrict s, regmatch_t **matches, const char *restrict repl)</div><div class="ttdoc">Replaces substrings from an array of regex match (regmatch_t*) in a string (char*). </div><div class="ttdef"><b>Definition:</b> colr.c:3309</div></div>
</div><!-- fragment -->
<p>Replace all substrings in <code>s</code> with another string, <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> string, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> string, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> string. </p>
<p>If a string (<code>char*</code>) is used as <code>target</code> and <code>repl</code>, this is just a wrapper around <a class="el" href="colr_8h.html#a2144034980aea6427fbc9bdf70e5b8c3" title="Replaces the first substring found in a string (char*). ">colr_str_replace()</a>.</p>
<p>If <code>target</code> is a string (<code>char*</code>), this is a plain string-replace.</p>
<p>If <code>target</code> is a regex pattern (<code>regex_t</code>), it's regex match (<code>regmatch_t</code>) will be used to find a target string to replace in <code>s</code>.</p>
<p>If <code>target</code> is a <code>NULL</code>-terminated array of regex matches (<code>regmatch_t**</code>), each match will be replaced in the target string, <code>s</code>.</p>
<p>There is no difference between <a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace()</a> and <a class="el" href="colr_8h.html#a1ca60a944b824cd8049451792904c2eb" title="Replace all substrings in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace_all()</a> when a <code>NULL</code>-terminated array of regex matches (<code>regmatch_t**</code>) is used.</p>
<p>If a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> is used as <code>repl</code>, the appropriate colr_str_replace_&lt;types&gt; function is called. The function will create a string of escape-codes/text to be used as a replacement.</p>
<p>If <code>repl</code> is <code>NULL</code>, then an empty string (<code>""</code>) is used as the replacement, which causes the <code>target</code> string to be removed.</p>
<p>If you would like to replace <b>only the first</b> occurrence of the substring, use <a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">The string to operate on.</p>
<p class="endtd"><em>Must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>A target string, or regex pattern (<code>regex_t</code>) to replace in <code>s</code>. If a string is given, it <em>must be null-terminated</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td><p class="starttd">A string, <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to replace the target string with. If this is <code>NULL</code>, then an empty string is used (<code>""</code>) as the replacement.</p>
<p class="endtd"><em><a class="el" href="colr_8h.html#a76eae619668e01987653932a7492fd94" title="Calls the &lt;type&gt;_free functions for the supported types. ">colr_free()</a> will be called on any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointer passed to this function</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a34553de01998eff17512d7ef1e9f3fa0" title="Replace all matches to a regex pattern string (char*) in s with another string, ColorArg string...">colr_replace_re_all</a> </dd>
<dd>
<a class="el" href="colr_8h.html#abb81a3339840e1f527463eaddf994d8e" title="Replaces the first substring found in a string (char*). ">colr_str_replace_all</a> </dd>
<dd>
<a class="el" href="colr_8h.html#af7c01a492bcbda6cf93705bff0cb0dbe" title="Replace all substrings in a string (char*) with a ColorArg&#39;s string result. ">colr_str_replace_all_ColorArg</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a53fa120c1074c836f65b4aace67d0c83" title="Replace all substrings in a string (char*) with a ColorResult&#39;s string result. ">colr_str_replace_all_ColorResult</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a73789c11eaeb5a36b5f97556103a108d" title="Replace all substrings in a string (char*) with a ColorText&#39;s string result. ">colr_str_replace_all_ColorText</a> </dd>
<dd>
<a class="el" href="colr_8h.html#afd19623913d27e2d9a5af3496a478c2b" title="Replaces all matches to a regex pattern in a string (char*). ">colr_str_replace_re_pat_all</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a090ba95c4560134ef9c2807eff6a0ea1" title="Replace all matches to a regex pattern in a string (char*) with a ColorArg&#39;s string result...">colr_str_replace_re_pat_all_ColorArg</a> </dd>
<dd>
<a class="el" href="colr_8h.html#af083c2e1867ecaad0ae38a1324c915ac" title="Replace all matches to a regex pattern in a string (char*) with a ColorResult&#39;s string result...">colr_str_replace_re_pat_all_ColorResult</a> </dd>
<dd>
<a class="el" href="colr_8h.html#ab9c4a5c34b26473dc45f93ce2c66faf1" title="Replace all matches to a regex pattern in a string (char*) with a ColorText&#39;s string result...">colr_str_replace_re_pat_all_ColorText</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="colr_replace_all_example_8c-example.html#a0">colr_replace_all_example.c</a>, and <a class="el" href="simple_example_8c-example.html#a16">simple_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="a2262af7b2b1e9281272c63c85b9e7357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2262af7b2b1e9281272c63c85b9e7357">&#9670;&nbsp;</a></span>colr_replace_re</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_replace_re</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">target, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">repl, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">flags&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_Generic( \</div><div class="line">        (repl), \</div><div class="line">        <span class="keywordtype">char</span>*: <a class="code" href="colr_8h.html#a09db8190822ff7e7e712399680325e6a">colr_str_replace_re</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorArg">ColorArg</a>*: <a class="code" href="colr_8h.html#a78d58bde53845d6ab2c54e4ba0c68a3d">colr_str_replace_re_ColorArg</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorResult">ColorResult</a>*: <a class="code" href="colr_8h.html#a0376bed13e55acaca37e52c382044e1d">colr_str_replace_re_ColorResult</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorText">ColorText</a>*: <a class="code" href="colr_8h.html#ab8d6a10f70b435559656bbad0090d92d">colr_str_replace_re_ColorText</a> \</div><div class="line">    )(s, target, repl, flags)</div><div class="ttc" id="colr_8h_html_a09db8190822ff7e7e712399680325e6a"><div class="ttname"><a href="colr_8h.html#a09db8190822ff7e7e712399680325e6a">colr_str_replace_re</a></div><div class="ttdeci">char * colr_str_replace_re(const char *restrict s, const char *restrict pattern, const char *restrict repl, int re_flags)</div><div class="ttdoc">Replaces a substring from a regex pattern string (char*) in a string (char*). </div><div class="ttdef"><b>Definition:</b> colr.c:2800</div></div>
<div class="ttc" id="colr_8h_html_ab8d6a10f70b435559656bbad0090d92d"><div class="ttname"><a href="colr_8h.html#ab8d6a10f70b435559656bbad0090d92d">colr_str_replace_re_ColorText</a></div><div class="ttdeci">char * colr_str_replace_re_ColorText(const char *restrict s, const char *restrict pattern, ColorText *repl, int re_flags)</div><div class="ttdoc">Replace substrings from a regex pattern string (char*) in a string (char*) with a ColorText&amp;#39;s string ...</div><div class="ttdef"><b>Definition:</b> colr.c:3053</div></div>
<div class="ttc" id="colr_8h_html_structColorResult"><div class="ttname"><a href="colr_8h.html#structColorResult">ColorResult</a></div><div class="ttdoc">Holds a string (char*) that was definitely allocated by Colr. </div><div class="ttdef"><b>Definition:</b> colr.h:2747</div></div>
<div class="ttc" id="colr_8h_html_structColorArg"><div class="ttname"><a href="colr_8h.html#structColorArg">ColorArg</a></div><div class="ttdoc">Holds an ArgType, and a ColorValue. </div><div class="ttdef"><b>Definition:</b> colr.h:2737</div></div>
<div class="ttc" id="colr_8h_html_a0376bed13e55acaca37e52c382044e1d"><div class="ttname"><a href="colr_8h.html#a0376bed13e55acaca37e52c382044e1d">colr_str_replace_re_ColorResult</a></div><div class="ttdeci">char * colr_str_replace_re_ColorResult(const char *restrict s, const char *restrict pattern, ColorResult *repl, int re_flags)</div><div class="ttdoc">Replace substrings from a regex pattern string (char*) in a string (char*) with a ColorResult&amp;#39;s strin...</div><div class="ttdef"><b>Definition:</b> colr.c:3022</div></div>
<div class="ttc" id="colr_8h_html_structColorText"><div class="ttname"><a href="colr_8h.html#structColorText">ColorText</a></div><div class="ttdoc">Holds a string of text, and optional fore, back, and style ColorArgs. </div><div class="ttdef"><b>Definition:</b> colr.h:2759</div></div>
<div class="ttc" id="colr_8h_html_a78d58bde53845d6ab2c54e4ba0c68a3d"><div class="ttname"><a href="colr_8h.html#a78d58bde53845d6ab2c54e4ba0c68a3d">colr_str_replace_re_ColorArg</a></div><div class="ttdeci">char * colr_str_replace_re_ColorArg(const char *restrict s, const char *restrict pattern, ColorArg *repl, int re_flags)</div><div class="ttdoc">Replace substrings from a regex pattern string (char*) in a string (char*) with a ColorArg&amp;#39;s string r...</div><div class="ttdef"><b>Definition:</b> colr.c:2989</div></div>
</div><!-- fragment -->
<p>Replace a regex pattern string (<code>char*</code>) in <code>s</code> with another string, <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> string, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> string, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> string. </p>
<p>If a string (<code>char*</code>) is used as <code>repl</code>, this is just a wrapper around <a class="el" href="colr_8h.html#a09db8190822ff7e7e712399680325e6a" title="Replaces a substring from a regex pattern string (char*) in a string (char*). ">colr_str_replace_re()</a>.</p>
<p>If a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> is used as <code>repl</code>, the appropriate colr_str_replace_re_&lt;type&gt; function is called. The function will create a string of escape-codes/text to be used as a replacement.</p>
<p>If <code>repl</code> is <code>NULL</code>, then an empty string (<code>""</code>) is used as the replacement, which causes the <code>target</code> string to be removed.</p>
<p>If you would like to replace <b>all</b> occurrences of the substring, use <a class="el" href="colr_8h.html#a34553de01998eff17512d7ef1e9f3fa0" title="Replace all matches to a regex pattern string (char*) in s with another string, ColorArg string...">colr_replace_re_all()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">The string to operate on.</p>
<p class="endtd"><em>Must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>A regex pattern string (<code>char*</code>), regex pattern (<code>regex_t</code>), or regex match (<code>regmatch_t</code>) to replace in <code>s</code>. <br />
 If a string is given, it <em>must be null-terminated</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td><p class="starttd">A string, <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to replace the target string with. If this is <code>NULL</code>, then an empty string is used (<code>""</code>) as the replacement.</p>
<p class="endtd"><em><a class="el" href="colr_8h.html#a76eae619668e01987653932a7492fd94" title="Calls the &lt;type&gt;_free functions for the supported types. ">colr_free()</a> will be called on any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointer passed to this function</em>. </p>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Flags for <code>regcomp()</code>. <code>REG_EXTENDED</code> is always used, whether flags are provided or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a1ca60a944b824cd8049451792904c2eb" title="Replace all substrings in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace_all</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a34553de01998eff17512d7ef1e9f3fa0" title="Replace all matches to a regex pattern string (char*) in s with another string, ColorArg string...">colr_replace_re_all</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a09db8190822ff7e7e712399680325e6a" title="Replaces a substring from a regex pattern string (char*) in a string (char*). ">colr_str_replace_re</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a78d58bde53845d6ab2c54e4ba0c68a3d" title="Replace substrings from a regex pattern string (char*) in a string (char*) with a ColorArg&#39;s string r...">colr_str_replace_re_ColorArg</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a0376bed13e55acaca37e52c382044e1d" title="Replace substrings from a regex pattern string (char*) in a string (char*) with a ColorResult&#39;s strin...">colr_str_replace_re_ColorResult</a> </dd>
<dd>
<a class="el" href="colr_8h.html#ab8d6a10f70b435559656bbad0090d92d" title="Replace substrings from a regex pattern string (char*) in a string (char*) with a ColorText&#39;s string ...">colr_str_replace_re_ColorText</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_replace_re-example" id="colr_replace_re-example" class="diamond-bullet">&#160;</a> colr_replace_re example: </div><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="colr_8h.html">colr.h</a>&quot;</span></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div><div class="line">    <span class="keywordtype">char</span>* mystring = <span class="stringliteral">&quot;This is a foo line.&quot;</span>;</div><div class="line">    puts(mystring);</div><div class="line">    <span class="keywordtype">char</span>* replaced = <a class="code" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357">colr_replace_re</a>(mystring, <span class="stringliteral">&quot;fo{2}&quot;</span>, <span class="stringliteral">&quot;replaced&quot;</span>, 0);</div><div class="line">    <span class="keywordflow">if</span> (!replaced) <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    puts(replaced);</div><div class="line">    free(replaced);</div><div class="line"></div><div class="line">    <span class="comment">// ColorArgs.</span></div><div class="line">    replaced = <a class="code" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357">colr_replace_re</a>(mystring, <span class="stringliteral">&quot;f\\w\\w &quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED), 0);</div><div class="line">    <span class="keywordflow">if</span> (!replaced) <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    puts(replaced);</div><div class="line">    <span class="comment">// No reset code was appended to that last one.</span></div><div class="line">    printf(<span class="stringliteral">&quot;%s&quot;</span>, <a class="code" href="colr_8h.html#add86801c90ad7bd8359242a2c1ef1297">CODE_RESET_ALL</a>);</div><div class="line">    free(replaced);</div><div class="line"></div><div class="line">    <span class="comment">// ColorResults.</span></div><div class="line">    replaced = <a class="code" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357">colr_replace_re</a>(</div><div class="line">        mystring,</div><div class="line">        <span class="stringliteral">&quot;\\woo&quot;</span>,</div><div class="line">        <a class="code" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e">Colr_join</a>(<span class="stringliteral">&quot; &quot;</span>, <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;nicely&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED)), <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;colored&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(BLUE))),</div><div class="line">        0</div><div class="line">    );</div><div class="line">    <span class="keywordflow">if</span> (!replaced) <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    puts(replaced);</div><div class="line">    free(replaced);</div><div class="line"></div><div class="line">    <span class="comment">// ColorTexts.</span></div><div class="line">    replaced = <a class="code" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357">colr_replace_re</a>(mystring, <span class="stringliteral">&quot;f[a-z]{2}&quot;</span>, <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;styled&quot;</span>, <a class="code" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662">style</a>(UNDERLINE)) , 0);</div><div class="line">    <span class="keywordflow">if</span> (!replaced) <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    puts(replaced);</div><div class="line">    free(replaced);</div><div class="line">}</div></div><!-- fragment --> </div> <dl><dt><b>Examples: </b></dt><dd><a class="el" href="colr_replace_re_example_8c-example.html#a0">colr_replace_re_example.c</a>, and <a class="el" href="simple_example_8c-example.html#a15">simple_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="a34553de01998eff17512d7ef1e9f3fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34553de01998eff17512d7ef1e9f3fa0">&#9670;&nbsp;</a></span>colr_replace_re_all</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_replace_re_all</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">target, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">repl, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">flags&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_Generic( \</div><div class="line">        (repl), \</div><div class="line">        <span class="keywordtype">char</span>*: <a class="code" href="colr_8h.html#a232c65d12eb09d598eeb64490f39371c">colr_str_replace_re_all</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorArg">ColorArg</a>*: <a class="code" href="colr_8h.html#a577e45a5c233dd1b4774a9034b17e3eb">colr_str_replace_re_all_ColorArg</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorResult">ColorResult</a>*: <a class="code" href="colr_8h.html#a3e18a36736e5451529e80443cfb7b1fc">colr_str_replace_re_all_ColorResult</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorText">ColorText</a>*: <a class="code" href="colr_8h.html#a747e31fa3d8961e0bdd11eabd673accc">colr_str_replace_re_all_ColorText</a> \</div><div class="line">    )(s, target, repl, flags)</div><div class="ttc" id="colr_8h_html_a577e45a5c233dd1b4774a9034b17e3eb"><div class="ttname"><a href="colr_8h.html#a577e45a5c233dd1b4774a9034b17e3eb">colr_str_replace_re_all_ColorArg</a></div><div class="ttdeci">char * colr_str_replace_re_all_ColorArg(const char *restrict s, const char *restrict pattern, ColorArg *repl, int re_flags)</div><div class="ttdoc">Replace all substrings from a regex pattern string (char*) in a string (char*) with a ColorArg&amp;#39;s stri...</div><div class="ttdef"><b>Definition:</b> colr.c:2891</div></div>
<div class="ttc" id="colr_8h_html_a232c65d12eb09d598eeb64490f39371c"><div class="ttname"><a href="colr_8h.html#a232c65d12eb09d598eeb64490f39371c">colr_str_replace_re_all</a></div><div class="ttdeci">char * colr_str_replace_re_all(const char *restrict s, const char *restrict pattern, const char *restrict repl, int re_flags)</div><div class="ttdoc">Replaces all substrings from a regex pattern string (char*) in a string (char*). </div><div class="ttdef"><b>Definition:</b> colr.c:2854</div></div>
<div class="ttc" id="colr_8h_html_a3e18a36736e5451529e80443cfb7b1fc"><div class="ttname"><a href="colr_8h.html#a3e18a36736e5451529e80443cfb7b1fc">colr_str_replace_re_all_ColorResult</a></div><div class="ttdeci">char * colr_str_replace_re_all_ColorResult(const char *restrict s, const char *restrict pattern, ColorResult *repl, int re_flags)</div><div class="ttdoc">Replace all substrings from a regex pattern string (char*) in a string (char*) with a ColorResult&amp;#39;s s...</div><div class="ttdef"><b>Definition:</b> colr.c:2924</div></div>
<div class="ttc" id="colr_8h_html_structColorResult"><div class="ttname"><a href="colr_8h.html#structColorResult">ColorResult</a></div><div class="ttdoc">Holds a string (char*) that was definitely allocated by Colr. </div><div class="ttdef"><b>Definition:</b> colr.h:2747</div></div>
<div class="ttc" id="colr_8h_html_structColorArg"><div class="ttname"><a href="colr_8h.html#structColorArg">ColorArg</a></div><div class="ttdoc">Holds an ArgType, and a ColorValue. </div><div class="ttdef"><b>Definition:</b> colr.h:2737</div></div>
<div class="ttc" id="colr_8h_html_structColorText"><div class="ttname"><a href="colr_8h.html#structColorText">ColorText</a></div><div class="ttdoc">Holds a string of text, and optional fore, back, and style ColorArgs. </div><div class="ttdef"><b>Definition:</b> colr.h:2759</div></div>
<div class="ttc" id="colr_8h_html_a747e31fa3d8961e0bdd11eabd673accc"><div class="ttname"><a href="colr_8h.html#a747e31fa3d8961e0bdd11eabd673accc">colr_str_replace_re_all_ColorText</a></div><div class="ttdeci">char * colr_str_replace_re_all_ColorText(const char *restrict s, const char *restrict pattern, ColorText *repl, int re_flags)</div><div class="ttdoc">Replace all substrings from a regex pattern string (char*) in a string (char*) with a ColorText&amp;#39;s str...</div><div class="ttdef"><b>Definition:</b> colr.c:2956</div></div>
</div><!-- fragment -->
<p>Replace all matches to a regex pattern string (<code>char*</code>) in <code>s</code> with another string, <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> string, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> string, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> string. </p>
<p>If a string (<code>char*</code>) is used as <code>repl</code>, this is just a wrapper around <a class="el" href="colr_8h.html#a232c65d12eb09d598eeb64490f39371c" title="Replaces all substrings from a regex pattern string (char*) in a string (char*). ">colr_str_replace_re_all()</a>.</p>
<p>If a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> is used as <code>repl</code>, the appropriate colr_str_replace_re_&lt;type&gt; function is called. The function will create a string of escape-codes/text to be used as a replacement.</p>
<p>If <code>repl</code> is <code>NULL</code>, then an empty string (<code>""</code>) is used as the replacement, which causes the <code>target</code> string to be removed.</p>
<p>If you would like to replace <b>only the first</b> occurrence of the substring, use <a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">The string to operate on.</p>
<p class="endtd"><em>Must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>A regex pattern string (<code>char*</code>), regex pattern (<code>regex_t</code>), or regex match (<code>regmatch_t</code>) to replace in <code>s</code>. <br />
 If a string is given, it <em>must be null-terminated</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td><p class="starttd">A string, <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to replace the target string with. If this is <code>NULL</code>, then an empty string is used (<code>""</code>) as the replacement.</p>
<p class="endtd"><em><a class="el" href="colr_8h.html#a76eae619668e01987653932a7492fd94" title="Calls the &lt;type&gt;_free functions for the supported types. ">colr_free()</a> will be called on any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointer passed to this function</em>. </p>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Flags for <code>regcomp()</code>. <code>REG_EXTENDED</code> is always used, whether flags are provided or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a1ca60a944b824cd8049451792904c2eb" title="Replace all substrings in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace_all</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a09db8190822ff7e7e712399680325e6a" title="Replaces a substring from a regex pattern string (char*) in a string (char*). ">colr_str_replace_re</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a78d58bde53845d6ab2c54e4ba0c68a3d" title="Replace substrings from a regex pattern string (char*) in a string (char*) with a ColorArg&#39;s string r...">colr_str_replace_re_ColorArg</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a0376bed13e55acaca37e52c382044e1d" title="Replace substrings from a regex pattern string (char*) in a string (char*) with a ColorResult&#39;s strin...">colr_str_replace_re_ColorResult</a> </dd>
<dd>
<a class="el" href="colr_8h.html#ab8d6a10f70b435559656bbad0090d92d" title="Replace substrings from a regex pattern string (char*) in a string (char*) with a ColorText&#39;s string ...">colr_str_replace_re_ColorText</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_replace_re_all-example" id="colr_replace_re_all-example" class="diamond-bullet">&#160;</a> colr_replace_re_all example: </div><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="colr_8h.html">colr.h</a>&quot;</span></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div><div class="line">    <span class="keywordtype">char</span>* mystring = <span class="stringliteral">&quot;This foo is a foo line.&quot;</span>;</div><div class="line">    puts(mystring);</div><div class="line">    <span class="keywordtype">char</span>* replaced = <a class="code" href="colr_8h.html#a34553de01998eff17512d7ef1e9f3fa0">colr_replace_re_all</a>(mystring, <span class="stringliteral">&quot;fo{2}&quot;</span>, <span class="stringliteral">&quot;replacement&quot;</span>, 0);</div><div class="line">    <span class="keywordflow">if</span> (!replaced) <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    puts(replaced);</div><div class="line">    free(replaced);</div><div class="line"></div><div class="line">    <span class="comment">// ColorArgs.</span></div><div class="line">    replaced = <a class="code" href="colr_8h.html#a34553de01998eff17512d7ef1e9f3fa0">colr_replace_re_all</a>(mystring, <span class="stringliteral">&quot;f\\w\\w &quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED), 0);</div><div class="line">    <span class="keywordflow">if</span> (!replaced) <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    puts(replaced);</div><div class="line">    <span class="comment">// No reset code was appended to that last one.</span></div><div class="line">    printf(<span class="stringliteral">&quot;%s&quot;</span>, <a class="code" href="colr_8h.html#add86801c90ad7bd8359242a2c1ef1297">CODE_RESET_ALL</a>);</div><div class="line">    free(replaced);</div><div class="line"></div><div class="line">    <span class="comment">// ColorResults.</span></div><div class="line">    replaced = <a class="code" href="colr_8h.html#a34553de01998eff17512d7ef1e9f3fa0">colr_replace_re_all</a>(</div><div class="line">        mystring,</div><div class="line">        <span class="stringliteral">&quot;\\woo&quot;</span>,</div><div class="line">        <a class="code" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e">Colr_join</a>(<span class="stringliteral">&quot; &quot;</span>, <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;nicely&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED)), <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;colored&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(BLUE))),</div><div class="line">        0</div><div class="line">    );</div><div class="line">    <span class="keywordflow">if</span> (!replaced) <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    puts(replaced);</div><div class="line">    free(replaced);</div><div class="line"></div><div class="line">    <span class="comment">// ColorTexts.</span></div><div class="line">    replaced = <a class="code" href="colr_8h.html#a34553de01998eff17512d7ef1e9f3fa0">colr_replace_re_all</a>(mystring, <span class="stringliteral">&quot;f[a-z]{2}&quot;</span>, <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;styled&quot;</span>, <a class="code" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662">style</a>(UNDERLINE)) , 0);</div><div class="line">    <span class="keywordflow">if</span> (!replaced) <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    puts(replaced);</div><div class="line">    free(replaced);</div><div class="line">}</div></div><!-- fragment --> </div> <dl><dt><b>Examples: </b></dt><dd><a class="el" href="colr_replace_re_all_example_8c-example.html#a0">colr_replace_re_all_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="ac1ef824dd213274fb239526269315543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ef824dd213274fb239526269315543">&#9670;&nbsp;</a></span>colr_repr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_repr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_Generic( \</div><div class="line">        (x), \</div><div class="line">        <a class="code" href="colr_8h.html#structColorArg">ColorArg</a>: <a class="code" href="colr_8h.html#a5af692f2357d46b9cee45bb114f2a4a2">ColorArg_repr</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorArg">ColorArg</a>**: <a class="code" href="colr_8h.html#a4e16f30e878a6fb53ed9af5f8fdd674a">ColorArgs_array_repr</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorJustify">ColorJustify</a>: <a class="code" href="colr_8h.html#a6c35f6b47cc737744487d14d20241656">ColorJustify_repr</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#af1a3fe0b966f944fd659a98be170045f">ColorJustifyMethod</a>: <a class="code" href="colr_8h.html#adf78eeb364553d130055d93e9892cd9c">ColorJustifyMethod_repr</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorResult">ColorResult</a>: <a class="code" href="colr_8h.html#aae0b90c57e8c4c475d9e0f517f3a0d42">ColorResult_repr</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorText">ColorText</a>: <a class="code" href="colr_8h.html#a65363a3601cd9cfcdc7fc40722d5d3c3">ColorText_repr</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorValue">ColorValue</a>: <a class="code" href="colr_8h.html#a95cf6ab7c565726eeb7c276d734193f6">ColorValue_repr</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>: <a class="code" href="colr_8h.html#ad01ccaf04c71fc2474da94b050236572">ArgType_repr</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>: <a class="code" href="colr_8h.html#a291ca6d28f9f430794413b76b7b094ed">ColorType_repr</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>: <a class="code" href="colr_8h.html#a1bc0d9917621cab5b3efd162b7dc5a8c">BasicValue_repr</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>: <a class="code" href="colr_8h.html#aa45baebc38756a40e7084f8198999902">ExtendedValue_repr</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structRGB">RGB</a>: <a class="code" href="colr_8h.html#afd28864afbcfa4a344e4596130645177">RGB_repr</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>: <a class="code" href="colr_8h.html#a24b74664587dd3c0e981603ee75c331b">StyleValue_repr</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structTermSize">TermSize</a>: <a class="code" href="colr_8h.html#a41b4ed49acc5d806f161a3b31f5bf023">TermSize_repr</a>, \</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>*: <a class="code" href="colr_8h.html#a196ad91a69cfbeb27a5266ffc93ed353">colr_str_repr</a>, \</div><div class="line">        <span class="keywordtype">char</span>*: colr_str_repr, \</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>: <a class="code" href="colr_8h.html#af78a98cb101d4d5f18df0023b3109013">colr_char_repr</a>, \</div><div class="line">        <span class="keywordtype">char</span>: colr_char_repr, \</div><div class="line">        <span class="keywordtype">void</span>*: <a class="code" href="colr_8h.html#a30cac3017a6ea8c78277882554c9419f">_colr_ptr_repr</a> \</div><div class="line">    )(x)</div><div class="ttc" id="colr_8h_html_a5af692f2357d46b9cee45bb114f2a4a2"><div class="ttname"><a href="colr_8h.html#a5af692f2357d46b9cee45bb114f2a4a2">ColorArg_repr</a></div><div class="ttdeci">char * ColorArg_repr(ColorArg carg)</div><div class="ttdoc">Creates a string (char*) representation for a ColorArg. </div><div class="ttdef"><b>Definition:</b> colr.c:5361</div></div>
<div class="ttc" id="colr_8h_html_aa45baebc38756a40e7084f8198999902"><div class="ttname"><a href="colr_8h.html#aa45baebc38756a40e7084f8198999902">ExtendedValue_repr</a></div><div class="ttdeci">char * ExtendedValue_repr(int eval)</div><div class="ttdoc">Creates a string (char*) representation of a ExtendedValue. </div><div class="ttdef"><b>Definition:</b> colr.c:7632</div></div>
<div class="ttc" id="colr_8h_html_structColorValue"><div class="ttname"><a href="colr_8h.html#structColorValue">ColorValue</a></div><div class="ttdoc">Holds a color type and it&amp;#39;s value. </div><div class="ttdef"><b>Definition:</b> colr.h:2712</div></div>
<div class="ttc" id="colr_8h_html_aae0b90c57e8c4c475d9e0f517f3a0d42"><div class="ttname"><a href="colr_8h.html#aae0b90c57e8c4c475d9e0f517f3a0d42">ColorResult_repr</a></div><div class="ttdeci">char * ColorResult_repr(ColorResult cres)</div><div class="ttdoc">Create a string representation for a ColorResult. </div><div class="ttdef"><b>Definition:</b> colr.c:5893</div></div>
<div class="ttc" id="colr_8h_html_a24b74664587dd3c0e981603ee75c331b"><div class="ttname"><a href="colr_8h.html#a24b74664587dd3c0e981603ee75c331b">StyleValue_repr</a></div><div class="ttdeci">char * StyleValue_repr(StyleValue sval)</div><div class="ttdoc">Creates a string (char*) representation of a StyleValue. </div><div class="ttdef"><b>Definition:</b> colr.c:8233</div></div>
<div class="ttc" id="colr_8h_html_a291ca6d28f9f430794413b76b7b094ed"><div class="ttname"><a href="colr_8h.html#a291ca6d28f9f430794413b76b7b094ed">ColorType_repr</a></div><div class="ttdeci">char * ColorType_repr(ColorType type)</div><div class="ttdoc">Creates a string (char*) representation of a ColorType. </div><div class="ttdef"><b>Definition:</b> colr.c:6437</div></div>
<div class="ttc" id="colr_8h_html_adf78eeb364553d130055d93e9892cd9c"><div class="ttname"><a href="colr_8h.html#adf78eeb364553d130055d93e9892cd9c">ColorJustifyMethod_repr</a></div><div class="ttdeci">char * ColorJustifyMethod_repr(ColorJustifyMethod meth)</div><div class="ttdoc">Creates a string (char*) representation for a ColorJustifyMethod. </div><div class="ttdef"><b>Definition:</b> colr.c:5765</div></div>
<div class="ttc" id="colr_8h_html_a0c061fbfddd43dfe324486dc86cb92ee"><div class="ttname"><a href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a></div><div class="ttdeci">BasicValue</div><div class="ttdoc">Basic color values, with a few convenience values for extended colors. </div><div class="ttdef"><b>Definition:</b> colr.h:2456</div></div>
<div class="ttc" id="colr_8h_html_structColorJustify"><div class="ttname"><a href="colr_8h.html#structColorJustify">ColorJustify</a></div><div class="ttdoc">Holds a string justification method, width, and padding character for ColorTexts. ...</div><div class="ttdef"><b>Definition:</b> colr.h:2680</div></div>
<div class="ttc" id="colr_8h_html_af78a98cb101d4d5f18df0023b3109013"><div class="ttname"><a href="colr_8h.html#af78a98cb101d4d5f18df0023b3109013">colr_char_repr</a></div><div class="ttdeci">char * colr_char_repr(char c)</div><div class="ttdoc">Creates a string (char*) representation for a char. </div><div class="ttdef"><b>Definition:</b> colr.c:934</div></div>
<div class="ttc" id="colr_8h_html_afd28864afbcfa4a344e4596130645177"><div class="ttname"><a href="colr_8h.html#afd28864afbcfa4a344e4596130645177">RGB_repr</a></div><div class="ttdeci">char * RGB_repr(RGB rgb)</div><div class="ttdoc">Creates a string (char*) representation for an RGB value. </div><div class="ttdef"><b>Definition:</b> colr.c:8100</div></div>
<div class="ttc" id="colr_8h_html_a58d8da4a4f5529031f00c7a6b9eeb5e1"><div class="ttname"><a href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a></div><div class="ttdeci">ArgType</div><div class="ttdoc">Argument types (fore, back, style). </div><div class="ttdef"><b>Definition:</b> colr.h:2593</div></div>
<div class="ttc" id="colr_8h_html_a95cf6ab7c565726eeb7c276d734193f6"><div class="ttname"><a href="colr_8h.html#a95cf6ab7c565726eeb7c276d734193f6">ColorValue_repr</a></div><div class="ttdeci">char * ColorValue_repr(ColorValue cval)</div><div class="ttdoc">Creates a string (char*) representation of a ColorValue. </div><div class="ttdef"><b>Definition:</b> colr.c:6949</div></div>
<div class="ttc" id="colr_8h_html_a6c35f6b47cc737744487d14d20241656"><div class="ttname"><a href="colr_8h.html#a6c35f6b47cc737744487d14d20241656">ColorJustify_repr</a></div><div class="ttdeci">char * ColorJustify_repr(ColorJustify cjust)</div><div class="ttdoc">Creates a string (char*) representation for a ColorJustify. </div><div class="ttdef"><b>Definition:</b> colr.c:5735</div></div>
<div class="ttc" id="colr_8h_html_a30cac3017a6ea8c78277882554c9419f"><div class="ttname"><a href="colr_8h.html#a30cac3017a6ea8c78277882554c9419f">_colr_ptr_repr</a></div><div class="ttdeci">char * _colr_ptr_repr(void *p)</div><div class="ttdoc">Determine what kind of pointer is being passed, and call the appropriate &lt;type&gt;_repr function to obta...</div><div class="ttdef"><b>Definition:</b> colr.c:4797</div></div>
<div class="ttc" id="colr_8h_html_ad01ccaf04c71fc2474da94b050236572"><div class="ttname"><a href="colr_8h.html#ad01ccaf04c71fc2474da94b050236572">ArgType_repr</a></div><div class="ttdeci">char * ArgType_repr(ArgType type)</div><div class="ttdoc">Creates a string (char*) representation of a ArgType. </div><div class="ttdef"><b>Definition:</b> colr.c:4866</div></div>
<div class="ttc" id="colr_8h_html_a41b4ed49acc5d806f161a3b31f5bf023"><div class="ttname"><a href="colr_8h.html#a41b4ed49acc5d806f161a3b31f5bf023">TermSize_repr</a></div><div class="ttdeci">char * TermSize_repr(TermSize ts)</div><div class="ttdoc">Create a string (char*) representation for a TermSize. </div><div class="ttdef"><b>Definition:</b> colr.c:8300</div></div>
<div class="ttc" id="colr_8h_html_structTermSize"><div class="ttname"><a href="colr_8h.html#structTermSize">TermSize</a></div><div class="ttdoc">Holds a terminal size, usually retrieved with colr_term_size(). </div><div class="ttdef"><b>Definition:</b> colr.h:2776</div></div>
<div class="ttc" id="colr_8h_html_structColorResult"><div class="ttname"><a href="colr_8h.html#structColorResult">ColorResult</a></div><div class="ttdoc">Holds a string (char*) that was definitely allocated by Colr. </div><div class="ttdef"><b>Definition:</b> colr.h:2747</div></div>
<div class="ttc" id="colr_8h_html_a1bc0d9917621cab5b3efd162b7dc5a8c"><div class="ttname"><a href="colr_8h.html#a1bc0d9917621cab5b3efd162b7dc5a8c">BasicValue_repr</a></div><div class="ttdeci">char * BasicValue_repr(BasicValue bval)</div><div class="ttdoc">Creates a string (char*) representation of a BasicValue. </div><div class="ttdef"><b>Definition:</b> colr.c:7260</div></div>
<div class="ttc" id="colr_8h_html_a4e16f30e878a6fb53ed9af5f8fdd674a"><div class="ttname"><a href="colr_8h.html#a4e16f30e878a6fb53ed9af5f8fdd674a">ColorArgs_array_repr</a></div><div class="ttdeci">char * ColorArgs_array_repr(ColorArg **lst)</div><div class="ttdoc">Creates a string representation for an array of ColorArg pointers. </div><div class="ttdef"><b>Definition:</b> colr.c:5506</div></div>
<div class="ttc" id="colr_8h_html_structColorArg"><div class="ttname"><a href="colr_8h.html#structColorArg">ColorArg</a></div><div class="ttdoc">Holds an ArgType, and a ColorValue. </div><div class="ttdef"><b>Definition:</b> colr.h:2737</div></div>
<div class="ttc" id="colr_8h_html_a196ad91a69cfbeb27a5266ffc93ed353"><div class="ttname"><a href="colr_8h.html#a196ad91a69cfbeb27a5266ffc93ed353">colr_str_repr</a></div><div class="ttdeci">char * colr_str_repr(const char *s)</div><div class="ttdoc">Convert a string (char*) into a representation of a string, by wrapping it in quotes and escaping cha...</div><div class="ttdef"><b>Definition:</b> colr.c:3862</div></div>
<div class="ttc" id="colr_8h_html_structColorText"><div class="ttname"><a href="colr_8h.html#structColorText">ColorText</a></div><div class="ttdoc">Holds a string of text, and optional fore, back, and style ColorArgs. </div><div class="ttdef"><b>Definition:</b> colr.h:2759</div></div>
<div class="ttc" id="colr_8h_html_structRGB"><div class="ttname"><a href="colr_8h.html#structRGB">RGB</a></div><div class="ttdoc">Container for RGB values. </div><div class="ttdef"><b>Definition:</b> colr.h:2535</div></div>
<div class="ttc" id="colr_8h_html_a5e133660cf9d4bcd1cb6a49e3ec16f83"><div class="ttname"><a href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a></div><div class="ttdeci">ColorType</div><div class="ttdoc">Color/Style code types. Used with ColorType_from_str() and ColorValue. </div><div class="ttdef"><b>Definition:</b> colr.h:2625</div></div>
<div class="ttc" id="colr_8h_html_a6dda29f582a062546ef8733d8b7d8a94"><div class="ttname"><a href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a></div><div class="ttdeci">unsigned char ExtendedValue</div><div class="ttdoc">Convenience typedef for clarity when dealing with extended (256) colors. </div><div class="ttdef"><b>Definition:</b> colr.h:2532</div></div>
<div class="ttc" id="colr_8h_html_a65363a3601cd9cfcdc7fc40722d5d3c3"><div class="ttname"><a href="colr_8h.html#a65363a3601cd9cfcdc7fc40722d5d3c3">ColorText_repr</a></div><div class="ttdeci">char * ColorText_repr(ColorText ctext)</div><div class="ttdoc">Allocate a string (char*) representation for a ColorText. </div><div class="ttdef"><b>Definition:</b> colr.c:6150</div></div>
<div class="ttc" id="colr_8h_html_a85224ec2507f33b1985f4cdd0adfe0e6"><div class="ttname"><a href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a></div><div class="ttdeci">StyleValue</div><div class="ttdoc">Style values. </div><div class="ttdef"><b>Definition:</b> colr.h:2549</div></div>
<div class="ttc" id="colr_8h_html_af1a3fe0b966f944fd659a98be170045f"><div class="ttname"><a href="colr_8h.html#af1a3fe0b966f944fd659a98be170045f">ColorJustifyMethod</a></div><div class="ttdeci">ColorJustifyMethod</div><div class="ttdoc">Justification style for ColorTexts. </div><div class="ttdef"><b>Definition:</b> colr.h:2609</div></div>
</div><!-- fragment -->
<p>Transforms several ColrC objects into their string representations. </p>
<p>Uses _Generic (C11 standard) to dynamically dispatch to the proper <code>*_repr</code> functions.</p>
<p>If a regular string is passed in, it will be escaped and you must still <code>free()</code> the result.</p>
<p>Supported Types:</p><ul>
<li><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a></li>
<li><a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a></li>
<li>ColorJustifyMethod</li>
<li><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a></li>
<li><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a></li>
<li>ArgType</li>
<li>ColorType</li>
<li>BasicValue</li>
<li>ExtendedValue</li>
<li><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a></li>
<li>StyleValue</li>
<li><a class="el" href="colr_8h.html#structTermSize" title="Holds a terminal size, usually retrieved with colr_term_size(). ">TermSize</a></li>
<li>char*</li>
<li>char</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A value with one of the supported types to transform into a string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">Stringified representation of what was passed in.</p>
<p class="enddd"><em>You must <code>free()</code> the memory allocated by this function.</em> </p>
</dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a4e16f30e878a6fb53ed9af5f8fdd674a">ColorArgs_array_repr()</a>, <a class="el" href="colr_8h.html#a34c359a48f811316d765b7abef1ea8f4">colr_printf_handler()</a>, and <a class="el" href="colr_8h.html#ab473f70278850994e1b7b9c8008353fa">colr_str_mb_len()</a>.</p>

</div>
</div>
<a id="aba613f3915a178c3eb981e072d53ef72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba613f3915a178c3eb981e072d53ef72">&#9670;&nbsp;</a></span>Colr_rjust</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Colr_rjust</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">text, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">justwidth, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="colr_8h.html#ab408d87cce896acccb75357acca8ade4">ColorText_set_just</a>( \</div><div class="line">        <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(text, __VA_ARGS__), \</div><div class="line">        (<a class="code" href="colr_8h.html#structColorJustify">ColorJustify</a>){.method=JUST_RIGHT, .width=justwidth, .padchar=<span class="charliteral">&#39; &#39;</span>} \</div><div class="line">    )</div><div class="ttc" id="colr_8h_html_ab408d87cce896acccb75357acca8ade4"><div class="ttname"><a href="colr_8h.html#ab408d87cce896acccb75357acca8ade4">ColorText_set_just</a></div><div class="ttdeci">ColorText * ColorText_set_just(ColorText *ctext, ColorJustify cjust)</div><div class="ttdoc">Set the ColorJustify method for a ColorText, and return the ColorText. </div><div class="ttdef"><b>Definition:</b> colr.c:6189</div></div>
<div class="ttc" id="colr_8h_html_structColorJustify"><div class="ttname"><a href="colr_8h.html#structColorJustify">ColorJustify</a></div><div class="ttdoc">Holds a string justification method, width, and padding character for ColorTexts. ...</div><div class="ttdef"><b>Definition:</b> colr.h:2680</div></div>
<div class="ttc" id="colr_8h_html_ade1c77f81a0fd49f7895598cbd9ac76c"><div class="ttname"><a href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a></div><div class="ttdeci">#define Colr(text,...)</div><div class="ttdoc">Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...</div><div class="ttdef"><b>Definition:</b> colr.h:751</div></div>
</div><!-- fragment -->
<p>Sets the JustifyMethod for a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> while allocating it. </p>
<p>This is like <a class="el" href="colr_8h.html#a3699ee65e44b71b4d4165fd167c746bb" title="Sets the JustifyMethod for a ColorText while allocating it. ">Colr_rjust_char()</a>, except is uses space as the default character.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>Text to colorize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">justwidth</td><td>Width for justification. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Fore, back, or style ColorArgs for <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.</p>
<p class="enddd">If used inside of the <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a>, <a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465" title="Like colr_cat(), but returns an allocated ColorResult that the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros will automatically free(). ">Colr_cat()</a>, and <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> macros, <em>they will <code>free()</code> the result</em>. Otherwise, <em>you are responsible for calling <code>free()</code></em>. </p>
</dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#Colr_rjust-example" id="Colr_rjust-example" class="diamond-bullet">&#160;</a> Colr_rjust example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* justified = <a class="code" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa">colr_cat</a>(<a class="code" href="colr_8h.html#aba613f3915a178c3eb981e072d53ef72">Colr_rjust</a>(<span class="stringliteral">&quot;This.&quot;</span>, 8, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED), <a class="code" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8">back</a>(WHITE)));</div><div class="line">assert(justified);</div><div class="line"><span class="comment">// The string still has codes, but only 3 spaces were added.</span></div><div class="line">assert(<a class="code" href="colr_8c.html#ac23328cead6a65d7b3ef2c2ca48d11ce">colr_str_starts_with</a>(justified, <span class="stringliteral">&quot;   &quot;</span>));</div><div class="line"><span class="comment">// It was &quot;justified&quot; to 8 characters long, but it is well over that.</span></div><div class="line">assert(strlen(justified) &gt; 8);</div><div class="line">printf(<span class="stringliteral">&quot;&#39;%s&#39;\n&quot;</span>, justified);</div><div class="line">free(justified);</div></div><!-- fragment --> </div> <dl><dt><b>Examples: </b></dt><dd><a class="el" href="Colr_example_8c-example.html#a6">Colr_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="a3699ee65e44b71b4d4165fd167c746bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3699ee65e44b71b4d4165fd167c746bb">&#9670;&nbsp;</a></span>Colr_rjust_char</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Colr_rjust_char</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">text, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">justwidth, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="colr_8h.html#ab408d87cce896acccb75357acca8ade4">ColorText_set_just</a>( \</div><div class="line">        <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(text, __VA_ARGS__), \</div><div class="line">        (<a class="code" href="colr_8h.html#structColorJustify">ColorJustify</a>){.method=JUST_RIGHT, .width=justwidth, .padchar=c} \</div><div class="line">    )</div><div class="ttc" id="colr_8h_html_ab408d87cce896acccb75357acca8ade4"><div class="ttname"><a href="colr_8h.html#ab408d87cce896acccb75357acca8ade4">ColorText_set_just</a></div><div class="ttdeci">ColorText * ColorText_set_just(ColorText *ctext, ColorJustify cjust)</div><div class="ttdoc">Set the ColorJustify method for a ColorText, and return the ColorText. </div><div class="ttdef"><b>Definition:</b> colr.c:6189</div></div>
<div class="ttc" id="colr_8h_html_structColorJustify"><div class="ttname"><a href="colr_8h.html#structColorJustify">ColorJustify</a></div><div class="ttdoc">Holds a string justification method, width, and padding character for ColorTexts. ...</div><div class="ttdef"><b>Definition:</b> colr.h:2680</div></div>
<div class="ttc" id="colr_8h_html_ade1c77f81a0fd49f7895598cbd9ac76c"><div class="ttname"><a href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a></div><div class="ttdeci">#define Colr(text,...)</div><div class="ttdoc">Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...</div><div class="ttdef"><b>Definition:</b> colr.h:751</div></div>
</div><!-- fragment -->
<p>Sets the JustifyMethod for a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> while allocating it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>Text to colorize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">justwidth</td><td>Width for justification. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The character to pad with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Fore, back, or style ColorArgs for <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.</p>
<p class="enddd">If used inside of the <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a>, <a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465" title="Like colr_cat(), but returns an allocated ColorResult that the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros will automatically free(). ">Colr_cat()</a>, and <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> macros, <em>they will <code>free()</code> the result</em>. Otherwise, <em>you are responsible for calling <code>free()</code></em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#aba613f3915a178c3eb981e072d53ef72" title="Sets the JustifyMethod for a ColorText while allocating it. ">Colr_rjust</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#Colr_rjust_char-example" id="Colr_rjust_char-example" class="diamond-bullet">&#160;</a> Colr_rjust_char example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* justified = <a class="code" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa">colr_cat</a>(<a class="code" href="colr_8h.html#a3699ee65e44b71b4d4165fd167c746bb">Colr_rjust_char</a>(<span class="stringliteral">&quot;This.&quot;</span>, 8, <span class="charliteral">&#39; &#39;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED), <a class="code" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8">back</a>(WHITE)));</div><div class="line">assert(justified);</div><div class="line"><span class="comment">// The string still has codes, but only 3 spaces were added.</span></div><div class="line">assert(<a class="code" href="colr_8c.html#ac23328cead6a65d7b3ef2c2ca48d11ce">colr_str_starts_with</a>(justified, <span class="stringliteral">&quot;   &quot;</span>));</div><div class="line"><span class="comment">// It was &quot;justified&quot; to 8 characters long, but it is well over that.</span></div><div class="line">assert(strlen(justified) &gt; 8);</div><div class="line">printf(<span class="stringliteral">&quot;&#39;%s&#39;\n&quot;</span>, justified);</div><div class="line">free(justified);</div></div><!-- fragment --> </div> 
</div>
</div>
<a id="af3d1de0d75fddd284223749e7c13408a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d1de0d75fddd284223749e7c13408a">&#9670;&nbsp;</a></span>colr_snprintf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_snprintf</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#a04ebe7aa43eab3e7e0bd9d769d2074ac">colr_printf_macro</a>(snprintf, __VA_ARGS__)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure <a class="el" href="colr_8h.html#aaaf134ca9a2188d83171fe91948354d9" title="Registers COLR_FMT_CHAR to handle Colr objects in the printf-family functions. ">colr_printf_register()</a> has been called, and then call <code>snprintf</code>. </p>
<p>Will call <code>free()</code> on any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointer, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> pointer, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointer, or the strings created by them.</p>
<dl class="section attention"><dt>Attention</dt><dd>This feature uses a GNU extension, and is only available when COLR_GNU is defined. See the documentation for COLR_GNU.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td><p class="starttd">Arguments for <code>snprintf</code>.</p>
<p class="endtd"><em><a class="el" href="colr_8h.html#a76eae619668e01987653932a7492fd94" title="Calls the &lt;type&gt;_free functions for the supported types. ">colr_free()</a> will be called on any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointer passed to this function</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Same as <code>snprintf</code>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="colr_printf_example_8c-example.html#a6">colr_printf_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="a58aca09bd7892f8c6b3255454ae2ff07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58aca09bd7892f8c6b3255454ae2ff07">&#9670;&nbsp;</a></span>colr_sprintf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_sprintf</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#a04ebe7aa43eab3e7e0bd9d769d2074ac">colr_printf_macro</a>(sprintf, __VA_ARGS__)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure <a class="el" href="colr_8h.html#aaaf134ca9a2188d83171fe91948354d9" title="Registers COLR_FMT_CHAR to handle Colr objects in the printf-family functions. ">colr_printf_register()</a> has been called, and then call <code>sprintf</code>. </p>
<p>Will call <code>free()</code> on any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointer, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> pointer, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointer, or the strings created by them.</p>
<dl class="section attention"><dt>Attention</dt><dd>This feature uses a GNU extension, and is only available when COLR_GNU is defined. See the documentation for COLR_GNU.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td><p class="starttd">Arguments for <code>sprintf</code>.</p>
<p class="endtd"><em><a class="el" href="colr_8h.html#a76eae619668e01987653932a7492fd94" title="Calls the &lt;type&gt;_free functions for the supported types. ">colr_free()</a> will be called on any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointer passed to this function</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Same as <code>sprintf</code>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="colr_printf_example_8c-example.html#a5">colr_printf_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="afeaf33a4617bbd5de036a160d784fb83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeaf33a4617bbd5de036a160d784fb83">&#9670;&nbsp;</a></span>colr_str_either</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_str_either</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s3&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(<a class="el" href="colr_8h.html#aa3efb8eb9314481b0692a75079e4a3f4">colr_str_eq</a>(s1, s2) || <a class="el" href="colr_8h.html#aa3efb8eb9314481b0692a75079e4a3f4">colr_str_eq</a>(s1, s3))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro for <code>!strcmp(s1, s2) || !strcmp(s1, s3)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s1</td><td>The string to compare against the other two strings. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s2</td><td>The first string to compare with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s3</td><td>The second string to compare with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if <code>s1</code> is equal to <code>s2</code> or <code>s3</code>, otherwise <code>0</code>. </dd></dl>

</div>
</div>
<a id="aa3efb8eb9314481b0692a75079e4a3f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3efb8eb9314481b0692a75079e4a3f4">&#9670;&nbsp;</a></span>colr_str_eq</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_str_eq</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s2&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div><div class="line">        ((s1) &amp;&amp; (s2)) ? !strcmp((s1), (s2)) : <span class="keyword">false</span> \</div><div class="line">    )</div></div><!-- fragment -->
<p>Convenience macro for <code>!strcmp(s1, s2)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s1</td><td>The first string to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s2</td><td>The second string to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if <code>s1</code> and <code>s2</code> are equal, otherwise <code>0</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#afb35d2507389c11d6ffe2adc6876efcc">ColorResult_eq()</a>, and <a class="el" href="colr_8h.html#a98c9e50fe14ad0c82bcf1a62699c05de">RGB_from_str()</a>.</p>

</div>
</div>
<a id="a790e5a9bd0b3ca7cd7d428007f6a21b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a790e5a9bd0b3ca7cd7d428007f6a21b9">&#9670;&nbsp;</a></span>colr_to_str</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_to_str</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_Generic( \</div><div class="line">        (x), \</div><div class="line">        <a class="code" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>: <a class="code" href="colr_8h.html#a2b270bebb1a01212b7e44e52f61f94be">ArgType_to_str</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>: <a class="code" href="colr_8h.html#a83ea2f6c1adea8535ae629051e74ced0">BasicValue_to_str</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorArg">ColorArg</a>: <a class="code" href="colr_8h.html#ad1d3aaca5e543f8fefbd863a959c9d67">ColorArg_to_esc</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorResult">ColorResult</a>: <a class="code" href="colr_8h.html#af5174a576892401ea59b737558f27d8b">ColorResult_to_str</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorText">ColorText</a>: <a class="code" href="colr_8h.html#ae305b33e0a44b956ccf4123aa4f1a033">ColorText_to_str</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>: <a class="code" href="colr_8h.html#acb73415f467b040d4b0f8f1ef5e95312">ColorType_to_str</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>: <a class="code" href="colr_8h.html#a4e334d6b9145fca9717fe5a2aeb542fe">ExtendedValue_to_str</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>: <a class="code" href="colr_8h.html#ac767fb032c9617e2830cc5e13e66c400">StyleValue_to_str</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structRGB">RGB</a>: <a class="code" href="colr_8h.html#a16d2f9a1133c8a955f0a551870d7ebe8">RGB_to_str</a>, \</div><div class="line">        <span class="keywordtype">void</span>*: <a class="code" href="colr_8h.html#a0d97f9b535a69642b926b38dce30b180">_colr_ptr_to_str</a> \</div><div class="line">    )(x)</div><div class="ttc" id="colr_8h_html_ac767fb032c9617e2830cc5e13e66c400"><div class="ttname"><a href="colr_8h.html#ac767fb032c9617e2830cc5e13e66c400">StyleValue_to_str</a></div><div class="ttdeci">char * StyleValue_to_str(StyleValue sval)</div><div class="ttdoc">Create a human-friendly string (char*) representation for a StyleValue. </div><div class="ttdef"><b>Definition:</b> colr.c:8210</div></div>
<div class="ttc" id="colr_8h_html_a83ea2f6c1adea8535ae629051e74ced0"><div class="ttname"><a href="colr_8h.html#a83ea2f6c1adea8535ae629051e74ced0">BasicValue_to_str</a></div><div class="ttdeci">char * BasicValue_to_str(BasicValue bval)</div><div class="ttdoc">Create a human-friendly string (char*) representation for a BasicValue. </div><div class="ttdef"><b>Definition:</b> colr.c:7366</div></div>
<div class="ttc" id="colr_8h_html_a0c061fbfddd43dfe324486dc86cb92ee"><div class="ttname"><a href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a></div><div class="ttdeci">BasicValue</div><div class="ttdoc">Basic color values, with a few convenience values for extended colors. </div><div class="ttdef"><b>Definition:</b> colr.h:2456</div></div>
<div class="ttc" id="colr_8h_html_acb73415f467b040d4b0f8f1ef5e95312"><div class="ttname"><a href="colr_8h.html#acb73415f467b040d4b0f8f1ef5e95312">ColorType_to_str</a></div><div class="ttdeci">char * ColorType_to_str(ColorType type)</div><div class="ttdoc">Create a human-friendly string (char*) representation for a ColorType. </div><div class="ttdef"><b>Definition:</b> colr.c:6482</div></div>
<div class="ttc" id="colr_8h_html_ad1d3aaca5e543f8fefbd863a959c9d67"><div class="ttname"><a href="colr_8h.html#ad1d3aaca5e543f8fefbd863a959c9d67">ColorArg_to_esc</a></div><div class="ttdeci">char * ColorArg_to_esc(ColorArg carg)</div><div class="ttdoc">Converts a ColorArg into an escape code string (char*). </div><div class="ttdef"><b>Definition:</b> colr.c:5400</div></div>
<div class="ttc" id="colr_8h_html_a58d8da4a4f5529031f00c7a6b9eeb5e1"><div class="ttname"><a href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a></div><div class="ttdeci">ArgType</div><div class="ttdoc">Argument types (fore, back, style). </div><div class="ttdef"><b>Definition:</b> colr.h:2593</div></div>
<div class="ttc" id="colr_8h_html_a16d2f9a1133c8a955f0a551870d7ebe8"><div class="ttname"><a href="colr_8h.html#a16d2f9a1133c8a955f0a551870d7ebe8">RGB_to_str</a></div><div class="ttdeci">char * RGB_to_str(RGB rgb)</div><div class="ttdoc">Convert an RGB value into a human-friendly RGB string (char*) suitable for input to RGB_from_str()...</div><div class="ttdef"><b>Definition:</b> colr.c:8044</div></div>
<div class="ttc" id="colr_8h_html_af5174a576892401ea59b737558f27d8b"><div class="ttname"><a href="colr_8h.html#af5174a576892401ea59b737558f27d8b">ColorResult_to_str</a></div><div class="ttdeci">char * ColorResult_to_str(ColorResult cres)</div><div class="ttdoc">Convert a ColorResult into a string (char*). </div><div class="ttdef"><b>Definition:</b> colr.c:5936</div></div>
<div class="ttc" id="colr_8h_html_a4e334d6b9145fca9717fe5a2aeb542fe"><div class="ttname"><a href="colr_8h.html#a4e334d6b9145fca9717fe5a2aeb542fe">ExtendedValue_to_str</a></div><div class="ttdeci">char * ExtendedValue_to_str(ExtendedValue eval)</div><div class="ttdoc">Creates a human-friendly string (char*) from an ExtendedValue&amp;#39;s actual value, suitable for use with E...</div><div class="ttdef"><b>Definition:</b> colr.c:7659</div></div>
<div class="ttc" id="colr_8h_html_structColorResult"><div class="ttname"><a href="colr_8h.html#structColorResult">ColorResult</a></div><div class="ttdoc">Holds a string (char*) that was definitely allocated by Colr. </div><div class="ttdef"><b>Definition:</b> colr.h:2747</div></div>
<div class="ttc" id="colr_8h_html_structColorArg"><div class="ttname"><a href="colr_8h.html#structColorArg">ColorArg</a></div><div class="ttdoc">Holds an ArgType, and a ColorValue. </div><div class="ttdef"><b>Definition:</b> colr.h:2737</div></div>
<div class="ttc" id="colr_8h_html_structColorText"><div class="ttname"><a href="colr_8h.html#structColorText">ColorText</a></div><div class="ttdoc">Holds a string of text, and optional fore, back, and style ColorArgs. </div><div class="ttdef"><b>Definition:</b> colr.h:2759</div></div>
<div class="ttc" id="colr_8h_html_structRGB"><div class="ttname"><a href="colr_8h.html#structRGB">RGB</a></div><div class="ttdoc">Container for RGB values. </div><div class="ttdef"><b>Definition:</b> colr.h:2535</div></div>
<div class="ttc" id="colr_8h_html_a5e133660cf9d4bcd1cb6a49e3ec16f83"><div class="ttname"><a href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a></div><div class="ttdeci">ColorType</div><div class="ttdoc">Color/Style code types. Used with ColorType_from_str() and ColorValue. </div><div class="ttdef"><b>Definition:</b> colr.h:2625</div></div>
<div class="ttc" id="colr_8h_html_ae305b33e0a44b956ccf4123aa4f1a033"><div class="ttname"><a href="colr_8h.html#ae305b33e0a44b956ccf4123aa4f1a033">ColorText_to_str</a></div><div class="ttdeci">char * ColorText_to_str(ColorText ctext)</div><div class="ttdoc">Stringifies a ColorText struct, creating a mix of escape codes and text. </div><div class="ttdef"><b>Definition:</b> colr.c:6271</div></div>
<div class="ttc" id="colr_8h_html_a6dda29f582a062546ef8733d8b7d8a94"><div class="ttname"><a href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a></div><div class="ttdeci">unsigned char ExtendedValue</div><div class="ttdoc">Convenience typedef for clarity when dealing with extended (256) colors. </div><div class="ttdef"><b>Definition:</b> colr.h:2532</div></div>
<div class="ttc" id="colr_8h_html_a2b270bebb1a01212b7e44e52f61f94be"><div class="ttname"><a href="colr_8h.html#a2b270bebb1a01212b7e44e52f61f94be">ArgType_to_str</a></div><div class="ttdeci">char * ArgType_to_str(ArgType type)</div><div class="ttdoc">Creates a human-friendly string (char*) from an ArgType. </div><div class="ttdef"><b>Definition:</b> colr.c:4896</div></div>
<div class="ttc" id="colr_8h_html_a85224ec2507f33b1985f4cdd0adfe0e6"><div class="ttname"><a href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a></div><div class="ttdeci">StyleValue</div><div class="ttdoc">Style values. </div><div class="ttdef"><b>Definition:</b> colr.h:2549</div></div>
<div class="ttc" id="colr_8h_html_a0d97f9b535a69642b926b38dce30b180"><div class="ttname"><a href="colr_8h.html#a0d97f9b535a69642b926b38dce30b180">_colr_ptr_to_str</a></div><div class="ttdeci">char * _colr_ptr_to_str(void *p)</div><div class="ttdoc">Determine what kind of pointer is being passed, and call the appropriate &lt;type&gt;_to_str function to ob...</div><div class="ttdef"><b>Definition:</b> colr.c:4826</div></div>
</div><!-- fragment -->
<p>Calls the &lt;type&gt;_to_str functions for the supported types. </p>
<p>If a string is given, it is duplicated like <code>strdup()</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A supported type to build a string from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string from the type's <code>*_to_str()</code> function.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ColorResult_example_8c-example.html#a11">ColorResult_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="a1dc8cf2eac15c7c27983616d23b10ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc8cf2eac15c7c27983616d23b10ed6">&#9670;&nbsp;</a></span>Colra</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Colra</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">text, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#ad4702d6ddc409a93a0b42c8f6141d2f2">ColorText_from_values</a>(text, __VA_ARGS__, _ColrLastArg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an initialized stack-allocated <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>. </p>
<p>If this <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> is manually stored on the heap, and then sent through the colr macros, it's ColorArgs will be free'd. You cannot use the same <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> twice inside the colr macros/functions.</p>
<dl class="section attention"><dt>Attention</dt><dd>The result cannot be used inside the <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a>, <a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465" title="Like colr_cat(), but returns an allocated ColorResult that the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros will automatically free(). ">Colr_cat()</a>, and <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> macros, because you must not call <code>free()</code> on it.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>String to colorize/style. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>No more than 3 <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointers for fore, back, and style in any order.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An initialized <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#Colra-example" id="Colra-example" class="diamond-bullet">&#160;</a> Colra example: </div><div class="fragment"><div class="line"><span class="comment">// This ColorText is stack-allocated, but it&#39;s ColorArgs are not.</span></div><div class="line"><a class="code" href="colr_8h.html#structColorText">ColorText</a> ctext = <a class="code" href="colr_8h.html#a1dc8cf2eac15c7c27983616d23b10ed6">Colra</a>(<span class="stringliteral">&quot;This.&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED), <a class="code" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8">back</a>(WHITE));</div><div class="line"><span class="comment">// You cannot use this in the colr macros.</span></div><div class="line"><span class="keywordtype">char</span>* mystring = <a class="code" href="colr_8c.html#ae305b33e0a44b956ccf4123aa4f1a033">ColorText_to_str</a>(ctext);</div><div class="line">printf(<span class="stringliteral">&quot;%s\n&quot;</span>, mystring);</div><div class="line">free(mystring);</div><div class="line"><span class="comment">// And you are responsible for cleaning up the ColorArgs.</span></div><div class="line"><a class="code" href="colr_8c.html#a4979a2ec9d5fb442ba025c6f2efc4864">ColorText_free_args</a>(&amp;ctext);</div><div class="line"></div><div class="line"><a class="code" href="colr_8h.html#structColorText">ColorText</a> singleuse = <a class="code" href="colr_8h.html#a1dc8cf2eac15c7c27983616d23b10ed6">Colra</a>(<span class="stringliteral">&quot;That.&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(BLUE));</div><div class="line"><a class="code" href="colr_8h.html#structColorText">ColorText</a>* manualalloc = <a class="code" href="colr_8c.html#a8e04de932a4cf712ac91e794bdc3f8db">ColorText_to_ptr</a>(singleuse);</div><div class="line">assert(singleuse.<a class="code" href="colr_8h.html#a788a3311c550c543c8ef345a5e90e757">fore</a> == manualalloc-&gt;<a class="code" href="colr_8h.html#a788a3311c550c543c8ef345a5e90e757">fore</a>);</div><div class="line"><a class="code" href="colr_8h.html#a7c188d16f60b7e296bd71ac95d8ec508">colr_printf</a>(<span class="stringliteral">&quot;Used up: %R\n&quot;</span>, manualalloc);</div><div class="line"><span class="comment">// The ColorArgs associated with `singleuse` were just free&#39;d</span></div><div class="line"><span class="comment">// because they were linked with the heap-allocated ColorText.</span></div></div><!-- fragment --> </div> 
</div>
</div>
<a id="aebecaca8dfed9f43418cb2c6b214eef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebecaca8dfed9f43418cb2c6b214eef3">&#9670;&nbsp;</a></span>ColrResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ColrResult</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#a5f5304067f9d673ce5b86ddba2a8807b">ColorResult_to_ptr</a>(<a class="el" href="colr_8h.html#af752035c362c7c9ddb2e7f2f2305d509">ColorResult_new</a>(s))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps an allocated string in a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, which marks it as "freeable" in the colr macros. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>An allocated string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>.</dd></dl>
<p>If used inside of the <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a>, <a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465" title="Like colr_cat(), but returns an allocated ColorResult that the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros will automatically free(). ">Colr_cat()</a>, and <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> macros, <em>they will <code>free()</code> the result</em>. Otherwise, <em>you are responsible for calling <code>free()</code></em>. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ColorResult_example_8c-example.html#a1">ColorResult_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="a37ff4fc6d17b53b60202be55bd0732c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ff4fc6d17b53b60202be55bd0732c5">&#9670;&nbsp;</a></span>ext</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ext</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;((<a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>)x)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts to ExtendedValue (<code>unsigned char</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Value to cast to <code>unsigned char</code>/<code>ExtendedValue</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ExtendedValue.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f" title="Create a fore color suitable for use with the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros. ">fore</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8" title="Create a back color suitable for use with the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros. ">back</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a753093cd4c872eed4b77feaa7816212b" title="Create an allocated string directly from Colr() arguments. ">colr</a> </dd>
<dd>
<a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr</a> </dd>
<dd>
<a class="el" href="colr_8h.html#aa3c79297600d8ab15a495843d63db54d" title="Like hex(), but force a conversion to the closest ExtendedValue (256-colors). ">ext_hex</a> </dd>
<dd>
<a class="el" href="colr_8h.html#affaeebdd3dad2cf0d5e14a7870c1e4f6" title="Like hex_or(), but force a conversion to the closest ExtendedValue (256-colors). ">ext_hex_or</a> </dd>
<dd>
<a class="el" href="colr_8h.html#add3d47951e17cbf856902e11e4efa2e6" title="Creates the closest matching ExtendedValue from separate red, green, and blue values. ">ext_rgb</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a0605394ac51b9927ec4a71e99365028e" title="Creates the closest matching ExtendedValue from an RGB value. ">ext_RGB</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="back_example_8c-example.html#a3">back_example.c</a>, <a class="el" href="colr_cat_example_8c-example.html#a6">colr_cat_example.c</a>, <a class="el" href="fore_example_8c-example.html#a2">fore_example.c</a>, and <a class="el" href="simple_example_8c-example.html#a4">simple_example.c</a>.</dd>
</dl>
<p class="reference">Referenced by <a class="el" href="colr_8h.html#af0b464ee51d75d7f45ddd5926a7c9cf5">ExtendedValue_from_BasicValue()</a>, and <a class="el" href="colr_8h.html#a1548d9fc5f3e00a7b5d834eb1e12ff93">ExtendedValue_from_RGB()</a>.</p>

</div>
</div>
<a id="aa3c79297600d8ab15a495843d63db54d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3c79297600d8ab15a495843d63db54d">&#9670;&nbsp;</a></span>ext_hex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ext_hex</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#affaeebdd3dad2cf0d5e14a7870c1e4f6">ext_hex_or</a>(s, <a class="el" href="colr_8h.html#a37ff4fc6d17b53b60202be55bd0732c5">ext</a>(0))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <a class="el" href="colr_8h.html#a8fe812f8e76e4baed394ee9adf46b3df" title="Use RGB_from_hex_default() to create an RGB value. ">hex()</a>, but force a conversion to the closest ExtendedValue (256-colors). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>A hex string to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The closest matching ExtendedValue, or 0 for bad hex strings.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a37ff4fc6d17b53b60202be55bd0732c5" title="Casts to ExtendedValue (unsigned char). ">ext</a> </dd>
<dd>
<a class="el" href="colr_8h.html#affaeebdd3dad2cf0d5e14a7870c1e4f6" title="Like hex_or(), but force a conversion to the closest ExtendedValue (256-colors). ">ext_hex_or</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a8fe812f8e76e4baed394ee9adf46b3df" title="Use RGB_from_hex_default() to create an RGB value. ">hex</a> </dd>
<dd>
<a class="el" href="colr_8h.html#ab55724d1f9877f698cf8591df92b8887" title="Use RGB_from_hex_default() to create an RGB value. ">hex_or</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="back_example_8c-example.html#a7">back_example.c</a>, <a class="el" href="Colr_example_8c-example.html#a5">Colr_example.c</a>, <a class="el" href="colr_join_example_8c-example.html#a5">colr_join_example.c</a>, and <a class="el" href="simple_example_8c-example.html#a7">simple_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="affaeebdd3dad2cf0d5e14a7870c1e4f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affaeebdd3dad2cf0d5e14a7870c1e4f6">&#9670;&nbsp;</a></span>ext_hex_or</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ext_hex_or</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">default_value&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#a757be189530b4925c84df25742374485">ExtendedValue_from_hex_default</a>(s, default_value)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <a class="el" href="colr_8h.html#ab55724d1f9877f698cf8591df92b8887" title="Use RGB_from_hex_default() to create an RGB value. ">hex_or()</a>, but force a conversion to the closest ExtendedValue (256-colors). </p>
<p>This is a convenience macro for <a class="el" href="colr_8h.html#a757be189530b4925c84df25742374485" title="Create an ExtendedValue from a hex string (char*), but return a default value if the hex string is in...">ExtendedValue_from_hex_default()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>A hex string to convert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_value</td><td>ExtendedValue to use if the hex string is not valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The closest matching ExtendedValue, or <code>default_value</code> for bad hex strings.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a37ff4fc6d17b53b60202be55bd0732c5" title="Casts to ExtendedValue (unsigned char). ">ext</a> </dd>
<dd>
<a class="el" href="colr_8h.html#aa3c79297600d8ab15a495843d63db54d" title="Like hex(), but force a conversion to the closest ExtendedValue (256-colors). ">ext_hex</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a8fe812f8e76e4baed394ee9adf46b3df" title="Use RGB_from_hex_default() to create an RGB value. ">hex</a> </dd>
<dd>
<a class="el" href="colr_8h.html#ab55724d1f9877f698cf8591df92b8887" title="Use RGB_from_hex_default() to create an RGB value. ">hex_or</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="back_example_8c-example.html#a8">back_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="ace6501099f0501e2faa18ebfc9a74105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace6501099f0501e2faa18ebfc9a74105">&#9670;&nbsp;</a></span>EXT_INVALID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EXT_INVALID&#160;&#160;&#160;<a class="el" href="colr_8h.html#aaaddb0f34c1374c29a8b7629ac40ca8b">COLOR_INVALID</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for COLOR_INVALID. </p>
<p>All color values share an _INVALID member with the same value, so: </p><div class="fragment"><div class="line"><a class="code" href="colr_8h.html#aaaddb0f34c1374c29a8b7629ac40ca8b">COLOR_INVALID</a> == BASIC_INVALID == <a class="code" href="colr_8h.html#ace6501099f0501e2faa18ebfc9a74105">EXT_INVALID</a> == STYLE_INVALID</div></div><!-- fragment --> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#af0b464ee51d75d7f45ddd5926a7c9cf5">ExtendedValue_from_BasicValue()</a>, <a class="el" href="colr_8h.html#aaabf63956f397a0fe628313622ba5cde">ExtendedValue_from_esc()</a>, and <a class="el" href="colr_8h.html#a2e859d542a8aa0939e4f76b1f33cb5f8">ExtendedValue_from_str()</a>.</p>

</div>
</div>
<a id="a29f95f31a14a8e3404651866911ea089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f95f31a14a8e3404651866911ea089">&#9670;&nbsp;</a></span>EXT_INVALID_RANGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EXT_INVALID_RANGE&#160;&#160;&#160;<a class="el" href="colr_8h.html#ab8b950e341a1ce7dd9b3325c53c50cfc">COLOR_INVALID_RANGE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Possible error return value for <a class="el" href="colr_8h.html#a2e859d542a8aa0939e4f76b1f33cb5f8" title="Converts a known name, integer string (0-255), or a hex string (char*), into an ExtendedValue suitabl...">ExtendedValue_from_str()</a> or <a class="el" href="colr_8h.html#aaabf63956f397a0fe628313622ba5cde" title="Convert an escape-code string (char*) to an ExtendedValue. ">ExtendedValue_from_esc()</a>. </p>
<p>This is just an alias for COLOR_INVALID_RANGE. </p><div class="fragment"><div class="line"><a class="code" href="colr_8h.html#ab8b950e341a1ce7dd9b3325c53c50cfc">COLOR_INVALID_RANGE</a> == BASIC_INVALID_RANGE == <a class="code" href="colr_8h.html#a29f95f31a14a8e3404651866911ea089">EXT_INVALID_RANGE</a> == STYLE_INVALID_RANGE</div></div><!-- fragment --> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#aaabf63956f397a0fe628313622ba5cde">ExtendedValue_from_esc()</a>, and <a class="el" href="colr_8h.html#a2e859d542a8aa0939e4f76b1f33cb5f8">ExtendedValue_from_str()</a>.</p>

</div>
</div>
<a id="add3d47951e17cbf856902e11e4efa2e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add3d47951e17cbf856902e11e4efa2e6">&#9670;&nbsp;</a></span>ext_rgb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ext_rgb</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">r, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">g, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#a1548d9fc5f3e00a7b5d834eb1e12ff93">ExtendedValue_from_RGB</a>((<a class="el" href="colr_8h.html#structRGB">RGB</a>){.red=r, .green=g, .blue=b})</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the closest matching ExtendedValue from separate red, green, and blue values. </p>
<p>This is short-hand for <code>ExtendedValue_from_RGB((<a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a>){r, g, b})</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>The red value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>The green value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The blue value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ExtendedValue that closely matches the <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a1548d9fc5f3e00a7b5d834eb1e12ff93" title="Convert an RGB value into the closest matching ExtendedValue. ">ExtendedValue_from_RGB</a> </dd>
<dd>
<a class="el" href="colr_8h.html#ab4576c531151e398b7ecede2e30df70d" title="Convert an RGB value into it&#39;s nearest terminal-friendly RGB value. ">RGB_to_term_RGB</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ColorResult_example_8c-example.html#a9">ColorResult_example.c</a>, and <a class="el" href="Colr_example_8c-example.html#a7">Colr_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="a0605394ac51b9927ec4a71e99365028e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0605394ac51b9927ec4a71e99365028e">&#9670;&nbsp;</a></span>ext_RGB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ext_RGB</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rgbval</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#a1548d9fc5f3e00a7b5d834eb1e12ff93">ExtendedValue_from_RGB</a>(rgbval)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the closest matching ExtendedValue from an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value. </p>
<p>This is short-hand for <code>ExtendedValue_from_RGB(rgbval)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rgbval</td><td>The <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ExtendedValue that closely matches the <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a1548d9fc5f3e00a7b5d834eb1e12ff93" title="Convert an RGB value into the closest matching ExtendedValue. ">ExtendedValue_from_RGB</a> </dd>
<dd>
<a class="el" href="colr_8h.html#ab4576c531151e398b7ecede2e30df70d" title="Convert an RGB value into it&#39;s nearest terminal-friendly RGB value. ">RGB_to_term_RGB</a> </dd></dl>

</div>
</div>
<a id="a19d8b61303404007a3224be0f8296c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19d8b61303404007a3224be0f8296c3f">&#9670;&nbsp;</a></span>fore</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define fore</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#afb5ac0bd012b8162cea125ad0d9e8bf0">ColorArg_to_ptr</a>(<a class="el" href="colr_8h.html#a3cc38de52ea52344113083ba4d90088e">fore_arg</a>(x))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a fore color suitable for use with the <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a>, <a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465" title="Like colr_cat(), but returns an allocated ColorResult that the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros will automatically free(). ">Colr_cat()</a>, and <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> macros. </p>
<p>Technically, this macro accepts BasicValues, ExtendedValues, or <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> structs. However, for some of these you should be using the macros that create those things.</p>
<p>BasicValues can be used by their names (RED, YELLOW, etc.).</p>
<p>ExtendedValues can be created on the fly with <a class="el" href="colr_8h.html#a37ff4fc6d17b53b60202be55bd0732c5" title="Casts to ExtendedValue (unsigned char). ">ext()</a>.</p>
<p><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> structs can be easily created with <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57" title="Creates an anonymous RGB struct for use in function calls. ">rgb()</a>.</p>
<p>Color names (<code>char*</code>) can be passed to generate the appropriate color value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A BasicValue, ExtendedValue, or <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct to use for the color value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">A pointer to a heap-allocated <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct.</p>
<p class="enddd">If used inside of the <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a>, <a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465" title="Like colr_cat(), but returns an allocated ColorResult that the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros will automatically free(). ">Colr_cat()</a>, and <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> macros, <em>they will <code>free()</code> the result</em>. Otherwise, <em>you are responsible for calling <code>free()</code></em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a3cc38de52ea52344113083ba4d90088e" title="Uses ColorArg_from_&lt;type&gt; to build a ColorArg with the appropriate color type, based on the type of i...">fore_arg</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a0e27cd8b78fc357be02c4dbf6a6c9096" title="Return just the escape code string for a fore color. ">fore_str</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a753093cd4c872eed4b77feaa7816212b" title="Create an allocated string directly from Colr() arguments. ">colr</a> </dd>
<dd>
<a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="back_example_8c-example.html#a1">back_example.c</a>, <a class="el" href="ColorResult_example_8c-example.html#a4">ColorResult_example.c</a>, <a class="el" href="colr_cat_example_8c-example.html#a2">colr_cat_example.c</a>, <a class="el" href="Colr_example_8c-example.html#a2">Colr_example.c</a>, <a class="el" href="colr_join_example_8c-example.html#a2">colr_join_example.c</a>, <a class="el" href="colr_printf_example_8c-example.html#a2">colr_printf_example.c</a>, <a class="el" href="colr_replace_all_example_8c-example.html#a2">colr_replace_all_example.c</a>, <a class="el" href="colr_replace_example_8c-example.html#a2">colr_replace_example.c</a>, <a class="el" href="colr_replace_re_all_example_8c-example.html#a2">colr_replace_re_all_example.c</a>, <a class="el" href="colr_replace_re_example_8c-example.html#a2">colr_replace_re_example.c</a>, <a class="el" href="fore_example_8c-example.html#a1">fore_example.c</a>, and <a class="el" href="simple_example_8c-example.html#a3">simple_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="a3cc38de52ea52344113083ba4d90088e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cc38de52ea52344113083ba4d90088e">&#9670;&nbsp;</a></span>fore_arg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define fore_arg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_Generic( \</div><div class="line">        (x), \</div><div class="line">        <span class="keywordtype">char</span>* : <a class="code" href="colr_8h.html#aa62406b058b948941a8906475924536a">ColorArg_from_str</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structRGB">RGB</a>: <a class="code" href="colr_8h.html#aaa24bba74e99aa66ed41839576e57856">ColorArg_from_RGB</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>: <a class="code" href="colr_8h.html#aad49f4597388e6bdb896ff28334cd5e6">ColorArg_from_BasicValue</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>: <a class="code" href="colr_8h.html#aed30e2a4b30ab5e3cf49608a3c410cc5">ColorArg_from_ExtendedValue</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>: <a class="code" href="colr_8h.html#acf63bcee395dca3ca29dc324e3d7c8f2">ColorArg_from_StyleValue</a> \</div><div class="line">    )(FORE, x)</div><div class="ttc" id="colr_8h_html_aa62406b058b948941a8906475924536a"><div class="ttname"><a href="colr_8h.html#aa62406b058b948941a8906475924536a">ColorArg_from_str</a></div><div class="ttdeci">ColorArg ColorArg_from_str(ArgType type, const char *colorname)</div><div class="ttdoc">Build a ColorArg (fore, back, or style value) from a known color name/style. </div><div class="ttdef"><b>Definition:</b> colr.c:5196</div></div>
<div class="ttc" id="colr_8h_html_aed30e2a4b30ab5e3cf49608a3c410cc5"><div class="ttname"><a href="colr_8h.html#aed30e2a4b30ab5e3cf49608a3c410cc5">ColorArg_from_ExtendedValue</a></div><div class="ttdeci">ColorArg ColorArg_from_ExtendedValue(ArgType type, ExtendedValue value)</div><div class="ttdoc">Explicit version of ColorArg_from_value that only handles ExtendedValues. </div><div class="ttdef"><b>Definition:</b> colr.c:5095</div></div>
<div class="ttc" id="colr_8h_html_a0c061fbfddd43dfe324486dc86cb92ee"><div class="ttname"><a href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a></div><div class="ttdeci">BasicValue</div><div class="ttdoc">Basic color values, with a few convenience values for extended colors. </div><div class="ttdef"><b>Definition:</b> colr.h:2456</div></div>
<div class="ttc" id="colr_8h_html_aaa24bba74e99aa66ed41839576e57856"><div class="ttname"><a href="colr_8h.html#aaa24bba74e99aa66ed41839576e57856">ColorArg_from_RGB</a></div><div class="ttdeci">ColorArg ColorArg_from_RGB(ArgType type, RGB value)</div><div class="ttdoc">Explicit version of ColorArg_from_value that only handles RGB structs. </div><div class="ttdef"><b>Definition:</b> colr.c:5118</div></div>
<div class="ttc" id="colr_8h_html_acf63bcee395dca3ca29dc324e3d7c8f2"><div class="ttname"><a href="colr_8h.html#acf63bcee395dca3ca29dc324e3d7c8f2">ColorArg_from_StyleValue</a></div><div class="ttdeci">ColorArg ColorArg_from_StyleValue(ArgType type, StyleValue value)</div><div class="ttdoc">Explicit version of ColorArg_from_value that only handles StyleValues. </div><div class="ttdef"><b>Definition:</b> colr.c:5235</div></div>
<div class="ttc" id="colr_8h_html_structRGB"><div class="ttname"><a href="colr_8h.html#structRGB">RGB</a></div><div class="ttdoc">Container for RGB values. </div><div class="ttdef"><b>Definition:</b> colr.h:2535</div></div>
<div class="ttc" id="colr_8h_html_aad49f4597388e6bdb896ff28334cd5e6"><div class="ttname"><a href="colr_8h.html#aad49f4597388e6bdb896ff28334cd5e6">ColorArg_from_BasicValue</a></div><div class="ttdeci">ColorArg ColorArg_from_BasicValue(ArgType type, BasicValue value)</div><div class="ttdoc">Explicit version of ColorArg_from_value that only handles BasicValues. </div><div class="ttdef"><b>Definition:</b> colr.c:5072</div></div>
<div class="ttc" id="colr_8h_html_a6dda29f582a062546ef8733d8b7d8a94"><div class="ttname"><a href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a></div><div class="ttdeci">unsigned char ExtendedValue</div><div class="ttdoc">Convenience typedef for clarity when dealing with extended (256) colors. </div><div class="ttdef"><b>Definition:</b> colr.h:2532</div></div>
<div class="ttc" id="colr_8h_html_a85224ec2507f33b1985f4cdd0adfe0e6"><div class="ttname"><a href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a></div><div class="ttdeci">StyleValue</div><div class="ttdoc">Style values. </div><div class="ttdef"><b>Definition:</b> colr.h:2549</div></div>
</div><!-- fragment -->
<p>Uses ColorArg_from_&lt;type&gt; to build a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> with the appropriate color type, based on the type of it's argument. </p>
<p>Uses <code>_Generic</code> (C11 standard) to dynamically create a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>. This is used by the <a class="el" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f" title="Create a fore color suitable for use with the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros. ">fore()</a> macro.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td><code>BasicValue</code>, <code>Extended</code> (<code>unsigned char</code>), <code><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a></code> struct, or string (color name) for fore color. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> with the FORE type set, and it's <code>.value.type</code> set for the appropriate color type/value. For invalid values the <code>.value.type</code> may be set to TYPE_INVALID.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f" title="Create a fore color suitable for use with the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros. ">fore</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a0e27cd8b78fc357be02c4dbf6a6c9096" title="Return just the escape code string for a fore color. ">fore_str</a> </dd></dl>

</div>
</div>
<a id="a0e27cd8b78fc357be02c4dbf6a6c9096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e27cd8b78fc357be02c4dbf6a6c9096">&#9670;&nbsp;</a></span>fore_str</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define fore_str</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#ad1d3aaca5e543f8fefbd863a959c9d67">ColorArg_to_esc</a>(<a class="el" href="colr_8h.html#a3cc38de52ea52344113083ba4d90088e">fore_arg</a>(x))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return just the escape code string for a fore color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A BasicValue, ExtendedValue, or <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string.</p>
<p class="enddd"><em>You must <code>free()</code> the memory allocated by this function.</em> </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f" title="Create a fore color suitable for use with the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros. ">fore</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a3cc38de52ea52344113083ba4d90088e" title="Uses ColorArg_from_&lt;type&gt; to build a ColorArg with the appropriate color type, based on the type of i...">fore_arg</a> </dd></dl>

</div>
</div>
<a id="ad0ab6c47eae67006285e33f1edd84278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ab6c47eae67006285e33f1edd84278">&#9670;&nbsp;</a></span>fore_str_static</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define fore_str_static</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">__extension__ ({ \</div><div class="line">        __typeof(x) _fss_val = x; \</div><div class="line">        ColorArg _fss_carg = <a class="code" href="colr_8h.html#a3cc38de52ea52344113083ba4d90088e">fore_arg</a>(_fss_val); \</div><div class="line">        size_t _fss_len = <a class="code" href="colr_8h.html#adaff727006f4c057aab75e55bfb473c4">ColorArg_length</a>(_fss_carg); \</div><div class="line">        char* _fss_codes = alloca(_fss_len); \</div><div class="line">        ColorArg_to_esc_s(_fss_codes, _fss_carg); \</div><div class="line">        _fss_codes; \</div><div class="line">    })</div><div class="ttc" id="colr_8h_html_a3cc38de52ea52344113083ba4d90088e"><div class="ttname"><a href="colr_8h.html#a3cc38de52ea52344113083ba4d90088e">fore_arg</a></div><div class="ttdeci">#define fore_arg(x)</div><div class="ttdoc">Uses ColorArg_from_&lt;type&gt; to build a ColorArg with the appropriate color type, based on the type of i...</div><div class="ttdef"><b>Definition:</b> colr.h:2197</div></div>
<div class="ttc" id="colr_8h_html_adaff727006f4c057aab75e55bfb473c4"><div class="ttname"><a href="colr_8h.html#adaff727006f4c057aab75e55bfb473c4">ColorArg_length</a></div><div class="ttdeci">size_t ColorArg_length(ColorArg carg)</div><div class="ttdoc">Returns the length in bytes needed to allocate a string (char*) built with ColorArg_to_esc(). </div><div class="ttdef"><b>Definition:</b> colr.c:5342</div></div>
</div><!-- fragment -->
<p>Creates a stack-allocated escape code string (<code>char*</code>) for a fore color. </p>
<p>These are not constant strings, but they are stored on the stack. A <a href="https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html">Statement Expression</a> is used to build a string of the correct length and content using <a class="el" href="colr_8h.html#abaf3d02ff1292f2aaa605522665ae564" title="Converts a ColorArg into an escape code string (char*) and fills the destination string. ">ColorArg_to_esc_s()</a>.</p>
<dl class="section attention"><dt>Attention</dt><dd>This feature uses a GNU extension, and is only available when COLR_GNU is defined. See the documentation for COLR_GNU. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This uses <a href="https://linux.die.net/man/3/alloca"><code>alloca</code></a> to reserve space on the stack inside of a <a href="https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html">Statement Expression</a>. A <a href="https://gcc.gnu.org/onlinedocs/gcc/Variable-Length.html">Variable Length Array</a> will not work inside of a statement expression. If the call causes a stack overflow, program behavior is undefined. See previous links, and <a href="https://stackoverflow.com/questions/1018853/why-is-the-use-of-alloca-not-considered-good-practice" title="Why is alloca considered bad practice?">here</a>.</dd></dl>
<p>You can also create stack-allocated escape code strings using <a class="el" href="colr_8h.html#a6027d93e8768f3c152edafd92e757801" title="Create an escape code for a fore color. ">format_fg()</a>, <a class="el" href="colr_8h.html#acfd2cf68768c59fc3ed5c31b93590c53" title="Create an escape code for an extended fore color. ">format_fgx()</a>, <a class="el" href="colr_8h.html#aa3391a0cd6b6f73d9d39f8179fc0eb0b" title="Create an escape code for a true color (rgb) fore color using an RGB struct&#39;s values. ">format_fg_RGB()</a>, and <a class="el" href="colr_8h.html#a4661c576a4da879b8d4a2c525a42ad78" title="Create an escape code for a true color (rgb) fore color using an RGB struct&#39;s values, approximating 256-color values. ">format_fg_RGB_term()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A BasicValue, ExtendedValue, or <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A stack-allocated escape code string.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a686865036c288a8c6d1626ce2f120039" title="Creates a stack-allocated escape code string (char*) for a back color. ">back_str_static</a> </dd>
<dd>
<a class="el" href="colr_8h.html#adb829be51382b5422286a8606a7ff4fc" title="A less-flexible style_str() that returns a static escape code string for a style. ...">style_str_static</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a6027d93e8768f3c152edafd92e757801" title="Create an escape code for a fore color. ">format_fg</a> </dd>
<dd>
<a class="el" href="colr_8h.html#ae29032483aea8cb25d6b90750767ffc1" title="Create an escape code for a background color. ">format_bg</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#fore_str_static-example" id="fore_str_static-example" class="diamond-bullet">&#160;</a> fore_str_static example: </div><div class="fragment"><div class="line"><span class="comment">// This results in a call to sprintf(), to format an extended escape code.</span></div><div class="line"><span class="comment">// The string is stored on the stack.</span></div><div class="line"><span class="keywordtype">char</span>* foreblue = <a class="code" href="colr_8h.html#ad0ab6c47eae67006285e33f1edd84278">fore_str_static</a>(BLUE);</div><div class="line"><span class="keywordtype">char</span>* backwhite = <a class="code" href="colr_8h.html#a686865036c288a8c6d1626ce2f120039">back_str_static</a>(WHITE);</div><div class="line">printf(<span class="stringliteral">&quot;%s%sBlue on White.&quot;</span> <a class="code" href="colr_8h.html#a650ed7bed617e54aa77f7b2907675137">NCNL</a>, foreblue, backwhite);</div><div class="line"></div><div class="line"><a class="code" href="colr_8h.html#structRGB">RGB</a> rgbval = <a class="code" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>(255, 34, 0);</div><div class="line">printf(<span class="stringliteral">&quot;%sA reddish.&quot;</span> <a class="code" href="colr_8h.html#a650ed7bed617e54aa77f7b2907675137">NCNL</a>, <a class="code" href="colr_8h.html#ad0ab6c47eae67006285e33f1edd84278">fore_str_static</a>(rgbval));</div><div class="line"></div><div class="line">printf(<span class="stringliteral">&quot;%sAquaMarine.&quot;</span> <a class="code" href="colr_8h.html#a650ed7bed617e54aa77f7b2907675137">NCNL</a>, <a class="code" href="colr_8h.html#ad0ab6c47eae67006285e33f1edd84278">fore_str_static</a>(<span class="stringliteral">&quot;aquamarine&quot;</span>));</div></div><!-- fragment --> </div> 
</div>
</div>
<a id="a8fe812f8e76e4baed394ee9adf46b3df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe812f8e76e4baed394ee9adf46b3df">&#9670;&nbsp;</a></span>hex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hex</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#ab55724d1f9877f698cf8591df92b8887">hex_or</a>(s, <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>(0, 0, 0))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use <a class="el" href="colr_8h.html#a6133112d9c73a8b56995e16e1af62d3b" title="Convert a hex color into an RGB value, but use a default value when errors occur. ...">RGB_from_hex_default()</a> to create an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>A hex string to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A valid <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value, or <code><a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57" title="Creates an anonymous RGB struct for use in function calls. ">rgb(0, 0, 0)</a></code> for bad hex strings.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#ab55724d1f9877f698cf8591df92b8887" title="Use RGB_from_hex_default() to create an RGB value. ">hex_or</a> </dd>
<dd>
<a class="el" href="colr_8h.html#aa3c79297600d8ab15a495843d63db54d" title="Like hex(), but force a conversion to the closest ExtendedValue (256-colors). ">ext_hex</a> </dd>
<dd>
<a class="el" href="colr_8h.html#affaeebdd3dad2cf0d5e14a7870c1e4f6" title="Like hex_or(), but force a conversion to the closest ExtendedValue (256-colors). ">ext_hex_or</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="back_example_8c-example.html#a5">back_example.c</a>, <a class="el" href="colr_join_example_8c-example.html#a9">colr_join_example.c</a>, and <a class="el" href="simple_example_8c-example.html#a6">simple_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="ab55724d1f9877f698cf8591df92b8887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55724d1f9877f698cf8591df92b8887">&#9670;&nbsp;</a></span>hex_or</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hex_or</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">default_rgb&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#a6133112d9c73a8b56995e16e1af62d3b">RGB_from_hex_default</a>(s, default_rgb)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use <a class="el" href="colr_8h.html#a6133112d9c73a8b56995e16e1af62d3b" title="Convert a hex color into an RGB value, but use a default value when errors occur. ...">RGB_from_hex_default()</a> to create an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>A hex string to convert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_rgb</td><td>Default <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value to use if the hex string is not valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A valid <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value, or <code>default_rgb</code> for bad hex strings.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a8fe812f8e76e4baed394ee9adf46b3df" title="Use RGB_from_hex_default() to create an RGB value. ">hex</a> </dd>
<dd>
<a class="el" href="colr_8h.html#aa3c79297600d8ab15a495843d63db54d" title="Like hex(), but force a conversion to the closest ExtendedValue (256-colors). ">ext_hex</a> </dd>
<dd>
<a class="el" href="colr_8h.html#affaeebdd3dad2cf0d5e14a7870c1e4f6" title="Like hex_or(), but force a conversion to the closest ExtendedValue (256-colors). ">ext_hex_or</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="back_example_8c-example.html#a6">back_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="a80a08fc1383c7260a31698864d52fee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a08fc1383c7260a31698864d52fee2">&#9670;&nbsp;</a></span>if_not_asprintf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define if_not_asprintf</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;if (asprintf(__VA_ARGS__) &lt; 1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro for checking asprintf's return value. </p>
<p>Should be followed by a block of code.</p>
<p>Note: asprintf returns <code>-1</code> for errors, but <code>0</code> is a valid return (<code>0</code> bytes written to the string). The string will be untouched (may be <code>NULL</code> if it was initialized as <code>NULL</code>)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Arguments for asprintf. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6fa7a1b0351d0bdbdf9fd5f882673d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fa7a1b0351d0bdbdf9fd5f882673d57">&#9670;&nbsp;</a></span>rgb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rgb</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">r, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">g, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((<a class="el" href="colr_8h.html#structRGB">RGB</a>){.red=r, .green=g, .blue=b})</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an anonymous <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct for use in function calls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td><code>unsigned char</code> Red value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td><code>unsigned char</code> Blue value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td><code>unsigned char</code> Green value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>rgb_safe </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="back_example_8c-example.html#a4">back_example.c</a>, <a class="el" href="colr_cat_example_8c-example.html#a3">colr_cat_example.c</a>, <a class="el" href="colr_join_example_8c-example.html#a3">colr_join_example.c</a>, <a class="el" href="fore_example_8c-example.html#a3">fore_example.c</a>, and <a class="el" href="simple_example_8c-example.html#a5">simple_example.c</a>.</dd>
</dl>
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a0632d78965000b1e50068a64e335133b">ExtendedValue_from_hex()</a>, <a class="el" href="colr_8h.html#a3580f33d058571dffd8e5ff789c49296">rainbow_step()</a>, <a class="el" href="colr_8h.html#a6133112d9c73a8b56995e16e1af62d3b">RGB_from_hex_default()</a>, <a class="el" href="colr_8h.html#a49ce6e92a3b495166213e203ad3ab846">RGB_grayscale()</a>, <a class="el" href="colr_8h.html#a958e45854d69e8b59859244ce791673c">RGB_inverted()</a>, and <a class="el" href="colr_8h.html#abd85b5c5b79142c8656a065c58e4509e">RGB_monochrome()</a>.</p>

</div>
</div>
<a id="a7592d374ee178fd8ac19d8dabbb83662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7592d374ee178fd8ac19d8dabbb83662">&#9670;&nbsp;</a></span>style</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define style</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#afb5ac0bd012b8162cea125ad0d9e8bf0">ColorArg_to_ptr</a>(<a class="el" href="colr_8h.html#a53683a9e279942578e46768be25587d0">style_arg</a>(x))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a style suitable for use with the <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a>, <a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465" title="Like colr_cat(), but returns an allocated ColorResult that the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros will automatically free(). ">Colr_cat()</a>, and <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> macros. </p>
<p>This macro accepts strings (style names) and StyleValues.</p>
<p>Style names (<code>char*</code>) can be passed to generate the appropriate style value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A StyleValue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">A pointer to a heap-allocated <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct.</p>
<p class="enddd">If used inside of the <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a>, <a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465" title="Like colr_cat(), but returns an allocated ColorResult that the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros will automatically free(). ">Colr_cat()</a>, and <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> macros, <em>they will <code>free()</code> the result</em>. Otherwise, <em>you are responsible for calling <code>free()</code></em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a53683a9e279942578e46768be25587d0" title="Uses ColorArg_from_StyleValue to build a ColorArg with the appropriate color type/value. ">style_arg</a> </dd>
<dd>
<a class="el" href="colr_8h.html#ab307d323b317da4b6f4d24ee1929b354" title="Return just the escape code string for a style. ">style_str</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a753093cd4c872eed4b77feaa7816212b" title="Create an allocated string directly from Colr() arguments. ">colr</a> </dd>
<dd>
<a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ColorResult_example_8c-example.html#a10">ColorResult_example.c</a>, <a class="el" href="colr_cat_example_8c-example.html#a7">colr_cat_example.c</a>, <a class="el" href="Colr_example_8c-example.html#a10">Colr_example.c</a>, <a class="el" href="colr_join_example_8c-example.html#a4">colr_join_example.c</a>, <a class="el" href="colr_printf_example_8c-example.html#a3">colr_printf_example.c</a>, <a class="el" href="colr_replace_all_example_8c-example.html#a4">colr_replace_all_example.c</a>, <a class="el" href="colr_replace_example_8c-example.html#a4">colr_replace_example.c</a>, <a class="el" href="colr_replace_re_all_example_8c-example.html#a4">colr_replace_re_all_example.c</a>, <a class="el" href="colr_replace_re_example_8c-example.html#a4">colr_replace_re_example.c</a>, <a class="el" href="simple_example_8c-example.html#a9">simple_example.c</a>, and <a class="el" href="style_example_8c-example.html#a1">style_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="a53683a9e279942578e46768be25587d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53683a9e279942578e46768be25587d0">&#9670;&nbsp;</a></span>style_arg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define style_arg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_Generic( \</div><div class="line">        (x), \</div><div class="line">        <span class="keywordtype">char</span>* : <a class="code" href="colr_8h.html#aa62406b058b948941a8906475924536a">ColorArg_from_str</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>: <a class="code" href="colr_8h.html#acf63bcee395dca3ca29dc324e3d7c8f2">ColorArg_from_StyleValue</a> \</div><div class="line">    )(STYLE, x)</div><div class="ttc" id="colr_8h_html_aa62406b058b948941a8906475924536a"><div class="ttname"><a href="colr_8h.html#aa62406b058b948941a8906475924536a">ColorArg_from_str</a></div><div class="ttdeci">ColorArg ColorArg_from_str(ArgType type, const char *colorname)</div><div class="ttdoc">Build a ColorArg (fore, back, or style value) from a known color name/style. </div><div class="ttdef"><b>Definition:</b> colr.c:5196</div></div>
<div class="ttc" id="colr_8h_html_acf63bcee395dca3ca29dc324e3d7c8f2"><div class="ttname"><a href="colr_8h.html#acf63bcee395dca3ca29dc324e3d7c8f2">ColorArg_from_StyleValue</a></div><div class="ttdeci">ColorArg ColorArg_from_StyleValue(ArgType type, StyleValue value)</div><div class="ttdoc">Explicit version of ColorArg_from_value that only handles StyleValues. </div><div class="ttdef"><b>Definition:</b> colr.c:5235</div></div>
<div class="ttc" id="colr_8h_html_a85224ec2507f33b1985f4cdd0adfe0e6"><div class="ttname"><a href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a></div><div class="ttdeci">StyleValue</div><div class="ttdoc">Style values. </div><div class="ttdef"><b>Definition:</b> colr.h:2549</div></div>
</div><!-- fragment -->
<p>Uses ColorArg_from_StyleValue to build a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> with the appropriate color type/value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td><code>StyleValue</code> for the style. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> with the STYLE type set, and it's <code>.value.type</code> set for the appropriate color type/value. For invalid values the <code>.value.type</code> may be set to TYPE_INVALID.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662" title="Create a style suitable for use with the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros. ">style</a> </dd>
<dd>
<a class="el" href="colr_8h.html#ab307d323b317da4b6f4d24ee1929b354" title="Return just the escape code string for a style. ">style_str</a> </dd></dl>

</div>
</div>
<a id="a5fd8134cf00ddafc463dbce4010439af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd8134cf00ddafc463dbce4010439af">&#9670;&nbsp;</a></span>STYLE_LEN_MIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STYLE_LEN_MIN&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum length for the shortest style escape code, including `'\0'`. </p>
<p>Use STYLE_LEN for allocation. </p>

</div>
</div>
<a id="ab307d323b317da4b6f4d24ee1929b354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab307d323b317da4b6f4d24ee1929b354">&#9670;&nbsp;</a></span>style_str</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define style_str</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#ad1d3aaca5e543f8fefbd863a959c9d67">ColorArg_to_esc</a>(<a class="el" href="colr_8h.html#a53683a9e279942578e46768be25587d0">style_arg</a>(x))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return just the escape code string for a style. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>StyleValue to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string.</p>
<p class="enddd"><em>You must <code>free()</code> the memory allocated by this function.</em> </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662" title="Create a style suitable for use with the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros. ">style</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a53683a9e279942578e46768be25587d0" title="Uses ColorArg_from_StyleValue to build a ColorArg with the appropriate color type/value. ">style_arg</a> </dd></dl>

</div>
</div>
<a id="adb829be51382b5422286a8606a7ff4fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb829be51382b5422286a8606a7ff4fc">&#9670;&nbsp;</a></span>style_str_static</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define style_str_static</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(x == RESET_ALL ? <span class="stringliteral">&quot;\x1b[0m&quot;</span> : \</div><div class="line">    (x ==BRIGHT ? <span class="stringliteral">&quot;\x1b[1m&quot;</span> : \</div><div class="line">    (x == DIM ? <span class="stringliteral">&quot;\x1b[2m&quot;</span> : \</div><div class="line">    (x == ITALIC ? <span class="stringliteral">&quot;\x1b[3m&quot;</span> : \</div><div class="line">    (x == UNDERLINE ? <span class="stringliteral">&quot;\x1b[4m&quot;</span> : \</div><div class="line">    (x == FLASH ? <span class="stringliteral">&quot;\x1b[5m&quot;</span> : \</div><div class="line">    (x == HIGHLIGHT ? <span class="stringliteral">&quot;\x1b[7m&quot;</span> : \</div><div class="line">    (x == STRIKETHRU ? <span class="stringliteral">&quot;\x1b[9m&quot;</span> : \</div><div class="line">    (x == NORMAL ? <span class="stringliteral">&quot;\x1b[22m&quot;</span> : \</div><div class="line">    (x == FRAME ? <span class="stringliteral">&quot;\x1b[51m&quot;</span> : \</div><div class="line">    (x == ENCIRCLE ? <span class="stringliteral">&quot;\x1b[52m&quot;</span> : \</div><div class="line">    (x == OVERLINE ? <span class="stringliteral">&quot;\x1b[53m&quot;</span> : <span class="stringliteral">&quot;\x1b[&quot;</span> colr_macro_str(x) <span class="stringliteral">&quot;m&quot;</span> \</div><div class="line">    ))))))))))))</div></div><!-- fragment -->
<p>A less-flexible <a class="el" href="colr_8h.html#ab307d323b317da4b6f4d24ee1929b354" title="Return just the escape code string for a style. ">style_str()</a> that returns a static escape code string for a style. </p>
<p>This macro function does not accept style names. Only <code>StyleValue</code> and literal <code>int</code> values are accepted.</p>
<p>The resulting expression will be optimized into a constant static string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A StyleValue to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A stack-allocated string.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#ad0ab6c47eae67006285e33f1edd84278" title="Creates a stack-allocated escape code string (char*) for a fore color. ">fore_str_static</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a686865036c288a8c6d1626ce2f120039" title="Creates a stack-allocated escape code string (char*) for a back color. ">back_str_static</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a6027d93e8768f3c152edafd92e757801" title="Create an escape code for a fore color. ">format_fg</a> </dd>
<dd>
<a class="el" href="colr_8h.html#ae29032483aea8cb25d6b90750767ffc1" title="Create an escape code for a background color. ">format_bg</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#style_str_static-example" id="style_str_static-example" class="diamond-bullet">&#160;</a> style_str_static example: </div><div class="fragment"><div class="line"><span class="comment">// This is optimized into a constant static string, even with -g3.</span></div><div class="line"><span class="keywordtype">char</span>* ul_codes = <a class="code" href="colr_8h.html#adb829be51382b5422286a8606a7ff4fc">style_str_static</a>(UNDERLINE);</div><div class="line">printf(<span class="stringliteral">&quot;%sUnderlined.\n&quot;</span> <a class="code" href="colr_8h.html#a1fa2460e32327ade49189c95740bc1b5">NC</a>, ul_codes);</div><div class="line"></div><div class="line"><span class="comment">// This is also optimized as if you wrote the string &quot;\x1b[4m&quot;.</span></div><div class="line">printf(<span class="stringliteral">&quot;%sNo branches.\n&quot;</span> <a class="code" href="colr_8h.html#a1fa2460e32327ade49189c95740bc1b5">NC</a>, <a class="code" href="colr_8h.html#adb829be51382b5422286a8606a7ff4fc">style_str_static</a>(UNDERLINE));</div><div class="line"></div><div class="line"><span class="comment">// This is only optimized when optimizations are turned on (-O2, -O3)</span></div><div class="line"><span class="comment">// because of the variable `sval`.</span></div><div class="line"><span class="comment">// When compiling for debug (-g3), the compiler will produce branches/jumps</span></div><div class="line"><span class="comment">// for each possible StyleValue case.</span></div><div class="line"><a class="code" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a> sval = BRIGHT;</div><div class="line">printf(<span class="stringliteral">&quot;%sBranches in debug mode.\n&quot;</span> <a class="code" href="colr_8h.html#a1fa2460e32327ade49189c95740bc1b5">NC</a>, <a class="code" href="colr_8h.html#adb829be51382b5422286a8606a7ff4fc">style_str_static</a>(sval));</div></div><!-- fragment --> </div> 
</div>
</div>
<a id="ad1d2ceec58f8075f06e09f277c8893ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d2ceec58f8075f06e09f277c8893ae">&#9670;&nbsp;</a></span>while_colr_va_arg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define while_colr_va_arg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ap, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">vartype, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;while (x = va_arg(ap, vartype), !<a class="el" href="colr_8h.html#af64af11f4992c8143cb722772df98c98">_colr_is_last_arg</a>(x))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a while-loop over a <code>va_list</code>, where the last argument is expected to be _ColrLastArg, or a pointer to a _ColrLastArg_s with the same values as _ColrLastArg. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ap</td><td>The <code>va_list</code> to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vartype</td><td>Expected type of the argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The variable to assign to (usually <code>arg</code>). </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>, <a class="el" href="colr_8h.html#a91a051ef4cd2e7200a31f9de48766b4c">_colr_join_size()</a>, <a class="el" href="colr_8h.html#ad4702d6ddc409a93a0b42c8f6141d2f2">ColorText_from_values()</a>, and <a class="el" href="colr_8h.html#a880b39cd2ce9b622dbe7790a162d88f7">ColorText_set_values()</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="adc966460db21ff6c35f23fcf6abe541e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc966460db21ff6c35f23fcf6abe541e">&#9670;&nbsp;</a></span>RGB_fmter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* RGB_fmter) (char *out, <a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function type that knows how to fill a string with an rgb escape code. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a0c061fbfddd43dfe324486dc86cb92ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c061fbfddd43dfe324486dc86cb92ee">&#9670;&nbsp;</a></span>BasicValue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Basic color values, with a few convenience values for extended colors. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aaa888f1b31eb40ec7d252d3ee9175d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa888f1b31eb40ec7d252d3ee9175d76">&#9670;&nbsp;</a></span>_colr_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _colr_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls Colr <code>*_free()</code> functions for Colr objects, otherwise just calls <code>free()</code>. </p>
<p>You should use the <a class="el" href="colr_8h.html#a76eae619668e01987653932a7492fd94" title="Calls the &lt;type&gt;_free functions for the supported types. ">colr_free()</a> macro instead.</p>
<dl class="section warning"><dt>Warning</dt><dd>This is for internal use only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Pointer to a heap-allocated object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af64af11f4992c8143cb722772df98c98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af64af11f4992c8143cb722772df98c98">&#9670;&nbsp;</a></span>_colr_is_last_arg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool _colr_is_last_arg </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a void pointer is _ColrLastArg (the last-arg-marker). </p>
<dl class="section warning"><dt>Warning</dt><dd>This is for internal use only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The pointer to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the pointer is _ColrLastArg, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a4227a65824fdd699a25d3200706c9e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4227a65824fdd699a25d3200706c9e9e">&#9670;&nbsp;</a></span>_colr_join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* _colr_join </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>joinerp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Joins ColorArgs, ColorTexts, and strings (<code>char*</code>) into one long string separated by it's first argument. </p>
<p>This will free() any <code><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a></code>s, <code><a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a></code>s, or <code><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a></code>s that are passed in. It is backing the <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, <a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465" title="Like colr_cat(), but returns an allocated ColorResult that the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros will automatically free(). ">Colr_cat()</a>, and <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> macros, and enables easy throw-away color values.</p>
<p>Any plain strings that are passed in are left alone. It is up to the caller to free those. ColrC only manages the temporary Colr-based objects needed to build up these strings.</p>
<p>You should use <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, <a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465" title="Like colr_cat(), but returns an allocated ColorResult that the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros will automatically free(). ">Colr_cat()</a>, and <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> macros instead.</p>
<dl class="section warning"><dt>Warning</dt><dd>This is for internal use only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">joinerp</td><td>The joiner (any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, or string). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Zero or more ColorArgs, ColorResults, ColorTexts, or strings to join by the joiner. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with mixed escape codes/strings. CODE_RESET_ALL is appended to all <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> arguments. This allows easy part-colored messages.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. Also, <code>NULL</code> will be returned if <code>joinerp</code> is <code>NULL</code>. </p>
</dd></dl>

</div>
</div>
<a id="a6d47ac6ee2a59e1c976cf2838545aa25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d47ac6ee2a59e1c976cf2838545aa25">&#9670;&nbsp;</a></span>_colr_join_array_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t _colr_join_array_length </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the length of a <code>NULL</code>-terminated array of strings (<code>char*</code>), <code><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a></code>s, <code><a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a></code>s, or <code><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a></code>s. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is for internal use only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ps</td><td>A <code>NULL</code>-terminated array of <code><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a></code>s, <code><a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a></code>s, <code><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a></code>s, or strings (<code>char*</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of items (before <code>NULL</code>) in the array. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a701126bd27c90fafa46152d9f9327b2f">colr_join_array()</a>.</p>

</div>
</div>
<a id="ac49c3a33d328ebaf2b0564d5a9b1d4ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac49c3a33d328ebaf2b0564d5a9b1d4ec">&#9670;&nbsp;</a></span>_colr_join_arrayn_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t _colr_join_arrayn_size </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>joinerp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size in bytes needed to join an array of strings (<code>char*</code>), <code><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a></code>s, <code><a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a></code>s, or <code><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a></code>s by another string (<code>char*</code>), <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>. </p>
<p>This is used to allocate memory in the _colr_join_array() function.</p>
<dl class="section warning"><dt>Warning</dt><dd>This is for internal use only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">joinerp</td><td>The joiner (any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, or string). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ps</td><td>An array of pointers to <code><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a></code>s, <code><a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a></code>s, <code><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a></code>s, or strings. The array must have <code>NULL</code> as the last item if <code>count</code> is greater than the total number of items. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Total number of items in the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes needed to allocate the result of <a class="el" href="colr_8c.html#a71fcf08ad36d4424790e275d973445fc" title="Join an array of strings (char*), ColorArgs, or ColorTexts by another string (char*), ColorArg, or ColorText. ">colr_join_arrayn()</a>, possibly <code>0</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a753093cd4c872eed4b77feaa7816212b" title="Create an allocated string directly from Colr() arguments. ">colr</a> </dd>
<dd>
<a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join</a> </dd>
<dd>
<a class="el" href="colr_8c.html#a701126bd27c90fafa46152d9f9327b2f" title="Join an array of strings (char*), ColorArgs, or ColorTexts by another string (char*), ColorArg, or ColorText. ">colr_join_array</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a71fcf08ad36d4424790e275d973445fc">colr_join_arrayn()</a>.</p>

</div>
</div>
<a id="a91a051ef4cd2e7200a31f9de48766b4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a051ef4cd2e7200a31f9de48766b4c">&#9670;&nbsp;</a></span>_colr_join_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t _colr_join_size </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>joinerp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse arguments, just as in <a class="el" href="colr_8c.html#a4227a65824fdd699a25d3200706c9e9e" title="Joins ColorArgs, ColorTexts, and strings (char*) into one long string separated by it&#39;s first argumen...">_colr_join()</a>, but only return the size needed to allocate the resulting string. </p>
<p>This allows <a class="el" href="colr_8c.html#a4227a65824fdd699a25d3200706c9e9e" title="Joins ColorArgs, ColorTexts, and strings (char*) into one long string separated by it&#39;s first argumen...">_colr_join()</a> to allocate once, instead of reallocating for each argument that is passed.</p>
<dl class="section warning"><dt>Warning</dt><dd>This is for internal use only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">joinerp</td><td>The joiner (any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, or string (<code>char*</code>)). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>A <code>va_list</code> with zero or more <code><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a></code>s, <code><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a></code>s, or strings (<code>char*</code>) to join. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length (in bytes) needed to allocate a string built with _colr_cat(). This function will return <code>0</code> if <code>joinerp</code> is <code>NULL</code>/empty). Except for <code>0</code>, it will never return anything less than <code>CODE_RESET_LEN</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>_colr </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>.</p>

</div>
</div>
<a id="ab0be451277fc7e39aee0aa409c9d3f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0be451277fc7e39aee0aa409c9d3f0c">&#9670;&nbsp;</a></span>_colr_ptr_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t _colr_ptr_length </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size, in bytes, needed to convert a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, or string (<code>char*</code>) into a string. </p>
<p>This is used in the variadic _colr* functions.</p>
<dl class="section warning"><dt>Warning</dt><dd>This is for internal use only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointer, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> pointer, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointer, or string (<code>char*</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length needed to convert the object into a string (<code>strlen() + 1</code> for strings). </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ac49c3a33d328ebaf2b0564d5a9b1d4ec">_colr_join_arrayn_size()</a>, and <a class="el" href="colr_8h.html#a91a051ef4cd2e7200a31f9de48766b4c">_colr_join_size()</a>.</p>

</div>
</div>
<a id="a30cac3017a6ea8c78277882554c9419f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30cac3017a6ea8c78277882554c9419f">&#9670;&nbsp;</a></span>_colr_ptr_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* _colr_ptr_repr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine what kind of pointer is being passed, and call the appropriate &lt;type&gt;_repr function to obtain an allocated string representation. </p>
<p>You should use <a class="el" href="colr_8h.html#ac1ef824dd213274fb239526269315543" title="Transforms several ColrC objects into their string representations. ">colr_repr()</a> instead.</p>
<dl class="section warning"><dt>Warning</dt><dd>This is for internal use only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointer, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> pointer, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointer, or string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#ac1ef824dd213274fb239526269315543" title="Transforms several ColrC objects into their string representations. ">colr_repr</a> </dd></dl>

</div>
</div>
<a id="a0d97f9b535a69642b926b38dce30b180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d97f9b535a69642b926b38dce30b180">&#9670;&nbsp;</a></span>_colr_ptr_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* _colr_ptr_to_str </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine what kind of pointer is being passed, and call the appropriate &lt;type&gt;_to_str function to obtain an allocated string. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is for internal use only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointer, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> pointer, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointer, or string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>

</div>
</div>
<a id="ab88ca919420f2df896b7973401641ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab88ca919420f2df896b7973401641ab4">&#9670;&nbsp;</a></span>_rainbow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* _rainbow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#adc966460db21ff6c35f23fcf6abe541e">RGB_fmter</a>&#160;</td>
          <td class="paramname"><em>fmter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>spread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles multibyte character string (<code>char*</code>) conversion and character iteration for all of the rainbow_ functions. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is for internal use only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fmter</td><td>A formatter function (RGB_fmter) that can create escape codes from <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">The string to "rainbowize".</p>
<p class="endtd">Input <em>must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freq</td><td>The "tightness" for colors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting offset into the rainbow. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spread</td><td>Number of characters per color. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string (<code>char*</code>) with the result.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ab39e0b3981b4f0a8a113c6949bc8b103">rainbow_bg()</a>, <a class="el" href="colr_8h.html#adf264c63c394f9ecb19cd8565cda7197">rainbow_bg_term()</a>, <a class="el" href="colr_8h.html#ac50eca5901ca237550cf4129237a3411">rainbow_fg()</a>, and <a class="el" href="colr_8h.html#a5a24d379435d64d1212858b173e6f9a7">rainbow_fg_term()</a>.</p>

</div>
</div>
<a id="a69d1fc130eeaf6ed62066e25478cb433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69d1fc130eeaf6ed62066e25478cb433">&#9670;&nbsp;</a></span>ArgType_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ArgType_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two ArgTypes. </p>
<p>This is used to implement <a class="el" href="colr_8h.html#a36af8aa0f01eaa780da182e856923faa" title="Calls the &lt;type&gt;_eq functions for the supported types. ">colr_eq()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first ArgType to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second ArgType to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if they are equal, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="ad01ccaf04c71fc2474da94b050236572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01ccaf04c71fc2474da94b050236572">&#9670;&nbsp;</a></span>ArgType_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ArgType_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation of a ArgType. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>An ArgType to get the type from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">A pointer to an allocated string.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1" title="Argument types (fore, back, style). ">ArgType</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a5af692f2357d46b9cee45bb114f2a4a2">ColorArg_repr()</a>.</p>

</div>
</div>
<a id="a2b270bebb1a01212b7e44e52f61f94be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b270bebb1a01212b7e44e52f61f94be">&#9670;&nbsp;</a></span>ArgType_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ArgType_to_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a human-friendly string (<code>char*</code>) from an ArgType. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>An ArgType to get the type from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">A pointer to an allocated string.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1" title="Argument types (fore, back, style). ">ArgType</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#aa54ab1879f6de8ca2fcb4702250741f5">ColorArg_example()</a>.</p>

</div>
</div>
<a id="a17bf46ac385e41b729d07a65dd506cba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17bf46ac385e41b729d07a65dd506cba">&#9670;&nbsp;</a></span>BasicValue_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BasicValue_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two BasicValues. </p>
<p>This is used to implement <a class="el" href="colr_8h.html#a36af8aa0f01eaa780da182e856923faa" title="Calls the &lt;type&gt;_eq functions for the supported types. ">colr_eq()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first BasicValue to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second BasicValue to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if they are equal, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee" title="Basic color values, with a few convenience values for extended colors. ">BasicValue</a> </dd></dl>

</div>
</div>
<a id="a481b2cb2526e58b2fdb2e52a722d987b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a481b2cb2526e58b2fdb2e52a722d987b">&#9670;&nbsp;</a></span>BasicValue_from_esc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> BasicValue_from_esc </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an escape-code string (<code>char*</code>) to an actual BasicValue enum value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">Escape-code string.</p>
<p class="endtd"><em>Must be <code>null</code>-terminated</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">BasicValue</td><td>value on success. </td></tr>
    <tr><td class="paramname">BASIC_INVALID</td><td>on error (or if <code>s</code> is <code>NULL</code>). </td></tr>
    <tr><td class="paramname">BASIC_INVALID_RANGE</td><td>if the code number was outside of the range <code>0-255</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee" title="Basic color values, with a few convenience values for extended colors. ">BasicValue</a> </dd></dl>

</div>
</div>
<a id="a4163ac65dca3e222525808b80a40b733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4163ac65dca3e222525808b80a40b733">&#9670;&nbsp;</a></span>BasicValue_from_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> BasicValue_from_str </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert named argument to an actual BasicValue enum value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Color name to find the BasicValue for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BasicValue value on success, or BASIC_INVALID on error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee" title="Basic color values, with a few convenience values for extended colors. ">BasicValue</a> </dd></dl>

</div>
</div>
<a id="a6332bbd16e746a02491eee70c13d0735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6332bbd16e746a02491eee70c13d0735">&#9670;&nbsp;</a></span>BasicValue_is_invalid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BasicValue_is_invalid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>bval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a BasicValue is invalid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bval</td><td>A BasicValue to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is considered invalid, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee" title="Basic color values, with a few convenience values for extended colors. ">BasicValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#af0b464ee51d75d7f45ddd5926a7c9cf5">ExtendedValue_from_BasicValue()</a>.</p>

</div>
</div>
<a id="a29e4c8a4789232c78b9ef17e292839ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29e4c8a4789232c78b9ef17e292839ca">&#9670;&nbsp;</a></span>BasicValue_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BasicValue_is_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>bval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a BasicValue is valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bval</td><td>A BasicValue to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is considered valid, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee" title="Basic color values, with a few convenience values for extended colors. ">BasicValue</a> </dd></dl>

</div>
</div>
<a id="a1bc0d9917621cab5b3efd162b7dc5a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc0d9917621cab5b3efd162b7dc5a8c">&#9670;&nbsp;</a></span>BasicValue_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* BasicValue_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>bval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation of a BasicValue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bval</td><td>A BasicValue to get the value from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">A pointer to an allocated string.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee" title="Basic color values, with a few convenience values for extended colors. ">BasicValue</a> </dd></dl>

</div>
</div>
<a id="a71a78ebb45cb53792d4c658bade99a70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71a78ebb45cb53792d4c658bade99a70">&#9670;&nbsp;</a></span>BasicValue_to_ansi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BasicValue_to_ansi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>bval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a fore/back BasicValue to the actual ansi code number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ArgType (FORE/BACK). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bval</td><td>BasicValue to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer usable with basic escape code fore/back colors.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee" title="Basic color values, with a few convenience values for extended colors. ">BasicValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ae29032483aea8cb25d6b90750767ffc1">format_bg()</a>, and <a class="el" href="colr_8h.html#a6027d93e8768f3c152edafd92e757801">format_fg()</a>.</p>

</div>
</div>
<a id="a83ea2f6c1adea8535ae629051e74ced0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83ea2f6c1adea8535ae629051e74ced0">&#9670;&nbsp;</a></span>BasicValue_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* BasicValue_to_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>bval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a human-friendly string (<code>char*</code>) representation for a BasicValue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bval</td><td>BasicValue to get the name for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee" title="Basic color values, with a few convenience values for extended colors. ">BasicValue</a> </dd></dl>

</div>
</div>
<a id="af838f8479681d809beb868b2e1b547e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af838f8479681d809beb868b2e1b547e7">&#9670;&nbsp;</a></span>ColorArg_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> ColorArg_empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> with ARGTYPE_NONE and ColorValue.type.TYPE_NONE. </p>
<p>This is used to pass "empty" fore/back/style args to the <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a>, <a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465" title="Like colr_cat(), but returns an allocated ColorResult that the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros will automatically free(). ">Colr_cat()</a>, and <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> macros, where <code>NULL</code> may have a different meaning for users of the <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>(<a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>){.type=ARGTYPE_NONE, .value.type=TYPE_NONE}</code></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#a752355c2d96d35688d3756558f8421ba" title="Checks to see if a ColorArg is an empty placeholder. ">ColorArg_is_empty</a> </dd>
<dd>
<a class="el" href="colr_8c.html#a5ce7c54ad0e31ecf6d790c5770c2b66b" title="Create an &quot;empty&quot; ColorValue. ">ColorValue_empty</a> </dd></dl>

</div>
</div>
<a id="acb62efc0182d6f6107055eeda961a628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb62efc0182d6f6107055eeda961a628">&#9670;&nbsp;</a></span>ColorArg_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorArg_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> structs. </p>
<p>They are considered "equal" if their <code>.type</code> and <code>.value</code> match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if they are equal, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a93f65430500d003575c547eb667330b0">ColorText_has_arg()</a>.</p>

</div>
</div>
<a id="aa54ab1879f6de8ca2fcb4702250741f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa54ab1879f6de8ca2fcb4702250741f5">&#9670;&nbsp;</a></span>ColorArg_example()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorArg_example </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>carg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>colorized</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a string (<code>char*</code>) representation of a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> with a stylized type/name using escape codes built from the <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">carg</td><td>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to get an example string for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">colorized</td><td>Whether to include a colorized example. If set to <code>false</code>, there will be no escape-codes in the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#ColorArg_example-example" id="ColorArg_example-example" class="diamond-bullet">&#160;</a> ColorArg_example example: </div><div class="fragment"><div class="line"><a class="code" href="colr_8h.html#structColorArg">ColorArg</a> args[] = {</div><div class="line">    <a class="code" href="colr_8h.html#a3cc38de52ea52344113083ba4d90088e">fore_arg</a>(<a class="code" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>(75, 25, 155)),</div><div class="line">    <a class="code" href="colr_8h.html#a3cc38de52ea52344113083ba4d90088e">fore_arg</a>(<a class="code" href="colr_8h.html#aa3c79297600d8ab15a495843d63db54d">ext_hex</a>(<span class="stringliteral">&quot;#ff00bb&quot;</span>)),</div><div class="line">    <a class="code" href="colr_8h.html#aeba419af1d4c23615eb844db37e46ee6">back_arg</a>(RED),</div><div class="line">    <a class="code" href="colr_8h.html#a53683a9e279942578e46768be25587d0">style_arg</a>(UNDERLINE),</div><div class="line">    <a class="code" href="colr_8h.html#a3cc38de52ea52344113083ba4d90088e">fore_arg</a>(<span class="stringliteral">&quot;NOT_VALID&quot;</span>),</div><div class="line">    <a class="code" href="colr_8h.html#aeba419af1d4c23615eb844db37e46ee6">back_arg</a>(<span class="stringliteral">&quot;NOT_VALID&quot;</span>),</div><div class="line">    <a class="code" href="colr_8h.html#a53683a9e279942578e46768be25587d0">style_arg</a>(<span class="stringliteral">&quot;NOT_VALID&quot;</span>)</div><div class="line">};</div><div class="line"><span class="keywordtype">size_t</span> arg_len = <span class="keyword">sizeof</span>(args) / <span class="keyword">sizeof</span>(args[0]);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; arg_len; i++) {</div><div class="line">    <span class="keywordtype">char</span>* example = <a class="code" href="colr_8c.html#aa54ab1879f6de8ca2fcb4702250741f5">ColorArg_example</a>(args[i], <span class="keyword">true</span>);</div><div class="line">    <span class="keywordflow">if</span> (!example) <span class="keywordflow">continue</span>;</div><div class="line">    printf(<span class="stringliteral">&quot;%s\n&quot;</span>, example);</div><div class="line">    free(example);</div><div class="line">}</div></div><!-- fragment --> </div> 
</div>
</div>
<a id="aa1163a9c866767fb7fcb734d3c0d9b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1163a9c866767fb7fcb734d3c0d9b7c">&#9670;&nbsp;</a></span>ColorArg_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ColorArg_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free allocated memory for a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>. </p>
<p>This has no advantage over <code>free(colorarg)</code> right now, it is used in debugging, and may be extended in the future. It's better just to use it (or the <a class="el" href="colr_8h.html#a76eae619668e01987653932a7492fd94" title="Calls the &lt;type&gt;_free functions for the supported types. ">colr_free()</a> macro).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to free.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#aaa888f1b31eb40ec7d252d3ee9175d76">_colr_free()</a>, <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>, <a class="el" href="colr_8h.html#a4979a2ec9d5fb442ba025c6f2efc4864">ColorText_free_args()</a>, <a class="el" href="colr_8h.html#a34c359a48f811316d765b7abef1ea8f4">colr_printf_handler()</a>, <a class="el" href="colr_8h.html#af7c01a492bcbda6cf93705bff0cb0dbe">colr_str_replace_all_ColorArg()</a>, <a class="el" href="colr_8h.html#aa8b61a4cadcf73e21eee109623695bad">colr_str_replace_ColorArg()</a>, <a class="el" href="colr_8h.html#a577e45a5c233dd1b4774a9034b17e3eb">colr_str_replace_re_all_ColorArg()</a>, <a class="el" href="colr_8h.html#a78d58bde53845d6ab2c54e4ba0c68a3d">colr_str_replace_re_ColorArg()</a>, <a class="el" href="colr_8h.html#a0d4cbd6a8fd3cef76f07b705b09d2a54">colr_str_replace_re_match_ColorArg()</a>, <a class="el" href="colr_8h.html#a75b2cdee697818e2f9f38ec7eac98bcb">colr_str_replace_re_matches_ColorArg()</a>, <a class="el" href="colr_8h.html#a090ba95c4560134ef9c2807eff6a0ea1">colr_str_replace_re_pat_all_ColorArg()</a>, and <a class="el" href="colr_8h.html#adecbe2f1e87613b6f4a51158325dd4f7">colr_str_replace_re_pat_ColorArg()</a>.</p>

</div>
</div>
<a id="aad49f4597388e6bdb896ff28334cd5e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad49f4597388e6bdb896ff28334cd5e6">&#9670;&nbsp;</a></span>ColorArg_from_BasicValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> ColorArg_from_BasicValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicit version of ColorArg_from_value that only handles BasicValues. </p>
<p>This is used in some macros to aid in dynamic escape code creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ArgType (FORE, BACK, STYLE). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>BasicValue to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, with the <code>.value.type</code> member possibly set to <code>TYPE_INVALID</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

</div>
</div>
<a id="a70e9640f37dd85cde0b6f25c0b705912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70e9640f37dd85cde0b6f25c0b705912">&#9670;&nbsp;</a></span>ColorArg_from_esc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> ColorArg_from_esc </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an escape-code string (<code>char*</code>) into a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>. </p>
<p>For malformed escape-codes the <code>.type</code> member will be <code>ARGTYPE_NONE</code>, and the <code>.value.type</code> member will be set to <code>TYPE_INVALID</code>. This means that <code>ColorArg_is_invalid(carg) == true</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The escape code to parse. It must not have extra characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An initialized <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, possibly invalid.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd>
<dd>
<a class="el" href="colr_8c.html#a6292cbb8bd9f3d19bb0bd05a4d7b0bea" title="Get an array of escape-codes from a string (char*). ">colr_str_get_codes</a> </dd>
<dd>
<a class="el" href="colr_8c.html#af308e8dcd4a1d47a05736882d5a9698d" title="Convert an escape-code string (char*) into a ColorValue. ">ColorValue_from_esc</a> </dd>
<dd>
<a class="el" href="colr_8c.html#a481b2cb2526e58b2fdb2e52a722d987b" title="Convert an escape-code string (char*) to an actual BasicValue enum value. ">BasicValue_from_esc</a> </dd>
<dd>
<a class="el" href="colr_8c.html#aaabf63956f397a0fe628313622ba5cde" title="Convert an escape-code string (char*) to an ExtendedValue. ">ExtendedValue_from_esc</a> </dd>
<dd>
<a class="el" href="colr_8c.html#a9f4fd7f8901569c053bd29f2035c69b7" title="Convert an escape-code string (char*) to an actual StyleValue enum value. ">StyleValue_from_esc</a> </dd>
<dd>
<a class="el" href="colr_8c.html#a252adee47cc218a9208f16cb0ff42bfe" title="Convert an escape-code string (char*) to an actual RGB value. ">RGB_from_esc</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a4897abe50811762a84ee409c0c2d300f">ColorArgs_from_str()</a>.</p>

</div>
</div>
<a id="aed30e2a4b30ab5e3cf49608a3c410cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed30e2a4b30ab5e3cf49608a3c410cc5">&#9670;&nbsp;</a></span>ColorArg_from_ExtendedValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> ColorArg_from_ExtendedValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicit version of ColorArg_from_value that only handles ExtendedValues. </p>
<p>This is used in some macros to aid in dynamic escape code creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ArgType (FORE, BACK, STYLE). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>ExtendedValue to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, with the <code>.value.type</code> member possibly set to <code>TYPE_INVALID</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

</div>
</div>
<a id="aaa24bba74e99aa66ed41839576e57856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa24bba74e99aa66ed41839576e57856">&#9670;&nbsp;</a></span>ColorArg_from_RGB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> ColorArg_from_RGB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicit version of ColorArg_from_value that only handles <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> structs. </p>
<p>This is used in some macros to aid in dynamic escape code creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ArgType (FORE, BACK, STYLE). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, with the <code>.value.type</code> member possibly set to <code>TYPE_INVALID</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

</div>
</div>
<a id="aa62406b058b948941a8906475924536a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa62406b058b948941a8906475924536a">&#9670;&nbsp;</a></span>ColorArg_from_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> ColorArg_from_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>colorname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> (fore, back, or style value) from a known color name/style. </p>
<p>The <code>.value.type</code> attribute can be checked for an invalid type, or you can call ColorArg_is_invalid(x).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ArgType (FORE, BACK, STYLE). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">colorname</td><td>A known color name/style.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct with usable values.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

</div>
</div>
<a id="acf63bcee395dca3ca29dc324e3d7c8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf63bcee395dca3ca29dc324e3d7c8f2">&#9670;&nbsp;</a></span>ColorArg_from_StyleValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> ColorArg_from_StyleValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicit version of ColorArg_from_value that only handles StyleValues. </p>
<p>This is used in some macros to aid in dynamic escape code creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ArgType (FORE, BACK, STYLE). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>StyleValue to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, with the <code>.value.type</code> member possibly set to <code>TYPE_INVALID</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

</div>
</div>
<a id="a89a5aa762bd5802872faf571aa32ea35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a5aa762bd5802872faf571aa32ea35">&#9670;&nbsp;</a></span>ColorArg_from_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> ColorArg_from_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>&#160;</td>
          <td class="paramname"><em>colrtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used with the color_arg macro to dynamically create a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> based on it's argument type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ArgType value, to mark the type of <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">colrtype</td><td>ColorType value, to mark the type of <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A pointer to either a BasicValue, ExtendedValue, or a <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct with the appropriate <code>.value.type</code> member set for the value that was passed. For invalid types the <code>.value.type</code> member may be set to one of:<ul>
<li>TYPE_INVALID</li>
<li>TYPE_INVALID_EXT_RANGE</li>
<li>TYPE_INVALID_RGB_RANGE</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

</div>
</div>
<a id="a752355c2d96d35688d3756558f8421ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a752355c2d96d35688d3756558f8421ba">&#9670;&nbsp;</a></span>ColorArg_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorArg_is_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>carg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> is an empty placeholder. </p>
<p>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> is empty if it's <code>.type</code> is set to <code>ARGTYPE_NONE</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">carg</td><td>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> is considered "empty", otherwise <code>false</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#adaff727006f4c057aab75e55bfb473c4">ColorArg_length()</a>, <a class="el" href="colr_8h.html#ad1d3aaca5e543f8fefbd863a959c9d67">ColorArg_to_esc()</a>, <a class="el" href="colr_8h.html#abaf3d02ff1292f2aaa605522665ae564">ColorArg_to_esc_s()</a>, <a class="el" href="colr_8h.html#a93b38987063bb127bb34761961d7f678">ColorText_has_args()</a>, and <a class="el" href="colr_8h.html#ae305b33e0a44b956ccf4123aa4f1a033">ColorText_to_str()</a>.</p>

</div>
</div>
<a id="a66b4906cfb08588005536db1250dc899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b4906cfb08588005536db1250dc899">&#9670;&nbsp;</a></span>ColorArg_is_invalid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorArg_is_invalid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>carg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> holds an invalid value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">carg</td><td><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is invalid, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

</div>
</div>
<a id="ad15f3a714a6383123d3fb24ade173e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad15f3a714a6383123d3fb24ade173e29">&#9670;&nbsp;</a></span>ColorArg_is_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorArg_is_ptr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks a void pointer to see if it contains a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct. </p>
<p>The first member of a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> is a marker.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A void pointer to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the pointer is a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#aaa888f1b31eb40ec7d252d3ee9175d76">_colr_free()</a>, <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>, <a class="el" href="colr_8h.html#a6d47ac6ee2a59e1c976cf2838545aa25">_colr_join_array_length()</a>, <a class="el" href="colr_8h.html#ac49c3a33d328ebaf2b0564d5a9b1d4ec">_colr_join_arrayn_size()</a>, <a class="el" href="colr_8h.html#ab0be451277fc7e39aee0aa409c9d3f0c">_colr_ptr_length()</a>, <a class="el" href="colr_8h.html#a30cac3017a6ea8c78277882554c9419f">_colr_ptr_repr()</a>, <a class="el" href="colr_8h.html#a0d97f9b535a69642b926b38dce30b180">_colr_ptr_to_str()</a>, <a class="el" href="colr_8h.html#ad4702d6ddc409a93a0b42c8f6141d2f2">ColorText_from_values()</a>, <a class="el" href="colr_8h.html#a880b39cd2ce9b622dbe7790a162d88f7">ColorText_set_values()</a>, <a class="el" href="colr_8h.html#a71fcf08ad36d4424790e275d973445fc">colr_join_arrayn()</a>, and <a class="el" href="colr_8h.html#a34c359a48f811316d765b7abef1ea8f4">colr_printf_handler()</a>.</p>

</div>
</div>
<a id="a1e446f65d6987d52522a1755c909d421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e446f65d6987d52522a1755c909d421">&#9670;&nbsp;</a></span>ColorArg_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorArg_is_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>carg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> holds a valid value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">carg</td><td><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is valid, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

</div>
</div>
<a id="adaff727006f4c057aab75e55bfb473c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaff727006f4c057aab75e55bfb473c4">&#9670;&nbsp;</a></span>ColorArg_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ColorArg_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>carg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length in bytes needed to allocate a string (<code>char*</code>) built with <a class="el" href="colr_8c.html#ad1d3aaca5e543f8fefbd863a959c9d67" title="Converts a ColorArg into an escape code string (char*). ">ColorArg_to_esc()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">carg</td><td><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length (<code>size_t</code>) needed to allocate a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string, or <code>1</code> (size of an empty string) for invalid/empty arg types/values.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ac49c3a33d328ebaf2b0564d5a9b1d4ec">_colr_join_arrayn_size()</a>, <a class="el" href="colr_8h.html#ab0be451277fc7e39aee0aa409c9d3f0c">_colr_ptr_length()</a>, and <a class="el" href="colr_8h.html#a412833a097b050c8ee99874c733bd030">ColorText_length()</a>.</p>

</div>
</div>
<a id="a5af692f2357d46b9cee45bb114f2a4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af692f2357d46b9cee45bb114f2a4a2">&#9670;&nbsp;</a></span>ColorArg_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorArg_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>carg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation for a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>. </p>
<p>Allocates memory for the string representation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">carg</td><td><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct to get the representation for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">Allocated string for the representation.</p>
<p class="enddd"><em>You must <code>free()</code> the memory allocated by this function.</em> </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a30cac3017a6ea8c78277882554c9419f">_colr_ptr_repr()</a>, and <a class="el" href="colr_8h.html#a65363a3601cd9cfcdc7fc40722d5d3c3">ColorText_repr()</a>.</p>

</div>
</div>
<a id="ad1d3aaca5e543f8fefbd863a959c9d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d3aaca5e543f8fefbd863a959c9d67">&#9670;&nbsp;</a></span>ColorArg_to_esc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorArg_to_esc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>carg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> into an escape code string (<code>char*</code>). </p>
<p>Allocates memory for the string.</p>
<p>If the <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> is empty (<code>ARGTYPE_NONE</code>), an empty string is returned.</p>
<p>If the <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> is invalid, an empty string is returned. You must still free the empty string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">carg</td><td><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to get the ArgType and <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">Allocated string for the escape code.</p>
<p class="enddd"><em>You must <code>free()</code> the memory allocated by this function.</em> If the <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> is considered "empty", or the <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> is invalid, then <code>NULL</code> is returned. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>, <a class="el" href="colr_8h.html#a0d97f9b535a69642b926b38dce30b180">_colr_ptr_to_str()</a>, <a class="el" href="colr_8h.html#ae305b33e0a44b956ccf4123aa4f1a033">ColorText_to_str()</a>, <a class="el" href="colr_8h.html#a71fcf08ad36d4424790e275d973445fc">colr_join_arrayn()</a>, <a class="el" href="colr_8h.html#a34c359a48f811316d765b7abef1ea8f4">colr_printf_handler()</a>, <a class="el" href="colr_8h.html#af7c01a492bcbda6cf93705bff0cb0dbe">colr_str_replace_all_ColorArg()</a>, <a class="el" href="colr_8h.html#aa8b61a4cadcf73e21eee109623695bad">colr_str_replace_ColorArg()</a>, <a class="el" href="colr_8h.html#a577e45a5c233dd1b4774a9034b17e3eb">colr_str_replace_re_all_ColorArg()</a>, <a class="el" href="colr_8h.html#a78d58bde53845d6ab2c54e4ba0c68a3d">colr_str_replace_re_ColorArg()</a>, <a class="el" href="colr_8h.html#a0d4cbd6a8fd3cef76f07b705b09d2a54">colr_str_replace_re_match_ColorArg()</a>, <a class="el" href="colr_8h.html#a75b2cdee697818e2f9f38ec7eac98bcb">colr_str_replace_re_matches_ColorArg()</a>, <a class="el" href="colr_8h.html#a090ba95c4560134ef9c2807eff6a0ea1">colr_str_replace_re_pat_all_ColorArg()</a>, and <a class="el" href="colr_8h.html#adecbe2f1e87613b6f4a51158325dd4f7">colr_str_replace_re_pat_ColorArg()</a>.</p>

</div>
</div>
<a id="abaf3d02ff1292f2aaa605522665ae564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaf3d02ff1292f2aaa605522665ae564">&#9670;&nbsp;</a></span>ColorArg_to_esc_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorArg_to_esc_s </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>carg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> into an escape code string (<code>char*</code>) and fills the destination string. </p>
<p>If the <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> is empty (<code>ARGTYPE_NONE</code>), <code>dest[0]</code> is set to `'\0'`.</p>
<p>If the <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> is invalid, <code>dest[0]</code> is set to `'\0'`.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>Destination for the escape code string. <em>Must have room for the code type being used</em>. See <a class="el" href="colr_8c.html#adaff727006f4c057aab75e55bfb473c4" title="Returns the length in bytes needed to allocate a string (char*) built with ColorArg_to_esc(). ">ColorArg_length()</a> for determining the size needed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">carg</td><td><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to get the ArgType and <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> was valid, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

</div>
</div>
<a id="afb5ac0bd012b8162cea125ad0d9e8bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb5ac0bd012b8162cea125ad0d9e8bf0">&#9670;&nbsp;</a></span>ColorArg_to_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>* ColorArg_to_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>carg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> into memory and returns the pointer. </p>
<p>You must free() the memory if you call this directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">carg</td><td><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to copy/allocate for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">Pointer to a heap-allocated <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a4897abe50811762a84ee409c0c2d300f">ColorArgs_from_str()</a>.</p>

</div>
</div>
<a id="a32c5256623852632a4ba040e3447431c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c5256623852632a4ba040e3447431c">&#9670;&nbsp;</a></span>ColorArgs_array_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ColorArgs_array_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> **&#160;</td>
          <td class="paramname"><em>ps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free an allocated array of ColorArgs, including the array itself. </p>
<p>Each individual <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> will be released, and finally the allocated memory for the array of pointers will be released.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ps</td><td>A pointer to an array of ColorArgs, where <code>NULL</code> is the last item.</td></tr>
  </table>
  </dd>
</dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#ColorArgs_array_free-example" id="ColorArgs_array_free-example" class="diamond-bullet">&#160;</a> ColorArgs_array_free example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* s = <a class="code" href="colr_8h.html#a753093cd4c872eed4b77feaa7816212b">colr</a>(<span class="stringliteral">&quot;Test&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED), <a class="code" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8">back</a>(WHITE), <a class="code" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662">style</a>(BRIGHT));</div><div class="line"><span class="keywordflow">if</span> (!s) exit(1);</div><div class="line"><span class="comment">// Call something that creates an array of ColorArgs on the heap.</span></div><div class="line"><a class="code" href="colr_8h.html#structColorArg">ColorArg</a>** carg_array = <a class="code" href="colr_8c.html#a4897abe50811762a84ee409c0c2d300f">ColorArgs_from_str</a>(s, <span class="keyword">false</span>);</div><div class="line">free(s);</div><div class="line"><span class="keywordflow">if</span> (!carg_array) exit(1);</div><div class="line"><span class="comment">// ... do something with the array of ColorArgs.</span></div><div class="line"></div><div class="line"><span class="comment">// And then free it:</span></div><div class="line"><a class="code" href="colr_8c.html#a32c5256623852632a4ba040e3447431c">ColorArgs_array_free</a>(carg_array);</div></div><!-- fragment --> </div> 
</div>
</div>
<a id="a4e16f30e878a6fb53ed9af5f8fdd674a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e16f30e878a6fb53ed9af5f8fdd674a">&#9670;&nbsp;</a></span>ColorArgs_array_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorArgs_array_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> **&#160;</td>
          <td class="paramname"><em>lst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string representation for an array of <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lst</td><td>The <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> array to create the representation for (<code>ColorArg**</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string, or <code>NULL</code> if <code>lst</code> is <code>NULL</code>, or the allocation fails.</dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#ColorArgs_array_repr-example" id="ColorArgs_array_repr-example" class="diamond-bullet">&#160;</a> ColorArgs_array_repr example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* s = <a class="code" href="colr_8h.html#a753093cd4c872eed4b77feaa7816212b">colr</a>(<span class="stringliteral">&quot;Test&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED), <a class="code" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8">back</a>(WHITE), <a class="code" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662">style</a>(BRIGHT));</div><div class="line"><span class="keywordflow">if</span> (!s) exit(1);</div><div class="line"><span class="comment">// Call something that creates an array of ColorArgs on the heap.</span></div><div class="line"><a class="code" href="colr_8h.html#structColorArg">ColorArg</a>** carg_array = <a class="code" href="colr_8c.html#a4897abe50811762a84ee409c0c2d300f">ColorArgs_from_str</a>(s, <span class="keyword">false</span>);</div><div class="line">free(s);</div><div class="line"><span class="keywordflow">if</span> (!carg_array) exit(1);</div><div class="line"><span class="keywordtype">char</span>* lst_repr = <a class="code" href="colr_8c.html#a4e16f30e878a6fb53ed9af5f8fdd674a">ColorArgs_array_repr</a>(carg_array);</div><div class="line"><a class="code" href="colr_8c.html#a32c5256623852632a4ba040e3447431c">ColorArgs_array_free</a>(carg_array);</div><div class="line"><span class="keywordflow">if</span> (!lst_repr) exit(1);</div><div class="line">printf(<span class="stringliteral">&quot;ColorArg carg_array[] = %s\n&quot;</span>, lst_repr);</div><div class="line"><span class="comment">// And then free it:</span></div><div class="line">free(lst_repr);</div></div><!-- fragment --> </div> 
</div>
</div>
<a id="a4897abe50811762a84ee409c0c2d300f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4897abe50811762a84ee409c0c2d300f">&#9670;&nbsp;</a></span>ColorArgs_from_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>** ColorArgs_from_str </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unique</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an array of ColorArgs from escape-codes found in a string (<code>char*</code>). </p>
<p>This uses <a class="el" href="colr_8c.html#a70e9640f37dd85cde0b6f25c0b705912" title="Parse an escape-code string (char*) into a ColorArg. ">ColorArg_from_esc()</a> and <a class="el" href="colr_8c.html#a6292cbb8bd9f3d19bb0bd05a4d7b0bea" title="Get an array of escape-codes from a string (char*). ">colr_str_get_codes()</a> to build a heap-allocated array of heap-allocated ColorArgs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">A string to get the escape-codes from.</p>
<p class="endtd"><em>Must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unique</td><td>Whether to only include <em>unique</em> ColorArgs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated array of <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointers, where the last element is <code>NULL</code>.</p>
<p class="enddd"><em>You must <code>free()</code> the memory allocated by this function.</em> </p>
</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">If</td><td><code>s</code> is <code>NULL</code>, or empty, or there are otherwise no escape-codes found in the string, then <code>NULL</code> is returned. </td></tr>
    <tr><td class="paramname">On</td><td>success, there will be at least two pointers behind the return value. The last pointer is always <code>NULL</code>.</td></tr>
  </table>
  </dd>
</dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#ColorArgs_from_str-example" id="ColorArgs_from_str-example" class="diamond-bullet">&#160;</a> ColorArgs_from_str example: </div><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="colr_8h.html">colr.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div><div class="line">    <span class="keywordtype">char</span>* s = <a class="code" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa">colr_cat</a>(</div><div class="line">        <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;Testing this out.&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED), <a class="code" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8">back</a>(WHITE)),</div><div class="line">        <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;Again.&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED), <a class="code" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662">style</a>(UNDERLINE))</div><div class="line">    );</div><div class="line">    <span class="keywordflow">if</span> (!s) <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    <a class="code" href="colr_8h.html#structColorArg">ColorArg</a>** carg_array = <a class="code" href="colr_8c.html#a4897abe50811762a84ee409c0c2d300f">ColorArgs_from_str</a>(s, <span class="keyword">false</span>);</div><div class="line">    free(s);</div><div class="line">    <span class="keywordflow">if</span> (!carg_array) {</div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;No code found? Impossible!\n&quot;</span>);</div><div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line">    <span class="comment">// Iterate over the ColorArg array.</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; carg_array[i]; i++) {</div><div class="line">        <span class="keywordtype">char</span>* carg_example = <a class="code" href="colr_8c.html#aa54ab1879f6de8ca2fcb4702250741f5">ColorArg_example</a>(*(carg_array[i]), <span class="keyword">true</span>);</div><div class="line">        <span class="keywordflow">if</span> (!carg_example) <span class="keywordflow">continue</span>;</div><div class="line">        printf(<span class="stringliteral">&quot;%s\n&quot;</span>, carg_example);</div><div class="line">        free(carg_example);</div><div class="line">    }</div><div class="line">    <span class="comment">// Free the ColorArgs, and the array of pointers.</span></div><div class="line">    <a class="code" href="colr_8c.html#a32c5256623852632a4ba040e3447431c">ColorArgs_array_free</a>(carg_array);</div><div class="line">}</div></div><!-- fragment --> </div> 
</div>
</div>
<a id="ae11e9457ca4e8f5be0e29351b49b6844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae11e9457ca4e8f5be0e29351b49b6844">&#9670;&nbsp;</a></span>ColorJustify_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a> ColorJustify_empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an "empty" <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a>, with JUST_NONE set. </p>
<dl class="section return"><dt>Returns</dt><dd>An initialized <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a>, with no justification method set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a341b4033c31c58e412ff15280185c6bd">ColorText_empty()</a>.</p>

</div>
</div>
<a id="ab71656e616aef4bbb3c278d43c4a326e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab71656e616aef4bbb3c278d43c4a326e">&#9670;&nbsp;</a></span>ColorJustify_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorJustify_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> structs. </p>
<p>They are considered "equal" if their member values match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if they are equal, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> </dd></dl>

</div>
</div>
<a id="a34f193b6e6a20c63caecc1d9b53c89fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f193b6e6a20c63caecc1d9b53c89fb">&#9670;&nbsp;</a></span>ColorJustify_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorJustify_is_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a>&#160;</td>
          <td class="paramname"><em>cjust</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> is "empty". </p>
<p>A <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> is considered "empty" if the <code>.method</code> member is set to <code>JUST_NONE</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cjust</td><td>The <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> is empty, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> </dd>
<dd>
<a class="el" href="colr_8c.html#ae11e9457ca4e8f5be0e29351b49b6844" title="Creates an &quot;empty&quot; ColorJustify, with JUST_NONE set. ">ColorJustify_empty</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ac846e583415e832b9090270020320b9f">ColorText_is_empty()</a>, and <a class="el" href="colr_8h.html#a412833a097b050c8ee99874c733bd030">ColorText_length()</a>.</p>

</div>
</div>
<a id="a7d4a7a21151993343ef96a068c6d5018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4a7a21151993343ef96a068c6d5018">&#9670;&nbsp;</a></span>ColorJustify_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a> ColorJustify_new </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#af1a3fe0b966f944fd659a98be170045f">ColorJustifyMethod</a>&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>padchar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a>. </p>
<p>This is used to ensure every <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> has it's <code>.marker</code> member set correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>ColorJustifyMethod to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>Width for justification. If <code>0</code> is given, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> will use the width from <a class="el" href="colr_8c.html#ae4c11bb5b3b1bb2848bb16aee39763b2" title="Attempts to retrieve the row/column size of the terminal and returns a TermSize. ">colr_term_size()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">padchar</td><td>Padding character to use. If <code>0</code> is given, the default, space (`' '`), is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An initialized <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a>. </dd></dl>

</div>
</div>
<a id="a6c35f6b47cc737744487d14d20241656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c35f6b47cc737744487d14d20241656">&#9670;&nbsp;</a></span>ColorJustify_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorJustify_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a>&#160;</td>
          <td class="paramname"><em>cjust</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation for a <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a>. </p>
<p>Allocates memory for the string representation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cjust</td><td><a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> struct to get the representation for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">Allocated string for the representation.</p>
<p class="enddd"><em>You must <code>free()</code> the memory allocated by this function.</em> </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a65363a3601cd9cfcdc7fc40722d5d3c3">ColorText_repr()</a>.</p>

</div>
</div>
<a id="adf78eeb364553d130055d93e9892cd9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf78eeb364553d130055d93e9892cd9c">&#9670;&nbsp;</a></span>ColorJustifyMethod_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorJustifyMethod_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#af1a3fe0b966f944fd659a98be170045f">ColorJustifyMethod</a>&#160;</td>
          <td class="paramname"><em>meth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation for a ColorJustifyMethod. </p>
<p>Allocates memory for the string representation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meth</td><td>ColorJustifyMethod to get the representation for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">Allocated string for the representation.</p>
<p class="enddd"><em>You must <code>free()</code> the memory allocated by this function.</em> </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#af1a3fe0b966f944fd659a98be170045f" title="Justification style for ColorTexts. ">ColorJustifyMethod</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a6c35f6b47cc737744487d14d20241656">ColorJustify_repr()</a>.</p>

</div>
</div>
<a id="a5b59e832f322e617a89ca14046cc41d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b59e832f322e617a89ca14046cc41d2">&#9670;&nbsp;</a></span>ColorResult_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a> ColorResult_empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> with <code>.result=NULL</code> and <code>.length=-1</code>, with the appropriate struct marker. </p>
<dl class="section return"><dt>Returns</dt><dd>An "empty" (initialized) <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#af752035c362c7c9ddb2e7f2f2305d509">ColorResult_new()</a>.</p>

</div>
</div>
<a id="afb35d2507389c11d6ffe2adc6876efcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb35d2507389c11d6ffe2adc6876efcc">&#9670;&nbsp;</a></span>ColorResult_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorResult_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two ColorResults. </p>
<p>They are equal if all of their members are equal, excluding the memory address for the <code>.result</code> member.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if they are equal, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> </dd></dl>

</div>
</div>
<a id="a27b70c6de9b2351424100bd742b1f1a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b70c6de9b2351424100bd742b1f1a8">&#9670;&nbsp;</a></span>ColorResult_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ColorResult_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free allocated memory for a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> and it's <code>.result</code> member. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> with a <code>NULL</code> or heap-allocated <code>.result</code> member.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#aaa888f1b31eb40ec7d252d3ee9175d76">_colr_free()</a>, <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>, <a class="el" href="colr_8h.html#a34c359a48f811316d765b7abef1ea8f4">colr_printf_handler()</a>, <a class="el" href="colr_8h.html#a53fa120c1074c836f65b4aace67d0c83">colr_str_replace_all_ColorResult()</a>, <a class="el" href="colr_8h.html#a136d15edf2f804c89cee619bb811ef3a">colr_str_replace_ColorResult()</a>, <a class="el" href="colr_8h.html#a3e18a36736e5451529e80443cfb7b1fc">colr_str_replace_re_all_ColorResult()</a>, <a class="el" href="colr_8h.html#a0376bed13e55acaca37e52c382044e1d">colr_str_replace_re_ColorResult()</a>, <a class="el" href="colr_8h.html#ac092f944961dddc6574a6c55e6e878b0">colr_str_replace_re_match_ColorResult()</a>, <a class="el" href="colr_8h.html#a4d4bb71015338108d86fcf47317cc5ff">colr_str_replace_re_matches_ColorResult()</a>, <a class="el" href="colr_8h.html#af083c2e1867ecaad0ae38a1324c915ac">colr_str_replace_re_pat_all_ColorResult()</a>, and <a class="el" href="colr_8h.html#abcd756c82acab9505343b614d52c0b19">colr_str_replace_re_pat_ColorResult()</a>.</p>

</div>
</div>
<a id="afd5fe635f26119c3a341b5dfe23abc97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd5fe635f26119c3a341b5dfe23abc97">&#9670;&nbsp;</a></span>ColorResult_is_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorResult_is_ptr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks a void pointer to see if it contains a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> struct. </p>
<p>The first member of a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> is a marker.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A void pointer to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the pointer is a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#aaa888f1b31eb40ec7d252d3ee9175d76">_colr_free()</a>, <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>, <a class="el" href="colr_8h.html#a6d47ac6ee2a59e1c976cf2838545aa25">_colr_join_array_length()</a>, <a class="el" href="colr_8h.html#ac49c3a33d328ebaf2b0564d5a9b1d4ec">_colr_join_arrayn_size()</a>, <a class="el" href="colr_8h.html#ab0be451277fc7e39aee0aa409c9d3f0c">_colr_ptr_length()</a>, <a class="el" href="colr_8h.html#a30cac3017a6ea8c78277882554c9419f">_colr_ptr_repr()</a>, <a class="el" href="colr_8h.html#a0d97f9b535a69642b926b38dce30b180">_colr_ptr_to_str()</a>, <a class="el" href="colr_8h.html#a71fcf08ad36d4424790e275d973445fc">colr_join_arrayn()</a>, and <a class="el" href="colr_8h.html#a34c359a48f811316d765b7abef1ea8f4">colr_printf_handler()</a>.</p>

</div>
</div>
<a id="a5169ef5d27a9c14bb765f7e7b70c9e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5169ef5d27a9c14bb765f7e7b70c9e2b">&#9670;&nbsp;</a></span>ColorResult_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ColorResult_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a>&#160;</td>
          <td class="paramname"><em>cres</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the length in bytes (including the null-terminator), that is needed to store the return from <a class="el" href="colr_8c.html#af5174a576892401ea59b737558f27d8b" title="Convert a ColorResult into a string (char*). ">ColorResult_to_str()</a> (<code>.result</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cres</td><td>A <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> to calculate the length for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, possibly <code>0</code> if <code>.result</code> is <code>NULL</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ac49c3a33d328ebaf2b0564d5a9b1d4ec">_colr_join_arrayn_size()</a>, and <a class="el" href="colr_8h.html#ab0be451277fc7e39aee0aa409c9d3f0c">_colr_ptr_length()</a>.</p>

</div>
</div>
<a id="af752035c362c7c9ddb2e7f2f2305d509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af752035c362c7c9ddb2e7f2f2305d509">&#9670;&nbsp;</a></span>ColorResult_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a> ColorResult_new </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a new <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> with an allocated string (<code>char*</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>An allocated string to use for the <code>.result</code> member. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An initialized <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> </dd></dl>

</div>
</div>
<a id="aae0b90c57e8c4c475d9e0f517f3a0d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0b90c57e8c4c475d9e0f517f3a0d42">&#9670;&nbsp;</a></span>ColorResult_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorResult_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a>&#160;</td>
          <td class="paramname"><em>cres</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a string representation for a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>. </p>
<p>This happens to be the same as <code>colr_str_repr(cres.result)</code> right now.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cres</td><td>A <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> to create the representation string for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a30cac3017a6ea8c78277882554c9419f">_colr_ptr_repr()</a>.</p>

</div>
</div>
<a id="a5f5304067f9d673ce5b86ddba2a8807b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f5304067f9d673ce5b86ddba2a8807b">&#9670;&nbsp;</a></span>ColorResult_to_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a>* ColorResult_to_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a>&#160;</td>
          <td class="paramname"><em>cres</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate memory for a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, fill it, and return it. </p>
<p>This ensure the appropriate struct marker is set, for use with Colr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cres</td><td>A <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p>If used inside of the <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a>, <a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465" title="Like colr_cat(), but returns an allocated ColorResult that the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros will automatically free(). ">Colr_cat()</a>, and <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> macros, <em>they will <code>free()</code> the result</em>. Otherwise, <em>you are responsible for calling <code>free()</code></em>.</p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> </dd></dl>

</div>
</div>
<a id="af5174a576892401ea59b737558f27d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5174a576892401ea59b737558f27d8b">&#9670;&nbsp;</a></span>ColorResult_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorResult_to_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a>&#160;</td>
          <td class="paramname"><em>cres</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> into a string (<code>char*</code>). </p>
<p>This simply returns the <code>.result</code> member right now. It is used for compatibility with the <a class="el" href="colr_8h.html#a790e5a9bd0b3ca7cd7d428007f6a21b9" title="Calls the &lt;type&gt;_to_str functions for the supported types. ">colr_to_str()</a> macro.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cres</td><td>A <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A stringified-version if this <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, which happens to be the <code>.result</code> member. <em>If you free the result of this function, the original string used to create the <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> will be lost</em>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>, <a class="el" href="colr_8h.html#a0d97f9b535a69642b926b38dce30b180">_colr_ptr_to_str()</a>, <a class="el" href="colr_8h.html#a71fcf08ad36d4424790e275d973445fc">colr_join_arrayn()</a>, <a class="el" href="colr_8h.html#a34c359a48f811316d765b7abef1ea8f4">colr_printf_handler()</a>, <a class="el" href="colr_8h.html#a53fa120c1074c836f65b4aace67d0c83">colr_str_replace_all_ColorResult()</a>, <a class="el" href="colr_8h.html#a136d15edf2f804c89cee619bb811ef3a">colr_str_replace_ColorResult()</a>, <a class="el" href="colr_8h.html#a3e18a36736e5451529e80443cfb7b1fc">colr_str_replace_re_all_ColorResult()</a>, <a class="el" href="colr_8h.html#a0376bed13e55acaca37e52c382044e1d">colr_str_replace_re_ColorResult()</a>, <a class="el" href="colr_8h.html#ac092f944961dddc6574a6c55e6e878b0">colr_str_replace_re_match_ColorResult()</a>, <a class="el" href="colr_8h.html#a4d4bb71015338108d86fcf47317cc5ff">colr_str_replace_re_matches_ColorResult()</a>, <a class="el" href="colr_8h.html#af083c2e1867ecaad0ae38a1324c915ac">colr_str_replace_re_pat_all_ColorResult()</a>, and <a class="el" href="colr_8h.html#abcd756c82acab9505343b614d52c0b19">colr_str_replace_re_pat_ColorResult()</a>.</p>

</div>
</div>
<a id="a341b4033c31c58e412ff15280185c6bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a341b4033c31c58e412ff15280185c6bd">&#9670;&nbsp;</a></span>ColorText_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorText">ColorText</a> ColorText_empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an "empty" <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> with pointers set to <code>NULL</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>An initialized <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ad4702d6ddc409a93a0b42c8f6141d2f2">ColorText_from_values()</a>, and <a class="el" href="colr_8h.html#a880b39cd2ce9b622dbe7790a162d88f7">ColorText_set_values()</a>.</p>

</div>
</div>
<a id="a901e5738358a739629cc3aaccab3e73f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a901e5738358a739629cc3aaccab3e73f">&#9670;&nbsp;</a></span>ColorText_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ColorText_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> and it's ColorArgs. </p>
<p>The text member is left alone, because it wasn't created by ColrC.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Pointer to <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to free, along with it's Colr-based members.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#aaa888f1b31eb40ec7d252d3ee9175d76">_colr_free()</a>, <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>, <a class="el" href="colr_8h.html#a34c359a48f811316d765b7abef1ea8f4">colr_printf_handler()</a>, <a class="el" href="colr_8h.html#a73789c11eaeb5a36b5f97556103a108d">colr_str_replace_all_ColorText()</a>, <a class="el" href="colr_8h.html#aaee8d79a90917974ee4537705e34fd76">colr_str_replace_ColorText()</a>, <a class="el" href="colr_8h.html#a747e31fa3d8961e0bdd11eabd673accc">colr_str_replace_re_all_ColorText()</a>, <a class="el" href="colr_8h.html#ab8d6a10f70b435559656bbad0090d92d">colr_str_replace_re_ColorText()</a>, <a class="el" href="colr_8h.html#a4d954398333472c1436f9bc051f46392">colr_str_replace_re_match_ColorText()</a>, <a class="el" href="colr_8h.html#aa4fe38cc205cbd49b2f8477744574294">colr_str_replace_re_matches_ColorText()</a>, <a class="el" href="colr_8h.html#ab9c4a5c34b26473dc45f93ce2c66faf1">colr_str_replace_re_pat_all_ColorText()</a>, and <a class="el" href="colr_8h.html#a6f8b04b6d851f26304183d1111b8f0dc">colr_str_replace_re_pat_ColorText()</a>.</p>

</div>
</div>
<a id="a4979a2ec9d5fb442ba025c6f2efc4864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4979a2ec9d5fb442ba025c6f2efc4864">&#9670;&nbsp;</a></span>ColorText_free_args()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ColorText_free_args </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> members of a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>. </p>
<p>The <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> itself is not free'd.</p>
<p>This is safe to use on a stack-allocated <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> with heap-allocated ColorArgs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Pointer to a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a901e5738358a739629cc3aaccab3e73f">ColorText_free()</a>.</p>

</div>
</div>
<a id="ad4702d6ddc409a93a0b42c8f6141d2f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4702d6ddc409a93a0b42c8f6141d2f2">&#9670;&nbsp;</a></span>ColorText_from_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorText">ColorText</a> ColorText_from_values </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> from 1 mandatory string (<code>char*</code>), and optional fore, back, and style args (pointers to ColorArgs). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>Text to colorize (a regular string). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>ColorArgs for fore, back, and style, in any order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An initialized <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> struct.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

</div>
</div>
<a id="a93f65430500d003575c547eb667330b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f65430500d003575c547eb667330b0">&#9670;&nbsp;</a></span>ColorText_has_arg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorText_has_arg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a>&#160;</td>
          <td class="paramname"><em>ctext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>carg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> has a certain <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> value set. </p>
<p>Uses <a class="el" href="colr_8c.html#acb62efc0182d6f6107055eeda961a628" title="Compares two ColorArg structs. ">ColorArg_eq()</a> to inspect the <code>fore</code>, <code>back</code>, and <code>style</code> members.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctext</td><td>The <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to inspect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">carg</td><td>The <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <code>fore</code>, <code>back</code>, or <code>style</code> arg matches <code>carg</code>, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

</div>
</div>
<a id="a93b38987063bb127bb34761961d7f678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93b38987063bb127bb34761961d7f678">&#9670;&nbsp;</a></span>ColorText_has_args()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorText_has_args </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a>&#160;</td>
          <td class="paramname"><em>ctext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> has any argument values set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctext</td><td>A <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>.fore</code>, <code>.back</code>, or .<code>style</code> is set to a non-empty <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

</div>
</div>
<a id="ac846e583415e832b9090270020320b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac846e583415e832b9090270020320b9f">&#9670;&nbsp;</a></span>ColorText_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorText_is_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a>&#160;</td>
          <td class="paramname"><em>ctext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> has no usable values. </p>
<p>A <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> is considered "empty" if the <code>.text</code>, <code>.fore</code>, <code>.back</code>, and <code>.style</code> pointers are <code>NULL</code>, and the <code>.just</code> member is set to an "empty" <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctext</td><td>The <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> is empty, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd>
<dd>
<a class="el" href="colr_8c.html#a341b4033c31c58e412ff15280185c6bd" title="Creates an &quot;empty&quot; ColorText with pointers set to NULL. ">ColorText_empty</a> </dd></dl>

</div>
</div>
<a id="a1d6eb8832110b943c3a3a17627a50288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6eb8832110b943c3a3a17627a50288">&#9670;&nbsp;</a></span>ColorText_is_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorText_is_ptr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks a void pointer to see if it contains a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> struct. </p>
<p>The first member of a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> is a marker.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A void pointer to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the pointer is a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#aaa888f1b31eb40ec7d252d3ee9175d76">_colr_free()</a>, <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>, <a class="el" href="colr_8h.html#a6d47ac6ee2a59e1c976cf2838545aa25">_colr_join_array_length()</a>, <a class="el" href="colr_8h.html#ac49c3a33d328ebaf2b0564d5a9b1d4ec">_colr_join_arrayn_size()</a>, <a class="el" href="colr_8h.html#ab0be451277fc7e39aee0aa409c9d3f0c">_colr_ptr_length()</a>, <a class="el" href="colr_8h.html#a30cac3017a6ea8c78277882554c9419f">_colr_ptr_repr()</a>, <a class="el" href="colr_8h.html#a0d97f9b535a69642b926b38dce30b180">_colr_ptr_to_str()</a>, <a class="el" href="colr_8h.html#a71fcf08ad36d4424790e275d973445fc">colr_join_arrayn()</a>, and <a class="el" href="colr_8h.html#a34c359a48f811316d765b7abef1ea8f4">colr_printf_handler()</a>.</p>

</div>
</div>
<a id="a412833a097b050c8ee99874c733bd030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a412833a097b050c8ee99874c733bd030">&#9670;&nbsp;</a></span>ColorText_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ColorText_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a>&#160;</td>
          <td class="paramname"><em>ctext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length in bytes needed to allocate a string (<code>char*</code>) built with <a class="el" href="colr_8c.html#ae305b33e0a44b956ccf4123aa4f1a033" title="Stringifies a ColorText struct, creating a mix of escape codes and text. ">ColorText_to_str()</a> with the current <code>text</code>, <code>fore</code>, <code>back</code>, and <code>style</code> members. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctext</td><td><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length (<code>size_t</code>) needed to allocate a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string, or <code>1</code> (size of an empty string) for invalid/empty arg types/values.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ac49c3a33d328ebaf2b0564d5a9b1d4ec">_colr_join_arrayn_size()</a>, <a class="el" href="colr_8h.html#ab0be451277fc7e39aee0aa409c9d3f0c">_colr_ptr_length()</a>, and <a class="el" href="colr_8h.html#ae305b33e0a44b956ccf4123aa4f1a033">ColorText_to_str()</a>.</p>

</div>
</div>
<a id="a65363a3601cd9cfcdc7fc40722d5d3c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65363a3601cd9cfcdc7fc40722d5d3c3">&#9670;&nbsp;</a></span>ColorText_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorText_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a>&#160;</td>
          <td class="paramname"><em>ctext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a string (<code>char*</code>) representation for a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctext</td><td><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to get the string representation for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Allocated string for the <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a30cac3017a6ea8c78277882554c9419f">_colr_ptr_repr()</a>.</p>

</div>
</div>
<a id="ab408d87cce896acccb75357acca8ade4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab408d87cce896acccb75357acca8ade4">&#9670;&nbsp;</a></span>ColorText_set_just()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorText">ColorText</a>* ColorText_set_just </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td>
          <td class="paramname"><em>ctext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a>&#160;</td>
          <td class="paramname"><em>cjust</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> method for a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, and return the <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>. </p>
<p>This is to facilitate the justification macros. If you already have a pointer to a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, you can just do <code>ctext-&gt;just = just;</code>. The purpose of this is to allow <code>ColorText_set_just(ColorText_to_ptr(...), ...)</code> to work.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ctext</td><td>The <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to set the justification method for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cjust</td><td>The <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> struct to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The same pointer that was given as <code>ctext</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

</div>
</div>
<a id="a880b39cd2ce9b622dbe7790a162d88f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a880b39cd2ce9b622dbe7790a162d88f7">&#9670;&nbsp;</a></span>ColorText_set_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ColorText_set_values </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td>
          <td class="paramname"><em>ctext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an existing <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> from 1 mandatory string (<code>char*</code>), and optional fore, back, and style args (pointers to ColorArgs). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ctext</td><td>A <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to initialize with values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>Text to colorize (a regular string). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>A <code>va_list</code> with ColorArgs pointers for fore, back, and style, in any order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An initialized <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> struct.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

</div>
</div>
<a id="a8e04de932a4cf712ac91e794bdc3f8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e04de932a4cf712ac91e794bdc3f8db">&#9670;&nbsp;</a></span>ColorText_to_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorText">ColorText</a>* ColorText_to_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a>&#160;</td>
          <td class="paramname"><em>ctext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> into allocated memory and returns the pointer. </p>
<p>You must free() the memory if you call this directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctext</td><td><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to copy/allocate for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">Pointer to a heap-allocated <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

</div>
</div>
<a id="ae305b33e0a44b956ccf4123aa4f1a033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae305b33e0a44b956ccf4123aa4f1a033">&#9670;&nbsp;</a></span>ColorText_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorText_to_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a>&#160;</td>
          <td class="paramname"><em>ctext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stringifies a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> struct, creating a mix of escape codes and text. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctext</td><td><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to stringify. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with text/escape-codes.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. If the <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> has a <code>NULL</code> <code>.text</code> member, <code>NULL</code> is returned. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>, <a class="el" href="colr_8h.html#a0d97f9b535a69642b926b38dce30b180">_colr_ptr_to_str()</a>, <a class="el" href="colr_8h.html#a71fcf08ad36d4424790e275d973445fc">colr_join_arrayn()</a>, <a class="el" href="colr_8h.html#a34c359a48f811316d765b7abef1ea8f4">colr_printf_handler()</a>, <a class="el" href="colr_8h.html#a73789c11eaeb5a36b5f97556103a108d">colr_str_replace_all_ColorText()</a>, <a class="el" href="colr_8h.html#aaee8d79a90917974ee4537705e34fd76">colr_str_replace_ColorText()</a>, <a class="el" href="colr_8h.html#a747e31fa3d8961e0bdd11eabd673accc">colr_str_replace_re_all_ColorText()</a>, <a class="el" href="colr_8h.html#ab8d6a10f70b435559656bbad0090d92d">colr_str_replace_re_ColorText()</a>, <a class="el" href="colr_8h.html#a4d954398333472c1436f9bc051f46392">colr_str_replace_re_match_ColorText()</a>, <a class="el" href="colr_8h.html#aa4fe38cc205cbd49b2f8477744574294">colr_str_replace_re_matches_ColorText()</a>, <a class="el" href="colr_8h.html#ab9c4a5c34b26473dc45f93ce2c66faf1">colr_str_replace_re_pat_all_ColorText()</a>, and <a class="el" href="colr_8h.html#a6f8b04b6d851f26304183d1111b8f0dc">colr_str_replace_re_pat_ColorText()</a>.</p>

</div>
</div>
<a id="a29e3483ae4add048424177fdc2b97b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29e3483ae4add048424177fdc2b97b71">&#9670;&nbsp;</a></span>ColorType_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorType_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two ColorTypes. </p>
<p>This is used to implement <a class="el" href="colr_8h.html#a36af8aa0f01eaa780da182e856923faa" title="Calls the &lt;type&gt;_eq functions for the supported types. ">colr_eq()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first ColorType to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second ColorType to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if they are equal, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83" title="Color/Style code types. Used with ColorType_from_str() and ColorValue. ">ColorType</a> </dd></dl>

</div>
</div>
<a id="afa75deef059c002134a88dbbdc18fd49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa75deef059c002134a88dbbdc18fd49">&#9670;&nbsp;</a></span>ColorType_from_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> ColorType_from_str </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine which type of color value is desired by name. </p>
<p>Example:</p><ul>
<li>"red" == TYPE_BASIC</li>
<li>"253" == TYPE_EXTENDED</li>
<li>"123,55,67" == TYPE_RGB</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Color name to get the ColorType for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ColorType</td><td>value on success. </td></tr>
    <tr><td class="paramname">TYPE_INVALID</td><td>for invalid color names/strings. </td></tr>
    <tr><td class="paramname">TYPE_INVALID_EXT_RANGE</td><td>for ExtendedValues outside of 0-255. </td></tr>
    <tr><td class="paramname">TYPE_INVALID_RGB_RANGE</td><td>for rgb values outside of 0-255.</td></tr>
  </table>
  </dd>
</dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#ColorType_from_str-example" id="ColorType_from_str-example" class="diamond-bullet">&#160;</a> ColorType_from_str example: </div><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="colr_8h.html">colr.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div><div class="line">    <span class="keywordtype">char</span>* userarg;</div><div class="line">    <span class="keywordflow">if</span> (argc == 1) {</div><div class="line">        <span class="keywordflow">if</span> (asprintf(&amp;userarg, <span class="stringliteral">&quot;%s&quot;</span>, <span class="stringliteral">&quot;123,54,25&quot;</span>) &lt; 1) <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">        <span class="keywordflow">if</span> (asprintf(&amp;userarg, <span class="stringliteral">&quot;%s&quot;</span>,  argv[1]) &lt; 1) <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line">    <a class="code" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> type = <a class="code" href="colr_8c.html#afa75deef059c002134a88dbbdc18fd49">ColorType_from_str</a>(userarg);</div><div class="line">    <span class="keywordflow">if</span> (!<a class="code" href="colr_8c.html#adc223f6fda6296396e9ecddcc68d4aec">ColorType_is_invalid</a>(type)) {</div><div class="line">        <span class="keywordtype">char</span>* repr = <a class="code" href="colr_8h.html#ac1ef824dd213274fb239526269315543">colr_repr</a>(type);</div><div class="line">        printf(<span class="stringliteral">&quot;User passed in a %s, %s\n&quot;</span>, repr, userarg);</div><div class="line">        free(repr);</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">        printf(<span class="stringliteral">&quot;User passed in an invalid color name: %s\n&quot;</span>, userarg);</div><div class="line">    }</div><div class="line">    free(userarg);</div><div class="line">}</div></div><!-- fragment --> </div> <dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83" title="Color/Style code types. Used with ColorType_from_str() and ColorValue. ">ColorType</a> </dd></dl>

</div>
</div>
<a id="adc223f6fda6296396e9ecddcc68d4aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc223f6fda6296396e9ecddcc68d4aec">&#9670;&nbsp;</a></span>ColorType_is_invalid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorType_is_invalid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check to see if a ColorType value is considered invalid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ColorType value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is considered invalid, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83" title="Color/Style code types. Used with ColorType_from_str() and ColorValue. ">ColorType</a> </dd></dl>

</div>
</div>
<a id="a5a5883d43e3206584ad048908720afb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a5883d43e3206584ad048908720afb2">&#9670;&nbsp;</a></span>ColorType_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorType_is_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check to see if a ColorType value is considered valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ColorType value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is considered valid, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83" title="Color/Style code types. Used with ColorType_from_str() and ColorValue. ">ColorType</a> </dd></dl>

</div>
</div>
<a id="a291ca6d28f9f430794413b76b7b094ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a291ca6d28f9f430794413b76b7b094ed">&#9670;&nbsp;</a></span>ColorType_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorType_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation of a ColorType. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>A ColorType to get the type from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">A pointer to an allocated string.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83" title="Color/Style code types. Used with ColorType_from_str() and ColorValue. ">ColorType</a> </dd></dl>

</div>
</div>
<a id="acb73415f467b040d4b0f8f1ef5e95312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb73415f467b040d4b0f8f1ef5e95312">&#9670;&nbsp;</a></span>ColorType_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorType_to_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a human-friendly string (<code>char*</code>) representation for a ColorType. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>A ColorType to get the name for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83" title="Color/Style code types. Used with ColorType_from_str() and ColorValue. ">ColorType</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a89b5fc81980cbbfb425c7756eb8f0d0a">ColorValue_example()</a>.</p>

</div>
</div>
<a id="a5ce7c54ad0e31ecf6d790c5770c2b66b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce7c54ad0e31ecf6d790c5770c2b66b">&#9670;&nbsp;</a></span>ColorValue_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a> ColorValue_empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an "empty" <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>. </p>
<p>This is used with <a class="el" href="colr_8c.html#af838f8479681d809beb868b2e1b547e7" title="Create a ColorArg with ARGTYPE_NONE and ColorValue.type.TYPE_NONE. ">ColorArg_empty()</a> to build ColorArgs that don't do anything, where using <code>NULL</code> has a different meaning inside the <a class="el" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa" title="Join ColorArg pointers, ColorResult pointers, ColorText pointers, and strings into one long string...">colr_cat()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr_cat()...">Colr()</a>, <a class="el" href="colr_8h.html#a9c6a8a9f484ac09c39e5f76bba61f465" title="Like colr_cat(), but returns an allocated ColorResult that the colr_cat(), colr_join(), Colr(), Colr_cat(), and Colr_join() macros will automatically free(). ">Colr_cat()</a>, and <a class="el" href="colr_8h.html#a4d87ca8cb5460146965bd85ec82f293e" title="Joins Colr objects and strings, exactly like colr_join(), but returns an allocated ColorResult that t...">Colr_join()</a> macros.</p>
<dl class="section return"><dt>Returns</dt><dd><code>(<a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>){.type=TYPE_NONE, .basic=0, .ext=0, .rgb=(<a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a>){0, 0, 0}}</code></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd>
<dd>
<a class="el" href="colr_8c.html#af838f8479681d809beb868b2e1b547e7" title="Create a ColorArg with ARGTYPE_NONE and ColorValue.type.TYPE_NONE. ">ColorArg_empty</a> </dd>
<dd>
<a class="el" href="colr_8c.html#a752355c2d96d35688d3756558f8421ba" title="Checks to see if a ColorArg is an empty placeholder. ">ColorArg_is_empty</a> </dd>
<dd>
<a class="el" href="colr_8c.html#a48005bb1589a7ebeef413ccee2a7c2a1" title="Checks to see if a ColorValue is an empty placeholder. ">ColorValue_is_empty</a> </dd></dl>

</div>
</div>
<a id="adf57e195301864cec80739e7e0f3000c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf57e195301864cec80739e7e0f3000c">&#9670;&nbsp;</a></span>ColorValue_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorValue_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> structs. </p>
<p>They are considered "equal" if all of their members match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if they are equal, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#acb62efc0182d6f6107055eeda961a628">ColorArg_eq()</a>.</p>

</div>
</div>
<a id="a89b5fc81980cbbfb425c7756eb8f0d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89b5fc81980cbbfb425c7756eb8f0d0a">&#9670;&nbsp;</a></span>ColorValue_example()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorValue_example </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a string (<code>char*</code>) representation of a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> with a human-friendly type/name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td>A <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to get an example string for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#aa54ab1879f6de8ca2fcb4702250741f5">ColorArg_example()</a>.</p>

</div>
</div>
<a id="af308e8dcd4a1d47a05736882d5a9698d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af308e8dcd4a1d47a05736882d5a9698d">&#9670;&nbsp;</a></span>ColorValue_from_esc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a> ColorValue_from_esc </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an escape-code string (<code>char*</code>) into a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">An escape-code string to parse.</p>
<p class="endtd"><em>Must be <code>null</code>-terminated</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> (with no fore/back information, only the color type and value). </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">For</td><td>invalid strings, the <code>.type</code> member can be one of:<ul>
<li>TYPE_INVALID</li>
<li>TYPE_INVALID_EXT_RANGE</li>
<li>TYPE_INVALID_RGB_RANGE</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd>
<dd>
<a class="el" href="colr_8c.html#a70e9640f37dd85cde0b6f25c0b705912" title="Parse an escape-code string (char*) into a ColorArg. ">ColorArg_from_esc</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a70e9640f37dd85cde0b6f25c0b705912">ColorArg_from_esc()</a>.</p>

</div>
</div>
<a id="a7c63f5f62e11d5f375a3824b12c80608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c63f5f62e11d5f375a3824b12c80608">&#9670;&nbsp;</a></span>ColorValue_from_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a> ColorValue_from_str </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> from a known color name, or <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> string (<code>char*</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>A string to parse the color name from (can be an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> string). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> (with no fore/back information, only the color type and value).</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">For</td><td>invalid strings, the <code>.type</code> member can be one of:<ul>
<li>TYPE_INVALID</li>
<li>TYPE_INVALID_EXT_RANGE</li>
<li>TYPE_INVALID_RGB_RANGE</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#aa62406b058b948941a8906475924536a">ColorArg_from_str()</a>.</p>

</div>
</div>
<a id="aca7fedbceb4f751d0d30034c0ef1dca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca7fedbceb4f751d0d30034c0ef1dca8">&#9670;&nbsp;</a></span>ColorValue_from_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a> ColorValue_from_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used with the color_val macro to dynamically create a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> based on it's argument type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>A ColorType value, to mark the type of <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A pointer to either a BasicValue, ExtendedValue, or a <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> struct with the appropriate <code>.type</code> member set for the value that was passed. For invalid types the <code>.type</code> member may be set to one of:<ul>
<li>TYPE_INVALID</li>
<li>TYPE_INVALID_EXT_RANGE</li>
<li>TYPE_INVALID_RGB_RANGE </li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#aad49f4597388e6bdb896ff28334cd5e6">ColorArg_from_BasicValue()</a>, <a class="el" href="colr_8h.html#aed30e2a4b30ab5e3cf49608a3c410cc5">ColorArg_from_ExtendedValue()</a>, <a class="el" href="colr_8h.html#aaa24bba74e99aa66ed41839576e57856">ColorArg_from_RGB()</a>, <a class="el" href="colr_8h.html#acf63bcee395dca3ca29dc324e3d7c8f2">ColorArg_from_StyleValue()</a>, <a class="el" href="colr_8h.html#af308e8dcd4a1d47a05736882d5a9698d">ColorValue_from_esc()</a>, and <a class="el" href="colr_8h.html#a7c63f5f62e11d5f375a3824b12c80608">ColorValue_from_str()</a>.</p>

</div>
</div>
<a id="a711a955406cde9716797bf61ab43a7a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a711a955406cde9716797bf61ab43a7a7">&#9670;&nbsp;</a></span>ColorValue_has_BasicValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorValue_has_BasicValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>bval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has a BasicValue set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bval</td><td>BasicValue to look for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has the exact BasicValue set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

</div>
</div>
<a id="a11dc047d1defc4de2239a45667b45f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11dc047d1defc4de2239a45667b45f85">&#9670;&nbsp;</a></span>ColorValue_has_ExtendedValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorValue_has_ExtendedValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>&#160;</td>
          <td class="paramname"><em>eval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has a ExtendedValue set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eval</td><td>ExtendedValue to look for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has the exact ExtendedValue set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

</div>
</div>
<a id="ab6908a961d4165a458be1aa64f082a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6908a961d4165a458be1aa64f082a45">&#9670;&nbsp;</a></span>ColorValue_has_RGB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorValue_has_RGB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has a <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value to look for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has the exact <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

</div>
</div>
<a id="a3fbfa502deb1f2bb920b74b9f4867fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fbfa502deb1f2bb920b74b9f4867fcf">&#9670;&nbsp;</a></span>ColorValue_has_StyleValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorValue_has_StyleValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>&#160;</td>
          <td class="paramname"><em>sval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has a StyleValue set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sval</td><td>StyleValue to look for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has the exact StyleValue set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

</div>
</div>
<a id="a48005bb1589a7ebeef413ccee2a7c2a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48005bb1589a7ebeef413ccee2a7c2a1">&#9670;&nbsp;</a></span>ColorValue_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorValue_is_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> is an empty placeholder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> is "empty", otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd>
<dd>
<a class="el" href="colr_8c.html#a5ce7c54ad0e31ecf6d790c5770c2b66b" title="Create an &quot;empty&quot; ColorValue. ">ColorValue_empty</a> </dd>
<dd>
<a class="el" href="colr_8c.html#af838f8479681d809beb868b2e1b547e7" title="Create a ColorArg with ARGTYPE_NONE and ColorValue.type.TYPE_NONE. ">ColorArg_empty</a> </dd>
<dd>
<a class="el" href="colr_8c.html#a752355c2d96d35688d3756558f8421ba" title="Checks to see if a ColorArg is an empty placeholder. ">ColorArg_is_empty</a> </dd></dl>

</div>
</div>
<a id="a22fcf30338eb777592421543885f74e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22fcf30338eb777592421543885f74e0">&#9670;&nbsp;</a></span>ColorValue_is_invalid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorValue_is_invalid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> holds an invalid value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> struct to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is invalid, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a70e9640f37dd85cde0b6f25c0b705912">ColorArg_from_esc()</a>.</p>

</div>
</div>
<a id="ac7183410b61d12a99dda3f76c2705497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7183410b61d12a99dda3f76c2705497">&#9670;&nbsp;</a></span>ColorValue_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorValue_is_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> holds a valid value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> struct to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is valid, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

</div>
</div>
<a id="af891527249f068cfcef057313c522a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af891527249f068cfcef057313c522a42">&#9670;&nbsp;</a></span>ColorValue_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ColorValue_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length in bytes needed to allocate a string (<code>char*</code>) built with <a class="el" href="colr_8c.html#ab62d1c5cc30bb9211de8b5321be5c3ee" title="Converts a ColorValue into an escape code string (char*). ">ColorValue_to_esc()</a> with the specified ArgType and <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ArgType (<code>FORE</code>, <code>BACK</code>, <code>STYLE</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length (<code>size_t</code>) needed to allocate a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>'s string, or <code>1</code> (size of an empty string) for invalid/empty arg types/values.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#adaff727006f4c057aab75e55bfb473c4">ColorArg_length()</a>.</p>

</div>
</div>
<a id="a95cf6ab7c565726eeb7c276d734193f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95cf6ab7c565726eeb7c276d734193f6">&#9670;&nbsp;</a></span>ColorValue_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorValue_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation of a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td>A <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to get the type and value from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">A pointer to an allocated string.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a5af692f2357d46b9cee45bb114f2a4a2">ColorArg_repr()</a>.</p>

</div>
</div>
<a id="ab62d1c5cc30bb9211de8b5321be5c3ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab62d1c5cc30bb9211de8b5321be5c3ee">&#9670;&nbsp;</a></span>ColorValue_to_esc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorValue_to_esc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> into an escape code string (<code>char*</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ArgType (FORE, BACK, STYLE) to build the escape code for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to get the color value from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the appropriate escape code. For invalid values, an empty string is returned.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ad1d3aaca5e543f8fefbd863a959c9d67">ColorArg_to_esc()</a>.</p>

</div>
</div>
<a id="aebcf95faa1465843b6510d534d0311a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebcf95faa1465843b6510d534d0311a0">&#9670;&nbsp;</a></span>ColorValue_to_esc_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorValue_to_esc_s </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> into an escape code string (<code>char*</code>) and fills the destination string. </p>
<p>For invalid ArgType/ColorValue combinations, <code>dest[0]</code> is set to `'\0'`.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>Destination string for the escape code string. <em>Must have room for the code type being used</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ArgType (FORE, BACK, STYLE) to build the escape code for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to get the color value from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a proper ArgType/ColorValue combination was used, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#abaf3d02ff1292f2aaa605522665ae564">ColorArg_to_esc_s()</a>.</p>

</div>
</div>
<a id="afc40c0187b5a18c21428e18434e8e0df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc40c0187b5a18c21428e18434e8e0df">&#9670;&nbsp;</a></span>colr_alloc_regmatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regmatch_t* colr_alloc_regmatch </td>
          <td>(</td>
          <td class="paramtype">regmatch_t&#160;</td>
          <td class="paramname"><em>match</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates space for a regmatch_t, initializes it, and returns a pointer to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">match</td><td>A <code>regmatch_t</code> to allocate for and copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated copy of the <code>regmatch_t</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a37cd9a8f2748629e68e9c41ffca557a9">colr_re_matches()</a>.</p>

</div>
</div>
<a id="a10030070daafdee7124638adfc5469d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10030070daafdee7124638adfc5469d8">&#9670;&nbsp;</a></span>colr_append_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void colr_append_reset </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends CODE_RESET_ALL to a string (<code>char*</code>), but makes sure to do it before any newlines. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">The string to append to. <em>Must have extra room for CODE_RESET_ALL</em>.</p>
<p class="endtd"><em>Must be <code>null</code>-terminated</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>, <a class="el" href="colr_8h.html#ab88ca919420f2df896b7973401641ab4">_rainbow()</a>, <a class="el" href="colr_8h.html#ae305b33e0a44b956ccf4123aa4f1a033">ColorText_to_str()</a>, and <a class="el" href="colr_8h.html#a71fcf08ad36d4424790e275d973445fc">colr_join_arrayn()</a>.</p>

</div>
</div>
<a id="a7f1ea562310969b7efa8711a843f103c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f1ea562310969b7efa8711a843f103c">&#9670;&nbsp;</a></span>colr_char_escape_char()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char colr_char_escape_char </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the char needed to represent an escape sequence in C. </p>
<p>The following characters are supported: </p><table class="doxtable">
<tr>
<th align="right">Escape Sequence </th><th align="left">Description Representation  </th></tr>
<tr>
<td align="right">\ ' </td><td align="left">single quote </td></tr>
<tr>
<td align="right">\ " </td><td align="left">double quote </td></tr>
<tr>
<td align="right">\ ? </td><td align="left">question mark </td></tr>
<tr>
<td align="right">\ \ </td><td align="left">backslash </td></tr>
<tr>
<td align="right">\ a </td><td align="left">audible bell </td></tr>
<tr>
<td align="right">\ b </td><td align="left">backspace </td></tr>
<tr>
<td align="right">\ f </td><td align="left">form feed - new page </td></tr>
<tr>
<td align="right">\ n </td><td align="left">line feed - new line </td></tr>
<tr>
<td align="right">\ r </td><td align="left">carriage return </td></tr>
<tr>
<td align="right">\ t </td><td align="left">horizontal tab </td></tr>
<tr>
<td align="right">\ v </td><td align="left">vertical tab </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The character to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The letter, without a backslash, needed to create an escape sequence. If the char doesn't need an escape sequence, it is simply returned.</dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_char_escape_char-example" id="colr_char_escape_char-example" class="diamond-bullet">&#160;</a> colr_char_escape_char example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span> constantchar = <a class="code" href="colr_8c.html#a7f1ea562310969b7efa8711a843f103c">colr_char_escape_char</a>(<span class="charliteral">&#39;\n&#39;</span>);</div><div class="line">assert(constantchar == <span class="charliteral">&#39;n&#39;</span>);</div><div class="line"></div><div class="line"><span class="keywordtype">char</span> constantquote = <a class="code" href="colr_8c.html#a7f1ea562310969b7efa8711a843f103c">colr_char_escape_char</a>(<span class="charliteral">&#39;&quot;&#39;</span>);</div><div class="line">assert(constantquote == <span class="charliteral">&#39;&quot;&#39;</span>);</div><div class="line"></div><div class="line"><span class="comment">// The actual escape sequence would need the backslash added to it:</span></div><div class="line"><span class="keywordtype">char</span>* escaped;</div><div class="line">asprintf(&amp;escaped, <span class="stringliteral">&quot;\\%c&quot;</span>, <a class="code" href="colr_8c.html#a7f1ea562310969b7efa8711a843f103c">colr_char_escape_char</a>(<span class="charliteral">&#39;\t&#39;</span>));</div><div class="line">free(escaped);</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a196ad91a69cfbeb27a5266ffc93ed353">colr_str_repr()</a>.</p>

</div>
</div>
<a id="a38331775450608b94c5ecfeec28f9363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38331775450608b94c5ecfeec28f9363">&#9670;&nbsp;</a></span>colr_char_in_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_char_in_str </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a character exists in the given string (<code>char*</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Character to search for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">String to check.</p>
<p class="endtd">Input <em>must be <code>null</code>-terminated</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>c</code> is found in <code>s</code>, otherwise <code>false</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a566857db0f22ad4a1ba17ee3a56cf174">colr_str_chars_lcount()</a>, and <a class="el" href="colr_8h.html#af502be785bdb221c2dc1a47fece1fc5f">colr_str_lstrip_chars()</a>.</p>

</div>
</div>
<a id="ab4fed7123927027262875834964b0a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4fed7123927027262875834964b0a94">&#9670;&nbsp;</a></span>colr_char_is_code_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_char_is_code_end </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a character is suitable for an escape code ending. </p>
<p><code>m</code> is used as the last character in color codes, but other characters can be used for escape sequences (such as "\x1b[2A", cursor up). Actual escape code endings can be in the range (<code>char</code>) 64-126 (inclusive).</p>
<p>Since ColrC only deals with color codes and maybe some cursor/erase codes, this function tests if the character is either <code>A-Z</code> or <code>a-z</code>.</p>
<p>For more information, see: <a href="https://en.wikipedia.org/wiki/ANSI_escape_code">https://en.wikipedia.org/wiki/ANSI_escape_code</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Character to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the character is a possible escape code ending, otherwise <code>false</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#afa991b64a363bd5e6f1a722ed0759338">colr_str_code_count()</a>, <a class="el" href="colr_8h.html#ab6fa8ad1635fcff75ee1213a975dba4d">colr_str_code_len()</a>, <a class="el" href="colr_8h.html#a6292cbb8bd9f3d19bb0bd05a4d7b0bea">colr_str_get_codes()</a>, <a class="el" href="colr_8h.html#a85b2971301b5247769b08f5ed08564fb">colr_str_is_codes()</a>, <a class="el" href="colr_8h.html#a037a0245a39d7ff5cfba5f779d0eb251">colr_str_noncode_len()</a>, and <a class="el" href="colr_8h.html#ab0b13b04dc178d0990ab2ae403ee64e0">colr_str_strip_codes()</a>.</p>

</div>
</div>
<a id="af78a98cb101d4d5f18df0023b3109013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af78a98cb101d4d5f18df0023b3109013">&#9670;&nbsp;</a></span>colr_char_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_char_repr </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation for a char. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Value to create the representation for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a6c35f6b47cc737744487d14d20241656">ColorJustify_repr()</a>.</p>

</div>
</div>
<a id="a67ef4700a46e78c2bed1132428a610fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ef4700a46e78c2bed1132428a610fb">&#9670;&nbsp;</a></span>colr_char_should_escape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_char_should_escape </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if an ascii character has an escape sequence in C. </p>
<p>The following characters are supported: </p><table class="doxtable">
<tr>
<th align="right">Escape Sequence </th><th align="left">Description Representation  </th></tr>
<tr>
<td align="right">\ ' </td><td align="left">single quote </td></tr>
<tr>
<td align="right">\ " </td><td align="left">double quote </td></tr>
<tr>
<td align="right">\ ? </td><td align="left">question mark </td></tr>
<tr>
<td align="right">\ \ </td><td align="left">backslash </td></tr>
<tr>
<td align="right">\ a </td><td align="left">audible bell </td></tr>
<tr>
<td align="right">\ b </td><td align="left">backspace </td></tr>
<tr>
<td align="right">\ f </td><td align="left">form feed - new page </td></tr>
<tr>
<td align="right">\ n </td><td align="left">line feed - new line </td></tr>
<tr>
<td align="right">\ r </td><td align="left">carriage return </td></tr>
<tr>
<td align="right">\ t </td><td align="left">horizontal tab </td></tr>
<tr>
<td align="right">\ v </td><td align="left">vertical tab </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The character to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the character needs an escape sequence, otherwise <code>false</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a196ad91a69cfbeb27a5266ffc93ed353">colr_str_repr()</a>.</p>

</div>
</div>
<a id="adfe470aae91128e4529563c90c214e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfe470aae91128e4529563c90c214e3a">&#9670;&nbsp;</a></span>colr_check_marker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_check_marker </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>marker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks an unsigned int against the individual bytes behind a pointer's value. </p>
<p>This helps to guard against overflows, because only a single byte is checked at a time. If any byte doesn't match the marker, <code>false</code> is immediately returned, instead of continuing past the pointer's bounds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">marker</td><td>A colr marker, like COLORARG_MARKER, COLORTEXT_MARKER, etc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A pointer to check, to see if it starts with the marker. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all bytes match the marker, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#ad15f3a714a6383123d3fb24ade173e29" title="Checks a void pointer to see if it contains a ColorArg struct. ">ColorArg_is_ptr</a> </dd>
<dd>
<a class="el" href="colr_8c.html#a1d6eb8832110b943c3a3a17627a50288" title="Checks a void pointer to see if it contains a ColorText struct. ">ColorText_is_ptr</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_check_marker-example" id="colr_check_marker-example" class="diamond-bullet">&#160;</a> colr_check_marker example: </div><div class="fragment"><div class="line"><span class="comment">// This is actually used with void pointer, where the type is not known.</span></div><div class="line"><span class="comment">// It&#39;s only known that the pointer will be 1 of 3 types.</span></div><div class="line"><a class="code" href="colr_8h.html#structColorArg">ColorArg</a>* cargp = <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(GREEN);</div><div class="line">assert(<a class="code" href="colr_8c.html#adfe470aae91128e4529563c90c214e3a">colr_check_marker</a>(<a class="code" href="colr_8h.html#a22fa09afcaf087080075551d293a72fd">COLORARG_MARKER</a>, cargp));</div><div class="line"><a class="code" href="colr_8h.html#a76eae619668e01987653932a7492fd94">colr_free</a>(cargp);</div><div class="line"></div><div class="line"><span class="keywordtype">char</span>* s = <span class="stringliteral">&quot;Not a ColorText at all.&quot;</span>;</div><div class="line">assert(!<a class="code" href="colr_8c.html#adfe470aae91128e4529563c90c214e3a">colr_check_marker</a>(<a class="code" href="colr_8h.html#afc3756a551f1f8e5dfb56f6ab41d9e07">COLORTEXT_MARKER</a>, s));</div><div class="line"></div><div class="line"><a class="code" href="colr_8h.html#structColorText">ColorText</a>* ctextp = <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;But this is a ColorText.&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(GREEN));</div><div class="line">assert(<a class="code" href="colr_8c.html#adfe470aae91128e4529563c90c214e3a">colr_check_marker</a>(<a class="code" href="colr_8h.html#afc3756a551f1f8e5dfb56f6ab41d9e07">COLORTEXT_MARKER</a>, ctextp));</div><div class="line"><a class="code" href="colr_8h.html#a76eae619668e01987653932a7492fd94">colr_free</a>(ctextp);</div><div class="line"></div><div class="line">printf(<span class="stringliteral">&quot;colr_check_marker() assertions held up.\n&quot;</span>);</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#af64af11f4992c8143cb722772df98c98">_colr_is_last_arg()</a>, <a class="el" href="colr_8h.html#ad15f3a714a6383123d3fb24ade173e29">ColorArg_is_ptr()</a>, <a class="el" href="colr_8h.html#afd5fe635f26119c3a341b5dfe23abc97">ColorResult_is_ptr()</a>, and <a class="el" href="colr_8h.html#a1d6eb8832110b943c3a3a17627a50288">ColorText_is_ptr()</a>.</p>

</div>
</div>
<a id="a8963c87ccb1c39bdd4481bb81810ba78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8963c87ccb1c39bdd4481bb81810ba78">&#9670;&nbsp;</a></span>colr_empty_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_empty_str </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates an empty string (<code>char*</code>). </p>
<p>This is for keeping the interface simple, so the return values from color functions with invalid values can be consistent.</p>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">Pointer to an allocated string consisting of '\0'.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a1a8345393e635e1c5e148473bdce292d">colr_str_center()</a>, <a class="el" href="colr_8h.html#a5eedebae47b5d22dda709f833f23a256">colr_str_ljust()</a>, <a class="el" href="colr_8h.html#a2fbc36f0f7aba3aa0616437f937efd20">colr_str_replace_re_match()</a>, <a class="el" href="colr_8h.html#acc75e3bf729168f9ac204ef0a1708d46">colr_str_rjust()</a>, and <a class="el" href="colr_8h.html#ab0b13b04dc178d0990ab2ae403ee64e0">colr_str_strip_codes()</a>.</p>

</div>
</div>
<a id="a67e72a18762c87886173dd0a0dc37887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67e72a18762c87886173dd0a0dc37887">&#9670;&nbsp;</a></span>colr_free_re_matches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void colr_free_re_matches </td>
          <td>(</td>
          <td class="paramtype">regmatch_t **&#160;</td>
          <td class="paramname"><em>matches</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free an array of allocated <code>regmatch_t</code>, like the return from <a class="el" href="colr_8c.html#a37cd9a8f2748629e68e9c41ffca557a9" title="Returns all regmatch_t matches for regex pattern in a string (char*). ">colr_re_matches()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">matches</td><td>A pointer to an array of <code>regmatch_t</code> pointers. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#afd19623913d27e2d9a5af3496a478c2b">colr_str_replace_re_pat_all()</a>.</p>

</div>
</div>
<a id="a701126bd27c90fafa46152d9f9327b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a701126bd27c90fafa46152d9f9327b2f">&#9670;&nbsp;</a></span>colr_join_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_join_array </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>joinerp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join an array of strings (<code>char*</code>), <code><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a></code>s, or <code><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a></code>s by another string (<code>char*</code>), <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">joinerp</td><td>The joiner (any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, or string (<code>char*</code>)). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ps</td><td>An array of pointers to <code><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a></code>s, <code><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a></code>s, or strings (<code>char*</code>). The array must have <code>NULL</code> as the last item. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_join_array-example" id="colr_join_array-example" class="diamond-bullet">&#160;</a> colr_join_array example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* joiner = <span class="stringliteral">&quot; [and] &quot;</span>;</div><div class="line"><a class="code" href="colr_8h.html#structColorText">ColorText</a>* words[] = {</div><div class="line">    <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;this&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED)),</div><div class="line">    <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;that&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(<a class="code" href="colr_8h.html#a8fe812f8e76e4baed394ee9adf46b3df">hex</a>(<span class="stringliteral">&quot;ff3599&quot;</span>))),</div><div class="line">    <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;the other&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(BLUE), <a class="code" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662">style</a>(UNDERLINE)),</div><div class="line">    NULL</div><div class="line">};</div><div class="line"><span class="keywordtype">char</span>* s = <a class="code" href="colr_8c.html#a701126bd27c90fafa46152d9f9327b2f">colr_join_array</a>(joiner, words);</div><div class="line"><span class="keywordflow">if</span> (!s) exit(1);</div><div class="line">printf(<span class="stringliteral">&quot;%s\n&quot;</span>, s);</div><div class="line">free(s);</div><div class="line"></div><div class="line"><span class="comment">// Don&#39;t forget to free the ColorTexts/ColorArgs.</span></div><div class="line"><span class="keywordtype">size_t</span> i = 0;</div><div class="line"><span class="keywordflow">while</span> (words[i]) <a class="code" href="colr_8c.html#a901e5738358a739629cc3aaccab3e73f">ColorText_free</a>(words[i++]);</div></div><!-- fragment --> </div> <dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a753093cd4c872eed4b77feaa7816212b" title="Create an allocated string directly from Colr() arguments. ">colr</a> </dd>
<dd>
<a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join</a> </dd>
<dd>
<a class="el" href="colr_8c.html#a71fcf08ad36d4424790e275d973445fc" title="Join an array of strings (char*), ColorArgs, or ColorTexts by another string (char*), ColorArg, or ColorText. ">colr_join_arrayn</a> </dd></dl>

</div>
</div>
<a id="a71fcf08ad36d4424790e275d973445fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71fcf08ad36d4424790e275d973445fc">&#9670;&nbsp;</a></span>colr_join_arrayn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_join_arrayn </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>joinerp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join an array of strings (<code>char*</code>), <code><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a></code>s, or <code><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a></code>s by another string (<code>char*</code>), <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">joinerp</td><td>The joiner (any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, or string (<code>char*</code>)). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ps</td><td>An array of pointers to <code><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a></code>s, <code><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a></code>s, or strings (<code>char*</code>). The array must have at least a length of <code>count</code>, unless a <code>NULL</code> element is placed at the end. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The total number of items in the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. If any parameter is <code>NULL</code>, <code>NULL</code> is returned. </p>
</dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_join_arrayn-example" id="colr_join_arrayn-example" class="diamond-bullet">&#160;</a> colr_join_arrayn example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* joiner = <span class="stringliteral">&quot; [and] &quot;</span>;</div><div class="line"><a class="code" href="colr_8h.html#structColorText">ColorText</a>* words[] = {</div><div class="line">    <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;this&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED)),</div><div class="line">    <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;that&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(<a class="code" href="colr_8h.html#a8fe812f8e76e4baed394ee9adf46b3df">hex</a>(<span class="stringliteral">&quot;ff3599&quot;</span>))),</div><div class="line">    <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;the other&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(BLUE), <a class="code" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662">style</a>(UNDERLINE))</div><div class="line">};</div><div class="line"><span class="comment">// This only works for actual arrays, not malloc&#39;d stuff.</span></div><div class="line"><span class="keywordtype">size_t</span> arr_length = <span class="keyword">sizeof</span>(words) / <span class="keyword">sizeof</span>(words[0]);</div><div class="line"><span class="keywordtype">char</span>* s = <a class="code" href="colr_8c.html#a71fcf08ad36d4424790e275d973445fc">colr_join_arrayn</a>(joiner, words, arr_length);</div><div class="line"><span class="keywordflow">if</span> (!s) exit(1);</div><div class="line">printf(<span class="stringliteral">&quot;%s\n&quot;</span>, s);</div><div class="line">free(s);</div><div class="line"></div><div class="line"><span class="comment">// Don&#39;t forget to free the ColorTexts/ColorArgs.</span></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; arr_length; i++) <a class="code" href="colr_8c.html#a901e5738358a739629cc3aaccab3e73f">ColorText_free</a>(words[i]);</div></div><!-- fragment --> </div> <dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a753093cd4c872eed4b77feaa7816212b" title="Create an allocated string directly from Colr() arguments. ">colr</a> </dd>
<dd>
<a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a701126bd27c90fafa46152d9f9327b2f">colr_join_array()</a>.</p>

</div>
</div>
<a id="ade675256d9e88682d4bebdcc4a57f86f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade675256d9e88682d4bebdcc4a57f86f">&#9670;&nbsp;</a></span>colr_mb_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t colr_mb_len </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <code>mbrlen</code>, except it will return the length of the next N (<code>length</code>) multibyte characters in bytes. </p>
<p>/details Unlike <a class="el" href="colr_8c.html#ab473f70278850994e1b7b9c8008353fa" title="Returns the number of characters in a string (char*), taking into account possibly multibyte characte...">colr_str_mb_len()</a>, which returns the number of multibyte characters, this function will return the number of bytes that make up the next number (<code>length</code>) of multibyte characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Number of multibyte characters to get the length for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes parsed in <code>s</code> to get at least <code>length</code> multibyte characters. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if <code>s</code> is <code>NULL</code>/empty, or <code>length</code> is <code>0</code>. </td></tr>
    <tr><td class="paramname">(size_t)-1</td><td>if an invalid multibyte sequence is found at the start of <code>s</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#ab473f70278850994e1b7b9c8008353fa" title="Returns the number of characters in a string (char*), taking into account possibly multibyte characte...">colr_str_mb_len</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a9b95dc82c67a2ec94053e207b0b87594" title="Checks return values from mbrlen() and colr_mb_len(). ">colr_is_valid_mblen</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_mb_len-example" id="colr_mb_len-example" class="diamond-bullet">&#160;</a> colr_mb_len example: </div><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="colr_8h.html">colr.h</a>&quot;</span></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div><div class="line">    <span class="comment">// There are 4 multibyte characters in the string.</span></div><div class="line">    <span class="comment">// There are multiple bytes making up each character, probably 3 each,</span></div><div class="line">    <span class="comment">// which makes the byte-length 12.</span></div><div class="line">    <span class="keywordtype">char</span>* s = <span class="stringliteral">&quot;&quot;</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Calling colr_mb_len(s, 1) is like calling mbrlen().</span></div><div class="line">    <span class="keywordtype">size_t</span> first_len = <a class="code" href="colr_8c.html#ade675256d9e88682d4bebdcc4a57f86f">colr_mb_len</a>(s, 1);</div><div class="line">    mbstate_t st;</div><div class="line">    memset(&amp;st, 0, <span class="keyword">sizeof</span>(mbstate_t));</div><div class="line">    assert(first_len == (<span class="keywordtype">size_t</span>)mbrlen(s, MB_LEN_MAX, &amp;st));</div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> first_two_len = <a class="code" href="colr_8c.html#ade675256d9e88682d4bebdcc4a57f86f">colr_mb_len</a>(s, 2);</div><div class="line">    <span class="comment">// This assertion doesn&#39;t hold for ALL characters, but it should hold</span></div><div class="line">    <span class="comment">// for these, because they are all FULLWIDTH DIGIT chars.</span></div><div class="line">    assert(first_two_len == (first_len * 2));</div><div class="line"></div><div class="line">    <span class="comment">// Skip about 6 bytes, to get past the first 2</span></div><div class="line">    <span class="keywordtype">char</span>* skip2 = s + first_two_len;</div><div class="line">    assert(strcmp(skip2, <span class="stringliteral">&quot;&quot;</span>) == 0);</div><div class="line"></div><div class="line">    <span class="comment">// There are only about 7 bytes (6 + 1 for the null).</span></div><div class="line">    <span class="comment">// Calling colr_mb_len with a `length` that is too large is okay.</span></div><div class="line">    <span class="keywordtype">size_t</span> length = <a class="code" href="colr_8c.html#ade675256d9e88682d4bebdcc4a57f86f">colr_mb_len</a>(skip2, 100);</div><div class="line">    assert(length == strlen(skip2));</div><div class="line">    <span class="keywordtype">size_t</span> charlength = <a class="code" href="colr_8c.html#ab473f70278850994e1b7b9c8008353fa">colr_str_mb_len</a>(skip2);</div><div class="line">    printf(<span class="stringliteral">&quot;\&quot;%s\&quot; contains %lu bytes for %lu chars.\n&quot;</span>, skip2, length, charlength);</div><div class="line"></div><div class="line">    <span class="comment">// This should always hold true, even though it is useless:</span></div><div class="line">    assert(<a class="code" href="colr_8c.html#ade675256d9e88682d4bebdcc4a57f86f">colr_mb_len</a>(s, strlen(s)) == strlen(s));</div><div class="line"></div><div class="line">}</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#ab88ca919420f2df896b7973401641ab4">_rainbow()</a>.</p>

</div>
</div>
<a id="a34c359a48f811316d765b7abef1ea8f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34c359a48f811316d765b7abef1ea8f4">&#9670;&nbsp;</a></span>colr_printf_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int colr_printf_handler </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct printf_info *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *const *&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles printing with printf for Colr objects. </p>
<p>This function matches the required <code>typedef</code> in <code>printf.h</code> (<code>printf_function</code>), for handling a custom printf format char with <code>register_printf_specifier</code>.</p>
<dl class="section attention"><dt>Attention</dt><dd>This feature uses a GNU extension, and is only available when COLR_GNU is defined. See the documentation for COLR_GNU.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fp</td><td>FILE pointer for output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">info</td><td>Info from printf about how to format the argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Argument list (with only 1 argument), containing a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, or string (<code>char*</code>) to format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters written. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#aaaf134ca9a2188d83171fe91948354d9">colr_printf_register()</a>.</p>

</div>
</div>
<a id="a95619a7f5eeb0158dfb969ae9a26a6bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95619a7f5eeb0158dfb969ae9a26a6bb">&#9670;&nbsp;</a></span>colr_printf_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int colr_printf_info </td>
          <td>(</td>
          <td class="paramtype">const struct printf_info *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>argtypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles the arg count/size for the Colr printf handler. </p>
<p>This function matches the required <code>typedef</code> in <code>printf.h</code> (<code>printf_arginfo_size_function</code>) for handling a custom printf format char with <code>register_printf_specifier</code>.</p>
<dl class="section attention"><dt>Attention</dt><dd>This feature uses a GNU extension, and is only available when COLR_GNU is defined. See the documentation for COLR_GNU.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">info</td><td>Info from printf about how to format the argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of arguments for the format char. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">argtypes</td><td>Type of arguments being handled, from an <code>enum</code> defined in <code>printf</code>. Colr uses/sets one argument, a <code>PA_POINTER</code> type. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sz</td><td>Size of the arguments. Not used in Colr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of argument types set in <code>argtypes</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#aaaf134ca9a2188d83171fe91948354d9">colr_printf_register()</a>.</p>

</div>
</div>
<a id="aaaf134ca9a2188d83171fe91948354d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf134ca9a2188d83171fe91948354d9">&#9670;&nbsp;</a></span>colr_printf_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void colr_printf_register </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers COLR_FMT_CHAR to handle Colr objects in the printf-family functions. </p>
<p>This function only needs to be called once and <code>register_printf_specifier</code> is only called the first time this function is called.</p>
<dl class="section attention"><dt>Attention</dt><dd>This feature uses a GNU extension, and is only available when COLR_GNU is defined. See the documentation for COLR_GNU.</dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_printf_register-example" id="colr_printf_register-example" class="diamond-bullet">&#160;</a> colr_printf_register example: </div><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="colr_8h.html">colr.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="comment">// These are needed if you have certain warnings enabled.</span></div><div class="line"><span class="preprocessor">#pragma clang diagnostic ignored &quot;-Winvalid-format-specifier&quot;</span></div><div class="line"><span class="preprocessor">#pragma GCC diagnostic ignored &quot;-Wformat=&quot;</span></div><div class="line"><span class="preprocessor">#pragma GCC diagnostic ignored &quot;-Wformat-extra-args&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div><div class="line">    <a class="code" href="colr_8c.html#aaaf134ca9a2188d83171fe91948354d9">colr_printf_register</a>();</div><div class="line">    printf(<span class="stringliteral">&quot;A colr object: %R\n&quot;</span>, <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;Hello&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED)));</div><div class="line"></div><div class="line">    <span class="keywordtype">char</span>* colorized = NULL;</div><div class="line">    asprintf(</div><div class="line">        &amp;colorized,</div><div class="line">        <span class="stringliteral">&quot;I made this: %R&quot;</span>,</div><div class="line">        <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;No, I made this.&quot;</span>, <a class="code" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662">style</a>(UNDERLINE))</div><div class="line">    );</div><div class="line">    puts(colorized);</div><div class="line">    free(colorized);</div><div class="line">}</div></div><!-- fragment --> </div> 
</div>
</div>
<a id="a37cd9a8f2748629e68e9c41ffca557a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37cd9a8f2748629e68e9c41ffca557a9">&#9670;&nbsp;</a></span>colr_re_matches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regmatch_t** colr_re_matches </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">regex_t *&#160;</td>
          <td class="paramname"><em>repattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all <code>regmatch_t</code> matches for regex pattern in a string (<code>char*</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repattern</td><td>The pattern to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">A pointer to an allocated array of <code>regmatch_t*</code>, or <code>NULL</code> if <code>s</code> is <code>NULL</code> or <code>repattern</code> is <code>NULL</code>. The last member is always <code>NULL</code>.</p>
<p class="enddd"><em>You must <code>free()</code> the memory allocated by this function.</em> </p>
</dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_re_matches-example" id="colr_re_matches-example" class="diamond-bullet">&#160;</a> colr_re_matches example: </div><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="colr_8h.html">colr.h</a>&quot;</span></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div><div class="line">    <span class="comment">// Compile a regex pattern.</span></div><div class="line">    regex_t pat;</div><div class="line">    <span class="keywordflow">if</span> (regcomp(&amp;pat, <span class="stringliteral">&quot;foo&quot;</span>, 0)) {</div><div class="line">        regfree(&amp;pat);</div><div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line">    <span class="comment">// The string to operate on.</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* s = <span class="stringliteral">&quot;This foo is a foo string, foo?&quot;</span>;</div><div class="line">    <span class="comment">// Get all matches.</span></div><div class="line">    regmatch_t** matches = <a class="code" href="colr_8c.html#a37cd9a8f2748629e68e9c41ffca557a9">colr_re_matches</a>(s, &amp;pat);</div><div class="line">    <span class="keywordflow">if</span> (!matches) {</div><div class="line">        <span class="comment">// This should be impossible (for this example).</span></div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;No matches?\n&quot;</span>);</div><div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line">    puts(s);</div><div class="line">    <span class="comment">// `colr_re_matches` always leaves `NULL` as the last member.</span></div><div class="line">    <span class="keywordtype">size_t</span> cnt = 0;</div><div class="line">    <span class="keywordflow">while</span> (matches[cnt]) {</div><div class="line">        printf(<span class="stringliteral">&quot;Found a match at: %d-%d\n&quot;</span>, matches[cnt]-&gt;rm_so, matches[cnt]-&gt;rm_eo);</div><div class="line">        cnt++;</div><div class="line">    }</div><div class="line">    <span class="comment">// Free all of your resources.</span></div><div class="line">    <a class="code" href="colr_8h.html#a76eae619668e01987653932a7492fd94">colr_free</a>(matches);</div><div class="line">    regfree(&amp;pat);</div><div class="line">}</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#afd19623913d27e2d9a5af3496a478c2b">colr_str_replace_re_pat_all()</a>.</p>

</div>
</div>
<a id="a180c1ac4711df9fb025639c966f84727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a180c1ac4711df9fb025639c966f84727">&#9670;&nbsp;</a></span>colr_set_locale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_set_locale </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the locale to <code>(LC_ALL, "")</code> if it hasn't already been set. </p>
<p>This is used for functions dealing with multibyte strings.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the locale had to be set, <code>false</code> if it was already set. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ade675256d9e88682d4bebdcc4a57f86f">colr_mb_len()</a>, and <a class="el" href="colr_8h.html#ab473f70278850994e1b7b9c8008353fa">colr_str_mb_len()</a>.</p>

</div>
</div>
<a id="a1b98f363fb0873cfb7e60e99191647a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b98f363fb0873cfb7e60e99191647a6">&#9670;&nbsp;</a></span>colr_str_array_contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_str_array_contains </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>lst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a string (<code>char*</code>) is in an array of strings (<code>char**</code>, where the last element is <code>NULL</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lst</td><td>The string array to look in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the string is found, otherwise <code>false</code>. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&lt;tt&gt;false&lt;/tt&gt;</td><td>if <code>lst</code> is <code>NULL</code> or <code>s</code> is <code>NULL</code>.</td></tr>
  </table>
  </dd>
</dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_array_contains-example" id="colr_str_array_contains-example" class="diamond-bullet">&#160;</a> colr_str_array_contains example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* strarray[] = {</div><div class="line">    <span class="stringliteral">&quot;this&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;that&quot;</span>,</div><div class="line">    NULL</div><div class="line">};</div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="colr_8c.html#a1b98f363fb0873cfb7e60e99191647a6">colr_str_array_contains</a>(strarray, <span class="stringliteral">&quot;that&quot;</span>)) {</div><div class="line">    printf(<span class="stringliteral">&quot;List contained \&quot;that\&quot;.\n&quot;</span>);</div><div class="line">}</div><div class="line"><span class="keywordflow">if</span> (!<a class="code" href="colr_8c.html#a1b98f363fb0873cfb7e60e99191647a6">colr_str_array_contains</a>(strarray, <span class="stringliteral">&quot;NONEXISTENT&quot;</span>)) {</div><div class="line">    printf(<span class="stringliteral">&quot;List did not contain \&quot;NONEXISTENT\&quot;.\n&quot;</span>);</div><div class="line">}</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a6292cbb8bd9f3d19bb0bd05a4d7b0bea">colr_str_get_codes()</a>.</p>

</div>
</div>
<a id="a90384ff3082ad86bf5eb0923ac9a644a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90384ff3082ad86bf5eb0923ac9a644a">&#9670;&nbsp;</a></span>colr_str_array_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void colr_str_array_free </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free an allocated array of strings, including the array itself. </p>
<p>Each individual string will be released, and finally the allocated memory for the array of pointers will be released.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ps</td><td>A pointer to an array of strings.</td></tr>
  </table>
  </dd>
</dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_array_free-example" id="colr_str_array_free-example" class="diamond-bullet">&#160;</a> colr_str_array_free example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* s = <a class="code" href="colr_8h.html#a753093cd4c872eed4b77feaa7816212b">colr</a>(<span class="stringliteral">&quot;Test&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED), <a class="code" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8">back</a>(WHITE), <a class="code" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662">style</a>(BRIGHT));</div><div class="line"><span class="keywordflow">if</span> (!s) exit(1);</div><div class="line"><span class="comment">// Call something that creates an array of strings on the heap.</span></div><div class="line"><span class="keywordtype">char</span>** code_array = <a class="code" href="colr_8c.html#a6292cbb8bd9f3d19bb0bd05a4d7b0bea">colr_str_get_codes</a>(s, <span class="keyword">false</span>);</div><div class="line">free(s);</div><div class="line"><span class="keywordflow">if</span> (!code_array) exit(1);</div><div class="line"><span class="comment">// ... do something with the array of strings.</span></div><div class="line"></div><div class="line"><span class="comment">// And then free it:</span></div><div class="line"><a class="code" href="colr_8c.html#a90384ff3082ad86bf5eb0923ac9a644a">colr_str_array_free</a>(code_array);</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a4897abe50811762a84ee409c0c2d300f">ColorArgs_from_str()</a>.</p>

</div>
</div>
<a id="a1a8345393e635e1c5e148473bdce292d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a8345393e635e1c5e148473bdce292d">&#9670;&nbsp;</a></span>colr_str_center()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_center </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>padchar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Center-justifies a string (<code>char*</code>), ignoring escape codes when measuring the width. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">The string to justify.</p>
<p class="endtd">Input <em>must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The overall width for the resulting string. If set to '0', the terminal width will be used from <a class="el" href="colr_8c.html#ae4c11bb5b3b1bb2848bb16aee39763b2" title="Attempts to retrieve the row/column size of the terminal and returns a TermSize. ">colr_term_size()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">padchar</td><td>The character to pad with. If '0', then `' '` is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#a5eedebae47b5d22dda709f833f23a256" title="Left-justifies a string (char*), ignoring escape codes when measuring the width. ">colr_str_ljust</a> </dd>
<dd>
<a class="el" href="colr_8c.html#acc75e3bf729168f9ac204ef0a1708d46" title="Right-justifies a string (char*), ignoring escape codes when measuring the width. ...">colr_str_rjust</a> </dd>
<dd>
<a class="el" href="colr_8c.html#ae4c11bb5b3b1bb2848bb16aee39763b2" title="Attempts to retrieve the row/column size of the terminal and returns a TermSize. ">colr_term_size</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_center-example" id="colr_str_center-example" class="diamond-bullet">&#160;</a> colr_str_center example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* colorized = <a class="code" href="colr_8h.html#a753093cd4c872eed4b77feaa7816212b">colr</a>(<span class="stringliteral">&quot;This.&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED), <a class="code" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8">back</a>(WHITE));</div><div class="line"><span class="keywordtype">char</span>* justified = <a class="code" href="colr_8c.html#a1a8345393e635e1c5e148473bdce292d">colr_str_center</a>(colorized, 9, <span class="charliteral">&#39; &#39;</span>);</div><div class="line">free(colorized);</div><div class="line"><span class="comment">// The string still has codes, but only 4 spaces were added.</span></div><div class="line">assert(<a class="code" href="colr_8c.html#ac23328cead6a65d7b3ef2c2ca48d11ce">colr_str_starts_with</a>(justified, <span class="stringliteral">&quot;  &quot;</span>));</div><div class="line">assert(<a class="code" href="colr_8c.html#a7dd712bd8253271f0c88158db791c8bf">colr_str_ends_with</a>(justified, <span class="stringliteral">&quot;  &quot;</span>));</div><div class="line"><span class="comment">// It was &quot;justified&quot; to 9 characters long, but it is well over that.</span></div><div class="line">assert(strlen(justified) &gt; 9);</div><div class="line">printf(<span class="stringliteral">&quot;&#39;%s&#39;\n&quot;</span>, justified);</div><div class="line">free(justified);</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a34c359a48f811316d765b7abef1ea8f4">colr_printf_handler()</a>.</p>

</div>
</div>
<a id="ad5e3ecc4a6c4bcaad1217df9200d271e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e3ecc4a6c4bcaad1217df9200d271e">&#9670;&nbsp;</a></span>colr_str_char_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t colr_str_char_count </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of characters (<code>c</code>) that are found in a string (<code>char*</code>) (<code>s</code>). </p>
<p>Returns <code>0</code> if <code>s</code> is <code>NULL</code>, or <code>c</code> is `'\0'`.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">The string to examine.</p>
<p class="endtd"><em>Must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td><p class="starttd">The character to count.</p>
<p class="endtd"><em>Must not be <code>0</code></em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of times <code>c</code> occurs in <code>s</code>.</dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_char_count-example" id="colr_str_char_count-example" class="diamond-bullet">&#160;</a> colr_str_char_count example: </div><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> ps = <a class="code" href="colr_8c.html#ad5e3ecc4a6c4bcaad1217df9200d271e">colr_str_char_count</a>(<span class="stringliteral">&quot;apple&quot;</span>, <span class="charliteral">&#39;p&#39;</span>);</div><div class="line">assert(ps == 2);</div><div class="line">printf(<span class="stringliteral">&quot;Found %lu &#39;p&#39; characters.\n&quot;</span>, ps)</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#ab88ca919420f2df896b7973401641ab4">_rainbow()</a>.</p>

</div>
</div>
<a id="ae479b42d955b24cc1ddf572b9282a624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae479b42d955b24cc1ddf572b9282a624">&#9670;&nbsp;</a></span>colr_str_char_lcount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t colr_str_char_lcount </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of characters (<code>c</code>) that are found at the beginning of a string (<code>char*</code>) (<code>s</code>). </p>
<p>Returns <code>0</code> if <code>s</code> is <code>NULL</code>, <code>c</code> is `'\0'`, or the string doesn't start with <code>c</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">The string to examine.</p>
<p class="endtd"><em>Must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td><p class="starttd">The character to count.</p>
<p class="endtd"><em>Must not be <code>0</code></em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of times <code>c</code> occurs at the start of <code>s</code>.</dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_char_lcount-example" id="colr_str_char_lcount-example" class="diamond-bullet">&#160;</a> colr_str_char_lcount example: </div><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> xs = <a class="code" href="colr_8c.html#ae479b42d955b24cc1ddf572b9282a624">colr_str_char_lcount</a>(<span class="stringliteral">&quot;xxApple&quot;</span>, <span class="charliteral">&#39;x&#39;</span>);</div><div class="line">assert(xs == 2);</div><div class="line">printf(<span class="stringliteral">&quot;Found %lu &#39;x&#39; characters.\n&quot;</span>, xs)</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a060dc0f80eade56563d6942339c2859e">colr_str_lstrip_char()</a>.</p>

</div>
</div>
<a id="a566857db0f22ad4a1ba17ee3a56cf174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a566857db0f22ad4a1ba17ee3a56cf174">&#9670;&nbsp;</a></span>colr_str_chars_lcount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t colr_str_chars_lcount </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>chars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of characters that are found at the beginning of a string (<code>char*</code>) (<code>s</code>), where the character can be any of <code>chars</code>. </p>
<p>Returns <code>0</code> if <code>s</code> is <code>NULL</code>/empty, <code>chars</code> is <code>NULL</code>/empty, or the string doesn't start with any of the characters in <code>chars</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">The string to examine.</p>
<p class="endtd"><em>Must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">chars</td><td><p class="starttd">The characters to count, in any order.</p>
<p class="endtd"><em>Must not be <code>0</code></em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of times a character in <code>chars</code> occurs at the start of <code>s</code>.</dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_chars_lcount-example" id="colr_str_chars_lcount-example" class="diamond-bullet">&#160;</a> colr_str_chars_lcount example: </div><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> chars = <a class="code" href="colr_8c.html#a566857db0f22ad4a1ba17ee3a56cf174">colr_str_chars_lcount</a>(<span class="stringliteral">&quot;cbaabcbbccApple&quot;</span>, <span class="stringliteral">&quot;abc&quot;</span>);</div><div class="line">assert(chars == 10);</div><div class="line">printf(<span class="stringliteral">&quot;Found %lu &#39;a&#39;, &#39;b&#39;, or &#39;c&#39; characters.\n&quot;</span>, chars)</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#af502be785bdb221c2dc1a47fece1fc5f">colr_str_lstrip_chars()</a>.</p>

</div>
</div>
<a id="afa991b64a363bd5e6f1a722ed0759338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa991b64a363bd5e6f1a722ed0759338">&#9670;&nbsp;</a></span>colr_str_code_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t colr_str_code_count </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of escape-codes in a string (<code>char*</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">A string to count the escape-codes for.</p>
<p class="endtd"><em>Must be <code>null</code>-terminated</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of escape-codes, or <code>0</code> if <code>s</code> is <code>NULL</code>, or doesn't contain any escape-codes.</dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_code_count-example" id="colr_str_code_count-example" class="diamond-bullet">&#160;</a> colr_str_code_count example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* s = <a class="code" href="colr_8h.html#a753093cd4c872eed4b77feaa7816212b">colr</a>(<span class="stringliteral">&quot;Testing this out.&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED), <a class="code" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8">back</a>(WHITE));</div><div class="line"><span class="keywordflow">if</span> (!s) exit(1);</div><div class="line"><span class="keywordtype">size_t</span> code_cnt = <a class="code" href="colr_8c.html#afa991b64a363bd5e6f1a722ed0759338">colr_str_code_count</a>(s);</div><div class="line">assert(code_cnt == 3); <span class="comment">// The reset code is also appended.</span></div><div class="line">printf(<span class="stringliteral">&quot;Found codes: %zu\n&quot;</span>, code_cnt);</div><div class="line">free(s);</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a6292cbb8bd9f3d19bb0bd05a4d7b0bea">colr_str_get_codes()</a>.</p>

</div>
</div>
<a id="ab6fa8ad1635fcff75ee1213a975dba4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6fa8ad1635fcff75ee1213a975dba4d">&#9670;&nbsp;</a></span>colr_str_code_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t colr_str_code_len </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of bytes that make up all the escape-codes in a string (<code>char*</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">A string to count the code-chars for.</p>
<p class="endtd"><em>Must be <code>null</code>-terminated</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of escape-code characters, or <code>0</code> if <code>s</code> is <code>NULL</code>, or doesn't contain any escape-codes.</dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_code_len-example" id="colr_str_code_len-example" class="diamond-bullet">&#160;</a> colr_str_code_len example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* s = <a class="code" href="colr_8h.html#a753093cd4c872eed4b77feaa7816212b">colr</a>(<span class="stringliteral">&quot;Testing this out.&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED), <a class="code" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8">back</a>(WHITE));</div><div class="line"><span class="keywordflow">if</span> (!s) exit(1);</div><div class="line"><span class="keywordtype">size_t</span> code_len = <a class="code" href="colr_8c.html#ab6fa8ad1635fcff75ee1213a975dba4d">colr_str_code_len</a>(s);</div><div class="line">assert(code_len == 14); <span class="comment">// The reset code is also appended.</span></div><div class="line">printf(<span class="stringliteral">&quot;Found code chars: %zu\n&quot;</span>, code_len);</div><div class="line">free(s);</div></div><!-- fragment --> </div> 
</div>
</div>
<a id="a4fb3c15e839f5c16d3e7cd001d32aee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fb3c15e839f5c16d3e7cd001d32aee6">&#9670;&nbsp;</a></span>colr_str_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_copy </td>
          <td>(</td>
          <td class="paramtype">char *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a string (<code>char*</code>) like strncpy, but ensures null-termination. </p>
<p>If <code>src</code> is <code>NULL</code>, or <code>dest</code> is <code>NULL</code>, <code>NULL</code> is returned.</p>
<p>If <code>src</code> does not contain a null-terminator, <em>this function will truncate at <code>length</code> characters</em>.</p>
<p>If <code>src</code> is an empty string, then <code>dest[0]</code> will be `'\0'` (an empty string).</p>
<p>A null-terminator is always appended to <code>dest</code>.</p>
<p><code>src</code> and <code>dest</code> must not overlap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>Memory allocated for new string. <em>Must have room for <code>strlen(src) + 1</code> or <code>length + 1</code></em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source string to copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Maximum characters to copy. <em>This does not include the null-terminator</em>. Usually set to <code>strlen(dest)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a pointer to dest is returned.</dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_copy-example" id="colr_str_copy-example" class="diamond-bullet">&#160;</a> colr_str_copy example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* s = <span class="stringliteral">&quot;testing&quot;</span>;</div><div class="line"><span class="keywordtype">size_t</span> length = strlen(s);</div><div class="line"><span class="keywordtype">char</span>* dest = malloc(length + 1);</div><div class="line"></div><div class="line"><span class="comment">// Copy the entire string:</span></div><div class="line"><a class="code" href="colr_8c.html#a4fb3c15e839f5c16d3e7cd001d32aee6">colr_str_copy</a>(dest, s, length);</div><div class="line">assert(strcmp(dest, <span class="stringliteral">&quot;testing&quot;</span>) == 0);</div><div class="line">printf(<span class="stringliteral">&quot;Copied: %s\n&quot;</span>, dest);</div><div class="line"></div><div class="line"><span class="comment">// Copy only 4 bytes:</span></div><div class="line"><a class="code" href="colr_8c.html#a4fb3c15e839f5c16d3e7cd001d32aee6">colr_str_copy</a>(dest, s, 4);</div><div class="line">assert(strcmp(dest, <span class="stringliteral">&quot;test&quot;</span>) == 0);</div><div class="line">printf(<span class="stringliteral">&quot;Truncated: %s\n&quot;</span>, dest);</div><div class="line"></div><div class="line"><span class="comment">// String gets truncated when dest is too small:</span></div><div class="line"><a class="code" href="colr_8c.html#a4fb3c15e839f5c16d3e7cd001d32aee6">colr_str_copy</a>(dest, <span class="stringliteral">&quot;this is too long.&quot;</span>, length);</div><div class="line">assert(strcmp(dest, <span class="stringliteral">&quot;this is&quot;</span>) == 0);</div><div class="line">assert(dest[length] == <span class="charliteral">&#39;\0&#39;</span>);</div><div class="line">printf(<span class="stringliteral">&quot;Truncated: %s\n&quot;</span>, dest);</div><div class="line">free(dest);</div></div><!-- fragment --> </div> 
</div>
</div>
<a id="a7dd712bd8253271f0c88158db791c8bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd712bd8253271f0c88158db791c8bf">&#9670;&nbsp;</a></span>colr_str_ends_with()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_str_ends_with </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if one string (<code>char*</code>) ends with another. </p>
<p><code>str</code> and <code>suffix</code> must not overlap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">String to check.</p>
<p class="endtd"><em>Must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">suffix</td><td><p class="starttd">Suffix to check for.</p>
<p class="endtd"><em>Must be <code>null</code>-terminated</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <code>str</code> ends with <code>suffix</code>. </dd>
<dd>
False if either is NULL, or the string doesn't end with the suffix. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a10030070daafdee7124638adfc5469d8">colr_append_reset()</a>.</p>

</div>
</div>
<a id="a6292cbb8bd9f3d19bb0bd05a4d7b0bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6292cbb8bd9f3d19bb0bd05a4d7b0bea">&#9670;&nbsp;</a></span>colr_str_get_codes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** colr_str_get_codes </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unique</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an array of escape-codes from a string (<code>char*</code>). </p>
<p>This function copies the escape-code strings, and the pointers to the heap, if any escape-codes are found in the string.</p>
<p><a class="el" href="colr_8c.html#a90384ff3082ad86bf5eb0923ac9a644a" title="Free an allocated array of strings, including the array itself. ">colr_str_array_free()</a> can be used to easily <code>free()</code> the result of this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">A string to get the escape-codes from.</p>
<p class="endtd"><em>Must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unique</td><td>Whether to only include <em>unique</em> escape codes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated array of string (<code>char*</code>) pointers, where the last element is <code>NULL</code>.</p>
<p class="enddd"><em>You must <code>free()</code> the memory allocated by this function.</em> </p>
</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">If</td><td><code>s</code> is <code>NULL</code>, or empty, or there are otherwise no escape-codes found in the string, or allocation fails for the strings/array, then <code>NULL</code> is returned. </td></tr>
    <tr><td class="paramname">On</td><td>success, there will be at least two pointers behind the return value. The last pointer is always <code>NULL</code>.</td></tr>
  </table>
  </dd>
</dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_get_codes-example" id="colr_str_get_codes-example" class="diamond-bullet">&#160;</a> colr_str_get_codes example: </div><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="colr_8h.html">colr.h</a>&quot;</span></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div><div class="line">    <span class="keywordtype">char</span>* s = <a class="code" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa">colr_cat</a>(</div><div class="line">        <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;Testing this out.&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED), <a class="code" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8">back</a>(WHITE)),</div><div class="line">        <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;Again.&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED), <a class="code" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662">style</a>(UNDERLINE))</div><div class="line">    );</div><div class="line">    <span class="keywordflow">if</span> (!s) <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    <span class="keywordtype">char</span>** code_array = <a class="code" href="colr_8c.html#a6292cbb8bd9f3d19bb0bd05a4d7b0bea">colr_str_get_codes</a>(s, <span class="keyword">false</span>);</div><div class="line">    free(s);</div><div class="line">    <span class="keywordflow">if</span> (!code_array) {</div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;No code found? Impossible!\n&quot;</span>);</div><div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line">    <span class="comment">// Iterate over the code array.</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; code_array[i]; i++) {</div><div class="line">        <span class="keywordtype">char</span>* code_repr = <a class="code" href="colr_8h.html#ac1ef824dd213274fb239526269315543">colr_repr</a>(code_array[i]);</div><div class="line">        printf(<span class="stringliteral">&quot;Found code: %s\n&quot;</span>, code_repr);</div><div class="line">        free(code_repr);</div><div class="line">    }</div><div class="line">    <span class="comment">// Free the strings, and the array of pointers.</span></div><div class="line">    <a class="code" href="colr_8c.html#a90384ff3082ad86bf5eb0923ac9a644a">colr_str_array_free</a>(code_array);</div><div class="line">}</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a4897abe50811762a84ee409c0c2d300f">ColorArgs_from_str()</a>.</p>

</div>
</div>
<a id="a8b9f4cbe1e806316e063206dfb610476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b9f4cbe1e806316e063206dfb610476">&#9670;&nbsp;</a></span>colr_str_has_codes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_str_has_codes </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a string (<code>char*</code>) has ANSI escape codes in it. </p>
<p>This will detect any ansi escape code, not just colors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">The string to check. Can be <code>NULL</code>.</p>
<p class="endtd">Input <em>must be <code>null</code>-terminated</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the string has at least one escape code, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#a85b2971301b5247769b08f5ed08564fb" title="Determines if a string (char*) is composed entirely of escape codes. ">colr_str_is_codes</a> </dd></dl>

</div>
</div>
<a id="adf5a3149704b14b85a0236d9940fb4e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf5a3149704b14b85a0236d9940fb4e7">&#9670;&nbsp;</a></span>colr_str_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ColrHash colr_str_hash </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hash a string using <a href="http://www.cse.yorku.ca/~oz/hash.html">djb2</a>. </p>
<p>This is only used for simple, short, string (<code>char*</code>) hashing. It is not designed for cryptography.</p>
<p>There are some notes about collision rates for this function <a href="https://softwareengineering.stackexchange.com/a/145633">here</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">The string to hash.</p>
<p class="endtd"><em>Must be <code>null</code>-terminated</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A ColrHash (<code>unsigned long</code>) value with the hash. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if <code>s</code> is <code>NULL</code>. </td></tr>
    <tr><td class="paramname">COLR_HASH_SEED</td><td>if <code>s</code> is an empty string.</td></tr>
  </table>
  </dd>
</dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_hash-example" id="colr_str_hash-example" class="diamond-bullet">&#160;</a> colr_str_hash example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* strings[] = {</div><div class="line">    <span class="stringliteral">&quot;fore&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;back&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;style&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;invalid&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;red&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;\x1b[4m&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;\x1b[0m&quot;</span></div><div class="line">};</div><div class="line"><span class="keywordtype">size_t</span> strings_len = <span class="keyword">sizeof</span>(strings) / <span class="keyword">sizeof</span>(strings[0]);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; strings_len; i++) {</div><div class="line">    ColrHash hashval = <a class="code" href="colr_8c.html#adf5a3149704b14b85a0236d9940fb4e7">colr_str_hash</a>(strings[i]);</div><div class="line">    printf(<span class="stringliteral">&quot;%8s: hash=%lu\n&quot;</span>, strings[i], hashval);</div><div class="line">}</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a1b98f363fb0873cfb7e60e99191647a6">colr_str_array_contains()</a>.</p>

</div>
</div>
<a id="a3dc3f370843b64e92fb7d79e7989b5c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc3f370843b64e92fb7d79e7989b5c3">&#9670;&nbsp;</a></span>colr_str_is_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_str_is_all </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a string (<code>char*</code>) consists of only one character, possibly repeated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>String to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Character to test for. Must not be <code>0</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>s</code> contains only the character <code>c</code>, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a85b2971301b5247769b08f5ed08564fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b2971301b5247769b08f5ed08564fb">&#9670;&nbsp;</a></span>colr_str_is_codes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_str_is_codes </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a string (<code>char*</code>) is composed entirely of escape codes. </p>
<p>Returns <code>false</code> if the string is <code>NULL</code>, or empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">The string to check.</p>
<p class="endtd">Input <em>must be <code>null</code>-terminated</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the string is escape-codes only, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#a8b9f4cbe1e806316e063206dfb610476" title="Determines if a string (char*) has ANSI escape codes in it. ">colr_str_has_codes</a> </dd></dl>

</div>
</div>
<a id="af5492da225ade4fd8fe71989826348b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5492da225ade4fd8fe71989826348b4">&#9670;&nbsp;</a></span>colr_str_is_digits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_str_is_digits </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether all characters in a string (<code>char*</code>) are digits. </p>
<p>If <code>s</code> is NULL or an empty string (<code>""</code>), <code>false</code> is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">String to check.</p>
<p class="endtd">Input <em>must be <code>null</code>-terminated</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all characters are digits (0-9), otherwise <code>false</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a2e859d542a8aa0939e4f76b1f33cb5f8">ExtendedValue_from_str()</a>.</p>

</div>
</div>
<a id="a5eedebae47b5d22dda709f833f23a256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eedebae47b5d22dda709f833f23a256">&#9670;&nbsp;</a></span>colr_str_ljust()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_ljust </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>padchar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left-justifies a string (<code>char*</code>), ignoring escape codes when measuring the width. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">The string to justify.</p>
<p class="endtd">Input <em>must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The overall width for the resulting string. If set to '0', the terminal width will be used from <a class="el" href="colr_8c.html#ae4c11bb5b3b1bb2848bb16aee39763b2" title="Attempts to retrieve the row/column size of the terminal and returns a TermSize. ">colr_term_size()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">padchar</td><td>The character to pad with. If '0', then `' '` is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#a1a8345393e635e1c5e148473bdce292d" title="Center-justifies a string (char*), ignoring escape codes when measuring the width. ">colr_str_center</a> </dd>
<dd>
<a class="el" href="colr_8c.html#acc75e3bf729168f9ac204ef0a1708d46" title="Right-justifies a string (char*), ignoring escape codes when measuring the width. ...">colr_str_rjust</a> </dd>
<dd>
<a class="el" href="colr_8c.html#ae4c11bb5b3b1bb2848bb16aee39763b2" title="Attempts to retrieve the row/column size of the terminal and returns a TermSize. ">colr_term_size</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_ljust-example" id="colr_str_ljust-example" class="diamond-bullet">&#160;</a> colr_str_ljust example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* colorized = <a class="code" href="colr_8h.html#a753093cd4c872eed4b77feaa7816212b">colr</a>(<span class="stringliteral">&quot;This.&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED), <a class="code" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8">back</a>(WHITE));</div><div class="line"><span class="keywordtype">char</span>* justified = <a class="code" href="colr_8c.html#a5eedebae47b5d22dda709f833f23a256">colr_str_ljust</a>(colorized, 8, <span class="charliteral">&#39; &#39;</span>);</div><div class="line">free(colorized);</div><div class="line"><span class="comment">// The string still has codes, but only 3 spaces were added.</span></div><div class="line">assert(<a class="code" href="colr_8c.html#a7dd712bd8253271f0c88158db791c8bf">colr_str_ends_with</a>(justified, <span class="stringliteral">&quot;   &quot;</span>));</div><div class="line"><span class="comment">// It was &quot;justified&quot; to 8 characters long, but it is well over that.</span></div><div class="line">assert(strlen(justified) &gt; 8);</div><div class="line">printf(<span class="stringliteral">&quot;&#39;%s&#39;\n&quot;</span>, justified);</div><div class="line">free(justified);</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a34c359a48f811316d765b7abef1ea8f4">colr_printf_handler()</a>.</p>

</div>
</div>
<a id="a116ec26960e79456dbf9cf7f40ffe0d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116ec26960e79456dbf9cf7f40ffe0d7">&#9670;&nbsp;</a></span>colr_str_lower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void colr_str_lower </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a string (<code>char*</code>) into lower case in place. </p>
<p>Input <em>must be <code>null</code>-terminated</em>.</p>
<p>If <code>s</code> is <code>NULL</code>, nothing is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The input string to convert to lower case. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35ffd3ec364c8d0c0e96a0723b7aa46f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35ffd3ec364c8d0c0e96a0723b7aa46f">&#9670;&nbsp;</a></span>colr_str_lstrip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t colr_str_lstrip </td>
          <td>(</td>
          <td class="paramtype">char *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Strip a leading character from a string (<code>char*</code>), filling another string (<code>char*</code>) with the result. </p>
<p><code>dest</code> and <code>s</code> should not overlap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>Destination <code>char</code> array. Must have room for <code>strlen(s) + 1</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>String to strip the character from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of <code>s</code>, the input string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Character to strip. If set to <code>0</code>, all whitespace characters will be used (' ', '\n', '\t', '\v', '\f', '\r'). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of <code>c</code> characters removed. May return <code>0</code> if <code>s</code> is <code>NULL</code>/empty, <code>dest</code> is <code>NULL</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a060dc0f80eade56563d6942339c2859e">colr_str_lstrip_char()</a>, and <a class="el" href="colr_8h.html#ad33884dcde034819c5e6749667247194">RGB_from_hex()</a>.</p>

</div>
</div>
<a id="a060dc0f80eade56563d6942339c2859e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a060dc0f80eade56563d6942339c2859e">&#9670;&nbsp;</a></span>colr_str_lstrip_char()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_lstrip_char </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Strips a leading character from a string (<code>char*</code>), and allocates a new string with the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>String to strip the character from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Character to strip. If set to <code>0</code>, all whitespace characters will be used (' ', '\n', '\t'). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result. May return <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>

</div>
</div>
<a id="af502be785bdb221c2dc1a47fece1fc5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af502be785bdb221c2dc1a47fece1fc5f">&#9670;&nbsp;</a></span>colr_str_lstrip_chars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_lstrip_chars </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>chars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes certain characters from the start of a string (<code>char*</code>) and allocates a new string with the result. </p>
<p>The order of the characters in <code>chars</code> does not matter. If any of them are found at the start of a string, they will be removed.</p>
<p><code>colr_str_lstrip_chars("aabbccTEST", "bca") == "TEST"</code></p>
<p><code>s</code> and <code>chars</code> must not overlap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to strip. <code>s</code> <em>Must be <code>null</code>-terminated</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">chars</td><td>A string of characters to remove. Each will be removed from the start of the string. <code>chars</code> <em>Must be <code>null</code>-terminated</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result. May return NULL if <code>s</code> or <code>chars</code> is NULL.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>

</div>
</div>
<a id="ab473f70278850994e1b7b9c8008353fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab473f70278850994e1b7b9c8008353fa">&#9670;&nbsp;</a></span>colr_str_mb_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t colr_str_mb_len </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of characters in a string (<code>char*</code>), taking into account possibly multibyte characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to get the length of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters, single and multibyte, or <code>0</code> if <code>s</code> is <code>NULL</code>, empty, or has invalid multibyte sequences.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#ade675256d9e88682d4bebdcc4a57f86f" title="Like mbrlen, except it will return the length of the next N (length) multibyte characters in bytes...">colr_mb_len</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_mb_len-example" id="colr_str_mb_len-example" class="diamond-bullet">&#160;</a> colr_str_mb_len example: </div><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="colr_8h.html">colr.h</a>&quot;</span></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div><div class="line">    <span class="keywordtype">char</span>* s = <span class="stringliteral">&quot;&quot;</span>;</div><div class="line">    <span class="comment">// There are 4 multibyte characters in the string.</span></div><div class="line">    assert(<a class="code" href="colr_8c.html#ab473f70278850994e1b7b9c8008353fa">colr_str_mb_len</a>(s) == 4);</div><div class="line">    <span class="comment">// There are multiple bytes making up each characters, probably 3 each,</span></div><div class="line">    <span class="comment">// which makes the byte-length 12.</span></div><div class="line">    assert(strlen(s) &gt; 4);</div><div class="line">}</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#ab88ca919420f2df896b7973401641ab4">_rainbow()</a>.</p>

</div>
</div>
<a id="a037a0245a39d7ff5cfba5f779d0eb251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037a0245a39d7ff5cfba5f779d0eb251">&#9670;&nbsp;</a></span>colr_str_noncode_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t colr_str_noncode_len </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length of string (<code>char*</code>), ignoring escape codes and the the null-terminator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">String to get the length for.</p>
<p class="endtd">Input <em>must be <code>null</code>-terminated</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the string, as if it didn't contain escape codes. For non-escape-code strings, this is like <code>strlen()</code>. For <code>NULL</code> or "empty" strings, <code>0</code> is returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#ab0b13b04dc178d0990ab2ae403ee64e0" title="Strips escape codes from a string (char*), resulting in a new allocated string. ">colr_str_strip_codes</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a412833a097b050c8ee99874c733bd030">ColorText_length()</a>, <a class="el" href="colr_8h.html#a1a8345393e635e1c5e148473bdce292d">colr_str_center()</a>, <a class="el" href="colr_8h.html#a5eedebae47b5d22dda709f833f23a256">colr_str_ljust()</a>, and <a class="el" href="colr_8h.html#acc75e3bf729168f9ac204ef0a1708d46">colr_str_rjust()</a>.</p>

</div>
</div>
<a id="a2144034980aea6427fbc9bdf70e5b8c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2144034980aea6427fbc9bdf70e5b8c3">&#9670;&nbsp;</a></span>colr_str_replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the first substring found in a string (<code>char*</code>). </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string (""), which removes the <code>target</code> string from <code>s</code>.</p>
<p>For a more dynamic version, see the colr_replace and colr_replace_re macros.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>The string to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The string to replace with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, or <code>target</code> is <code>NULL</code>/empty.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_replace-example" id="colr_str_replace-example" class="diamond-bullet">&#160;</a> colr_str_replace example: </div><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="colr_8h.html">colr.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div><div class="line">    <span class="keywordtype">char</span>* mystring = <span class="stringliteral">&quot;This is a foo foo foo line.&quot;</span>;</div><div class="line">    <span class="keywordtype">char</span>* replaced = <a class="code" href="colr_8c.html#a420403f3115f43c5e6356deee5644e84">colr_str_replace_cnt</a>(mystring, <span class="stringliteral">&quot;foo&quot;</span>, <span class="stringliteral">&quot;replaced&quot;</span>, 2);</div><div class="line">    <span class="keywordflow">if</span> (!replaced) {</div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;Failed to allocate for new string!\n&quot;</span>);</div><div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line">    printf(<span class="stringliteral">&quot;%s\n&quot;</span>, replaced);</div><div class="line">    <span class="comment">// Don&#39;t forget to free the new string.</span></div><div class="line">    free(replaced);</div><div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#aa8b61a4cadcf73e21eee109623695bad">colr_str_replace_ColorArg()</a>, <a class="el" href="colr_8h.html#a136d15edf2f804c89cee619bb811ef3a">colr_str_replace_ColorResult()</a>, and <a class="el" href="colr_8h.html#aaee8d79a90917974ee4537705e34fd76">colr_str_replace_ColorText()</a>.</p>

</div>
</div>
<a id="abb81a3339840e1f527463eaddf994d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb81a3339840e1f527463eaddf994d8e">&#9670;&nbsp;</a></span>colr_str_replace_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_all </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the first substring found in a string (<code>char*</code>). </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string (""), which removes the <code>target</code> string from <code>s</code>.</p>
<p>For a more dynamic version, see the colr_replace and colr_replace_re macros.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>The string to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The string to replace with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, or <code>target</code> is <code>NULL</code>/empty.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_replace_all-example" id="colr_str_replace_all-example" class="diamond-bullet">&#160;</a> colr_str_replace_all example: </div><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="colr_8h.html">colr.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div><div class="line">    <span class="keywordtype">char</span>* mystring = <span class="stringliteral">&quot;This is a foo foo foo line.&quot;</span>;</div><div class="line">    <span class="keywordtype">char</span>* replaced = <a class="code" href="colr_8c.html#abb81a3339840e1f527463eaddf994d8e">colr_str_replace_all</a>(mystring, <span class="stringliteral">&quot;foo&quot;</span>, <span class="stringliteral">&quot;replaced&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (!replaced) {</div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;Failed to allocate for new string!\n&quot;</span>);</div><div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line">    printf(<span class="stringliteral">&quot;%s\n&quot;</span>, replaced);</div><div class="line">    <span class="comment">// Don&#39;t forget to free the new string.</span></div><div class="line">    free(replaced);</div><div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#af7c01a492bcbda6cf93705bff0cb0dbe">colr_str_replace_all_ColorArg()</a>, <a class="el" href="colr_8h.html#a53fa120c1074c836f65b4aace67d0c83">colr_str_replace_all_ColorResult()</a>, and <a class="el" href="colr_8h.html#a73789c11eaeb5a36b5f97556103a108d">colr_str_replace_all_ColorText()</a>.</p>

</div>
</div>
<a id="af7c01a492bcbda6cf93705bff0cb0dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c01a492bcbda6cf93705bff0cb0dbe">&#9670;&nbsp;</a></span>colr_str_replace_all_ColorArg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_all_ColorArg </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all substrings in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>The string to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to produce escape-codes to replace with. <a class="el" href="colr_8c.html#aa1163a9c866767fb7fcb734d3c0d9b7c" title="Free allocated memory for a ColorArg. ">ColorArg_free()</a> is called after the replacement is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, or <code>target</code> is <code>NULL</code>/empty.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="a53fa120c1074c836f65b4aace67d0c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53fa120c1074c836f65b4aace67d0c83">&#9670;&nbsp;</a></span>colr_str_replace_all_ColorResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_all_ColorResult </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all substrings in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>The string to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> to produce escape-codes to replace with. <a class="el" href="colr_8c.html#a27b70c6de9b2351424100bd742b1f1a8" title="Free allocated memory for a ColorResult and it&#39;s .result member. ">ColorResult_free()</a> is called after the replacement is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, or <code>target</code> is <code>NULL</code>/empty.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="a73789c11eaeb5a36b5f97556103a108d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73789c11eaeb5a36b5f97556103a108d">&#9670;&nbsp;</a></span>colr_str_replace_all_ColorText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_all_ColorText </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all substrings in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>The string to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to produce text/escape-codes to replace with. <a class="el" href="colr_8c.html#a901e5738358a739629cc3aaccab3e73f" title="Frees a ColorText and it&#39;s ColorArgs. ">ColorText_free()</a> is called after the replacement is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, or <code>target</code> is <code>NULL</code>/empty.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="a420403f3115f43c5e6356deee5644e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a420403f3115f43c5e6356deee5644e84">&#9670;&nbsp;</a></span>colr_str_replace_cnt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_cnt </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces one or more substrings in a string (<code>char*</code>). </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string (""), which removes the <code>target</code> string from <code>s</code>.</p>
<p>For a more dynamic version, see the colr_replace and colr_replace_re macros.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>The string to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The string to replace with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of substrings to replace, or <code>0</code> to replace all substrings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, or <code>target</code> is <code>NULL</code>/empty.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_replace_cnt-example" id="colr_str_replace_cnt-example" class="diamond-bullet">&#160;</a> colr_str_replace_cnt example: </div><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="colr_8h.html">colr.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div><div class="line">    <span class="keywordtype">char</span>* mystring = <span class="stringliteral">&quot;This is a foo foo foo line.&quot;</span>;</div><div class="line">    <span class="keywordtype">char</span>* replaced = <a class="code" href="colr_8c.html#a420403f3115f43c5e6356deee5644e84">colr_str_replace_cnt</a>(mystring, <span class="stringliteral">&quot;foo&quot;</span>, <span class="stringliteral">&quot;replaced&quot;</span>, 2);</div><div class="line">    <span class="keywordflow">if</span> (!replaced) {</div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;Failed to allocate for new string!\n&quot;</span>);</div><div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line">    printf(<span class="stringliteral">&quot;%s\n&quot;</span>, replaced);</div><div class="line">    <span class="comment">// Don&#39;t forget to free the new string.</span></div><div class="line">    free(replaced);</div><div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a2144034980aea6427fbc9bdf70e5b8c3">colr_str_replace()</a>, and <a class="el" href="colr_8h.html#abb81a3339840e1f527463eaddf994d8e">colr_str_replace_all()</a>.</p>

</div>
</div>
<a id="aa8b61a4cadcf73e21eee109623695bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b61a4cadcf73e21eee109623695bad">&#9670;&nbsp;</a></span>colr_str_replace_ColorArg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_ColorArg </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a substring in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>The string to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to produce escape-codes to replace with. <a class="el" href="colr_8c.html#aa1163a9c866767fb7fcb734d3c0d9b7c" title="Free allocated memory for a ColorArg. ">ColorArg_free()</a> is called after the replacement is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, or <code>target</code> is <code>NULL</code>/empty.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="a136d15edf2f804c89cee619bb811ef3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a136d15edf2f804c89cee619bb811ef3a">&#9670;&nbsp;</a></span>colr_str_replace_ColorResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_ColorResult </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a substring in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>The string to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> to produce escape-codes to replace with. <a class="el" href="colr_8c.html#a27b70c6de9b2351424100bd742b1f1a8" title="Free allocated memory for a ColorResult and it&#39;s .result member. ">ColorResult_free()</a> is called after the replacement is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, or <code>target</code> is <code>NULL</code>/empty.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="aaee8d79a90917974ee4537705e34fd76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee8d79a90917974ee4537705e34fd76">&#9670;&nbsp;</a></span>colr_str_replace_ColorText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_ColorText </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a substring in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>The string to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to produce text/escape-codes to replace with. <a class="el" href="colr_8c.html#a901e5738358a739629cc3aaccab3e73f" title="Frees a ColorText and it&#39;s ColorArgs. ">ColorText_free()</a> is called after the replacement is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, or <code>target</code> is <code>NULL</code>/empty.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="a09db8190822ff7e7e712399680325e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09db8190822ff7e7e712399680325e6a">&#9670;&nbsp;</a></span>colr_str_replace_re()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>re_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces a substring from a regex pattern string (<code>char*</code>) in a string (<code>char*</code>). </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string (""), which removes the <code>target</code> string from <code>s</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>The regex match object to find text to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The string to replace with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">re_flags</td><td>Flags for <code>regcomp()</code>. <code>REG_EXTENDED</code> is always used, whether flags are provided or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>pattern</code> is <code>NULL</code>, or the regex pattern</p>
<p>doesn't compile/match.</p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_replace_re-example" id="colr_str_replace_re-example" class="diamond-bullet">&#160;</a> colr_str_replace_re example: </div><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="colr_8h.html">colr.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div><div class="line">    <span class="keywordtype">char</span>* mystring = <span class="stringliteral">&quot;This is a foo line.&quot;</span>;</div><div class="line">    <span class="keywordtype">char</span>* replaced = <a class="code" href="colr_8c.html#a09db8190822ff7e7e712399680325e6a">colr_str_replace_re</a>(mystring, <span class="stringliteral">&quot;foo&quot;</span>, <span class="stringliteral">&quot;replaced&quot;</span>, 0);</div><div class="line">    <span class="keywordflow">if</span> (!replaced) <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    puts(replaced);</div><div class="line">    free(replaced);</div><div class="line">    replaced = <a class="code" href="colr_8c.html#a09db8190822ff7e7e712399680325e6a">colr_str_replace_re</a>(mystring, <span class="stringliteral">&quot;^([^ ]+)&quot;</span>, <span class="stringliteral">&quot;That&quot;</span>, 0);</div><div class="line">    <span class="keywordflow">if</span> (!replaced) <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    puts(replaced);</div><div class="line">    free(replaced);</div><div class="line">}</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a78d58bde53845d6ab2c54e4ba0c68a3d">colr_str_replace_re_ColorArg()</a>, <a class="el" href="colr_8h.html#a0376bed13e55acaca37e52c382044e1d">colr_str_replace_re_ColorResult()</a>, and <a class="el" href="colr_8h.html#ab8d6a10f70b435559656bbad0090d92d">colr_str_replace_re_ColorText()</a>.</p>

</div>
</div>
<a id="a232c65d12eb09d598eeb64490f39371c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a232c65d12eb09d598eeb64490f39371c">&#9670;&nbsp;</a></span>colr_str_replace_re_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_all </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>re_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all substrings from a regex pattern string (<code>char*</code>) in a string (<code>char*</code>). </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string (""), which removes the <code>target</code> string from <code>s</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>The regex match object to find text to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The string to replace with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">re_flags</td><td>Flags for <code>regcomp()</code>. <code>REG_EXTENDED</code> is always used, whether flags are provided or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>pattern</code> is <code>NULL</code>, or the regex pattern</p>
<p>doesn't compile/match.</p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_replace_re_all-example" id="colr_str_replace_re_all-example" class="diamond-bullet">&#160;</a> colr_str_replace_re_all example: </div><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="colr_8h.html">colr.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div><div class="line">    <span class="keywordtype">char</span>* mystring = <span class="stringliteral">&quot;This is a foo bar line.&quot;</span>;</div><div class="line">    <span class="keywordtype">char</span>* replaced = <a class="code" href="colr_8c.html#a232c65d12eb09d598eeb64490f39371c">colr_str_replace_re_all</a>(mystring, <span class="stringliteral">&quot;(foo)|(bar)&quot;</span>, <span class="stringliteral">&quot;replaced&quot;</span>, 0);</div><div class="line">    <span class="keywordflow">if</span> (!replaced) <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    puts(replaced);</div><div class="line">    free(replaced);</div><div class="line">    replaced = <a class="code" href="colr_8c.html#a232c65d12eb09d598eeb64490f39371c">colr_str_replace_re_all</a>(mystring, <span class="stringliteral">&quot;^([^ ]+)&quot;</span>, <span class="stringliteral">&quot;That&quot;</span>, 0);</div><div class="line">    <span class="keywordflow">if</span> (!replaced) <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    puts(replaced);</div><div class="line">    free(replaced);</div><div class="line">}</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a577e45a5c233dd1b4774a9034b17e3eb">colr_str_replace_re_all_ColorArg()</a>, <a class="el" href="colr_8h.html#a3e18a36736e5451529e80443cfb7b1fc">colr_str_replace_re_all_ColorResult()</a>, and <a class="el" href="colr_8h.html#a747e31fa3d8961e0bdd11eabd673accc">colr_str_replace_re_all_ColorText()</a>.</p>

</div>
</div>
<a id="a577e45a5c233dd1b4774a9034b17e3eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a577e45a5c233dd1b4774a9034b17e3eb">&#9670;&nbsp;</a></span>colr_str_replace_re_all_ColorArg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_all_ColorArg </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *&#160;</td>
          <td class="paramname"><em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>re_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all substrings from a regex pattern string (<code>char*</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>The regex pattern to compile. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to produce escape-codes to replace with. <a class="el" href="colr_8c.html#aa1163a9c866767fb7fcb734d3c0d9b7c" title="Free allocated memory for a ColorArg. ">ColorArg_free()</a> is called after the replacement is done. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">re_flags</td><td>Flags for <code>regcomp()</code>. <code>REG_EXTENDED</code> is always used, whether flags are provided or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>pattern</code> is <code>NULL</code>, or the regex pattern doesn't compile/match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="a3e18a36736e5451529e80443cfb7b1fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e18a36736e5451529e80443cfb7b1fc">&#9670;&nbsp;</a></span>colr_str_replace_re_all_ColorResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_all_ColorResult </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *&#160;</td>
          <td class="paramname"><em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>re_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all substrings from a regex pattern string (<code>char*</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>The regex match object to find text to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> to produce escape-codes to replace with. <a class="el" href="colr_8c.html#a27b70c6de9b2351424100bd742b1f1a8" title="Free allocated memory for a ColorResult and it&#39;s .result member. ">ColorResult_free()</a> is called after the replacement is done. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">re_flags</td><td>Flags for <code>regcomp()</code>. <code>REG_EXTENDED</code> is always used, whether flags are provided or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>pattern</code> is <code>NULL</code>, or the regex pattern doesn't compile/match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="a747e31fa3d8961e0bdd11eabd673accc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a747e31fa3d8961e0bdd11eabd673accc">&#9670;&nbsp;</a></span>colr_str_replace_re_all_ColorText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_all_ColorText </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td>
          <td class="paramname"><em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>re_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all substrings from a regex pattern string (<code>char*</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>The regex match object to find text to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to produce text/escape-codes to replace with. <a class="el" href="colr_8c.html#a901e5738358a739629cc3aaccab3e73f" title="Frees a ColorText and it&#39;s ColorArgs. ">ColorText_free()</a> is called after the replacement is done. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">re_flags</td><td>Flags for <code>regcomp()</code>. <code>REG_EXTENDED</code> is always used, whether flags are provided or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>pattern</code> is <code>NULL</code>, or the regex pattern doesn't compile/match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="a78d58bde53845d6ab2c54e4ba0c68a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78d58bde53845d6ab2c54e4ba0c68a3d">&#9670;&nbsp;</a></span>colr_str_replace_re_ColorArg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_ColorArg </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *&#160;</td>
          <td class="paramname"><em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>re_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace substrings from a regex pattern string (<code>char*</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>The regex pattern to compile. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to produce escape-codes to replace with. <a class="el" href="colr_8c.html#aa1163a9c866767fb7fcb734d3c0d9b7c" title="Free allocated memory for a ColorArg. ">ColorArg_free()</a> is called after the replacement is done. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">re_flags</td><td>Flags for <code>regcomp()</code>. <code>REG_EXTENDED</code> is always used, whether flags are provided or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>pattern</code> is <code>NULL</code>, or the regex pattern doesn't compile/match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="a0376bed13e55acaca37e52c382044e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0376bed13e55acaca37e52c382044e1d">&#9670;&nbsp;</a></span>colr_str_replace_re_ColorResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_ColorResult </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *&#160;</td>
          <td class="paramname"><em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>re_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace substrings from a regex pattern string (<code>char*</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>The regex match object to find text to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> to produce escape-codes to replace with. <a class="el" href="colr_8c.html#a27b70c6de9b2351424100bd742b1f1a8" title="Free allocated memory for a ColorResult and it&#39;s .result member. ">ColorResult_free()</a> is called after the replacement is done. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">re_flags</td><td>Flags for <code>regcomp()</code>. <code>REG_EXTENDED</code> is always used, whether flags are provided or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>pattern</code> is <code>NULL</code>, or the regex pattern doesn't compile/match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="ab8d6a10f70b435559656bbad0090d92d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d6a10f70b435559656bbad0090d92d">&#9670;&nbsp;</a></span>colr_str_replace_re_ColorText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_ColorText </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td>
          <td class="paramname"><em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>re_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace substrings from a regex pattern string (<code>char*</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>The regex match object to find text to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to produce text/escape-codes to replace with. <a class="el" href="colr_8c.html#a901e5738358a739629cc3aaccab3e73f" title="Frees a ColorText and it&#39;s ColorArgs. ">ColorText_free()</a> is called after the replacement is done. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">re_flags</td><td>Flags for <code>regcomp()</code>. <code>REG_EXTENDED</code> is always used, whether flags are provided or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>pattern</code> is <code>NULL</code>, or the regex pattern doesn't compile/match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="a2fbc36f0f7aba3aa0616437f937efd20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fbc36f0f7aba3aa0616437f937efd20">&#9670;&nbsp;</a></span>colr_str_replace_re_match()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_match </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">regmatch_t *&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces substrings from a single regex match (<code>regmatch_t*</code>) in a string (<code>char*</code>). </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string (""), which removes the <code>target</code> string from <code>s</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">match</td><td>The regex match object to find text to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The string to replace with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>match</code> is <code>NULL</code>, or the regex pattern doesn't match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_replace_re_match-example" id="colr_str_replace_re_match-example" class="diamond-bullet">&#160;</a> colr_str_replace_re_match example: </div><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="colr_8h.html">colr.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div><div class="line">    <span class="comment">// Build a regex pattern.</span></div><div class="line">    regex_t pat;</div><div class="line">    <span class="keywordflow">if</span> (regcomp(&amp;pat, <span class="stringliteral">&quot;foo&quot;</span>, 0)) {</div><div class="line">        <span class="comment">// Failed to compile the pattern.</span></div><div class="line">        regfree(&amp;pat);</div><div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Set up our matches (only 1 can be used with colr_replace_re_match).</span></div><div class="line">    <span class="keywordtype">size_t</span> matchcnt = 1;</div><div class="line">    regmatch_t rematches[matchcnt];</div><div class="line"></div><div class="line">    <span class="comment">// Run the regex and we should get an initialized `regmatch_t`.</span></div><div class="line">    <span class="keywordtype">char</span>* mystring = <span class="stringliteral">&quot;This is a foo line.&quot;</span>;</div><div class="line">    <span class="keywordflow">if</span> (regexec(&amp;pat, mystring, matchcnt, rematches, 0)) {</div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;No matches!?&quot;</span>);</div><div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Replace the matched text with our string.</span></div><div class="line">    <span class="keywordtype">char</span>* replaced = <a class="code" href="colr_8c.html#a2fbc36f0f7aba3aa0616437f937efd20">colr_str_replace_re_match</a>(</div><div class="line">        mystring,</div><div class="line">        rematches,</div><div class="line">        <span class="stringliteral">&quot;REPLACED&quot;</span></div><div class="line">    );</div><div class="line">    <span class="comment">// Don&#39;t forget to free your regex object (even if stack-allocated).</span></div><div class="line">    regfree(&amp;pat);</div><div class="line">    <span class="keywordflow">if</span> (!replaced) {</div><div class="line">            fprintf(stderr, <span class="stringliteral">&quot;Cannot allocate for replaced string!\n&quot;</span>);</div><div class="line">            <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line">    printf(<span class="stringliteral">&quot;%s\n&quot;</span>, replaced);</div><div class="line">    free(replaced);</div><div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a0d4cbd6a8fd3cef76f07b705b09d2a54">colr_str_replace_re_match_ColorArg()</a>, <a class="el" href="colr_8h.html#ac092f944961dddc6574a6c55e6e878b0">colr_str_replace_re_match_ColorResult()</a>, <a class="el" href="colr_8h.html#a4d954398333472c1436f9bc051f46392">colr_str_replace_re_match_ColorText()</a>, and <a class="el" href="colr_8h.html#a63621c6749d8219112ff51ebf0ecb22a">colr_str_replace_re_pat()</a>.</p>

</div>
</div>
<a id="a0d4cbd6a8fd3cef76f07b705b09d2a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d4cbd6a8fd3cef76f07b705b09d2a54">&#9670;&nbsp;</a></span>colr_str_replace_re_match_ColorArg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_match_ColorArg </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">regmatch_t *&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace substrings from a regex match (<code>regmatch_t*</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">match</td><td>The regex match object to find text to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to produce escape-codes to replace with. <a class="el" href="colr_8c.html#aa1163a9c866767fb7fcb734d3c0d9b7c" title="Free allocated memory for a ColorArg. ">ColorArg_free()</a> is called after the replacement is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>match</code> is <code>NULL</code>, or the regex pattern doesn't match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="ac092f944961dddc6574a6c55e6e878b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac092f944961dddc6574a6c55e6e878b0">&#9670;&nbsp;</a></span>colr_str_replace_re_match_ColorResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_match_ColorResult </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">regmatch_t *&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace substrings from a regex match (<code>regmatch_t*</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">match</td><td>The regex match object to find text to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> to produce escape-codes to replace with. <a class="el" href="colr_8c.html#a27b70c6de9b2351424100bd742b1f1a8" title="Free allocated memory for a ColorResult and it&#39;s .result member. ">ColorResult_free()</a> is called after the replacement is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>match</code> is <code>NULL</code>, or the regex pattern doesn't match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="a4d954398333472c1436f9bc051f46392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d954398333472c1436f9bc051f46392">&#9670;&nbsp;</a></span>colr_str_replace_re_match_ColorText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_match_ColorText </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">regmatch_t *&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace substrings from a regex match (<code>regmatch_t*</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">match</td><td>The regex match object to find text to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to produce text/escape-codes to replace with. <a class="el" href="colr_8c.html#a901e5738358a739629cc3aaccab3e73f" title="Frees a ColorText and it&#39;s ColorArgs. ">ColorText_free()</a> is called after the replacement is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>match</code> is <code>NULL</code>, or the regex pattern doesn't match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="a205182bbcbf99a3faa1b207a28721c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a205182bbcbf99a3faa1b207a28721c87">&#9670;&nbsp;</a></span>colr_str_replace_re_match_i()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_match_i </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">regmatch_t *&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces substrings from a regex match (<code>regmatch_t*</code>) in a string (<code>char*</code>). </p>
<p>This modifies <code>target</code> in place. It must have capacity for the result.</p>
<p>Using <code>NULL</code> as a replacement is like using an empty string (""), which removes the <code>target</code> string from <code>s</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ref</td><td>The string to use for offset references. Can be <code>target</code>. Set this to the source string if <code>target</code> has not been filled yet. If <code>target</code> has been filled, you may use <code>target</code> for both <code>ref</code> and <code>target</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">target</td><td>The string to modify. Must have room for the resulting string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">match</td><td>The regex match object to find text to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The string to replace with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>match</code> is <code>NULL</code>, or the regex pattern doesn't match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_replace_re_match_i-example" id="colr_str_replace_re_match_i-example" class="diamond-bullet">&#160;</a> colr_str_replace_re_match_i example: </div><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="colr_8h.html">colr.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div><div class="line">    <span class="comment">// Build a regex pattern.</span></div><div class="line">    regex_t pat;</div><div class="line">    <span class="keywordflow">if</span> (regcomp(&amp;pat, <span class="stringliteral">&quot;foo&quot;</span>, 0)) {</div><div class="line">        <span class="comment">// Failed to compile the pattern.</span></div><div class="line">        regfree(&amp;pat);</div><div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Set up our matches (only 1 can be used with colr_replace_re_match_i).</span></div><div class="line">    <span class="keywordtype">size_t</span> matchcnt = 1;</div><div class="line">    regmatch_t rematches[matchcnt];</div><div class="line"></div><div class="line">    <span class="comment">// Run the regex and we should get an initialized `regmatch_t`.</span></div><div class="line">    <span class="keywordtype">char</span>* mystring = <span class="stringliteral">&quot;This is a foo line.&quot;</span>;</div><div class="line">    <span class="keywordtype">char</span>* replacement = <span class="stringliteral">&quot;REPLACED&quot;</span>;</div><div class="line">    <span class="keywordtype">size_t</span> length = strlen(mystring);</div><div class="line">    <span class="keywordtype">char</span>* targetstring = calloc(length + strlen(replacement) + 1, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));</div><div class="line">    strncpy(targetstring, mystring, length + 1);</div><div class="line">    <span class="keywordflow">if</span> (regexec(&amp;pat, mystring, matchcnt, rematches, 0)) {</div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;No matches!?&quot;</span>);</div><div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line">    <span class="comment">// Don&#39;t forget to free your regex object (even if stack-allocated).</span></div><div class="line">    regfree(&amp;pat);</div><div class="line"></div><div class="line">    <span class="comment">// Replace the matched text with our string.</span></div><div class="line">    <span class="keywordtype">char</span>* replaced = <a class="code" href="colr_8c.html#a205182bbcbf99a3faa1b207a28721c87">colr_str_replace_re_match_i</a>(</div><div class="line">        mystring,</div><div class="line">        targetstring,</div><div class="line">        rematches,</div><div class="line">        replacement</div><div class="line">    );</div><div class="line">    <span class="keywordflow">if</span> (!replaced) {</div><div class="line">            fprintf(stderr, <span class="stringliteral">&quot;An error occurred!\n&quot;</span>);</div><div class="line">            <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line">    printf(<span class="stringliteral">&quot;%s\n&quot;</span>, replaced);</div><div class="line">    free(targetstring);</div><div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a8c72d363d7f87e2a7546202b439557e1">colr_str_replace_re_matches()</a>.</p>

</div>
</div>
<a id="a8c72d363d7f87e2a7546202b439557e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c72d363d7f87e2a7546202b439557e1">&#9670;&nbsp;</a></span>colr_str_replace_re_matches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_matches </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">regmatch_t **&#160;</td>
          <td class="paramname"><em>matches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces substrings from an array of regex match (<code>regmatch_t*</code>) in a string (<code>char*</code>). </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string (""), which removes the <code>target</code> string from <code>s</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matches</td><td>Regex match objects to find text to replace. The array must have <code>NULL</code> as the last member. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The string to replace with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>match</code> is <code>NULL</code>, or the regex pattern doesn't match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a75b2cdee697818e2f9f38ec7eac98bcb">colr_str_replace_re_matches_ColorArg()</a>, <a class="el" href="colr_8h.html#a4d4bb71015338108d86fcf47317cc5ff">colr_str_replace_re_matches_ColorResult()</a>, <a class="el" href="colr_8h.html#aa4fe38cc205cbd49b2f8477744574294">colr_str_replace_re_matches_ColorText()</a>, and <a class="el" href="colr_8h.html#afd19623913d27e2d9a5af3496a478c2b">colr_str_replace_re_pat_all()</a>.</p>

</div>
</div>
<a id="a75b2cdee697818e2f9f38ec7eac98bcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b2cdee697818e2f9f38ec7eac98bcb">&#9670;&nbsp;</a></span>colr_str_replace_re_matches_ColorArg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_matches_ColorArg </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">regmatch_t **&#160;</td>
          <td class="paramname"><em>matches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace substrings from an array of regex matches (<code>regmatch_t**</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matches</td><td>The regex match objects to find text to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to produce escape-codes to replace with. <a class="el" href="colr_8c.html#aa1163a9c866767fb7fcb734d3c0d9b7c" title="Free allocated memory for a ColorArg. ">ColorArg_free()</a> is called after the replacement is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>match</code> is <code>NULL</code>, or the regex pattern doesn't match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="a4d4bb71015338108d86fcf47317cc5ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d4bb71015338108d86fcf47317cc5ff">&#9670;&nbsp;</a></span>colr_str_replace_re_matches_ColorResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_matches_ColorResult </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">regmatch_t **&#160;</td>
          <td class="paramname"><em>matches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace substrings from an array of regex matches (<code>regmatch_t**</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matches</td><td>The regex match objects to find text to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> to produce escape-codes to replace with. <a class="el" href="colr_8c.html#a27b70c6de9b2351424100bd742b1f1a8" title="Free allocated memory for a ColorResult and it&#39;s .result member. ">ColorResult_free()</a> is called after the replacement is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>match</code> is <code>NULL</code>, or the regex pattern doesn't match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="aa4fe38cc205cbd49b2f8477744574294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4fe38cc205cbd49b2f8477744574294">&#9670;&nbsp;</a></span>colr_str_replace_re_matches_ColorText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_matches_ColorText </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">regmatch_t **&#160;</td>
          <td class="paramname"><em>matches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace substrings from an array of regex matches (<code>regmatch_t**</code>) in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matches</td><td>The regex match objects to find text to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to produce text/escape-codes to replace with. <a class="el" href="colr_8c.html#a901e5738358a739629cc3aaccab3e73f" title="Frees a ColorText and it&#39;s ColorArgs. ">ColorText_free()</a> is called after the replacement is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>match</code> is <code>NULL</code>, or the regex pattern doesn't match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="a63621c6749d8219112ff51ebf0ecb22a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63621c6749d8219112ff51ebf0ecb22a">&#9670;&nbsp;</a></span>colr_str_replace_re_pat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_pat </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">regex_t *&#160;</td>
          <td class="paramname"><em>repattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces regex patterns in a string (<code>char*</code>). </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string (""), which removes the <code>target</code> string from <code>s</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repattern</td><td>The regex pattern to match (<code>regex_t*</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The string to replace with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>repattern</code> is <code>NULL</code>, or the regex pattern doesn't match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_replace_re_pat-example" id="colr_str_replace_re_pat-example" class="diamond-bullet">&#160;</a> colr_str_replace_re_pat example: </div><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="colr_8h.html">colr.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div><div class="line">    <span class="comment">// Compile a regex pattern.</span></div><div class="line">    regex_t pat;</div><div class="line">    <span class="keywordflow">if</span> (regcomp(&amp;pat, <span class="stringliteral">&quot;foo&quot;</span>, 0)) {</div><div class="line">        <span class="comment">// Failed to compile the pattern.</span></div><div class="line">        regfree(&amp;pat);</div><div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line">    <span class="keywordtype">char</span>* mystring = <span class="stringliteral">&quot;This is a foo line.&quot;</span>;</div><div class="line">    <span class="keywordtype">char</span>* replaced = <a class="code" href="colr_8c.html#a63621c6749d8219112ff51ebf0ecb22a">colr_str_replace_re_pat</a>(mystring, &amp;pat, <span class="stringliteral">&quot;replaced&quot;</span>);</div><div class="line">    <span class="comment">// Don&#39;t forget to free your regex pattern.</span></div><div class="line">    regfree(&amp;pat);</div><div class="line">    <span class="keywordflow">if</span> (!replaced) <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    puts(replaced);</div><div class="line">    free(replaced);</div><div class="line">}</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a09db8190822ff7e7e712399680325e6a">colr_str_replace_re()</a>, <a class="el" href="colr_8h.html#adecbe2f1e87613b6f4a51158325dd4f7">colr_str_replace_re_pat_ColorArg()</a>, <a class="el" href="colr_8h.html#abcd756c82acab9505343b614d52c0b19">colr_str_replace_re_pat_ColorResult()</a>, and <a class="el" href="colr_8h.html#a6f8b04b6d851f26304183d1111b8f0dc">colr_str_replace_re_pat_ColorText()</a>.</p>

</div>
</div>
<a id="afd19623913d27e2d9a5af3496a478c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd19623913d27e2d9a5af3496a478c2b">&#9670;&nbsp;</a></span>colr_str_replace_re_pat_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_pat_all </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">regex_t *&#160;</td>
          <td class="paramname"><em>repattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all matches to a regex pattern in a string (<code>char*</code>). </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string (""), which removes the <code>target</code> string from <code>s</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repattern</td><td>The regex pattern to match (<code>regex_t*</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The string to replace with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>repattern</code> is <code>NULL</code>, or the regex pattern doesn't match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_replace_re_pat_all-example" id="colr_str_replace_re_pat_all-example" class="diamond-bullet">&#160;</a> colr_str_replace_re_pat_all example: </div><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="colr_8h.html">colr.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div><div class="line">    <span class="comment">// Compile a regex pattern.</span></div><div class="line">    regex_t pat;</div><div class="line">    <span class="keywordflow">if</span> (regcomp(&amp;pat, <span class="stringliteral">&quot;[1-9]&quot;</span>, REG_EXTENDED)) {</div><div class="line">        <span class="comment">// Failed to compile the pattern.</span></div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;Cannot compile the pattern!\n&quot;</span>);</div><div class="line">        regfree(&amp;pat);</div><div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line">    <span class="keywordtype">char</span>* mystring = <span class="stringliteral">&quot;1 2 everywhere, but still no 3 to spare.&quot;</span>;</div><div class="line">    <span class="keywordtype">char</span>* replaced = <a class="code" href="colr_8c.html#afd19623913d27e2d9a5af3496a478c2b">colr_str_replace_re_pat_all</a>(mystring, &amp;pat, <span class="stringliteral">&quot;numbers&quot;</span>);</div><div class="line">    <span class="comment">// Don&#39;t forget to free your regex pattern.</span></div><div class="line">    regfree(&amp;pat);</div><div class="line">    <span class="keywordflow">if</span> (!replaced) <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    puts(replaced);</div><div class="line">    free(replaced);</div><div class="line">}</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a232c65d12eb09d598eeb64490f39371c">colr_str_replace_re_all()</a>, <a class="el" href="colr_8h.html#a090ba95c4560134ef9c2807eff6a0ea1">colr_str_replace_re_pat_all_ColorArg()</a>, <a class="el" href="colr_8h.html#af083c2e1867ecaad0ae38a1324c915ac">colr_str_replace_re_pat_all_ColorResult()</a>, and <a class="el" href="colr_8h.html#ab9c4a5c34b26473dc45f93ce2c66faf1">colr_str_replace_re_pat_all_ColorText()</a>.</p>

</div>
</div>
<a id="a090ba95c4560134ef9c2807eff6a0ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a090ba95c4560134ef9c2807eff6a0ea1">&#9670;&nbsp;</a></span>colr_str_replace_re_pat_all_ColorArg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_pat_all_ColorArg </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">regex_t *&#160;</td>
          <td class="paramname"><em>repattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all matches to a regex pattern in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repattern</td><td>The regex pattern to match (<code>regex_t*</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to produce escape-codes to replace with. <a class="el" href="colr_8c.html#aa1163a9c866767fb7fcb734d3c0d9b7c" title="Free allocated memory for a ColorArg. ">ColorArg_free()</a> is called after the replacement is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>repattern</code> is <code>NULL</code>, or the regex pattern doesn't match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="af083c2e1867ecaad0ae38a1324c915ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af083c2e1867ecaad0ae38a1324c915ac">&#9670;&nbsp;</a></span>colr_str_replace_re_pat_all_ColorResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_pat_all_ColorResult </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">regex_t *&#160;</td>
          <td class="paramname"><em>repattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all matches to a regex pattern in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repattern</td><td>The regex pattern to match (<code>regex_t*</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> to produce escape-codes to replace with. <a class="el" href="colr_8c.html#a27b70c6de9b2351424100bd742b1f1a8" title="Free allocated memory for a ColorResult and it&#39;s .result member. ">ColorResult_free()</a> is called after the replacement is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>repattern</code> is <code>NULL</code>, or the regex pattern doesn't match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="ab9c4a5c34b26473dc45f93ce2c66faf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9c4a5c34b26473dc45f93ce2c66faf1">&#9670;&nbsp;</a></span>colr_str_replace_re_pat_all_ColorText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_pat_all_ColorText </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">regex_t *&#160;</td>
          <td class="paramname"><em>repattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all matches to a regex pattern in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repattern</td><td>The regex pattern to match (<code>regex_t*</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to produce text/escape-codes to replace with. <a class="el" href="colr_8c.html#a901e5738358a739629cc3aaccab3e73f" title="Frees a ColorText and it&#39;s ColorArgs. ">ColorText_free()</a> is called after the replacement is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>repattern</code> is <code>NULL</code>, or the regex pattern doesn't match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="adecbe2f1e87613b6f4a51158325dd4f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adecbe2f1e87613b6f4a51158325dd4f7">&#9670;&nbsp;</a></span>colr_str_replace_re_pat_ColorArg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_pat_ColorArg </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">regex_t *&#160;</td>
          <td class="paramname"><em>repattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace regex patterns in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repattern</td><td>The regex pattern to match (<code>regex_t*</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to produce escape-codes to replace with. <a class="el" href="colr_8c.html#aa1163a9c866767fb7fcb734d3c0d9b7c" title="Free allocated memory for a ColorArg. ">ColorArg_free()</a> is called after the replacement is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>repattern</code> is <code>NULL</code>, or the regex pattern doesn't match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="abcd756c82acab9505343b614d52c0b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcd756c82acab9505343b614d52c0b19">&#9670;&nbsp;</a></span>colr_str_replace_re_pat_ColorResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_pat_ColorResult </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">regex_t *&#160;</td>
          <td class="paramname"><em>repattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorResult">ColorResult</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace regex patterns in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repattern</td><td>The regex pattern to match (<code>regex_t*</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorResult" title="Holds a string (char*) that was definitely allocated by Colr. ">ColorResult</a> to produce escape-codes to replace with. <a class="el" href="colr_8c.html#a27b70c6de9b2351424100bd742b1f1a8" title="Free allocated memory for a ColorResult and it&#39;s .result member. ">ColorResult_free()</a> is called after the replacement is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>repattern</code> is <code>NULL</code>, or the regex pattern doesn't match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="a6f8b04b6d851f26304183d1111b8f0dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f8b04b6d851f26304183d1111b8f0dc">&#9670;&nbsp;</a></span>colr_str_replace_re_pat_ColorText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_re_pat_ColorText </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">regex_t *&#160;</td>
          <td class="paramname"><em>repattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace regex patterns in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repattern</td><td>The regex pattern to match (<code>regex_t*</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to produce text/escape-codes to replace with. <a class="el" href="colr_8c.html#a901e5738358a739629cc3aaccab3e73f" title="Frees a ColorText and it&#39;s ColorArgs. ">ColorText_free()</a> is called after the replacement is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>repattern</code> is <code>NULL</code>, or the regex pattern doesn't match.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb" title="Replace a substring in s with another string, ColorArg string, ColorResult string, or ColorText string. ">colr_replace</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a2262af7b2b1e9281272c63c85b9e7357" title="Replace a regex pattern string (char*) in s with another string, ColorArg string, ColorResult string...">colr_replace_re</a> </dd></dl>

</div>
</div>
<a id="a196ad91a69cfbeb27a5266ffc93ed353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a196ad91a69cfbeb27a5266ffc93ed353">&#9670;&nbsp;</a></span>colr_str_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_repr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string (<code>char*</code>) into a representation of a string, by wrapping it in quotes and escaping characters that need escaping. </p>
<p>If <code>s</code> is NULL, then an allocated string containing the string "NULL" is returned (without quotes).</p>
<p>Escape codes will be escaped, so the terminal will ignore them if the result is printed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to represent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the representation.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#a67ef4700a46e78c2bed1132428a610fb" title="Determines if an ascii character has an escape sequence in C. ">colr_char_should_escape</a> </dd>
<dd>
<a class="el" href="colr_8c.html#a7f1ea562310969b7efa8711a843f103c" title="Returns the char needed to represent an escape sequence in C. ">colr_char_escape_char</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_repr-example" id="colr_str_repr-example" class="diamond-bullet">&#160;</a> colr_str_repr example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* s = <a class="code" href="colr_8c.html#a196ad91a69cfbeb27a5266ffc93ed353">colr_str_repr</a>(<span class="stringliteral">&quot;This\nhas \bspecial\tchars.&quot;</span>);</div><div class="line"><span class="comment">// The string `s` contains an escaped string, it *looks like* the definition,</span></div><div class="line"><span class="comment">// but no real newlines, backspaces, or tabs are in it.</span></div><div class="line">assert(strcmp(s, <span class="stringliteral">&quot;\&quot;This\\nhas \\bspecial\\tchars.\&quot;&quot;</span>) == 0);</div><div class="line">free(s);</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a30cac3017a6ea8c78277882554c9419f">_colr_ptr_repr()</a>, <a class="el" href="colr_8h.html#aae0b90c57e8c4c475d9e0f517f3a0d42">ColorResult_repr()</a>, and <a class="el" href="colr_8h.html#a65363a3601cd9cfcdc7fc40722d5d3c3">ColorText_repr()</a>.</p>

</div>
</div>
<a id="acc75e3bf729168f9ac204ef0a1708d46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc75e3bf729168f9ac204ef0a1708d46">&#9670;&nbsp;</a></span>colr_str_rjust()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_rjust </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>padchar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Right-justifies a string (<code>char*</code>), ignoring escape codes when measuring the width. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">The string to justify.</p>
<p class="endtd">Input <em>must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The overall width for the resulting string. If set to '0', the terminal width will be used from <a class="el" href="colr_8c.html#ae4c11bb5b3b1bb2848bb16aee39763b2" title="Attempts to retrieve the row/column size of the terminal and returns a TermSize. ">colr_term_size()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">padchar</td><td>The character to pad with. If '0', then `' '` is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#a1a8345393e635e1c5e148473bdce292d" title="Center-justifies a string (char*), ignoring escape codes when measuring the width. ">colr_str_center</a> </dd>
<dd>
<a class="el" href="colr_8c.html#a5eedebae47b5d22dda709f833f23a256" title="Left-justifies a string (char*), ignoring escape codes when measuring the width. ">colr_str_ljust</a> </dd>
<dd>
<a class="el" href="colr_8c.html#ae4c11bb5b3b1bb2848bb16aee39763b2" title="Attempts to retrieve the row/column size of the terminal and returns a TermSize. ">colr_term_size</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_rjust-example" id="colr_str_rjust-example" class="diamond-bullet">&#160;</a> colr_str_rjust example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* colorized = <a class="code" href="colr_8h.html#a753093cd4c872eed4b77feaa7816212b">colr</a>(<span class="stringliteral">&quot;This.&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED), <a class="code" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8">back</a>(WHITE));</div><div class="line"><span class="keywordtype">char</span>* justified = <a class="code" href="colr_8c.html#acc75e3bf729168f9ac204ef0a1708d46">colr_str_rjust</a>(colorized, 8, <span class="charliteral">&#39; &#39;</span>);</div><div class="line">free(colorized);</div><div class="line"><span class="comment">// The string still has codes, but only 3 spaces were added.</span></div><div class="line">assert(<a class="code" href="colr_8c.html#ac23328cead6a65d7b3ef2c2ca48d11ce">colr_str_starts_with</a>(justified, <span class="stringliteral">&quot;   &quot;</span>));</div><div class="line"><span class="comment">// It was &quot;justified&quot; to 8 characters long, but it is well over that.</span></div><div class="line">assert(strlen(justified) &gt; 8);</div><div class="line">printf(<span class="stringliteral">&quot;&#39;%s&#39;\n&quot;</span>, justified);</div><div class="line">free(justified);</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a34c359a48f811316d765b7abef1ea8f4">colr_printf_handler()</a>.</p>

</div>
</div>
<a id="ac23328cead6a65d7b3ef2c2ca48d11ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23328cead6a65d7b3ef2c2ca48d11ce">&#9670;&nbsp;</a></span>colr_str_starts_with()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_str_starts_with </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks a string (<code>char*</code>) for a certain prefix substring. </p>
<p><code>prefix</code> <em>Must be <code>null</code>-terminated</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>The prefix string to look for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the string <code>s</code> starts with prefix. </dd>
<dd>
False if one of the strings is null, or the prefix isn't found.</dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_starts_with-example" id="colr_str_starts_with-example" class="diamond-bullet">&#160;</a> colr_str_starts_with example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* s = <span class="stringliteral">&quot;This is my string.&quot;</span>;</div><div class="line">assert(<a class="code" href="colr_8c.html#ac23328cead6a65d7b3ef2c2ca48d11ce">colr_str_starts_with</a>(s, <span class="stringliteral">&quot;This&quot;</span>));</div><div class="line">assert(!<a class="code" href="colr_8c.html#ac23328cead6a65d7b3ef2c2ca48d11ce">colr_str_starts_with</a>(s, <span class="stringliteral">&quot;that&quot;</span>));</div></div><!-- fragment --> </div> 
</div>
</div>
<a id="ab0b13b04dc178d0990ab2ae403ee64e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b13b04dc178d0990ab2ae403ee64e0">&#9670;&nbsp;</a></span>colr_str_strip_codes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_strip_codes </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Strips escape codes from a string (<code>char*</code>), resulting in a new allocated string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">The string to strip escape codes from.</p>
<p class="endtd">Input <em>must be <code>null</code>-terminated</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#a037a0245a39d7ff5cfba5f779d0eb251" title="Returns the length of string (char*), ignoring escape codes and the the null-terminator. ">colr_str_noncode_len</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_strip_codes-example" id="colr_str_strip_codes-example" class="diamond-bullet">&#160;</a> colr_str_strip_codes example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* s = <span class="stringliteral">&quot;\x1b[31mRed text.\x1b[0m&quot;</span>;</div><div class="line">printf(<span class="stringliteral">&quot;With codes: %s\n&quot;</span>, s);</div><div class="line"><span class="keywordtype">char</span>* stripped = <a class="code" href="colr_8c.html#ab0b13b04dc178d0990ab2ae403ee64e0">colr_str_strip_codes</a>(s);</div><div class="line"><span class="keywordflow">if</span> (!stripped) exit(1);</div><div class="line">assert(!<a class="code" href="colr_8c.html#a8b9f4cbe1e806316e063206dfb610476">colr_str_has_codes</a>(stripped));</div><div class="line">assert(strlen(stripped) == 9);</div><div class="line">printf(<span class="stringliteral">&quot;Without codes: %s\n&quot;</span>, stripped);</div><div class="line"><span class="comment">// Don&#39;t forget to free the string:</span></div><div class="line">free(stripped);</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a34c359a48f811316d765b7abef1ea8f4">colr_printf_handler()</a>.</p>

</div>
</div>
<a id="ae9b847e10db135f7ebc89031b3a7ad56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b847e10db135f7ebc89031b3a7ad56">&#9670;&nbsp;</a></span>colr_str_to_lower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_to_lower </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new lowercase version of a string (<code>char*</code>). </p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">The input string to convert to lower case.</p>
<p class="endtd"><em>Must be <code>null</code>-terminated</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">The allocated string, or <code>NULL</code> if <code>s</code> is <code>NULL</code>.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a2e859d542a8aa0939e4f76b1f33cb5f8">ExtendedValue_from_str()</a>, and <a class="el" href="colr_8h.html#a98c9e50fe14ad0c82bcf1a62699c05de">RGB_from_str()</a>.</p>

</div>
</div>
<a id="ab2ebdcd3c6e598a244292c7605452e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ebdcd3c6e598a244292c7605452e9d">&#9670;&nbsp;</a></span>colr_supports_rgb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_supports_rgb </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether the current environment support <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> (True Colors). </p>
<p>This checks <code>$COLORTERM</code> for the appropriate value (<code>'truecolor'</code> or <code>'24bit'</code>). On "dumber" terminals, <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> codes are probably ignored or mistaken for a 256-color or even 8-color value.</p>
<p>For instance, <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> is supported in <code>konsole</code>, but not in <code>xterm</code> or <code>linux</code> ttys. Using <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> codes in <code>xterm</code> makes the colors appear as though a 256-color value was used (closest matching value, like <a class="el" href="colr_8c.html#ab4576c531151e398b7ecede2e30df70d" title="Convert an RGB value into it&#39;s nearest terminal-friendly RGB value. ">RGB_to_term_RGB()</a>). Using <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> codes in a simpler <code>linux</code> tty makes them appear as though an 8-color value was used. Very ugly, but not a disaster.</p>
<p>I haven't seen a <em>modern</em> linux terminal spew garbage across the screen from using <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> codes when they are not supported, but I could be wrong. I would like to see that terminal if you know of one.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if 24-bit (true color, or "rgb") support is detected, otherwise <code>false</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ac2aab28fe264005a5d17b888b542610b">colr_supports_rgb_static()</a>.</p>

</div>
</div>
<a id="ac2aab28fe264005a5d17b888b542610b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2aab28fe264005a5d17b888b542610b">&#9670;&nbsp;</a></span>colr_supports_rgb_static()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_supports_rgb_static </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="colr_8c.html#ab2ebdcd3c6e598a244292c7605452e9d" title="Determine whether the current environment support RGB (True Colors). ">colr_supports_rgb()</a>, but the environment is only checked on the first call. </p>
<p>All other calls return the same result as the first call.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if 24-bit (true color, or "rgb") support is detected, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="ae4c11bb5b3b1bb2848bb16aee39763b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c11bb5b3b1bb2848bb16aee39763b2">&#9670;&nbsp;</a></span>colr_term_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structTermSize">TermSize</a> colr_term_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to retrieve the row/column size of the terminal and returns a <a class="el" href="colr_8h.html#structTermSize" title="Holds a terminal size, usually retrieved with colr_term_size(). ">TermSize</a>. </p>
<p>If the call fails, the environment variables <code>LINES</code> and <code>COLUMNS</code> are checked. If that fails, a default <code><a class="el" href="colr_8h.html#structTermSize" title="Holds a terminal size, usually retrieved with colr_term_size(). ">TermSize</a></code> struct is returned: </p><div class="fragment"><div class="line">(<a class="code" href="colr_8h.html#structTermSize">TermSize</a>){.rows=35, .columns=80}</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structTermSize" title="Holds a terminal size, usually retrieved with colr_term_size(). ">TermSize</a> struct with terminal size information. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a412833a097b050c8ee99874c733bd030">ColorText_length()</a>, <a class="el" href="colr_8h.html#a1a8345393e635e1c5e148473bdce292d">colr_str_center()</a>, <a class="el" href="colr_8h.html#a5eedebae47b5d22dda709f833f23a256">colr_str_ljust()</a>, and <a class="el" href="colr_8h.html#acc75e3bf729168f9ac204ef0a1708d46">colr_str_rjust()</a>.</p>

</div>
</div>
<a id="ae7d7b7bf1080742eeb588ba70ce9ea77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d7b7bf1080742eeb588ba70ce9ea77">&#9670;&nbsp;</a></span>colr_win_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct winsize colr_win_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to retrieve a <code>winsize</code> struct from an <code>ioctl</code> call. </p>
<p>If the call fails, the environment variables <code>LINES</code> and <code>COLUMNS</code> are checked. If that fails, a default <code>winsize</code> struct is returned: </p><div class="fragment"><div class="line">(<span class="keyword">struct </span>winsize){.ws_row=35, .ws_col=80, .ws_xpixel=0, .ws_ypixel=0}</div></div><!-- fragment --><p><code>man ioctl_tty</code> says that <code>.ws_xpixel</code> and <code>.ws_ypixel</code> are unused.</p>
<dl class="section return"><dt>Returns</dt><dd>A <code>winsize</code> struct (<code>sys/ioctl.h</code>) with window size information. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ae4c11bb5b3b1bb2848bb16aee39763b2">colr_term_size()</a>.</p>

</div>
</div>
<a id="afc2c53ebede7f97645f671401bfe356d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc2c53ebede7f97645f671401bfe356d">&#9670;&nbsp;</a></span>colr_win_size_env()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct winsize colr_win_size_env </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get window/terminal size using the environment variables <code>LINES</code>, <code>COLUMNS</code>, or <code>COLS</code>. </p>
<p>This is used as a fallback if the <code>ioctl()</code> call fails in <a class="el" href="colr_8c.html#ae7d7b7bf1080742eeb588ba70ce9ea77" title="Attempts to retrieve a winsize struct from an ioctl call. ">colr_win_size()</a>. If environment variables are not available, a default <code>winsize</code> struct is returned: </p><div class="fragment"><div class="line">(<span class="keyword">struct </span>winsize){.ws_row=35, .ws_col=80, .ws_xpixel=0, .ws_ypixel=0}</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>A <code>winsize</code> struct (<code>sys/ioctl.h</code>) with window size information. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ae7d7b7bf1080742eeb588ba70ce9ea77">colr_win_size()</a>.</p>

</div>
</div>
<a id="ac847d91a396ae6babc0bd46e6386a701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac847d91a396ae6babc0bd46e6386a701">&#9670;&nbsp;</a></span>ExtendedValue_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ExtendedValue_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two ExtendedValues. </p>
<p>This is used to implement <a class="el" href="colr_8h.html#a36af8aa0f01eaa780da182e856923faa" title="Calls the &lt;type&gt;_eq functions for the supported types. ">colr_eq()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first ExtendedValue to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second ExtendedValue to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if they are equal, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94" title="Convenience typedef for clarity when dealing with extended (256) colors. ">ExtendedValue</a> </dd></dl>

</div>
</div>
<a id="af0b464ee51d75d7f45ddd5926a7c9cf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0b464ee51d75d7f45ddd5926a7c9cf5">&#9670;&nbsp;</a></span>ExtendedValue_from_BasicValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ExtendedValue_from_BasicValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>bval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a BasicValue into an ExtendedValue. </p>
<p>BASIC_INVALID, and other invalid BasicValues will return EXT_INVALID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bval</td><td>BasicValue to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ExtendedValue <code>0-15</code> on success, otherwise EXT_INVALID.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94" title="Convenience typedef for clarity when dealing with extended (256) colors. ">ExtendedValue</a> </dd></dl>

</div>
</div>
<a id="aaabf63956f397a0fe628313622ba5cde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaabf63956f397a0fe628313622ba5cde">&#9670;&nbsp;</a></span>ExtendedValue_from_esc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ExtendedValue_from_esc </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an escape-code string (<code>char*</code>) to an ExtendedValue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">Escape-code string.</p>
<p class="endtd"><em>Must be <code>null</code>-terminated</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">An</td><td>integer in the range <code>0-255</code> on success. </td></tr>
    <tr><td class="paramname">EXT_INVALID</td><td>on error (or if <code>s</code> is <code>NULL</code>). </td></tr>
    <tr><td class="paramname">EXT_INVALID_RANGE</td><td>if the code number was outside of the range <code>0-255</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94" title="Convenience typedef for clarity when dealing with extended (256) colors. ">ExtendedValue</a> </dd></dl>

</div>
</div>
<a id="a0632d78965000b1e50068a64e335133b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0632d78965000b1e50068a64e335133b">&#9670;&nbsp;</a></span>ExtendedValue_from_hex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ExtendedValue_from_hex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hexstr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an ExtendedValue from a hex string (<code>char*</code>). </p>
<p>This is not a 1:1 translation of hex to rgb. Use <a class="el" href="colr_8c.html#ad33884dcde034819c5e6749667247194" title="Convert a hex color into an RGB value. ">RGB_from_hex()</a> for that. This will convert the hex string to the closest matching ExtendedValue value.</p>
<p>The format for hex strings can be one of:</p><ul>
<li>"[#]ffffff" (Leading hash symbol is optional)</li>
<li>"[#]fff" (short-form)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hexstr</td><td>Hex string to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value between 0 and 255 on success. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">COLOR_INVALID</td><td>on error or bad values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94" title="Convenience typedef for clarity when dealing with extended (256) colors. ">ExtendedValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a757be189530b4925c84df25742374485">ExtendedValue_from_hex_default()</a>, and <a class="el" href="colr_8h.html#a2e859d542a8aa0939e4f76b1f33cb5f8">ExtendedValue_from_str()</a>.</p>

</div>
</div>
<a id="a757be189530b4925c84df25742374485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a757be189530b4925c84df25742374485">&#9670;&nbsp;</a></span>ExtendedValue_from_hex_default()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a> ExtendedValue_from_hex_default </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hexstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an ExtendedValue from a hex string (<code>char*</code>), but return a default value if the hex string is invalid. </p>
<p>This is not a 1:1 translation of hex to rgb. Use <a class="el" href="colr_8c.html#a6133112d9c73a8b56995e16e1af62d3b" title="Convert a hex color into an RGB value, but use a default value when errors occur. ...">RGB_from_hex_default()</a> for that. This will convert the hex string to the closest matching ExtendedValue value.</p>
<p>The format for hex strings can be one of:</p><ul>
<li>"[#]ffffff" (Leading hash symbol is optional)</li>
<li>"[#]fff" (short-form)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hexstr</td><td>Hex string to convert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_value</td><td>ExtendedValue to use for bad hex strings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ExtendedValue on success, or <code>default_value</code> on error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94" title="Convenience typedef for clarity when dealing with extended (256) colors. ">ExtendedValue</a> </dd>
<dd>
<a class="el" href="colr_8c.html#a0632d78965000b1e50068a64e335133b" title="Create an ExtendedValue from a hex string (char*). ">ExtendedValue_from_hex</a> </dd></dl>

</div>
</div>
<a id="a1548d9fc5f3e00a7b5d834eb1e12ff93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1548d9fc5f3e00a7b5d834eb1e12ff93">&#9670;&nbsp;</a></span>ExtendedValue_from_RGB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a> ExtendedValue_from_RGB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value into the closest matching ExtendedValue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ExtendedValue that closely matches the original <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94" title="Convenience typedef for clarity when dealing with extended (256) colors. ">ExtendedValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a0632d78965000b1e50068a64e335133b">ExtendedValue_from_hex()</a>, <a class="el" href="colr_8h.html#a185cec167afe41b6401206659d2d406c">format_bg_RGB_term()</a>, and <a class="el" href="colr_8h.html#a4661c576a4da879b8d4a2c525a42ad78">format_fg_RGB_term()</a>.</p>

</div>
</div>
<a id="a2e859d542a8aa0939e4f76b1f33cb5f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e859d542a8aa0939e4f76b1f33cb5f8">&#9670;&nbsp;</a></span>ExtendedValue_from_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ExtendedValue_from_str </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a known name, integer string (0-255), or a hex string (<code>char*</code>), into an ExtendedValue suitable for the extended-value-based functions. </p>
<p>Hex strings can be used:</p><ul>
<li>"#ffffff" (Leading hash symbol is <b>NOT</b> optional)</li>
<li>"#fff" (short-form)</li>
</ul>
<p>The `'#'` is not optional for hex strings because it is impossible to tell the difference between the hex value '111' and the extended value '111' without it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Color name to find the ExtendedValue for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value between 0 and 255 on success. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EXT_INVALID</td><td>on error or bad values. </td></tr>
    <tr><td class="paramname">EXT_INVALID_RANGE</td><td>if the number was outside of the range <code>0-255</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94" title="Convenience typedef for clarity when dealing with extended (256) colors. ">ExtendedValue</a> </dd></dl>

</div>
</div>
<a id="a669c8872f6b44a047470d33eb5d8b765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669c8872f6b44a047470d33eb5d8b765">&#9670;&nbsp;</a></span>ExtendedValue_is_invalid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ExtendedValue_is_invalid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether an integer is an invalid ExtendedValue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eval</td><td>A number to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is considered invalid, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94" title="Convenience typedef for clarity when dealing with extended (256) colors. ">ExtendedValue</a> </dd></dl>

</div>
</div>
<a id="a6b43e6ee55b05d9b73950794f2dd53a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b43e6ee55b05d9b73950794f2dd53a4">&#9670;&nbsp;</a></span>ExtendedValue_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ExtendedValue_is_valid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether an integer is a valid ExtendedValue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eval</td><td>A number to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is considered valid, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94" title="Convenience typedef for clarity when dealing with extended (256) colors. ">ExtendedValue</a> </dd></dl>

</div>
</div>
<a id="aa45baebc38756a40e7084f8198999902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa45baebc38756a40e7084f8198999902">&#9670;&nbsp;</a></span>ExtendedValue_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ExtendedValue_repr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation of a ExtendedValue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eval</td><td>A ExtendedValue to get the value from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">A pointer to an allocated string.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94" title="Convenience typedef for clarity when dealing with extended (256) colors. ">ExtendedValue</a> </dd></dl>

</div>
</div>
<a id="a4e334d6b9145fca9717fe5a2aeb542fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e334d6b9145fca9717fe5a2aeb542fe">&#9670;&nbsp;</a></span>ExtendedValue_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ExtendedValue_to_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>&#160;</td>
          <td class="paramname"><em>eval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a human-friendly string (<code>char*</code>) from an ExtendedValue's actual value, suitable for use with <a class="el" href="colr_8c.html#a2e859d542a8aa0939e4f76b1f33cb5f8" title="Converts a known name, integer string (0-255), or a hex string (char*), into an ExtendedValue suitabl...">ExtendedValue_from_str()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eval</td><td>A ExtendedValue to get the value from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">A pointer to an allocated string<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94" title="Convenience typedef for clarity when dealing with extended (256) colors. ">ExtendedValue</a> </dd></dl>

</div>
</div>
<a id="ae29032483aea8cb25d6b90750767ffc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae29032483aea8cb25d6b90750767ffc1">&#9670;&nbsp;</a></span>format_bg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_bg </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for a background color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. <em>Must have enough room for <code>CODEX_LEN</code></em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>BasicValue value to use for background. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97257ad40619df6a6c190890ff2873c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97257ad40619df6a6c190890ff2873c4">&#9670;&nbsp;</a></span>format_bg_RGB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_bg_RGB </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for a true color (rgb) background color using values from an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. <em>Must have enough room for <code>CODE_RGB_LEN</code></em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct to get red, blue, and green values from. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ab88ca919420f2df896b7973401641ab4">_rainbow()</a>, and <a class="el" href="colr_8h.html#ab39e0b3981b4f0a8a113c6949bc8b103">rainbow_bg()</a>.</p>

</div>
</div>
<a id="a185cec167afe41b6401206659d2d406c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a185cec167afe41b6401206659d2d406c">&#9670;&nbsp;</a></span>format_bg_RGB_term()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_bg_RGB_term </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for a true color (rgb) fore color using an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct's values, approximating 256-color values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td>Pointer to an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ab88ca919420f2df896b7973401641ab4">_rainbow()</a>, and <a class="el" href="colr_8h.html#adf264c63c394f9ecb19cd8565cda7197">rainbow_bg_term()</a>.</p>

</div>
</div>
<a id="aa4853b53fa18d26741ab7178606e5724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4853b53fa18d26741ab7178606e5724">&#9670;&nbsp;</a></span>format_bgx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_bgx </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for an extended background color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. <em>Must have enough room for <code>CODEX_LEN</code></em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>Value to use for background. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a185cec167afe41b6401206659d2d406c">format_bg_RGB_term()</a>.</p>

</div>
</div>
<a id="a6027d93e8768f3c152edafd92e757801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6027d93e8768f3c152edafd92e757801">&#9670;&nbsp;</a></span>format_fg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_fg </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for a fore color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. <em>Must have enough room for <code>CODEX_LEN</code></em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>BasicValue value to use for fore. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3391a0cd6b6f73d9d39f8179fc0eb0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3391a0cd6b6f73d9d39f8179fc0eb0b">&#9670;&nbsp;</a></span>format_fg_RGB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_fg_RGB </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for a true color (rgb) fore color using an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct's values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td>Pointer to an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ac50eca5901ca237550cf4129237a3411">rainbow_fg()</a>.</p>

</div>
</div>
<a id="a4661c576a4da879b8d4a2c525a42ad78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4661c576a4da879b8d4a2c525a42ad78">&#9670;&nbsp;</a></span>format_fg_RGB_term()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_fg_RGB_term </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for a true color (rgb) fore color using an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct's values, approximating 256-color values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td>Pointer to an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a5a24d379435d64d1212858b173e6f9a7">rainbow_fg_term()</a>.</p>

</div>
</div>
<a id="acfd2cf68768c59fc3ed5c31b93590c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfd2cf68768c59fc3ed5c31b93590c53">&#9670;&nbsp;</a></span>format_fgx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_fgx </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for an extended fore color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. <em>Must have enough room for <code>CODEX_LEN</code></em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>Value to use for fore. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a4661c576a4da879b8d4a2c525a42ad78">format_fg_RGB_term()</a>.</p>

</div>
</div>
<a id="a6aec8e6a80b4ca158df2ad20e3e6a59e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aec8e6a80b4ca158df2ad20e3e6a59e">&#9670;&nbsp;</a></span>format_style()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_style </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>&#160;</td>
          <td class="paramname"><em>style</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for a style. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. <em>Must have enough room for <code>STYLE_LEN</code></em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">style</td><td>StyleValue value to use for style. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab39e0b3981b4f0a8a113c6949bc8b103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab39e0b3981b4f0a8a113c6949bc8b103">&#9670;&nbsp;</a></span>rainbow_bg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* rainbow_bg </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>spread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rainbow-ize some text using rgb back colors, lolcat style. </p>
<p>This prepends a color code to every character in the string. Multi-byte characters are handled properly by checking <a class="el" href="colr_8c.html#ade675256d9e88682d4bebdcc4a57f86f" title="Like mbrlen, except it will return the length of the next N (length) multibyte characters in bytes...">colr_mb_len()</a>, and copying the bytes to the resulting string without codes between the multibyte characters.</p>
<p>The <code>CODE_RESET_ALL</code> code is appended to the result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">The string to colorize.</p>
<p class="endtd">Input <em>must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freq</td><td>Frequency ("tightness") for the colors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Starting offset in the rainbow. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spread</td><td>Number of characters per color. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">The allocated/formatted string on success.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>

</div>
</div>
<a id="adf264c63c394f9ecb19cd8565cda7197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf264c63c394f9ecb19cd8565cda7197">&#9670;&nbsp;</a></span>rainbow_bg_term()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* rainbow_bg_term </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>spread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is exactly like <a class="el" href="colr_8c.html#ab39e0b3981b4f0a8a113c6949bc8b103" title="Rainbow-ize some text using rgb back colors, lolcat style. ">rainbow_bg()</a>, except it uses colors that are closer to the standard 256-color values. </p>
<p>This prepends a color code to every character in the string. Multi-byte characters are handled properly by checking <a class="el" href="colr_8c.html#ade675256d9e88682d4bebdcc4a57f86f" title="Like mbrlen, except it will return the length of the next N (length) multibyte characters in bytes...">colr_mb_len()</a>, and copying the bytes to the resulting string without codes between the multibyte characters.</p>
<p>The <code>CODE_RESET_ALL</code> code is appended to the result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">The string to colorize.</p>
<p class="endtd">Input <em>must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freq</td><td>Frequency ("tightness") for the colors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Starting offset in the rainbow. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spread</td><td>Number of characters per color. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">The allocated/formatted string on success.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>

</div>
</div>
<a id="ac50eca5901ca237550cf4129237a3411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac50eca5901ca237550cf4129237a3411">&#9670;&nbsp;</a></span>rainbow_fg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* rainbow_fg </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>spread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rainbow-ize some text using rgb fore colors, lolcat style. </p>
<p>This prepends a color code to every character in the string. Multi-byte characters are handled properly by checking <a class="el" href="colr_8c.html#ade675256d9e88682d4bebdcc4a57f86f" title="Like mbrlen, except it will return the length of the next N (length) multibyte characters in bytes...">colr_mb_len()</a>, and copying the bytes to the resulting string without codes between the multibyte characters.</p>
<p>The <code>CODE_RESET_ALL</code> code is appended to the result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">The string to colorize.</p>
<p class="endtd">Input <em>must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freq</td><td>Frequency ("tightness") for the colors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Starting offset in the rainbow. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spread</td><td>Number of characters per color. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">The allocated/formatted string on success.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>

</div>
</div>
<a id="a5a24d379435d64d1212858b173e6f9a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a24d379435d64d1212858b173e6f9a7">&#9670;&nbsp;</a></span>rainbow_fg_term()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* rainbow_fg_term </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>spread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is exactly like <a class="el" href="colr_8c.html#ac50eca5901ca237550cf4129237a3411" title="Rainbow-ize some text using rgb fore colors, lolcat style. ">rainbow_fg()</a>, except it uses colors that are closer to the standard 256-color values. </p>
<p>This prepends a color code to every character in the string. Multi-byte characters are handled properly by checking <a class="el" href="colr_8c.html#ade675256d9e88682d4bebdcc4a57f86f" title="Like mbrlen, except it will return the length of the next N (length) multibyte characters in bytes...">colr_mb_len()</a>, and copying the bytes to the resulting string without codes between the multibyte characters.</p>
<p>The <code>CODE_RESET_ALL</code> code is appended to the result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">The string to colorize.</p>
<p class="endtd">Input <em>must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freq</td><td>Frequency ("tightness") for the colors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Starting offset in the rainbow. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spread</td><td>Number of characters per color. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">The allocated/formatted string on success.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>

</div>
</div>
<a id="a3580f33d058571dffd8e5ff789c49296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3580f33d058571dffd8e5ff789c49296">&#9670;&nbsp;</a></span>rainbow_step()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structRGB">RGB</a> rainbow_step </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A single step in rainbow-izing produces the next color in the "rainbow" as an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">freq</td><td>Frequency ("tightness") of the colors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Starting offset in the rainbow.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value with the next "step" in the "rainbow". </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ab88ca919420f2df896b7973401641ab4">_rainbow()</a>.</p>

</div>
</div>
<a id="a0d649fff907b84a625db3fc3b3ae545e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d649fff907b84a625db3fc3b3ae545e">&#9670;&nbsp;</a></span>RGB_average()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char RGB_average </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the average for an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value. </p>
<p>This is also it's "grayscale" value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td>The <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value to get the average for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value between <code>0-255</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a49ce6e92a3b495166213e203ad3ab846">RGB_grayscale()</a>.</p>

</div>
</div>
<a id="ad4b5f73b8aa9d72216d7386221418ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b5f73b8aa9d72216d7386221418ae1">&#9670;&nbsp;</a></span>RGB_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RGB_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> structs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>a</code> and <code>b</code> have the same <code>r</code>, <code>g</code>, and <code>b</code> values, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#adf57e195301864cec80739e7e0f3000c">ColorValue_eq()</a>, and <a class="el" href="colr_8h.html#a1548d9fc5f3e00a7b5d834eb1e12ff93">ExtendedValue_from_RGB()</a>.</p>

</div>
</div>
<a id="ac5fbdea47463b284cbc9b1242ace4f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5fbdea47463b284cbc9b1242ace4f1e">&#9670;&nbsp;</a></span>RGB_from_BasicValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structRGB">RGB</a> RGB_from_BasicValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>bval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value from a known BasicValue. </p>
<p>Terminals use different values to render basic 3/4-bit escape-codes. The values returned from this function match the names found in <code>colr_name_data[]</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bval</td><td>A BasicValue to get the <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value that matches the BasicValue's color.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

</div>
</div>
<a id="a252adee47cc218a9208f16cb0ff42bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a252adee47cc218a9208f16cb0ff42bfe">&#9670;&nbsp;</a></span>RGB_from_esc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RGB_from_esc </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a> *&#160;</td>
          <td class="paramname"><em>rgb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an escape-code string (<code>char*</code>) to an actual <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">Escape-code string.</p>
<p class="endtd"><em>Must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rgb</td><td>Pointer to an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct to fill in the values for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&lt;tt&gt;0&lt;/tt&gt;</td><td>on success, with <code>rgb</code> filled with values. </td></tr>
    <tr><td class="paramname">COLOR_INVALID</td><td>on error (or if <code>s</code> is <code>NULL</code>). </td></tr>
    <tr><td class="paramname">COLOR_INVALID_RANGE</td><td>if any code numbers were outside of the range <code>0-255</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

</div>
</div>
<a id="ab857a1ddce9743c1ef6d54d39e890275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab857a1ddce9743c1ef6d54d39e890275">&#9670;&nbsp;</a></span>RGB_from_ExtendedValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structRGB">RGB</a> RGB_from_ExtendedValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>&#160;</td>
          <td class="paramname"><em>eval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value from a known ExtendedValue. </p>
<p>This is just a type/bounds-checked alias for <code>ext2rgb_map[eval]</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eval</td><td>An ExtendedValue to get the <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value from <code>ext2rgb_map[]</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

</div>
</div>
<a id="ad33884dcde034819c5e6749667247194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad33884dcde034819c5e6749667247194">&#9670;&nbsp;</a></span>RGB_from_hex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RGB_from_hex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hexstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a> *&#160;</td>
          <td class="paramname"><em>rgb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a hex color into an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value. </p>
<p>The format for hex strings can be one of:</p><ul>
<li>"[#]ffffff" (Leading hash symbol is optional)</li>
<li>"[#]fff" (short-form)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hexstr</td><td><p class="starttd">String to check for hex values.</p>
<p class="endtd">Input <em>must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rgb</td><td>Pointer to an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct to fill in the values for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success, with <code>rgb</code> filled with the values. </td></tr>
    <tr><td class="paramname">COLOR_INVALID</td><td>for non-hex strings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a0632d78965000b1e50068a64e335133b">ExtendedValue_from_hex()</a>, <a class="el" href="colr_8h.html#a6133112d9c73a8b56995e16e1af62d3b">RGB_from_hex_default()</a>, and <a class="el" href="colr_8h.html#a98c9e50fe14ad0c82bcf1a62699c05de">RGB_from_str()</a>.</p>

</div>
</div>
<a id="a6133112d9c73a8b56995e16e1af62d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6133112d9c73a8b56995e16e1af62d3b">&#9670;&nbsp;</a></span>RGB_from_hex_default()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structRGB">RGB</a> RGB_from_hex_default </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hexstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a hex color into an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value, but use a default value when errors occur. </p>
<p>The format for hex strings can be one of:</p><ul>
<li>"[#]ffffff" (Leading hash symbol is optional)</li>
<li>"[#]fff" (short-form)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hexstr</td><td><p class="starttd">String to check for <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> values.</p>
<p class="endtd">Input <em>must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">default_value</td><td>An <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value to use when errors occur.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A valid <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value on success, or <code>default_value</code> on error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a8fe812f8e76e4baed394ee9adf46b3df" title="Use RGB_from_hex_default() to create an RGB value. ">hex</a> </dd></dl>

</div>
</div>
<a id="a98c9e50fe14ad0c82bcf1a62699c05de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c9e50fe14ad0c82bcf1a62699c05de">&#9670;&nbsp;</a></span>RGB_from_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RGB_from_str </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a> *&#160;</td>
          <td class="paramname"><em>rgb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> string (<code>char*</code>) into an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value. </p>
<p>The format for <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> strings can be one of:</p><ul>
<li>"RED,GREEN,BLUE"</li>
<li>"RED GREEN BLUE"</li>
<li>"RED:GREEN:BLUE"</li>
<li>"RED;GREEN;BLUE" Or hex strings can be used:</li>
<li>"#ffffff" (Leading hash symbol is <b>NOT</b> optional)</li>
<li>"#fff" (short-form)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td><p class="starttd">String to check for <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> values.</p>
<p class="endtd">Input <em>must be <code>null</code>-terminated</em>. </p>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rgb</td><td>Pointer to an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct to fill in the values for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success, with <code>rgb</code> filled with the values. </td></tr>
    <tr><td class="paramname">COLOR_INVALID</td><td>for non-rgb strings. </td></tr>
    <tr><td class="paramname">COLOR_INVALID_RANGE</td><td>for rgb values outside of 0-255.</td></tr>
  </table>
  </dd>
</dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#RGB_from_str-example" id="RGB_from_str-example" class="diamond-bullet">&#160;</a> RGB_from_str example: </div><div class="fragment"><div class="line"><a class="code" href="colr_8h.html#structRGB">RGB</a> rgbval;</div><div class="line"><span class="keywordtype">int</span> ret = <a class="code" href="colr_8c.html#a98c9e50fe14ad0c82bcf1a62699c05de">RGB_from_str</a>(<span class="stringliteral">&quot;123,0,234&quot;</span>, &amp;rgbval);</div><div class="line"><span class="keywordflow">if</span> (ret == 0) {</div><div class="line">    <span class="keywordtype">char</span>* s = <a class="code" href="colr_8h.html#a8e2c8bf2819cb36b1a34396a65b51faa">colr_cat</a>(<a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;Test&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(rgbval)));</div><div class="line">    printf(<span class="stringliteral">&quot;%s\n&quot;</span>, s);</div><div class="line">    free(s);</div><div class="line">}</div></div><!-- fragment --> </div> <dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

</div>
</div>
<a id="a49ce6e92a3b495166213e203ad3ab846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ce6e92a3b495166213e203ad3ab846">&#9670;&nbsp;</a></span>RGB_grayscale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structRGB">RGB</a> RGB_grayscale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grayscale version of an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td>The <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A grayscale <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

</div>
</div>
<a id="a958e45854d69e8b59859244ce791673c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a958e45854d69e8b59859244ce791673c">&#9670;&nbsp;</a></span>RGB_inverted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structRGB">RGB</a> RGB_inverted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a copy of an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value, with the colors "inverted" (like highlighting text in the terminal). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td>The <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value to invert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An "inverted" <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

</div>
</div>
<a id="abd85b5c5b79142c8656a065c58e4509e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd85b5c5b79142c8656a065c58e4509e">&#9670;&nbsp;</a></span>RGB_monochrome()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structRGB">RGB</a> RGB_monochrome </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value into either black or white, depending on it's average grayscale value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td>The <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either <code><a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57" title="Creates an anonymous RGB struct for use in function calls. ">rgb(1, 1, 1)</a></code> or <code><a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57" title="Creates an anonymous RGB struct for use in function calls. ">rgb(255, 255, 255)</a></code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

</div>
</div>
<a id="afd28864afbcfa4a344e4596130645177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd28864afbcfa4a344e4596130645177">&#9670;&nbsp;</a></span>RGB_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* RGB_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation for an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value. </p>
<p>Allocates memory for the string representation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct to get the representation for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">Allocated string for the representation.</p>
<p class="enddd"><em>You must <code>free()</code> the memory allocated by this function.</em> </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

</div>
</div>
<a id="a95e4feb89e009f00cfe7e74a55fab56f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e4feb89e009f00cfe7e74a55fab56f">&#9670;&nbsp;</a></span>RGB_to_hex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* RGB_to_hex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value into a hex string (<code>char*</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string.</dd></dl>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p><em>If allocation fails, <code>NULL</code> is returned</em>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

</div>
</div>
<a id="a16d2f9a1133c8a955f0a551870d7ebe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16d2f9a1133c8a955f0a551870d7ebe8">&#9670;&nbsp;</a></span>RGB_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* RGB_to_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value into a human-friendly <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> string (<code>char*</code>) suitable for input to <a class="el" href="colr_8c.html#a98c9e50fe14ad0c82bcf1a62699c05de" title="Convert an RGB string (char*) into an RGB value. ">RGB_from_str()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string in the form <code>"red;green;blue"</code>.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

</div>
</div>
<a id="ab4576c531151e398b7ecede2e30df70d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4576c531151e398b7ecede2e30df70d">&#9670;&nbsp;</a></span>RGB_to_term_RGB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structRGB">RGB</a> RGB_to_term_RGB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value into it's nearest terminal-friendly <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value. </p>
<p>This is a helper for the 'to_term' functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> with values close to a terminal code color.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a1548d9fc5f3e00a7b5d834eb1e12ff93">ExtendedValue_from_RGB()</a>.</p>

</div>
</div>
<a id="a32bf31475b0f6264b45438bd5c09ee7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32bf31475b0f6264b45438bd5c09ee7d">&#9670;&nbsp;</a></span>StyleValue_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool StyleValue_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two StyleValues. </p>
<p>This is used to implement <a class="el" href="colr_8h.html#a36af8aa0f01eaa780da182e856923faa" title="Calls the &lt;type&gt;_eq functions for the supported types. ">colr_eq()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first StyleValue to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second StyleValue to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if they are equal, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6" title="Style values. ">StyleValue</a> </dd></dl>

</div>
</div>
<a id="a9f4fd7f8901569c053bd29f2035c69b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f4fd7f8901569c053bd29f2035c69b7">&#9670;&nbsp;</a></span>StyleValue_from_esc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a> StyleValue_from_esc </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an escape-code string (<code>char*</code>) to an actual StyleValue enum value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><p class="starttd">Escape-code string.</p>
<p class="endtd"><em>Must be <code>null</code>-terminated</em>. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">StyleValue</td><td>value on success. </td></tr>
    <tr><td class="paramname">STYLE_INVALID</td><td>on error (or if <code>s</code> is <code>NULL</code>). </td></tr>
    <tr><td class="paramname">STYLE_INVALID_RANGE</td><td>if the code number was outside of the range <code>0-255</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6" title="Style values. ">StyleValue</a> </dd></dl>

</div>
</div>
<a id="a4ca63735ad2cbc6475d4af83dc7c1a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ca63735ad2cbc6475d4af83dc7c1a9b">&#9670;&nbsp;</a></span>StyleValue_from_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a> StyleValue_from_str </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a named argument to actual StyleValue enum value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Style name to convert into a StyleValue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A usable StyleValue value on success, or STYLE_INVALID on error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6" title="Style values. ">StyleValue</a> </dd></dl>

</div>
</div>
<a id="a3f8126147490f88283a53e9ef48d33f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f8126147490f88283a53e9ef48d33f0">&#9670;&nbsp;</a></span>StyleValue_is_invalid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool StyleValue_is_invalid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>&#160;</td>
          <td class="paramname"><em>sval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a StyleValue is invalid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sval</td><td>A StyleValue to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is considered invalid, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6" title="Style values. ">StyleValue</a> </dd></dl>

</div>
</div>
<a id="a2d6598b05bc5c742fbb94b47d8a3213a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d6598b05bc5c742fbb94b47d8a3213a">&#9670;&nbsp;</a></span>StyleValue_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool StyleValue_is_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>&#160;</td>
          <td class="paramname"><em>sval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a StyleValue is valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sval</td><td>A StyleValue to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is considered valid, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6" title="Style values. ">StyleValue</a> </dd></dl>

</div>
</div>
<a id="a24b74664587dd3c0e981603ee75c331b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b74664587dd3c0e981603ee75c331b">&#9670;&nbsp;</a></span>StyleValue_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* StyleValue_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>&#160;</td>
          <td class="paramname"><em>sval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation of a StyleValue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sval</td><td>A StyleValue to get the value from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">A pointer to an allocated string.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6" title="Style values. ">StyleValue</a> </dd></dl>

</div>
</div>
<a id="ac767fb032c9617e2830cc5e13e66c400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac767fb032c9617e2830cc5e13e66c400">&#9670;&nbsp;</a></span>StyleValue_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* StyleValue_to_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>&#160;</td>
          <td class="paramname"><em>sval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a human-friendly string (<code>char*</code>) representation for a StyleValue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sval</td><td>StyleValue to get the name for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6" title="Style values. ">StyleValue</a> </dd></dl>

</div>
</div>
<a id="a41b4ed49acc5d806f161a3b31f5bf023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b4ed49acc5d806f161a3b31f5bf023">&#9670;&nbsp;</a></span>TermSize_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* TermSize_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structTermSize">TermSize</a>&#160;</td>
          <td class="paramname"><em>ts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a string (<code>char*</code>) representation for a <a class="el" href="colr_8h.html#structTermSize" title="Holds a terminal size, usually retrieved with colr_term_size(). ">TermSize</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td><a class="el" href="colr_8h.html#structTermSize" title="Holds a terminal size, usually retrieved with colr_term_size(). ">TermSize</a> to get the representation for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">An allocated string with the result.</p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<p class="enddd"><em>If allocation fails, <code>NULL</code> is returned</em>. </p>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structTermSize" title="Holds a terminal size, usually retrieved with colr_term_size(). ">TermSize</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a62b38c28aba614d1bd1706d6099df0e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b38c28aba614d1bd1706d6099df0e6">&#9670;&nbsp;</a></span>colr_printf_esc_mod</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int colr_printf_esc_mod</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integer to test for the presence of the "escaped output modifier" in colr_printf_handler. </p>
<p>This is set in colr_printf_register. </p>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a34c359a48f811316d765b7abef1ea8f4">colr_printf_handler()</a>, and <a class="el" href="colr_8h.html#aaaf134ca9a2188d83171fe91948354d9">colr_printf_register()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="colr_8h.html">colr.h</a></li>
    <li class="footer">Generated by
        <a href="http://www.doxygen.org/index.html">
        Doxygen <!-- <img class="footer" src="doxygen.png" alt="doxygen"/> -->
        </a>
        1.8.13
    </li>
    <!-- This actually comes *before* the "generated by" msg, because of float. -->
    <li class="footer">
        ColrC v.0.3.6
    </li>
  </ul>
</div>
</body>
</html>
