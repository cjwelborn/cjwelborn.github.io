<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ColrC: colr.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="colrc-pixels.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ColrC
   </div>
   <div id="projectbrief">An easy to use C library for linux terminal colors/escape-codes.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('colr_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">colr.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Declarations for ColrC functions, enums, structs, etc.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;assert.h&gt;</code><br />
<code>#include &lt;ctype.h&gt;</code><br />
<code>#include &lt;errno.h&gt;</code><br />
<code>#include &lt;malloc.h&gt;</code><br />
<code>#include &lt;math.h&gt;</code><br />
<code>#include &lt;limits.h&gt;</code><br />
<code>#include &lt;locale.h&gt;</code><br />
<code>#include &lt;search.h&gt;</code><br />
<code>#include &lt;stdarg.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;sys/ioctl.h&gt;</code><br />
<code>#include &lt;unistd.h&gt;</code><br />
<code>#include &lt;wchar.h&gt;</code><br />
<code>#include &lt;ttyent.h&gt;</code><br />
<code>#include &quot;<a class="el" href="dbug_8h_source.html">dbug.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="colr_8h__dep__incl.png" border="0" usemap="#colr_8hdep" alt=""/></div>
<map name="colr_8hdep" id="colr_8hdep">
<area shape="rect" id="node2" href="colr_8c.html" title="Implements everything in the colr.h header. " alt="" coords="5,80,59,107"/>
</map>
</div>
</div>
<p><a href="colr_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structRGB"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#structRGB">RGB</a></td></tr>
<tr class="memdesc:structRGB"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> values.  <a href="colr_8h.html#structRGB">More...</a><br /></td></tr>
<tr class="separator:structRGB"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structBasicInfo"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#structBasicInfo">BasicInfo</a></td></tr>
<tr class="memdesc:structBasicInfo"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a known color name and it's <code>BasicValue</code>.  <a href="colr_8h.html#structBasicInfo">More...</a><br /></td></tr>
<tr class="separator:structBasicInfo"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structExtendedInfo"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#structExtendedInfo">ExtendedInfo</a></td></tr>
<tr class="memdesc:structExtendedInfo"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a known color name and it's <code>ExtendedValue</code>.  <a href="colr_8h.html#structExtendedInfo">More...</a><br /></td></tr>
<tr class="separator:structExtendedInfo"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structStyleInfo"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#structStyleInfo">StyleInfo</a></td></tr>
<tr class="memdesc:structStyleInfo"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a known style name and it's <code>StyleValue</code>.  <a href="colr_8h.html#structStyleInfo">More...</a><br /></td></tr>
<tr class="separator:structStyleInfo"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:unionColorStructMarker"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#unionColorStructMarker">ColorStructMarker</a></td></tr>
<tr class="memdesc:unionColorStructMarker"><td class="mdescLeft">&#160;</td><td class="mdescRight">Breaks down Colr struct markers, such as COLORARG_MARKER, into individual bytes.  <a href="colr_8h.html#unionColorStructMarker">More...</a><br /></td></tr>
<tr class="separator:unionColorStructMarker"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structColorValue"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a></td></tr>
<tr class="memdesc:structColorValue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a color type and it's value.  <a href="colr_8h.html#structColorValue">More...</a><br /></td></tr>
<tr class="separator:structColorValue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structColorJustify"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a></td></tr>
<tr class="memdesc:structColorJustify"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a string justification method, width, and padding character for ColorTexts.  <a href="colr_8h.html#structColorJustify">More...</a><br /></td></tr>
<tr class="separator:structColorJustify"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structColorNameData"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#structColorNameData">ColorNameData</a></td></tr>
<tr class="memdesc:structColorNameData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds info about a known color name, like it's ExtendedValue and it's <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.  <a href="colr_8h.html#structColorNameData">More...</a><br /></td></tr>
<tr class="separator:structColorNameData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structColorArg"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a></td></tr>
<tr class="memdesc:structColorArg"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds an ArgType, and a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>.  <a href="colr_8h.html#structColorArg">More...</a><br /></td></tr>
<tr class="separator:structColorArg"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structColorText"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#structColorText">ColorText</a></td></tr>
<tr class="memdesc:structColorText"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a string of text, and optional fore, back, and style ColorArgs.  <a href="colr_8h.html#structColorText">More...</a><br /></td></tr>
<tr class="separator:structColorText"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structTermSize"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#structTermSize">TermSize</a></td></tr>
<tr class="memdesc:structTermSize"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a terminal size, usually retrieved with <a class="el" href="colr_8c.html#ae4c11bb5b3b1bb2848bb16aee39763b2" title="Attempts to retrieve the row/column size of the terminal and returns a TermSize. ">colr_term_size()</a>.  <a href="colr_8h.html#structTermSize">More...</a><br /></td></tr>
<tr class="separator:structTermSize"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structColorStructMarker_8bytes"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#structColorStructMarker_8bytes">ColorStructMarker.bytes</a></td></tr>
<tr class="memdesc:structColorStructMarker_8bytes"><td class="mdescLeft">&#160;</td><td class="mdescRight">Individual bytes that make up the marker.  <a href="colr_8h.html#structColorStructMarker_8bytes">More...</a><br /></td></tr>
<tr class="separator:structColorStructMarker_8bytes"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ac1b8d77765654a95ec8684fcfd763261"><td class="memItemLeft" align="right" valign="top"><a id="ac1b8d77765654a95ec8684fcfd763261"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ac1b8d77765654a95ec8684fcfd763261">COLR_VERSION</a>&#160;&#160;&#160;&quot;0.3.0&quot;</td></tr>
<tr class="memdesc:ac1b8d77765654a95ec8684fcfd763261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current version for ColrC. <br /></td></tr>
<tr class="separator:ac1b8d77765654a95ec8684fcfd763261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add86801c90ad7bd8359242a2c1ef1297"><td class="memItemLeft" align="right" valign="top"><a id="add86801c90ad7bd8359242a2c1ef1297"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#add86801c90ad7bd8359242a2c1ef1297">CODE_RESET_ALL</a>&#160;&#160;&#160;&quot;\x1b[0m&quot;</td></tr>
<tr class="memdesc:add86801c90ad7bd8359242a2c1ef1297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience definition, because this is used a lot. <br /></td></tr>
<tr class="separator:add86801c90ad7bd8359242a2c1ef1297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5da78a4dc69dfce7a6d4d459e657e85"><td class="memItemLeft" align="right" valign="top"><a id="ab5da78a4dc69dfce7a6d4d459e657e85"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab5da78a4dc69dfce7a6d4d459e657e85">WCODE_RESET_ALL</a>&#160;&#160;&#160;L&quot;\x1b[0m&quot;</td></tr>
<tr class="memdesc:ab5da78a4dc69dfce7a6d4d459e657e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience definition for wide chars. <br /></td></tr>
<tr class="separator:ab5da78a4dc69dfce7a6d4d459e657e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa2460e32327ade49189c95740bc1b5"><td class="memItemLeft" align="right" valign="top"><a id="a1fa2460e32327ade49189c95740bc1b5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a1fa2460e32327ade49189c95740bc1b5">NC</a>&#160;&#160;&#160;<a class="el" href="colr_8h.html#add86801c90ad7bd8359242a2c1ef1297">CODE_RESET_ALL</a></td></tr>
<tr class="memdesc:a1fa2460e32327ade49189c95740bc1b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for CODE_RESET_ALL, stands for "No Color". <br /></td></tr>
<tr class="separator:a1fa2460e32327ade49189c95740bc1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776e776cd944dea88b370a8204be5df4"><td class="memItemLeft" align="right" valign="top"><a id="a776e776cd944dea88b370a8204be5df4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a776e776cd944dea88b370a8204be5df4">WNC</a>&#160;&#160;&#160;<a class="el" href="colr_8h.html#ab5da78a4dc69dfce7a6d4d459e657e85">WCODE_RESET_ALL</a></td></tr>
<tr class="memdesc:a776e776cd944dea88b370a8204be5df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for WCODE_RESET_ALL, stands for "Wide No Color". <br /></td></tr>
<tr class="separator:a776e776cd944dea88b370a8204be5df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c138529b05543ba04e6cdbdb5033f0"><td class="memItemLeft" align="right" valign="top"><a id="ae9c138529b05543ba04e6cdbdb5033f0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ae9c138529b05543ba04e6cdbdb5033f0">CODE_RESET_LEN</a>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:ae9c138529b05543ba04e6cdbdb5033f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of CODE_RESET_ALL, including `'\0'`. <br /></td></tr>
<tr class="separator:ae9c138529b05543ba04e6cdbdb5033f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9837a2915a770865032578914efb8621"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a9837a2915a770865032578914efb8621">CODE_LEN_MIN</a>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:a9837a2915a770865032578914efb8621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum length for the shortest basic fore/back escape code, including `'\0'`.  <a href="#a9837a2915a770865032578914efb8621">More...</a><br /></td></tr>
<tr class="separator:a9837a2915a770865032578914efb8621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef6ad74c493fe40e199341072fabefe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a4ef6ad74c493fe40e199341072fabefe">CODE_LEN</a>&#160;&#160;&#160;14</td></tr>
<tr class="memdesc:a4ef6ad74c493fe40e199341072fabefe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length for a basic fore/back escape code, including `'\0'`.  <a href="#a4ef6ad74c493fe40e199341072fabefe">More...</a><br /></td></tr>
<tr class="separator:a4ef6ad74c493fe40e199341072fabefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37730bc0c16d2d698f3d539add30483b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a37730bc0c16d2d698f3d539add30483b">CODEX_LEN_MIN</a>&#160;&#160;&#160;10</td></tr>
<tr class="memdesc:a37730bc0c16d2d698f3d539add30483b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum length for the shortest extended fore/back escape code, including `'\0'`.  <a href="#a37730bc0c16d2d698f3d539add30483b">More...</a><br /></td></tr>
<tr class="separator:a37730bc0c16d2d698f3d539add30483b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af77ec93393736fa98be724385d61614d"><td class="memItemLeft" align="right" valign="top"><a id="af77ec93393736fa98be724385d61614d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#af77ec93393736fa98be724385d61614d">CODEX_LEN</a>&#160;&#160;&#160;12</td></tr>
<tr class="memdesc:af77ec93393736fa98be724385d61614d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length for an extended fore/back escape code, including `'\0'`. <br /></td></tr>
<tr class="separator:af77ec93393736fa98be724385d61614d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd8134cf00ddafc463dbce4010439af"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a5fd8134cf00ddafc463dbce4010439af">STYLE_LEN_MIN</a>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:a5fd8134cf00ddafc463dbce4010439af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum length for the shortest style escape code, including `'\0'`.  <a href="#a5fd8134cf00ddafc463dbce4010439af">More...</a><br /></td></tr>
<tr class="separator:a5fd8134cf00ddafc463dbce4010439af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83d14a355d35b7af90deb99ad3b7601"><td class="memItemLeft" align="right" valign="top"><a id="ac83d14a355d35b7af90deb99ad3b7601"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ac83d14a355d35b7af90deb99ad3b7601">STYLE_LEN</a>&#160;&#160;&#160;6</td></tr>
<tr class="memdesc:ac83d14a355d35b7af90deb99ad3b7601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length for a style escape code, including `'\0'`. <br /></td></tr>
<tr class="separator:ac83d14a355d35b7af90deb99ad3b7601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5557ed18d83facb69dd68b30629c37e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab5557ed18d83facb69dd68b30629c37e">COLOR_LEN</a>&#160;&#160;&#160;30</td></tr>
<tr class="memdesc:ab5557ed18d83facb69dd68b30629c37e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length in chars for any combination of basic/extended escape codes.  <a href="#ab5557ed18d83facb69dd68b30629c37e">More...</a><br /></td></tr>
<tr class="separator:ab5557ed18d83facb69dd68b30629c37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffdc16cef9af954c4d62d29ba8d7961"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a3ffdc16cef9af954c4d62d29ba8d7961">CODE_RGB_LEN_MIN</a>&#160;&#160;&#160;14</td></tr>
<tr class="memdesc:a3ffdc16cef9af954c4d62d29ba8d7961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum length for the shortest <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> fore/back escape code, including `'\0'`.  <a href="#a3ffdc16cef9af954c4d62d29ba8d7961">More...</a><br /></td></tr>
<tr class="separator:a3ffdc16cef9af954c4d62d29ba8d7961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad50e6b68284102d5270834e02652af37"><td class="memItemLeft" align="right" valign="top"><a id="ad50e6b68284102d5270834e02652af37"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ad50e6b68284102d5270834e02652af37">CODE_RGB_LEN</a>&#160;&#160;&#160;20</td></tr>
<tr class="memdesc:ad50e6b68284102d5270834e02652af37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length in chars for an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> fore/back escape code, including `'\0'`. <br /></td></tr>
<tr class="separator:ad50e6b68284102d5270834e02652af37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbb9166f2a4d79e48dd5b11c3eb258b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a9dbb9166f2a4d79e48dd5b11c3eb258b">COLOR_RGB_LEN</a>&#160;&#160;&#160;26</td></tr>
<tr class="memdesc:a9dbb9166f2a4d79e48dd5b11c3eb258b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length in chars added to a rgb colorized string.  <a href="#a9dbb9166f2a4d79e48dd5b11c3eb258b">More...</a><br /></td></tr>
<tr class="separator:a9dbb9166f2a4d79e48dd5b11c3eb258b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e75d15b6f6536e745f66563c4ba6c3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab0e75d15b6f6536e745f66563c4ba6c3">CODE_ANY_LEN</a>&#160;&#160;&#160;46</td></tr>
<tr class="memdesc:ab0e75d15b6f6536e745f66563c4ba6c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length in chars for any possible escape code mixture.  <a href="#ab0e75d15b6f6536e745f66563c4ba6c3">More...</a><br /></td></tr>
<tr class="separator:ab0e75d15b6f6536e745f66563c4ba6c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22fa09afcaf087080075551d293a72fd"><td class="memItemLeft" align="right" valign="top"><a id="a22fa09afcaf087080075551d293a72fd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a22fa09afcaf087080075551d293a72fd">COLORARG_MARKER</a>&#160;&#160;&#160;UINT_MAX</td></tr>
<tr class="memdesc:a22fa09afcaf087080075551d293a72fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marker for the <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct, for identifying a void pointer as a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>. <br /></td></tr>
<tr class="separator:a22fa09afcaf087080075551d293a72fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151438a6f14e82e457ceaf7a168862d5"><td class="memItemLeft" align="right" valign="top"><a id="a151438a6f14e82e457ceaf7a168862d5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a151438a6f14e82e457ceaf7a168862d5">COLORLASTARG_MARKER</a>&#160;&#160;&#160;(UINT_MAX - 20)</td></tr>
<tr class="memdesc:a151438a6f14e82e457ceaf7a168862d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marker for the _ColrLastArg_s struct, for identifying a void pointer as a _ColrLastArg_s. <br /></td></tr>
<tr class="separator:a151438a6f14e82e457ceaf7a168862d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf2f23aa571eaa38d355336226d7786"><td class="memItemLeft" align="right" valign="top"><a id="acdf2f23aa571eaa38d355336226d7786"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#acdf2f23aa571eaa38d355336226d7786">COLORJUSTIFY_MARKER</a>&#160;&#160;&#160;(UINT_MAX - 30)</td></tr>
<tr class="memdesc:acdf2f23aa571eaa38d355336226d7786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marker for the <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> struct, for identifying a void pointer as a <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a>. <br /></td></tr>
<tr class="separator:acdf2f23aa571eaa38d355336226d7786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3756a551f1f8e5dfb56f6ab41d9e07"><td class="memItemLeft" align="right" valign="top"><a id="afc3756a551f1f8e5dfb56f6ab41d9e07"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#afc3756a551f1f8e5dfb56f6ab41d9e07">COLORTEXT_MARKER</a>&#160;&#160;&#160;(UINT_MAX - 40)</td></tr>
<tr class="memdesc:afc3756a551f1f8e5dfb56f6ab41d9e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marker for the <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> struct, for identifying a void pointer as a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>. <br /></td></tr>
<tr class="separator:afc3756a551f1f8e5dfb56f6ab41d9e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaddb0f34c1374c29a8b7629ac40ca8b"><td class="memItemLeft" align="right" valign="top"><a id="aaaddb0f34c1374c29a8b7629ac40ca8b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aaaddb0f34c1374c29a8b7629ac40ca8b">COLOR_INVALID</a>&#160;&#160;&#160;(-2)</td></tr>
<tr class="memdesc:aaaddb0f34c1374c29a8b7629ac40ca8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible error return value for <a class="el" href="colr_8h.html#a4163ac65dca3e222525808b80a40b733" title="Convert named argument to an actual BasicValue enum value. ">BasicValue_from_str()</a>, <a class="el" href="colr_8h.html#a2e859d542a8aa0939e4f76b1f33cb5f8" title="Converts a known name, integer string (0-255), or a hex string (char*), into an ExtendedValue suitabl...">ExtendedValue_from_str()</a>, and colorname_to_rgb(). <br /></td></tr>
<tr class="separator:aaaddb0f34c1374c29a8b7629ac40ca8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b950e341a1ce7dd9b3325c53c50cfc"><td class="memItemLeft" align="right" valign="top"><a id="ab8b950e341a1ce7dd9b3325c53c50cfc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab8b950e341a1ce7dd9b3325c53c50cfc">COLOR_INVALID_RANGE</a>&#160;&#160;&#160;(-1)</td></tr>
<tr class="memdesc:ab8b950e341a1ce7dd9b3325c53c50cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible error return value for <a class="el" href="colr_8h.html#a98c9e50fe14ad0c82bcf1a62699c05de" title="Convert an RGB string (char*) into an RGB value. ">RGB_from_str()</a>. <br /></td></tr>
<tr class="separator:ab8b950e341a1ce7dd9b3325c53c50cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f29d345901a016f81f020ca4326c61"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab7f29d345901a016f81f020ca4326c61">alloc_basic</a>()&#160;&#160;&#160;calloc(<a class="el" href="colr_8h.html#a4ef6ad74c493fe40e199341072fabefe">CODE_LEN</a>, sizeof(char))</td></tr>
<tr class="memdesc:ab7f29d345901a016f81f020ca4326c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate enough for a basic code.  <a href="#ab7f29d345901a016f81f020ca4326c61">More...</a><br /></td></tr>
<tr class="separator:ab7f29d345901a016f81f020ca4326c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c2b2b2835220a22a3b02e18febda40"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a27c2b2b2835220a22a3b02e18febda40">alloc_extended</a>()&#160;&#160;&#160;calloc(<a class="el" href="colr_8h.html#af77ec93393736fa98be724385d61614d">CODEX_LEN</a>, sizeof(char))</td></tr>
<tr class="memdesc:a27c2b2b2835220a22a3b02e18febda40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate enough for a extended code.  <a href="#a27c2b2b2835220a22a3b02e18febda40">More...</a><br /></td></tr>
<tr class="separator:a27c2b2b2835220a22a3b02e18febda40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4f7e3d0a7c1d9b991b0a33a995d6e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ade4f7e3d0a7c1d9b991b0a33a995d6e5">alloc_rgb</a>()&#160;&#160;&#160;calloc(<a class="el" href="colr_8h.html#ad50e6b68284102d5270834e02652af37">CODE_RGB_LEN</a>, sizeof(char))</td></tr>
<tr class="memdesc:ade4f7e3d0a7c1d9b991b0a33a995d6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate enough for an rgb code.  <a href="#ade4f7e3d0a7c1d9b991b0a33a995d6e5">More...</a><br /></td></tr>
<tr class="separator:ade4f7e3d0a7c1d9b991b0a33a995d6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af1a91e97e7aed226ab0cdc6ce205f8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a6af1a91e97e7aed226ab0cdc6ce205f8">alloc_style</a>()&#160;&#160;&#160;calloc(<a class="el" href="colr_8h.html#ac83d14a355d35b7af90deb99ad3b7601">STYLE_LEN</a>, sizeof(char))</td></tr>
<tr class="memdesc:a6af1a91e97e7aed226ab0cdc6ce205f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate enough for a style code.  <a href="#a6af1a91e97e7aed226ab0cdc6ce205f8">More...</a><br /></td></tr>
<tr class="separator:a6af1a91e97e7aed226ab0cdc6ce205f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63464899e77699c41410c7ed566342a7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a63464899e77699c41410c7ed566342a7">argeq</a>(arg,  s1,  s2)&#160;&#160;&#160;(!strcmp(arg, s1)) || (!strcmp(arg, s2))</td></tr>
<tr class="memdesc:a63464899e77699c41410c7ed566342a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro for <code>!strcmp(arg, s1) || !strcmp(arg, s2)</code>  <a href="#a63464899e77699c41410c7ed566342a7">More...</a><br /></td></tr>
<tr class="separator:a63464899e77699c41410c7ed566342a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e247a378d2359d2d6efa4af5e3cd03b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a6e247a378d2359d2d6efa4af5e3cd03b">asprintf_or_return</a>(retval, ...)&#160;&#160;&#160;<a class="el" href="colr_8h.html#a80a08fc1383c7260a31698864d52fee2">if_not_asprintf</a>(__VA_ARGS__) return retval</td></tr>
<tr class="memdesc:a6e247a378d2359d2d6efa4af5e3cd03b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro for bailing out of a function when asprintf fails.  <a href="#a6e247a378d2359d2d6efa4af5e3cd03b">More...</a><br /></td></tr>
<tr class="separator:a6e247a378d2359d2d6efa4af5e3cd03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947915cd251af5099f6a9232836b12d8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8">back</a>(x)&#160;&#160;&#160;<a class="el" href="colr_8h.html#afb5ac0bd012b8162cea125ad0d9e8bf0">ColorArg_to_ptr</a>(<a class="el" href="colr_8h.html#aeba419af1d4c23615eb844db37e46ee6">back_arg</a>(x))</td></tr>
<tr class="memdesc:a947915cd251af5099f6a9232836b12d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a back color suitable for use with the <a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2" title="Join ColorArg pointers, ColorText pointers, and strings into one long string. ">colr()</a> and <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr() macro...">Colr()</a> macros.  <a href="#a947915cd251af5099f6a9232836b12d8">More...</a><br /></td></tr>
<tr class="separator:a947915cd251af5099f6a9232836b12d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba419af1d4c23615eb844db37e46ee6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aeba419af1d4c23615eb844db37e46ee6">back_arg</a>(x)</td></tr>
<tr class="memdesc:aeba419af1d4c23615eb844db37e46ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses ColorArg_from_&lt;type&gt; to build a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> with the appropriate color type, based on the type of it's argument.  <a href="#aeba419af1d4c23615eb844db37e46ee6">More...</a><br /></td></tr>
<tr class="separator:aeba419af1d4c23615eb844db37e46ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f85c3a1434551be3846414be3d1bdb9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a5f85c3a1434551be3846414be3d1bdb9">back_str</a>(x)&#160;&#160;&#160;<a class="el" href="colr_8h.html#a91fb398f6463553e576fc067f5a0a854">ColorArg_to_str</a>(<a class="el" href="colr_8h.html#aeba419af1d4c23615eb844db37e46ee6">back_arg</a>(x))</td></tr>
<tr class="memdesc:a5f85c3a1434551be3846414be3d1bdb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve just the escape code string for a back color.  <a href="#a5f85c3a1434551be3846414be3d1bdb9">More...</a><br /></td></tr>
<tr class="separator:a5f85c3a1434551be3846414be3d1bdb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653c1408c1d132a05a5648ffd53ca2c6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a653c1408c1d132a05a5648ffd53ca2c6">basic</a>(x)&#160;&#160;&#160;((enum BasicValue_t)(x))</td></tr>
<tr class="memdesc:a653c1408c1d132a05a5648ffd53ca2c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts to BasicValue.  <a href="#a653c1408c1d132a05a5648ffd53ca2c6">More...</a><br /></td></tr>
<tr class="separator:a653c1408c1d132a05a5648ffd53ca2c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dbd4f0825e46d22010c39d92a5f6e60"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a7dbd4f0825e46d22010c39d92a5f6e60">bool_colr_enum</a>(x)&#160;&#160;&#160;(x &lt; 0 ? false: true)</td></tr>
<tr class="memdesc:a7dbd4f0825e46d22010c39d92a5f6e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the "truthiness" of the enums used in ColrC (BasicValue, ExtendedValue, StyleValue, ColorType, ArgType).  <a href="#a7dbd4f0825e46d22010c39d92a5f6e60">More...</a><br /></td></tr>
<tr class="separator:a7dbd4f0825e46d22010c39d92a5f6e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8903c150d5b0912b2f797f9235978f8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aa8903c150d5b0912b2f797f9235978f8">color_arg</a>(type,  x)</td></tr>
<tr class="memdesc:aa8903c150d5b0912b2f797f9235978f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a correct <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct according to the type of it's second argument.  <a href="#aa8903c150d5b0912b2f797f9235978f8">More...</a><br /></td></tr>
<tr class="separator:aa8903c150d5b0912b2f797f9235978f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a74a4af461e4aeacf99533a91c3fa0d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a4a74a4af461e4aeacf99533a91c3fa0d">color_name_is_basic</a>(x)&#160;&#160;&#160;(<a class="el" href="colr_8h.html#afa75deef059c002134a88dbbdc18fd49">ColorType_from_str</a>(x) == TYPE_BASIC)</td></tr>
<tr class="memdesc:a4a74a4af461e4aeacf99533a91c3fa0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro for checking if a color name is valid, and maps to a BasicValue.  <a href="#a4a74a4af461e4aeacf99533a91c3fa0d">More...</a><br /></td></tr>
<tr class="separator:a4a74a4af461e4aeacf99533a91c3fa0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631e5b639fc75363670dbd912c42abb3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a631e5b639fc75363670dbd912c42abb3">color_name_is_invalid</a>(x)&#160;&#160;&#160;<a class="el" href="colr_8h.html#adc223f6fda6296396e9ecddcc68d4aec">ColorType_is_invalid</a>(<a class="el" href="colr_8h.html#afa75deef059c002134a88dbbdc18fd49">ColorType_from_str</a>(x))</td></tr>
<tr class="memdesc:a631e5b639fc75363670dbd912c42abb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro for checking if a color name is invalid.  <a href="#a631e5b639fc75363670dbd912c42abb3">More...</a><br /></td></tr>
<tr class="separator:a631e5b639fc75363670dbd912c42abb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8da162275a03adc210cd90c0e2b923d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ad8da162275a03adc210cd90c0e2b923d">color_name_is_valid</a>(x)&#160;&#160;&#160;<a class="el" href="colr_8h.html#a5a5883d43e3206584ad048908720afb2">ColorType_is_valid</a>(<a class="el" href="colr_8h.html#afa75deef059c002134a88dbbdc18fd49">ColorType_from_str</a>(x))</td></tr>
<tr class="memdesc:ad8da162275a03adc210cd90c0e2b923d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro for checking if a color name is valid.  <a href="#ad8da162275a03adc210cd90c0e2b923d">More...</a><br /></td></tr>
<tr class="separator:ad8da162275a03adc210cd90c0e2b923d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb7445c534661e32283d2119beb45d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a4eb7445c534661e32283d2119beb45d6">color_val</a>(x)</td></tr>
<tr class="memdesc:a4eb7445c534661e32283d2119beb45d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a correct <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> struct according to the type of it's first argument.  <a href="#a4eb7445c534661e32283d2119beb45d6">More...</a><br /></td></tr>
<tr class="separator:a4eb7445c534661e32283d2119beb45d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1c77f81a0fd49f7895598cbd9ac76c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(text, ...)&#160;&#160;&#160;<a class="el" href="colr_8h.html#a8e04de932a4cf712ac91e794bdc3f8db">ColorText_to_ptr</a>(<a class="el" href="colr_8h.html#ad4702d6ddc409a93a0b42c8f6141d2f2">ColorText_from_values</a>(text, __VA_ARGS__, _ColrLastArg))</td></tr>
<tr class="memdesc:ade1c77f81a0fd49f7895598cbd9ac76c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a heap-allocated <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> struct that can be used by itself, or with the <a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2" title="Join ColorArg pointers, ColorText pointers, and strings into one long string. ">colr()</a> macro.  <a href="#ade1c77f81a0fd49f7895598cbd9ac76c">More...</a><br /></td></tr>
<tr class="separator:ade1c77f81a0fd49f7895598cbd9ac76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa52f88d230028534c63d4255ec4426c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aaa52f88d230028534c63d4255ec4426c">Colr_str</a>(text, ...)&#160;&#160;&#160;<a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2">colr</a>(<a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(text, __VA_ARGS__))</td></tr>
<tr class="memdesc:aaa52f88d230028534c63d4255ec4426c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an allocated string directly from <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr() macro...">Colr()</a> arguments.  <a href="#aaa52f88d230028534c63d4255ec4426c">More...</a><br /></td></tr>
<tr class="separator:aaa52f88d230028534c63d4255ec4426c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac52a4a5dbfd4f87ffd84e538eab9c29"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aac52a4a5dbfd4f87ffd84e538eab9c29">Colr_center</a>(text,  justwidth, ...)</td></tr>
<tr class="memdesc:aac52a4a5dbfd4f87ffd84e538eab9c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the JustifyMethod for a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> while allocating it.  <a href="#aac52a4a5dbfd4f87ffd84e538eab9c29">More...</a><br /></td></tr>
<tr class="separator:aac52a4a5dbfd4f87ffd84e538eab9c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373daeb0be048e4631ab04c445414362"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a373daeb0be048e4631ab04c445414362">Colr_ljust</a>(text,  justwidth, ...)</td></tr>
<tr class="memdesc:a373daeb0be048e4631ab04c445414362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the JustifyMethod for a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> while allocating it.  <a href="#a373daeb0be048e4631ab04c445414362">More...</a><br /></td></tr>
<tr class="separator:a373daeb0be048e4631ab04c445414362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba613f3915a178c3eb981e072d53ef72"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aba613f3915a178c3eb981e072d53ef72">Colr_rjust</a>(text,  justwidth, ...)</td></tr>
<tr class="memdesc:aba613f3915a178c3eb981e072d53ef72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the JustifyMethod for a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> while allocating it.  <a href="#aba613f3915a178c3eb981e072d53ef72">More...</a><br /></td></tr>
<tr class="separator:aba613f3915a178c3eb981e072d53ef72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429998ab7c120490f34921c35e1d76d2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2">colr</a>(...)&#160;&#160;&#160;<a class="el" href="colr_8h.html#a25670add558019fdb66a60d51f0ffbda">_colr</a>(__VA_ARGS__, _ColrLastArg)</td></tr>
<tr class="memdesc:a429998ab7c120490f34921c35e1d76d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointers, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointers, and strings into one long string.  <a href="#a429998ab7c120490f34921c35e1d76d2">More...</a><br /></td></tr>
<tr class="separator:a429998ab7c120490f34921c35e1d76d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36af8aa0f01eaa780da182e856923faa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a36af8aa0f01eaa780da182e856923faa">colr_eq</a>(a,  b)</td></tr>
<tr class="memdesc:a36af8aa0f01eaa780da182e856923faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the &lt;type&gt;_eq functions for the supported types.  <a href="#a36af8aa0f01eaa780da182e856923faa">More...</a><br /></td></tr>
<tr class="separator:a36af8aa0f01eaa780da182e856923faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76eae619668e01987653932a7492fd94"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a76eae619668e01987653932a7492fd94">colr_free</a>(x)</td></tr>
<tr class="memdesc:a76eae619668e01987653932a7492fd94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the &lt;type&gt;_free functions for the supported types.  <a href="#a76eae619668e01987653932a7492fd94">More...</a><br /></td></tr>
<tr class="separator:a76eae619668e01987653932a7492fd94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0819ea3109493d7fe1656a7cadaca7d5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a0819ea3109493d7fe1656a7cadaca7d5">colr_is_empty</a>(x)</td></tr>
<tr class="memdesc:a0819ea3109493d7fe1656a7cadaca7d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the &lt;type&gt;is_empty functions for the supported types.  <a href="#a0819ea3109493d7fe1656a7cadaca7d5">More...</a><br /></td></tr>
<tr class="separator:a0819ea3109493d7fe1656a7cadaca7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2982e773789d3f819036212694afed5e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a2982e773789d3f819036212694afed5e">colr_is_invalid</a>(x)</td></tr>
<tr class="memdesc:a2982e773789d3f819036212694afed5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the &lt;type&gt;is_invalid functions for the supported types.  <a href="#a2982e773789d3f819036212694afed5e">More...</a><br /></td></tr>
<tr class="separator:a2982e773789d3f819036212694afed5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8909ecf2f0be1bbc70ab33667578134e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a8909ecf2f0be1bbc70ab33667578134e">colr_is_valid</a>(x)</td></tr>
<tr class="memdesc:a8909ecf2f0be1bbc70ab33667578134e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the &lt;type&gt;is_valid functions for the supported types.  <a href="#a8909ecf2f0be1bbc70ab33667578134e">More...</a><br /></td></tr>
<tr class="separator:a8909ecf2f0be1bbc70ab33667578134e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b56172c3a4f77092b0b476359a2a746"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a3b56172c3a4f77092b0b476359a2a746">colr_istr_either</a>(s1,  s2,  s3)&#160;&#160;&#160;((s1 &amp;&amp; s2 &amp;&amp; s3) ? (<a class="el" href="colr_8h.html#a2e6c31c3ae1ebaec998e526d0cc38abb">colr_istreq</a>(s1, s2) || <a class="el" href="colr_8h.html#a2e6c31c3ae1ebaec998e526d0cc38abb">colr_istreq</a>(s1, s3)) : 0)</td></tr>
<tr class="memdesc:a3b56172c3a4f77092b0b476359a2a746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro for <code>!strcasecmp(s1, s2) || !strcasecmp(s1, s3)</code>.  <a href="#a3b56172c3a4f77092b0b476359a2a746">More...</a><br /></td></tr>
<tr class="separator:a3b56172c3a4f77092b0b476359a2a746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6c31c3ae1ebaec998e526d0cc38abb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a2e6c31c3ae1ebaec998e526d0cc38abb">colr_istreq</a>(s1,  s2)&#160;&#160;&#160;((s1 &amp;&amp; s2) ? !strcasecmp(s1, s2) : 0)</td></tr>
<tr class="memdesc:a2e6c31c3ae1ebaec998e526d0cc38abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro for <code>!strcasecmp(s1, s2)</code>.  <a href="#a2e6c31c3ae1ebaec998e526d0cc38abb">More...</a><br /></td></tr>
<tr class="separator:a2e6c31c3ae1ebaec998e526d0cc38abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8cc35d2d3a15c9c22ebb0a0835c92f0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0">colr_join</a>(joiner, ...)&#160;&#160;&#160;<a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join</a>(joiner, __VA_ARGS__, _ColrLastArg)</td></tr>
<tr class="memdesc:ae8cc35d2d3a15c9c22ebb0a0835c92f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointers, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointers, and strings by another <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointer, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointer, or string.  <a href="#ae8cc35d2d3a15c9c22ebb0a0835c92f0">More...</a><br /></td></tr>
<tr class="separator:ae8cc35d2d3a15c9c22ebb0a0835c92f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2011f1f6c35bc63ca0cb23b9b893f61"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#af2011f1f6c35bc63ca0cb23b9b893f61">colr_max</a>(a,  b)&#160;&#160;&#160;(a &gt; b ? a : b)</td></tr>
<tr class="memdesc:af2011f1f6c35bc63ca0cb23b9b893f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for <code>(a &gt; b ? a : b)</code>.  <a href="#af2011f1f6c35bc63ca0cb23b9b893f61">More...</a><br /></td></tr>
<tr class="separator:af2011f1f6c35bc63ca0cb23b9b893f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4559cb7ed508a538687727ccd4586ccb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a4559cb7ed508a538687727ccd4586ccb">colr_replace</a>(s,  target,  repl)</td></tr>
<tr class="memdesc:a4559cb7ed508a538687727ccd4586ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a substring in <code>s</code> with another string, <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> string, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> string.  <a href="#a4559cb7ed508a538687727ccd4586ccb">More...</a><br /></td></tr>
<tr class="separator:a4559cb7ed508a538687727ccd4586ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ef824dd213274fb239526269315543"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ac1ef824dd213274fb239526269315543">colr_repr</a>(x)</td></tr>
<tr class="memdesc:ac1ef824dd213274fb239526269315543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms several ColrC objects into their string representations.  <a href="#ac1ef824dd213274fb239526269315543">More...</a><br /></td></tr>
<tr class="separator:ac1ef824dd213274fb239526269315543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3efb8eb9314481b0692a75079e4a3f4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aa3efb8eb9314481b0692a75079e4a3f4">colr_str_eq</a>(s1,  s2)&#160;&#160;&#160;((s1 &amp;&amp; s2) ? !strcmp(s1, s2) : 0)</td></tr>
<tr class="memdesc:aa3efb8eb9314481b0692a75079e4a3f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro for <code>!strcmp(s1, s2)</code>.  <a href="#aa3efb8eb9314481b0692a75079e4a3f4">More...</a><br /></td></tr>
<tr class="separator:aa3efb8eb9314481b0692a75079e4a3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeaf33a4617bbd5de036a160d784fb83"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#afeaf33a4617bbd5de036a160d784fb83">colr_str_either</a>(s1,  s2,  s3)&#160;&#160;&#160;(<a class="el" href="colr_8h.html#aa3efb8eb9314481b0692a75079e4a3f4">colr_str_eq</a>(s1, s2) || <a class="el" href="colr_8h.html#aa3efb8eb9314481b0692a75079e4a3f4">colr_str_eq</a>(s1, s3))</td></tr>
<tr class="memdesc:afeaf33a4617bbd5de036a160d784fb83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro for <code>!strcmp(s1, s2) || !strcmp(s1, s3)</code>.  <a href="#afeaf33a4617bbd5de036a160d784fb83">More...</a><br /></td></tr>
<tr class="separator:afeaf33a4617bbd5de036a160d784fb83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790e5a9bd0b3ca7cd7d428007f6a21b9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a790e5a9bd0b3ca7cd7d428007f6a21b9">colr_to_str</a>(x)</td></tr>
<tr class="memdesc:a790e5a9bd0b3ca7cd7d428007f6a21b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the &lt;type&gt;to_str functions for the supported types.  <a href="#a790e5a9bd0b3ca7cd7d428007f6a21b9">More...</a><br /></td></tr>
<tr class="separator:a790e5a9bd0b3ca7cd7d428007f6a21b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69ec39944a786ba43206120851fa856"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ac69ec39944a786ba43206120851fa856">dbug_repr</a>(lbl,  x)</td></tr>
<tr class="memdesc:ac69ec39944a786ba43206120851fa856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses <a class="el" href="colr_8h.html#ac1ef824dd213274fb239526269315543" title="Transforms several ColrC objects into their string representations. ">colr_repr()</a> to build a string representation of a ColrC object, dbug prints it, and calls free() when it's done.  <a href="#ac69ec39944a786ba43206120851fa856">More...</a><br /></td></tr>
<tr class="separator:ac69ec39944a786ba43206120851fa856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ff4fc6d17b53b60202be55bd0732c5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a37ff4fc6d17b53b60202be55bd0732c5">ext</a>(x)&#160;&#160;&#160;((<a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>)x)</td></tr>
<tr class="memdesc:a37ff4fc6d17b53b60202be55bd0732c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts to ExtendedValue (unsigned char).  <a href="#a37ff4fc6d17b53b60202be55bd0732c5">More...</a><br /></td></tr>
<tr class="separator:a37ff4fc6d17b53b60202be55bd0732c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c79297600d8ab15a495843d63db54d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aa3c79297600d8ab15a495843d63db54d">ext_hex</a>(s)&#160;&#160;&#160;<a class="el" href="colr_8h.html#affaeebdd3dad2cf0d5e14a7870c1e4f6">ext_hex_or</a>(s, <a class="el" href="colr_8h.html#a37ff4fc6d17b53b60202be55bd0732c5">ext</a>(0))</td></tr>
<tr class="memdesc:aa3c79297600d8ab15a495843d63db54d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="colr_8h.html#a8fe812f8e76e4baed394ee9adf46b3df" title="Use RGB_from_hex_default() to create an RGB value. ">hex()</a>, but force a conversion to the closest ExtendedValue (256-colors).  <a href="#aa3c79297600d8ab15a495843d63db54d">More...</a><br /></td></tr>
<tr class="separator:aa3c79297600d8ab15a495843d63db54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affaeebdd3dad2cf0d5e14a7870c1e4f6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#affaeebdd3dad2cf0d5e14a7870c1e4f6">ext_hex_or</a>(s,  default_value)&#160;&#160;&#160;<a class="el" href="colr_8h.html#a757be189530b4925c84df25742374485">ExtendedValue_from_hex_default</a>(s, default_value)</td></tr>
<tr class="memdesc:affaeebdd3dad2cf0d5e14a7870c1e4f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="colr_8h.html#ab55724d1f9877f698cf8591df92b8887" title="Use RGB_from_hex_default() to create an RGB value. ">hex_or()</a>, but force a conversion to the closest ExtendedValue (256-colors).  <a href="#affaeebdd3dad2cf0d5e14a7870c1e4f6">More...</a><br /></td></tr>
<tr class="separator:affaeebdd3dad2cf0d5e14a7870c1e4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3d47951e17cbf856902e11e4efa2e6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#add3d47951e17cbf856902e11e4efa2e6">ext_rgb</a>(r,  g,  b)&#160;&#160;&#160;<a class="el" href="colr_8h.html#a1548d9fc5f3e00a7b5d834eb1e12ff93">ExtendedValue_from_RGB</a>((<a class="el" href="colr_8h.html#structRGB">RGB</a>){.red=r, .green=g, .blue=b})</td></tr>
<tr class="memdesc:add3d47951e17cbf856902e11e4efa2e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the closest matching ExtendedValue from an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.  <a href="#add3d47951e17cbf856902e11e4efa2e6">More...</a><br /></td></tr>
<tr class="separator:add3d47951e17cbf856902e11e4efa2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d8b61303404007a3224be0f8296c3f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(x)&#160;&#160;&#160;<a class="el" href="colr_8h.html#afb5ac0bd012b8162cea125ad0d9e8bf0">ColorArg_to_ptr</a>(<a class="el" href="colr_8h.html#a3cc38de52ea52344113083ba4d90088e">fore_arg</a>(x))</td></tr>
<tr class="memdesc:a19d8b61303404007a3224be0f8296c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a fore color suitable for use with the <a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2" title="Join ColorArg pointers, ColorText pointers, and strings into one long string. ">colr()</a> and <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr() macro...">Colr()</a> macros.  <a href="#a19d8b61303404007a3224be0f8296c3f">More...</a><br /></td></tr>
<tr class="separator:a19d8b61303404007a3224be0f8296c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc38de52ea52344113083ba4d90088e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a3cc38de52ea52344113083ba4d90088e">fore_arg</a>(x)</td></tr>
<tr class="memdesc:a3cc38de52ea52344113083ba4d90088e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses ColorArg_from_&lt;type&gt; to build a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> with the appropriate color type, based on the type of it's argument.  <a href="#a3cc38de52ea52344113083ba4d90088e">More...</a><br /></td></tr>
<tr class="separator:a3cc38de52ea52344113083ba4d90088e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e27cd8b78fc357be02c4dbf6a6c9096"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a0e27cd8b78fc357be02c4dbf6a6c9096">fore_str</a>(x)&#160;&#160;&#160;<a class="el" href="colr_8h.html#a91fb398f6463553e576fc067f5a0a854">ColorArg_to_str</a>(<a class="el" href="colr_8h.html#a3cc38de52ea52344113083ba4d90088e">fore_arg</a>(x))</td></tr>
<tr class="memdesc:a0e27cd8b78fc357be02c4dbf6a6c9096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve just the escape code string for a fore color.  <a href="#a0e27cd8b78fc357be02c4dbf6a6c9096">More...</a><br /></td></tr>
<tr class="separator:a0e27cd8b78fc357be02c4dbf6a6c9096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe812f8e76e4baed394ee9adf46b3df"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a8fe812f8e76e4baed394ee9adf46b3df">hex</a>(s)&#160;&#160;&#160;<a class="el" href="colr_8h.html#ab55724d1f9877f698cf8591df92b8887">hex_or</a>(s, <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>(0, 0, 0))</td></tr>
<tr class="memdesc:a8fe812f8e76e4baed394ee9adf46b3df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use <a class="el" href="colr_8h.html#a6133112d9c73a8b56995e16e1af62d3b" title="Convert a hex color into an RGB value, but use a default value when errors occur. ...">RGB_from_hex_default()</a> to create an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.  <a href="#a8fe812f8e76e4baed394ee9adf46b3df">More...</a><br /></td></tr>
<tr class="separator:a8fe812f8e76e4baed394ee9adf46b3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55724d1f9877f698cf8591df92b8887"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab55724d1f9877f698cf8591df92b8887">hex_or</a>(s,  default_rgb)&#160;&#160;&#160;<a class="el" href="colr_8h.html#a6133112d9c73a8b56995e16e1af62d3b">RGB_from_hex_default</a>(s, default_rgb)</td></tr>
<tr class="memdesc:ab55724d1f9877f698cf8591df92b8887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use <a class="el" href="colr_8h.html#a6133112d9c73a8b56995e16e1af62d3b" title="Convert a hex color into an RGB value, but use a default value when errors occur. ...">RGB_from_hex_default()</a> to create an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.  <a href="#ab55724d1f9877f698cf8591df92b8887">More...</a><br /></td></tr>
<tr class="separator:ab55724d1f9877f698cf8591df92b8887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a08fc1383c7260a31698864d52fee2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a80a08fc1383c7260a31698864d52fee2">if_not_asprintf</a>(...)&#160;&#160;&#160;if (asprintf(__VA_ARGS__) &lt; 1)</td></tr>
<tr class="memdesc:a80a08fc1383c7260a31698864d52fee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro for checking asprintf's return value.  <a href="#a80a08fc1383c7260a31698864d52fee2">More...</a><br /></td></tr>
<tr class="separator:a80a08fc1383c7260a31698864d52fee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9abca97d7bc45876db1833e5c788a8c"><td class="memItemLeft" align="right" valign="top"><a id="ab9abca97d7bc45876db1833e5c788a8c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab9abca97d7bc45876db1833e5c788a8c">printferr</a>(...)&#160;&#160;&#160;fprintf(stderr, __VA_ARGS__)</td></tr>
<tr class="memdesc:ab9abca97d7bc45876db1833e5c788a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro for <code>fprintf(stderr, ...)</code>. <br /></td></tr>
<tr class="separator:ab9abca97d7bc45876db1833e5c788a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa7a1b0351d0bdbdf9fd5f882673d57"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>(r,  g,  b)&#160;&#160;&#160;((<a class="el" href="colr_8h.html#structRGB">RGB</a>){.red=r, .green=g, .blue=b})</td></tr>
<tr class="memdesc:a6fa7a1b0351d0bdbdf9fd5f882673d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an anonymous <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct for use in function calls.  <a href="#a6fa7a1b0351d0bdbdf9fd5f882673d57">More...</a><br /></td></tr>
<tr class="separator:a6fa7a1b0351d0bdbdf9fd5f882673d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1adf75633b342417b6a2dda3d9e8dcd3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a1adf75633b342417b6a2dda3d9e8dcd3">inline_str_lstrip_char</a>(dest,  s,  length,  c)</td></tr>
<tr class="memdesc:a1adf75633b342417b6a2dda3d9e8dcd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strip a leading character from a string, filling a <code>char</code> array with the result.  <a href="#a1adf75633b342417b6a2dda3d9e8dcd3">More...</a><br /></td></tr>
<tr class="separator:a1adf75633b342417b6a2dda3d9e8dcd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7592d374ee178fd8ac19d8dabbb83662"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662">style</a>(x)&#160;&#160;&#160;<a class="el" href="colr_8h.html#afb5ac0bd012b8162cea125ad0d9e8bf0">ColorArg_to_ptr</a>(<a class="el" href="colr_8h.html#a53683a9e279942578e46768be25587d0">style_arg</a>(x))</td></tr>
<tr class="memdesc:a7592d374ee178fd8ac19d8dabbb83662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a style suitable for use with the <a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2" title="Join ColorArg pointers, ColorText pointers, and strings into one long string. ">colr()</a> and <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr() macro...">Colr()</a> macros.  <a href="#a7592d374ee178fd8ac19d8dabbb83662">More...</a><br /></td></tr>
<tr class="separator:a7592d374ee178fd8ac19d8dabbb83662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53683a9e279942578e46768be25587d0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a53683a9e279942578e46768be25587d0">style_arg</a>(x)</td></tr>
<tr class="memdesc:a53683a9e279942578e46768be25587d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses ColorArg_from_StyleValue to build a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> with the appropriate color type/value.  <a href="#a53683a9e279942578e46768be25587d0">More...</a><br /></td></tr>
<tr class="separator:a53683a9e279942578e46768be25587d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab307d323b317da4b6f4d24ee1929b354"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab307d323b317da4b6f4d24ee1929b354">style_str</a>(x)&#160;&#160;&#160;<a class="el" href="colr_8h.html#a91fb398f6463553e576fc067f5a0a854">ColorArg_to_str</a>(<a class="el" href="colr_8h.html#a53683a9e279942578e46768be25587d0">style_arg</a>(x))</td></tr>
<tr class="memdesc:ab307d323b317da4b6f4d24ee1929b354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve just the escape code string for a style.  <a href="#ab307d323b317da4b6f4d24ee1929b354">More...</a><br /></td></tr>
<tr class="separator:ab307d323b317da4b6f4d24ee1929b354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d2ceec58f8075f06e09f277c8893ae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ad1d2ceec58f8075f06e09f277c8893ae">while_colr_va_arg</a>(ap,  vartype,  x)&#160;&#160;&#160;while (x = va_arg(ap, vartype), !<a class="el" href="colr_8h.html#af64af11f4992c8143cb722772df98c98">_colr_is_last_arg</a>(x))</td></tr>
<tr class="memdesc:ad1d2ceec58f8075f06e09f277c8893ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a while-loop over a <code>va_list</code>, where the last argument is expected to be _ColrLastArg, or a pointer to a _ColrLastArg_s with the same values as _ColrLastArg.  <a href="#ad1d2ceec58f8075f06e09f277c8893ae">More...</a><br /></td></tr>
<tr class="separator:ad1d2ceec58f8075f06e09f277c8893ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab60aea9412ba6fb6859bf0db474e366"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aab60aea9412ba6fb6859bf0db474e366">with_rgbs</a>()</td></tr>
<tr class="memdesc:aab60aea9412ba6fb6859bf0db474e366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over every possible rgb combination, 0-255 for red, green, and blue.  <a href="#aab60aea9412ba6fb6859bf0db474e366">More...</a><br /></td></tr>
<tr class="separator:aab60aea9412ba6fb6859bf0db474e366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb79141345fded0a55ee9aba354f567"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#afeb79141345fded0a55ee9aba354f567">EXTENDED_INVALID</a>&#160;&#160;&#160;<a class="el" href="colr_8h.html#aaaddb0f34c1374c29a8b7629ac40ca8b">COLOR_INVALID</a></td></tr>
<tr class="memdesc:afeb79141345fded0a55ee9aba354f567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for COLOR_INVALID.  <a href="#afeb79141345fded0a55ee9aba354f567">More...</a><br /></td></tr>
<tr class="separator:afeb79141345fded0a55ee9aba354f567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf65d4f2956611639be470c5313af423"><td class="memItemLeft" align="right" valign="top"><a id="aaf65d4f2956611639be470c5313af423"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aaf65d4f2956611639be470c5313af423">STYLE_MAX_VALUE</a>&#160;&#160;&#160;((enum StyleValue_t)OVERLINE)</td></tr>
<tr class="memdesc:aaf65d4f2956611639be470c5313af423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value allowed for a StyleValue. <br /></td></tr>
<tr class="separator:aaf65d4f2956611639be470c5313af423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad378024e623ea8fdd0a2b061e59b546d"><td class="memItemLeft" align="right" valign="top"><a id="ad378024e623ea8fdd0a2b061e59b546d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ad378024e623ea8fdd0a2b061e59b546d">STYLE_MIN_VALUE</a>&#160;&#160;&#160;((enum StyleValue_t)STYLE_INVALID)</td></tr>
<tr class="memdesc:ad378024e623ea8fdd0a2b061e59b546d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum value allowed for a StyleValue. <br /></td></tr>
<tr class="separator:ad378024e623ea8fdd0a2b061e59b546d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a6dda29f582a062546ef8733d8b7d8a94"><td class="memItemLeft" align="right" valign="top"><a id="a6dda29f582a062546ef8733d8b7d8a94"></a>
typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a></td></tr>
<tr class="memdesc:a6dda29f582a062546ef8733d8b7d8a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience <code>typedef</code> for clarity when dealing with extended (256) colors. <br /></td></tr>
<tr class="separator:a6dda29f582a062546ef8733d8b7d8a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc966460db21ff6c35f23fcf6abe541e"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#adc966460db21ff6c35f23fcf6abe541e">RGB_fmter</a>) (char *out, <a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:adc966460db21ff6c35f23fcf6abe541e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function type that knows how to fill a string with an rgb escape code.  <a href="#adc966460db21ff6c35f23fcf6abe541e">More...</a><br /></td></tr>
<tr class="separator:adc966460db21ff6c35f23fcf6abe541e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0adbdb9ade63e653eedf0fc1b7614493"><td class="memItemLeft" align="right" valign="top"><a id="a0adbdb9ade63e653eedf0fc1b7614493"></a>
typedef char *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a0adbdb9ade63e653eedf0fc1b7614493">rainbow_creator</a>) (const char *s, double freq, size_t offset)</td></tr>
<tr class="memdesc:a0adbdb9ade63e653eedf0fc1b7614493"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function type that knows how to create rainbowized text. <br /></td></tr>
<tr class="separator:a0adbdb9ade63e653eedf0fc1b7614493"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a0c061fbfddd43dfe324486dc86cb92ee"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> { <br />
&#160;&#160;<b>BASIC_INVALID</b> = COLOR_INVALID, 
<br />
&#160;&#160;<b>BASIC_NONE</b> = -1, 
<br />
&#160;&#160;<b>BLACK</b> = 0, 
<br />
&#160;&#160;<b>RED</b> = 1, 
<br />
&#160;&#160;<b>GREEN</b> = 2, 
<br />
&#160;&#160;<b>YELLOW</b> = 3, 
<br />
&#160;&#160;<b>BLUE</b> = 4, 
<br />
&#160;&#160;<b>MAGENTA</b> = 5, 
<br />
&#160;&#160;<b>CYAN</b> = 6, 
<br />
&#160;&#160;<b>WHITE</b> = 7, 
<br />
&#160;&#160;<b>UNUSED</b> = 8, 
<br />
&#160;&#160;<b>RESET</b> = 9, 
<br />
&#160;&#160;<b>LIGHTBLACK</b> = 10, 
<br />
&#160;&#160;<b>LIGHTRED</b> = 11, 
<br />
&#160;&#160;<b>LIGHTGREEN</b> = 12, 
<br />
&#160;&#160;<b>LIGHTYELLOW</b> = 13, 
<br />
&#160;&#160;<b>LIGHTBLUE</b> = 14, 
<br />
&#160;&#160;<b>LIGHTMAGENTA</b> = 15, 
<br />
&#160;&#160;<b>LIGHTCYAN</b> = 16, 
<br />
&#160;&#160;<b>LIGHTWHITE</b> = 17
<br />
 }<tr class="memdesc:a0c061fbfddd43dfe324486dc86cb92ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic color values, with a few convenience values for extended colors.  <a href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a0c061fbfddd43dfe324486dc86cb92ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85224ec2507f33b1985f4cdd0adfe0e6"><td class="memItemLeft" align="right" valign="top"><a id="a85224ec2507f33b1985f4cdd0adfe0e6"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a> { <br />
&#160;&#160;<b>STYLE_INVALID</b> = COLOR_INVALID, 
<br />
&#160;&#160;<b>STYLE_NONE</b> = -1, 
<br />
&#160;&#160;<b>RESET_ALL</b> = 0, 
<br />
&#160;&#160;<b>BRIGHT</b> = 1, 
<br />
&#160;&#160;<b>DIM</b> = 2, 
<br />
&#160;&#160;<b>ITALIC</b> = 3, 
<br />
&#160;&#160;<b>UNDERLINE</b> = 4, 
<br />
&#160;&#160;<b>FLASH</b> = 5, 
<br />
&#160;&#160;<b>HIGHLIGHT</b> = 7, 
<br />
&#160;&#160;<b>STRIKETHRU</b> = 9, 
<br />
&#160;&#160;<b>NORMAL</b> = 22, 
<br />
&#160;&#160;<b>FRAME</b> = 51, 
<br />
&#160;&#160;<b>ENCIRCLE</b> = 52, 
<br />
&#160;&#160;<b>OVERLINE</b> = 53
<br />
 }<tr class="memdesc:a85224ec2507f33b1985f4cdd0adfe0e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Style values. <br /></td></tr>
</td></tr>
<tr class="separator:a85224ec2507f33b1985f4cdd0adfe0e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d8da4a4f5529031f00c7a6b9eeb5e1"><td class="memItemLeft" align="right" valign="top"><a id="a58d8da4a4f5529031f00c7a6b9eeb5e1"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> { <br />
&#160;&#160;<b>ARGTYPE_NONE</b> = -1, 
<br />
&#160;&#160;<b>FORE</b> = 0, 
<br />
&#160;&#160;<b>BACK</b> = 1, 
<br />
&#160;&#160;<b>STYLE</b> = 2
<br />
 }<tr class="memdesc:a58d8da4a4f5529031f00c7a6b9eeb5e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Argument types (fore, back, style). <br /></td></tr>
</td></tr>
<tr class="separator:a58d8da4a4f5529031f00c7a6b9eeb5e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a3fe0b966f944fd659a98be170045f"><td class="memItemLeft" align="right" valign="top"><a id="af1a3fe0b966f944fd659a98be170045f"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#af1a3fe0b966f944fd659a98be170045f">ColorJustifyMethod</a> { <br />
&#160;&#160;<b>JUST_NONE</b> = -1, 
<br />
&#160;&#160;<b>JUST_LEFT</b> = 0, 
<br />
&#160;&#160;<b>JUST_RIGHT</b> = 1, 
<br />
&#160;&#160;<b>JUST_CENTER</b> = 2
<br />
 }<tr class="memdesc:af1a3fe0b966f944fd659a98be170045f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Justification style for ColorTexts. <br /></td></tr>
</td></tr>
<tr class="separator:af1a3fe0b966f944fd659a98be170045f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e133660cf9d4bcd1cb6a49e3ec16f83"><td class="memItemLeft" align="right" valign="top"><a id="a5e133660cf9d4bcd1cb6a49e3ec16f83"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> { <br />
&#160;&#160;<b>TYPE_NONE</b> = -6, 
<br />
&#160;&#160;<b>TYPE_INVALID_EXTENDED_RANGE</b> = -5, 
<br />
&#160;&#160;<b>TYPE_INVALID_RGB_RANGE</b> = -4, 
<br />
&#160;&#160;<b>TYPE_INVALID_STYLE</b> = -3, 
<br />
&#160;&#160;<b>TYPE_INVALID</b> = COLOR_INVALID, 
<br />
&#160;&#160;<b>TYPE_BASIC</b> = 0, 
<br />
&#160;&#160;<b>TYPE_EXTENDED</b> = 1, 
<br />
&#160;&#160;<b>TYPE_RGB</b> = 2, 
<br />
&#160;&#160;<b>TYPE_STYLE</b> = 3
<br />
 }<tr class="memdesc:a5e133660cf9d4bcd1cb6a49e3ec16f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Color/Style code types. Used with <a class="el" href="colr_8h.html#afa75deef059c002134a88dbbdc18fd49" title="Determine which type of color value is desired by name. ">ColorType_from_str()</a> and <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>. <br /></td></tr>
</td></tr>
<tr class="separator:a5e133660cf9d4bcd1cb6a49e3ec16f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a10030070daafdee7124638adfc5469d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a10030070daafdee7124638adfc5469d8">colr_append_reset</a> (char *s)</td></tr>
<tr class="memdesc:a10030070daafdee7124638adfc5469d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends CODE_RESET_ALL to a string (<code>char*</code>), but makes sure to do it before any newlines.  <a href="#a10030070daafdee7124638adfc5469d8">More...</a><br /></td></tr>
<tr class="separator:a10030070daafdee7124638adfc5469d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1ea562310969b7efa8711a843f103c"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a7f1ea562310969b7efa8711a843f103c">colr_char_escape_char</a> (const char c)</td></tr>
<tr class="memdesc:a7f1ea562310969b7efa8711a843f103c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the char needed to represent an escape sequence in C.  <a href="#a7f1ea562310969b7efa8711a843f103c">More...</a><br /></td></tr>
<tr class="separator:a7f1ea562310969b7efa8711a843f103c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2bef208b24ea5962b8e1af154772c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a7c2bef208b24ea5962b8e1af154772c1">colr_char_in_str</a> (const char c, const char *s)</td></tr>
<tr class="memdesc:a7c2bef208b24ea5962b8e1af154772c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a character exists in the given string (<code>char*</code>).  <a href="#a7c2bef208b24ea5962b8e1af154772c1">More...</a><br /></td></tr>
<tr class="separator:a7c2bef208b24ea5962b8e1af154772c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4fed7123927027262875834964b0a94"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab4fed7123927027262875834964b0a94">colr_char_is_code_end</a> (const char c)</td></tr>
<tr class="memdesc:ab4fed7123927027262875834964b0a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a character is suitable for an escape code ending.  <a href="#ab4fed7123927027262875834964b0a94">More...</a><br /></td></tr>
<tr class="separator:ab4fed7123927027262875834964b0a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d7418d0f38aa5d42c9cc2f7a06cdd5"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aa4d7418d0f38aa5d42c9cc2f7a06cdd5">colr_char_repr</a> (char x)</td></tr>
<tr class="memdesc:aa4d7418d0f38aa5d42c9cc2f7a06cdd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation for a char.  <a href="#aa4d7418d0f38aa5d42c9cc2f7a06cdd5">More...</a><br /></td></tr>
<tr class="separator:aa4d7418d0f38aa5d42c9cc2f7a06cdd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ef4700a46e78c2bed1132428a610fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a67ef4700a46e78c2bed1132428a610fb">colr_char_should_escape</a> (const char c)</td></tr>
<tr class="memdesc:a67ef4700a46e78c2bed1132428a610fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if an ascii character has an escape sequence in C.  <a href="#a67ef4700a46e78c2bed1132428a610fb">More...</a><br /></td></tr>
<tr class="separator:a67ef4700a46e78c2bed1132428a610fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330b20c743df488e74e70e6b0daef62a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a330b20c743df488e74e70e6b0daef62a">colr_check_marker</a> (unsigned int marker, void *p)</td></tr>
<tr class="memdesc:a330b20c743df488e74e70e6b0daef62a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks an unsigned int against the individual bytes behind a pointer's value.  <a href="#a330b20c743df488e74e70e6b0daef62a">More...</a><br /></td></tr>
<tr class="separator:a330b20c743df488e74e70e6b0daef62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8963c87ccb1c39bdd4481bb81810ba78"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a8963c87ccb1c39bdd4481bb81810ba78">colr_empty_str</a> (void)</td></tr>
<tr class="memdesc:a8963c87ccb1c39bdd4481bb81810ba78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates an empty string (<code>char*</code>).  <a href="#a8963c87ccb1c39bdd4481bb81810ba78">More...</a><br /></td></tr>
<tr class="separator:a8963c87ccb1c39bdd4481bb81810ba78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ebdcd3c6e598a244292c7605452e9d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab2ebdcd3c6e598a244292c7605452e9d">colr_supports_rgb</a> (void)</td></tr>
<tr class="memdesc:ab2ebdcd3c6e598a244292c7605452e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the current environment support <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> (True Colors).  <a href="#ab2ebdcd3c6e598a244292c7605452e9d">More...</a><br /></td></tr>
<tr class="separator:ab2ebdcd3c6e598a244292c7605452e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e3ecc4a6c4bcaad1217df9200d271e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ad5e3ecc4a6c4bcaad1217df9200d271e">colr_str_char_count</a> (const char *s, const char c)</td></tr>
<tr class="memdesc:ad5e3ecc4a6c4bcaad1217df9200d271e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of characters (<code>c</code>) that are found in a string (<code>char*</code>) (<code>s</code>).  <a href="#ad5e3ecc4a6c4bcaad1217df9200d271e">More...</a><br /></td></tr>
<tr class="separator:ad5e3ecc4a6c4bcaad1217df9200d271e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32382336586dbda9a7e205403de8a14"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ad32382336586dbda9a7e205403de8a14">colr_str_center</a> (const char *s, const char padchar, int width)</td></tr>
<tr class="memdesc:ad32382336586dbda9a7e205403de8a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Center-justifies a string (<code>char*</code>), ignoring escape codes when measuring the width.  <a href="#ad32382336586dbda9a7e205403de8a14">More...</a><br /></td></tr>
<tr class="separator:ad32382336586dbda9a7e205403de8a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578b0f213d7b24b3f3c00ff4d3f6e292"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a578b0f213d7b24b3f3c00ff4d3f6e292">colr_str_copy</a> (char *dest, const char *src, size_t length)</td></tr>
<tr class="memdesc:a578b0f213d7b24b3f3c00ff4d3f6e292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like strncopy, but ensures null-termination.  <a href="#a578b0f213d7b24b3f3c00ff4d3f6e292">More...</a><br /></td></tr>
<tr class="separator:a578b0f213d7b24b3f3c00ff4d3f6e292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1471df42416f87bb2d9c30655a19f3a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a1471df42416f87bb2d9c30655a19f3a0">colr_str_ends_with</a> (const char *s, const char *suffix)</td></tr>
<tr class="memdesc:a1471df42416f87bb2d9c30655a19f3a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if one string (<code>char*</code>) ends with another.  <a href="#a1471df42416f87bb2d9c30655a19f3a0">More...</a><br /></td></tr>
<tr class="separator:a1471df42416f87bb2d9c30655a19f3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9f4cbe1e806316e063206dfb610476"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a8b9f4cbe1e806316e063206dfb610476">colr_str_has_codes</a> (const char *s)</td></tr>
<tr class="memdesc:a8b9f4cbe1e806316e063206dfb610476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a string (<code>char*</code>) has ANSI escape codes in it.  <a href="#a8b9f4cbe1e806316e063206dfb610476">More...</a><br /></td></tr>
<tr class="separator:a8b9f4cbe1e806316e063206dfb610476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc3f370843b64e92fb7d79e7989b5c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a3dc3f370843b64e92fb7d79e7989b5c3">colr_str_is_all</a> (const char *s, const char c)</td></tr>
<tr class="memdesc:a3dc3f370843b64e92fb7d79e7989b5c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a string (<code>char*</code>) consists of only one character, possibly repeated.  <a href="#a3dc3f370843b64e92fb7d79e7989b5c3">More...</a><br /></td></tr>
<tr class="separator:a3dc3f370843b64e92fb7d79e7989b5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b2971301b5247769b08f5ed08564fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a85b2971301b5247769b08f5ed08564fb">colr_str_is_codes</a> (const char *s)</td></tr>
<tr class="memdesc:a85b2971301b5247769b08f5ed08564fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a string (<code>char*</code>) is composed entirely of escape codes.  <a href="#a85b2971301b5247769b08f5ed08564fb">More...</a><br /></td></tr>
<tr class="separator:a85b2971301b5247769b08f5ed08564fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5492da225ade4fd8fe71989826348b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#af5492da225ade4fd8fe71989826348b4">colr_str_is_digits</a> (const char *s)</td></tr>
<tr class="memdesc:af5492da225ade4fd8fe71989826348b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all characters in a string (<code>char*</code>) are digits.  <a href="#af5492da225ade4fd8fe71989826348b4">More...</a><br /></td></tr>
<tr class="separator:af5492da225ade4fd8fe71989826348b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8be0d81828f73816a447b7440987d91"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ac8be0d81828f73816a447b7440987d91">colr_str_ljust</a> (const char *s, const char padchar, int width)</td></tr>
<tr class="memdesc:ac8be0d81828f73816a447b7440987d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-justifies a string (<code>char*</code>), ignoring escape codes when measuring the width.  <a href="#ac8be0d81828f73816a447b7440987d91">More...</a><br /></td></tr>
<tr class="separator:ac8be0d81828f73816a447b7440987d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116ec26960e79456dbf9cf7f40ffe0d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a116ec26960e79456dbf9cf7f40ffe0d7">colr_str_lower</a> (char *s)</td></tr>
<tr class="memdesc:a116ec26960e79456dbf9cf7f40ffe0d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string (<code>char*</code>) into lower case in place.  <a href="#a116ec26960e79456dbf9cf7f40ffe0d7">More...</a><br /></td></tr>
<tr class="separator:a116ec26960e79456dbf9cf7f40ffe0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab00c551514ec181b50628b8cc80e5527"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab00c551514ec181b50628b8cc80e5527">colr_str_lstrip_chars</a> (const char *s, const char *chars)</td></tr>
<tr class="memdesc:ab00c551514ec181b50628b8cc80e5527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes certain characters from the start of a string (<code>char*</code>).  <a href="#ab00c551514ec181b50628b8cc80e5527">More...</a><br /></td></tr>
<tr class="separator:ab00c551514ec181b50628b8cc80e5527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab473f70278850994e1b7b9c8008353fa"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab473f70278850994e1b7b9c8008353fa">colr_str_mb_len</a> (const char *s)</td></tr>
<tr class="memdesc:ab473f70278850994e1b7b9c8008353fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of characters in a string (<code>char*</code>), taking into account possibly multi-byte characters.  <a href="#ab473f70278850994e1b7b9c8008353fa">More...</a><br /></td></tr>
<tr class="separator:ab473f70278850994e1b7b9c8008353fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037a0245a39d7ff5cfba5f779d0eb251"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a037a0245a39d7ff5cfba5f779d0eb251">colr_str_noncode_len</a> (const char *s)</td></tr>
<tr class="memdesc:a037a0245a39d7ff5cfba5f779d0eb251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of string (<code>char*</code>), ignoring escape codes and the the null-terminator.  <a href="#a037a0245a39d7ff5cfba5f779d0eb251">More...</a><br /></td></tr>
<tr class="separator:a037a0245a39d7ff5cfba5f779d0eb251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29047496628c944048314c83f9415a5b"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a29047496628c944048314c83f9415a5b">colr_str_replace</a> (char *s, const char *target, const char *repl)</td></tr>
<tr class="memdesc:a29047496628c944048314c83f9415a5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces substrings in a string (<code>char*</code>).  <a href="#a29047496628c944048314c83f9415a5b">More...</a><br /></td></tr>
<tr class="separator:a29047496628c944048314c83f9415a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d236bca80dbce495c0f282c3a7d192"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a44d236bca80dbce495c0f282c3a7d192">colr_str_replace_ColorArg</a> (char *s, const char *target, const <a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *repl)</td></tr>
<tr class="memdesc:a44d236bca80dbce495c0f282c3a7d192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace substrings in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string result.  <a href="#a44d236bca80dbce495c0f282c3a7d192">More...</a><br /></td></tr>
<tr class="separator:a44d236bca80dbce495c0f282c3a7d192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec6d96305890148b019602f2301f989"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a7ec6d96305890148b019602f2301f989">colr_str_replace_ColorText</a> (char *s, const char *target, const <a class="el" href="colr_8h.html#structColorText">ColorText</a> *repl)</td></tr>
<tr class="memdesc:a7ec6d96305890148b019602f2301f989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace substrings in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string result.  <a href="#a7ec6d96305890148b019602f2301f989">More...</a><br /></td></tr>
<tr class="separator:a7ec6d96305890148b019602f2301f989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196ad91a69cfbeb27a5266ffc93ed353"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a196ad91a69cfbeb27a5266ffc93ed353">colr_str_repr</a> (const char *s)</td></tr>
<tr class="memdesc:a196ad91a69cfbeb27a5266ffc93ed353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string (<code>char*</code>) into a representation of a string, by wrapping it in quotes and escaping characters that need escaping.  <a href="#a196ad91a69cfbeb27a5266ffc93ed353">More...</a><br /></td></tr>
<tr class="separator:a196ad91a69cfbeb27a5266ffc93ed353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fbaa15923af761c5eb99224ef8089b4"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a8fbaa15923af761c5eb99224ef8089b4">colr_str_rjust</a> (const char *s, const char padchar, int width)</td></tr>
<tr class="memdesc:a8fbaa15923af761c5eb99224ef8089b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right-justifies a string (<code>char*</code>), ignoring escape codes when measuring the width.  <a href="#a8fbaa15923af761c5eb99224ef8089b4">More...</a><br /></td></tr>
<tr class="separator:a8fbaa15923af761c5eb99224ef8089b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f001f49e15a8c38e0dc3c6c6c1bb06c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a7f001f49e15a8c38e0dc3c6c6c1bb06c">colr_str_starts_with</a> (const char *s, const char *prefix)</td></tr>
<tr class="memdesc:a7f001f49e15a8c38e0dc3c6c6c1bb06c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a string (<code>char*</code>) for a certain prefix substring.  <a href="#a7f001f49e15a8c38e0dc3c6c6c1bb06c">More...</a><br /></td></tr>
<tr class="separator:a7f001f49e15a8c38e0dc3c6c6c1bb06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b13b04dc178d0990ab2ae403ee64e0"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab0b13b04dc178d0990ab2ae403ee64e0">colr_str_strip_codes</a> (const char *s)</td></tr>
<tr class="memdesc:ab0b13b04dc178d0990ab2ae403ee64e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strips escape codes from a string (<code>char*</code>), resulting in a new allocated string.  <a href="#ab0b13b04dc178d0990ab2ae403ee64e0">More...</a><br /></td></tr>
<tr class="separator:ab0b13b04dc178d0990ab2ae403ee64e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b847e10db135f7ebc89031b3a7ad56"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ae9b847e10db135f7ebc89031b3a7ad56">colr_str_to_lower</a> (const char *s)</td></tr>
<tr class="memdesc:ae9b847e10db135f7ebc89031b3a7ad56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new lowercase version of a string (<code>char*</code>).  <a href="#ae9b847e10db135f7ebc89031b3a7ad56">More...</a><br /></td></tr>
<tr class="separator:ae9b847e10db135f7ebc89031b3a7ad56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c11bb5b3b1bb2848bb16aee39763b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structTermSize">TermSize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ae4c11bb5b3b1bb2848bb16aee39763b2">colr_term_size</a> (void)</td></tr>
<tr class="memdesc:ae4c11bb5b3b1bb2848bb16aee39763b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to retrieve the row/column size of the terminal and returns a <a class="el" href="colr_8h.html#structTermSize" title="Holds a terminal size, usually retrieved with colr_term_size(). ">TermSize</a>.  <a href="#ae4c11bb5b3b1bb2848bb16aee39763b2">More...</a><br /></td></tr>
<tr class="separator:ae4c11bb5b3b1bb2848bb16aee39763b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d7b7bf1080742eeb588ba70ce9ea77"><td class="memItemLeft" align="right" valign="top">struct winsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ae7d7b7bf1080742eeb588ba70ce9ea77">colr_win_size</a> (void)</td></tr>
<tr class="memdesc:ae7d7b7bf1080742eeb588ba70ce9ea77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to retrieve a <code>winsize</code> struct from an <code>ioctl</code> call.  <a href="#ae7d7b7bf1080742eeb588ba70ce9ea77">More...</a><br /></td></tr>
<tr class="separator:ae7d7b7bf1080742eeb588ba70ce9ea77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2c53ebede7f97645f671401bfe356d"><td class="memItemLeft" align="right" valign="top">struct winsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#afc2c53ebede7f97645f671401bfe356d">colr_win_size_env</a> (void)</td></tr>
<tr class="memdesc:afc2c53ebede7f97645f671401bfe356d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get window/terminal size using the environment variables <code>LINES</code>, <code>COLUMNS</code>, or <code>COLS</code>.  <a href="#afc2c53ebede7f97645f671401bfe356d">More...</a><br /></td></tr>
<tr class="separator:afc2c53ebede7f97645f671401bfe356d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4853b53fa18d26741ab7178606e5724"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aa4853b53fa18d26741ab7178606e5724">format_bgx</a> (char *out, unsigned char num)</td></tr>
<tr class="memdesc:aa4853b53fa18d26741ab7178606e5724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for an extended background color.  <a href="#aa4853b53fa18d26741ab7178606e5724">More...</a><br /></td></tr>
<tr class="separator:aa4853b53fa18d26741ab7178606e5724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29032483aea8cb25d6b90750767ffc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ae29032483aea8cb25d6b90750767ffc1">format_bg</a> (char *out, <a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> value)</td></tr>
<tr class="memdesc:ae29032483aea8cb25d6b90750767ffc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for a background color.  <a href="#ae29032483aea8cb25d6b90750767ffc1">More...</a><br /></td></tr>
<tr class="separator:ae29032483aea8cb25d6b90750767ffc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a88e36717ca1e6a4892d2ffda1f4f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a15a88e36717ca1e6a4892d2ffda1f4f3">format_bg_rgb</a> (char *out, unsigned char red, unsigned char green, unsigned char blue)</td></tr>
<tr class="memdesc:a15a88e36717ca1e6a4892d2ffda1f4f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for a true color (rgb) background color.  <a href="#a15a88e36717ca1e6a4892d2ffda1f4f3">More...</a><br /></td></tr>
<tr class="separator:a15a88e36717ca1e6a4892d2ffda1f4f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97257ad40619df6a6c190890ff2873c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a97257ad40619df6a6c190890ff2873c4">format_bg_RGB</a> (char *out, <a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:a97257ad40619df6a6c190890ff2873c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for a true color (rgb) background color using values from an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct.  <a href="#a97257ad40619df6a6c190890ff2873c4">More...</a><br /></td></tr>
<tr class="separator:a97257ad40619df6a6c190890ff2873c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185cec167afe41b6401206659d2d406c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a185cec167afe41b6401206659d2d406c">format_bg_RGB_term</a> (char *out, <a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:a185cec167afe41b6401206659d2d406c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for a true color (rgb) fore color using an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct's values, approximating 256-color values.  <a href="#a185cec167afe41b6401206659d2d406c">More...</a><br /></td></tr>
<tr class="separator:a185cec167afe41b6401206659d2d406c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd2cf68768c59fc3ed5c31b93590c53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#acfd2cf68768c59fc3ed5c31b93590c53">format_fgx</a> (char *out, unsigned char num)</td></tr>
<tr class="memdesc:acfd2cf68768c59fc3ed5c31b93590c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for an extended fore color.  <a href="#acfd2cf68768c59fc3ed5c31b93590c53">More...</a><br /></td></tr>
<tr class="separator:acfd2cf68768c59fc3ed5c31b93590c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6027d93e8768f3c152edafd92e757801"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a6027d93e8768f3c152edafd92e757801">format_fg</a> (char *out, <a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> value)</td></tr>
<tr class="memdesc:a6027d93e8768f3c152edafd92e757801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for a fore color.  <a href="#a6027d93e8768f3c152edafd92e757801">More...</a><br /></td></tr>
<tr class="separator:a6027d93e8768f3c152edafd92e757801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1991134c0d649bdc57b86140b6c2b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aca1991134c0d649bdc57b86140b6c2b0">format_fg_rgb</a> (char *out, unsigned char red, unsigned char green, unsigned char blue)</td></tr>
<tr class="memdesc:aca1991134c0d649bdc57b86140b6c2b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for a true color (rgb) fore color.  <a href="#aca1991134c0d649bdc57b86140b6c2b0">More...</a><br /></td></tr>
<tr class="separator:aca1991134c0d649bdc57b86140b6c2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3391a0cd6b6f73d9d39f8179fc0eb0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aa3391a0cd6b6f73d9d39f8179fc0eb0b">format_fg_RGB</a> (char *out, <a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:aa3391a0cd6b6f73d9d39f8179fc0eb0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for a true color (rgb) fore color using an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct's values.  <a href="#aa3391a0cd6b6f73d9d39f8179fc0eb0b">More...</a><br /></td></tr>
<tr class="separator:aa3391a0cd6b6f73d9d39f8179fc0eb0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4661c576a4da879b8d4a2c525a42ad78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a4661c576a4da879b8d4a2c525a42ad78">format_fg_RGB_term</a> (char *out, <a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:a4661c576a4da879b8d4a2c525a42ad78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for a true color (rgb) fore color using an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct's values, approximating 256-color values.  <a href="#a4661c576a4da879b8d4a2c525a42ad78">More...</a><br /></td></tr>
<tr class="separator:a4661c576a4da879b8d4a2c525a42ad78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aec8e6a80b4ca158df2ad20e3e6a59e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a6aec8e6a80b4ca158df2ad20e3e6a59e">format_style</a> (char *out, <a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a> <a class="el" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662">style</a>)</td></tr>
<tr class="memdesc:a6aec8e6a80b4ca158df2ad20e3e6a59e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an escape code for a style.  <a href="#a6aec8e6a80b4ca158df2ad20e3e6a59e">More...</a><br /></td></tr>
<tr class="separator:a6aec8e6a80b4ca158df2ad20e3e6a59e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d16a274fbb779576396457264453873"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a7d16a274fbb779576396457264453873">_rainbow</a> (<a class="el" href="colr_8h.html#adc966460db21ff6c35f23fcf6abe541e">RGB_fmter</a> fmter, const char *s, double freq, size_t offset)</td></tr>
<tr class="memdesc:a7d16a274fbb779576396457264453873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles multi-byte character string (<code>char*</code>) conversion and character iteration for all of the rainbow_ functions.  <a href="#a7d16a274fbb779576396457264453873">More...</a><br /></td></tr>
<tr class="separator:a7d16a274fbb779576396457264453873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aed06cce3570d914738ce3f517e7ee9"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a7aed06cce3570d914738ce3f517e7ee9">rainbow_fg</a> (const char *s, double freq, size_t offset)</td></tr>
<tr class="memdesc:a7aed06cce3570d914738ce3f517e7ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rainbow-ize some text using rgb fore colors, lolcat style.  <a href="#a7aed06cce3570d914738ce3f517e7ee9">More...</a><br /></td></tr>
<tr class="separator:a7aed06cce3570d914738ce3f517e7ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa740f000c6d3ebe24734411e83125e37"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aa740f000c6d3ebe24734411e83125e37">rainbow_fg_term</a> (const char *s, double freq, size_t offset)</td></tr>
<tr class="memdesc:aa740f000c6d3ebe24734411e83125e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is exactly like <a class="el" href="colr_8c.html#a7aed06cce3570d914738ce3f517e7ee9" title="Rainbow-ize some text using rgb fore colors, lolcat style. ">rainbow_fg()</a>, except it uses colors that are closer to the standard 256-color values.  <a href="#aa740f000c6d3ebe24734411e83125e37">More...</a><br /></td></tr>
<tr class="separator:aa740f000c6d3ebe24734411e83125e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69dd994da51a57fc3cedb5ade591d5c1"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a69dd994da51a57fc3cedb5ade591d5c1">rainbow_bg</a> (const char *s, double freq, size_t offset)</td></tr>
<tr class="memdesc:a69dd994da51a57fc3cedb5ade591d5c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rainbow-ize some text using rgb back colors, lolcat style.  <a href="#a69dd994da51a57fc3cedb5ade591d5c1">More...</a><br /></td></tr>
<tr class="separator:a69dd994da51a57fc3cedb5ade591d5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab261b60d6d790f5a3c91883a1b6646a7"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab261b60d6d790f5a3c91883a1b6646a7">rainbow_bg_term</a> (const char *s, double freq, size_t offset)</td></tr>
<tr class="memdesc:ab261b60d6d790f5a3c91883a1b6646a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is exactly like <a class="el" href="colr_8c.html#a69dd994da51a57fc3cedb5ade591d5c1" title="Rainbow-ize some text using rgb back colors, lolcat style. ">rainbow_bg()</a>, except it uses colors that are closer to the standard 256-color values.  <a href="#ab261b60d6d790f5a3c91883a1b6646a7">More...</a><br /></td></tr>
<tr class="separator:ab261b60d6d790f5a3c91883a1b6646a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3580f33d058571dffd8e5ff789c49296"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a3580f33d058571dffd8e5ff789c49296">rainbow_step</a> (double freq, size_t offset)</td></tr>
<tr class="memdesc:a3580f33d058571dffd8e5ff789c49296"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single step in rainbow-izing produces the next color in the "rainbow" as an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.  <a href="#a3580f33d058571dffd8e5ff789c49296">More...</a><br /></td></tr>
<tr class="separator:a3580f33d058571dffd8e5ff789c49296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64af11f4992c8143cb722772df98c98"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#af64af11f4992c8143cb722772df98c98">_colr_is_last_arg</a> (void *p)</td></tr>
<tr class="memdesc:af64af11f4992c8143cb722772df98c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a void pointer is _ColrLastArg (the last-arg-marker).  <a href="#af64af11f4992c8143cb722772df98c98">More...</a><br /></td></tr>
<tr class="separator:af64af11f4992c8143cb722772df98c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0be451277fc7e39aee0aa409c9d3f0c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab0be451277fc7e39aee0aa409c9d3f0c">_colr_ptr_length</a> (void *p)</td></tr>
<tr class="memdesc:ab0be451277fc7e39aee0aa409c9d3f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size, in bytes, needed to convert a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, or string (<code>char*</code>) into a string.  <a href="#ab0be451277fc7e39aee0aa409c9d3f0c">More...</a><br /></td></tr>
<tr class="separator:ab0be451277fc7e39aee0aa409c9d3f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25670add558019fdb66a60d51f0ffbda"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a25670add558019fdb66a60d51f0ffbda">_colr</a> (void *p,...)</td></tr>
<tr class="memdesc:a25670add558019fdb66a60d51f0ffbda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joins ColorArgs, ColorTexts, and strings (<code>char*</code>) into one long string.  <a href="#a25670add558019fdb66a60d51f0ffbda">More...</a><br /></td></tr>
<tr class="separator:a25670add558019fdb66a60d51f0ffbda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70e1c4f6da5a46e6fcf838aed07885b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ad70e1c4f6da5a46e6fcf838aed07885b">_colr_size</a> (void *p, va_list args)</td></tr>
<tr class="memdesc:ad70e1c4f6da5a46e6fcf838aed07885b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse arguments, just as in <a class="el" href="colr_8c.html#a25670add558019fdb66a60d51f0ffbda" title="Joins ColorArgs, ColorTexts, and strings (char*) into one long string. ">_colr()</a>, but only return the length needed to allocate the resulting string.  <a href="#ad70e1c4f6da5a46e6fcf838aed07885b">More...</a><br /></td></tr>
<tr class="separator:ad70e1c4f6da5a46e6fcf838aed07885b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a051ef4cd2e7200a31f9de48766b4c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a91a051ef4cd2e7200a31f9de48766b4c">_colr_join_size</a> (void *joinerp, va_list args)</td></tr>
<tr class="memdesc:a91a051ef4cd2e7200a31f9de48766b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse arguments, just as in <a class="el" href="colr_8c.html#a4227a65824fdd699a25d3200706c9e9e" title="Joins ColorArgs, ColorTexts, and strings (char*) into one long string separated by it&#39;s first argumen...">_colr_join()</a>, but only return the size needed to allocate the resulting string.  <a href="#a91a051ef4cd2e7200a31f9de48766b4c">More...</a><br /></td></tr>
<tr class="separator:a91a051ef4cd2e7200a31f9de48766b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4227a65824fdd699a25d3200706c9e9e"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join</a> (void *joinerp,...)</td></tr>
<tr class="memdesc:a4227a65824fdd699a25d3200706c9e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joins ColorArgs, ColorTexts, and strings (<code>char*</code>) into one long string separated by it's first argument.  <a href="#a4227a65824fdd699a25d3200706c9e9e">More...</a><br /></td></tr>
<tr class="separator:a4227a65824fdd699a25d3200706c9e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d47ac6ee2a59e1c976cf2838545aa25"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a6d47ac6ee2a59e1c976cf2838545aa25">_colr_join_array_length</a> (void *ps)</td></tr>
<tr class="memdesc:a6d47ac6ee2a59e1c976cf2838545aa25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the length of a <code>NULL</code>-terminated array of strings (<code>char*</code>), ColorArgs, or ColorTexts.  <a href="#a6d47ac6ee2a59e1c976cf2838545aa25">More...</a><br /></td></tr>
<tr class="separator:a6d47ac6ee2a59e1c976cf2838545aa25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49c3a33d328ebaf2b0564d5a9b1d4ec"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ac49c3a33d328ebaf2b0564d5a9b1d4ec">_colr_join_arrayn_size</a> (void *joinerp, void *ps, size_t count)</td></tr>
<tr class="memdesc:ac49c3a33d328ebaf2b0564d5a9b1d4ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size in bytes needed to join an array of strings (<code>char*</code>), ColorArgs, or ColorTexts by another string (<code>char*</code>), <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.  <a href="#ac49c3a33d328ebaf2b0564d5a9b1d4ec">More...</a><br /></td></tr>
<tr class="separator:ac49c3a33d328ebaf2b0564d5a9b1d4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701126bd27c90fafa46152d9f9327b2f"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a701126bd27c90fafa46152d9f9327b2f">colr_join_array</a> (void *joinerp, void *ps)</td></tr>
<tr class="memdesc:a701126bd27c90fafa46152d9f9327b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join an array of strings (<code>char*</code>), ColorArgs, or ColorTexts by another string (<code>char*</code>), <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.  <a href="#a701126bd27c90fafa46152d9f9327b2f">More...</a><br /></td></tr>
<tr class="separator:a701126bd27c90fafa46152d9f9327b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71fcf08ad36d4424790e275d973445fc"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a71fcf08ad36d4424790e275d973445fc">colr_join_arrayn</a> (void *joinerp, void *ps, size_t count)</td></tr>
<tr class="memdesc:a71fcf08ad36d4424790e275d973445fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join an array of strings (<code>char*</code>), ColorArgs, or ColorTexts by another string (<code>char*</code>), <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.  <a href="#a71fcf08ad36d4424790e275d973445fc">More...</a><br /></td></tr>
<tr class="separator:a71fcf08ad36d4424790e275d973445fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01ccaf04c71fc2474da94b050236572"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ad01ccaf04c71fc2474da94b050236572">ArgType_repr</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type)</td></tr>
<tr class="memdesc:ad01ccaf04c71fc2474da94b050236572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation of a ArgType.  <a href="#ad01ccaf04c71fc2474da94b050236572">More...</a><br /></td></tr>
<tr class="separator:ad01ccaf04c71fc2474da94b050236572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b270bebb1a01212b7e44e52f61f94be"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a2b270bebb1a01212b7e44e52f61f94be">ArgType_to_str</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type)</td></tr>
<tr class="memdesc:a2b270bebb1a01212b7e44e52f61f94be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) from an ArgType.  <a href="#a2b270bebb1a01212b7e44e52f61f94be">More...</a><br /></td></tr>
<tr class="separator:a2b270bebb1a01212b7e44e52f61f94be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af838f8479681d809beb868b2e1b547e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#af838f8479681d809beb868b2e1b547e7">ColorArg_empty</a> (void)</td></tr>
<tr class="memdesc:af838f8479681d809beb868b2e1b547e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> with ARGTYPE_NONE and ColorValue.type.TYPE_NONE.  <a href="#af838f8479681d809beb868b2e1b547e7">More...</a><br /></td></tr>
<tr class="separator:af838f8479681d809beb868b2e1b547e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb62efc0182d6f6107055eeda961a628"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#acb62efc0182d6f6107055eeda961a628">ColorArg_eq</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> a, <a class="el" href="colr_8h.html#structColorArg">ColorArg</a> b)</td></tr>
<tr class="memdesc:acb62efc0182d6f6107055eeda961a628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> structs.  <a href="#acb62efc0182d6f6107055eeda961a628">More...</a><br /></td></tr>
<tr class="separator:acb62efc0182d6f6107055eeda961a628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1163a9c866767fb7fcb734d3c0d9b7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aa1163a9c866767fb7fcb734d3c0d9b7c">ColorArg_free</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *p)</td></tr>
<tr class="memdesc:aa1163a9c866767fb7fcb734d3c0d9b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free allocated memory for a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>.  <a href="#aa1163a9c866767fb7fcb734d3c0d9b7c">More...</a><br /></td></tr>
<tr class="separator:aa1163a9c866767fb7fcb734d3c0d9b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad49f4597388e6bdb896ff28334cd5e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aad49f4597388e6bdb896ff28334cd5e6">ColorArg_from_BasicValue</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type, <a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> value)</td></tr>
<tr class="memdesc:aad49f4597388e6bdb896ff28334cd5e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit version of ColorArg_from_value that only handles BasicValues.  <a href="#aad49f4597388e6bdb896ff28334cd5e6">More...</a><br /></td></tr>
<tr class="separator:aad49f4597388e6bdb896ff28334cd5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed30e2a4b30ab5e3cf49608a3c410cc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aed30e2a4b30ab5e3cf49608a3c410cc5">ColorArg_from_ExtendedValue</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type, <a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a> value)</td></tr>
<tr class="memdesc:aed30e2a4b30ab5e3cf49608a3c410cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit version of ColorArg_from_value that only handles ExtendedValues.  <a href="#aed30e2a4b30ab5e3cf49608a3c410cc5">More...</a><br /></td></tr>
<tr class="separator:aed30e2a4b30ab5e3cf49608a3c410cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa24bba74e99aa66ed41839576e57856"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aaa24bba74e99aa66ed41839576e57856">ColorArg_from_RGB</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type, <a class="el" href="colr_8h.html#structRGB">RGB</a> value)</td></tr>
<tr class="memdesc:aaa24bba74e99aa66ed41839576e57856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit version of ColorArg_from_value that only handles <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> structs.  <a href="#aaa24bba74e99aa66ed41839576e57856">More...</a><br /></td></tr>
<tr class="separator:aaa24bba74e99aa66ed41839576e57856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d897499fca87d7902159f4ed7dbba3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ae8d897499fca87d7902159f4ed7dbba3">ColorArg_from_str</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type, char *colorname)</td></tr>
<tr class="memdesc:ae8d897499fca87d7902159f4ed7dbba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> (fore, back, or style value) from a known color name/style.  <a href="#ae8d897499fca87d7902159f4ed7dbba3">More...</a><br /></td></tr>
<tr class="separator:ae8d897499fca87d7902159f4ed7dbba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf63bcee395dca3ca29dc324e3d7c8f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#acf63bcee395dca3ca29dc324e3d7c8f2">ColorArg_from_StyleValue</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type, <a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a> value)</td></tr>
<tr class="memdesc:acf63bcee395dca3ca29dc324e3d7c8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit version of ColorArg_from_value that only handles StyleValues.  <a href="#acf63bcee395dca3ca29dc324e3d7c8f2">More...</a><br /></td></tr>
<tr class="separator:acf63bcee395dca3ca29dc324e3d7c8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a5aa762bd5802872faf571aa32ea35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a89a5aa762bd5802872faf571aa32ea35">ColorArg_from_value</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type, <a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> colrtype, void *p)</td></tr>
<tr class="memdesc:a89a5aa762bd5802872faf571aa32ea35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used with the color_arg macro to dynamically create a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> based on it's argument type.  <a href="#a89a5aa762bd5802872faf571aa32ea35">More...</a><br /></td></tr>
<tr class="separator:a89a5aa762bd5802872faf571aa32ea35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752355c2d96d35688d3756558f8421ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a752355c2d96d35688d3756558f8421ba">ColorArg_is_empty</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> carg)</td></tr>
<tr class="memdesc:a752355c2d96d35688d3756558f8421ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> is an empty placeholder.  <a href="#a752355c2d96d35688d3756558f8421ba">More...</a><br /></td></tr>
<tr class="separator:a752355c2d96d35688d3756558f8421ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b4906cfb08588005536db1250dc899"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a66b4906cfb08588005536db1250dc899">ColorArg_is_invalid</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> carg)</td></tr>
<tr class="memdesc:a66b4906cfb08588005536db1250dc899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> holds an invalid value.  <a href="#a66b4906cfb08588005536db1250dc899">More...</a><br /></td></tr>
<tr class="separator:a66b4906cfb08588005536db1250dc899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15f3a714a6383123d3fb24ade173e29"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ad15f3a714a6383123d3fb24ade173e29">ColorArg_is_ptr</a> (void *p)</td></tr>
<tr class="memdesc:ad15f3a714a6383123d3fb24ade173e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a void pointer to see if it contains a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct.  <a href="#ad15f3a714a6383123d3fb24ade173e29">More...</a><br /></td></tr>
<tr class="separator:ad15f3a714a6383123d3fb24ade173e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e446f65d6987d52522a1755c909d421"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a1e446f65d6987d52522a1755c909d421">ColorArg_is_valid</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> carg)</td></tr>
<tr class="memdesc:a1e446f65d6987d52522a1755c909d421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> holds a valid value.  <a href="#a1e446f65d6987d52522a1755c909d421">More...</a><br /></td></tr>
<tr class="separator:a1e446f65d6987d52522a1755c909d421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaff727006f4c057aab75e55bfb473c4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#adaff727006f4c057aab75e55bfb473c4">ColorArg_length</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> carg)</td></tr>
<tr class="memdesc:adaff727006f4c057aab75e55bfb473c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length in bytes needed to allocate a string (<code>char*</code>) built with <a class="el" href="colr_8c.html#a91fb398f6463553e576fc067f5a0a854" title="Converts a ColorArg into an escape code string (char*). ">ColorArg_to_str()</a>.  <a href="#adaff727006f4c057aab75e55bfb473c4">More...</a><br /></td></tr>
<tr class="separator:adaff727006f4c057aab75e55bfb473c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af692f2357d46b9cee45bb114f2a4a2"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a5af692f2357d46b9cee45bb114f2a4a2">ColorArg_repr</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> carg)</td></tr>
<tr class="memdesc:a5af692f2357d46b9cee45bb114f2a4a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation for a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>.  <a href="#a5af692f2357d46b9cee45bb114f2a4a2">More...</a><br /></td></tr>
<tr class="separator:a5af692f2357d46b9cee45bb114f2a4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5ac0bd012b8162cea125ad0d9e8bf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#afb5ac0bd012b8162cea125ad0d9e8bf0">ColorArg_to_ptr</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> carg)</td></tr>
<tr class="memdesc:afb5ac0bd012b8162cea125ad0d9e8bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> into memory and returns the pointer.  <a href="#afb5ac0bd012b8162cea125ad0d9e8bf0">More...</a><br /></td></tr>
<tr class="separator:afb5ac0bd012b8162cea125ad0d9e8bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91fb398f6463553e576fc067f5a0a854"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a91fb398f6463553e576fc067f5a0a854">ColorArg_to_str</a> (<a class="el" href="colr_8h.html#structColorArg">ColorArg</a> carg)</td></tr>
<tr class="memdesc:a91fb398f6463553e576fc067f5a0a854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> into an escape code string (<code>char*</code>).  <a href="#a91fb398f6463553e576fc067f5a0a854">More...</a><br /></td></tr>
<tr class="separator:a91fb398f6463553e576fc067f5a0a854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11e9457ca4e8f5be0e29351b49b6844"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ae11e9457ca4e8f5be0e29351b49b6844">ColorJustify_empty</a> (void)</td></tr>
<tr class="memdesc:ae11e9457ca4e8f5be0e29351b49b6844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an "empty" <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a>, with JUST_NONE set.  <a href="#ae11e9457ca4e8f5be0e29351b49b6844">More...</a><br /></td></tr>
<tr class="separator:ae11e9457ca4e8f5be0e29351b49b6844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71656e616aef4bbb3c278d43c4a326e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab71656e616aef4bbb3c278d43c4a326e">ColorJustify_eq</a> (<a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a> a, <a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a> b)</td></tr>
<tr class="memdesc:ab71656e616aef4bbb3c278d43c4a326e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> structs.  <a href="#ab71656e616aef4bbb3c278d43c4a326e">More...</a><br /></td></tr>
<tr class="separator:ab71656e616aef4bbb3c278d43c4a326e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f193b6e6a20c63caecc1d9b53c89fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a34f193b6e6a20c63caecc1d9b53c89fb">ColorJustify_is_empty</a> (<a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a> cjust)</td></tr>
<tr class="memdesc:a34f193b6e6a20c63caecc1d9b53c89fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> is "empty".  <a href="#a34f193b6e6a20c63caecc1d9b53c89fb">More...</a><br /></td></tr>
<tr class="separator:a34f193b6e6a20c63caecc1d9b53c89fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4a7a21151993343ef96a068c6d5018"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a7d4a7a21151993343ef96a068c6d5018">ColorJustify_new</a> (<a class="el" href="colr_8h.html#af1a3fe0b966f944fd659a98be170045f">ColorJustifyMethod</a> method, int width, char padchar)</td></tr>
<tr class="memdesc:a7d4a7a21151993343ef96a068c6d5018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a>.  <a href="#a7d4a7a21151993343ef96a068c6d5018">More...</a><br /></td></tr>
<tr class="separator:a7d4a7a21151993343ef96a068c6d5018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c35f6b47cc737744487d14d20241656"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a6c35f6b47cc737744487d14d20241656">ColorJustify_repr</a> (<a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a> cjust)</td></tr>
<tr class="memdesc:a6c35f6b47cc737744487d14d20241656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation for a <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a>.  <a href="#a6c35f6b47cc737744487d14d20241656">More...</a><br /></td></tr>
<tr class="separator:a6c35f6b47cc737744487d14d20241656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf78eeb364553d130055d93e9892cd9c"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#adf78eeb364553d130055d93e9892cd9c">ColorJustifyMethod_repr</a> (<a class="el" href="colr_8h.html#af1a3fe0b966f944fd659a98be170045f">ColorJustifyMethod</a> meth)</td></tr>
<tr class="memdesc:adf78eeb364553d130055d93e9892cd9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation for a ColorJustifyMethod.  <a href="#adf78eeb364553d130055d93e9892cd9c">More...</a><br /></td></tr>
<tr class="separator:adf78eeb364553d130055d93e9892cd9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341b4033c31c58e412ff15280185c6bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorText">ColorText</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a341b4033c31c58e412ff15280185c6bd">ColorText_empty</a> (void)</td></tr>
<tr class="memdesc:a341b4033c31c58e412ff15280185c6bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an "empty" <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> with pointers set to <code>NULL</code>.  <a href="#a341b4033c31c58e412ff15280185c6bd">More...</a><br /></td></tr>
<tr class="separator:a341b4033c31c58e412ff15280185c6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901e5738358a739629cc3aaccab3e73f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a901e5738358a739629cc3aaccab3e73f">ColorText_free</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> *p)</td></tr>
<tr class="memdesc:a901e5738358a739629cc3aaccab3e73f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> and it's ColorArgs.  <a href="#a901e5738358a739629cc3aaccab3e73f">More...</a><br /></td></tr>
<tr class="separator:a901e5738358a739629cc3aaccab3e73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4702d6ddc409a93a0b42c8f6141d2f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorText">ColorText</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ad4702d6ddc409a93a0b42c8f6141d2f2">ColorText_from_values</a> (char *text,...)</td></tr>
<tr class="memdesc:ad4702d6ddc409a93a0b42c8f6141d2f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> from 1 mandatory string (<code>char*</code>), and optional fore, back, and style args (pointers to ColorArgs).  <a href="#ad4702d6ddc409a93a0b42c8f6141d2f2">More...</a><br /></td></tr>
<tr class="separator:ad4702d6ddc409a93a0b42c8f6141d2f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f65430500d003575c547eb667330b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a93f65430500d003575c547eb667330b0">ColorText_has_arg</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> ctext, <a class="el" href="colr_8h.html#structColorArg">ColorArg</a> carg)</td></tr>
<tr class="memdesc:a93f65430500d003575c547eb667330b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> has a certain <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> value set.  <a href="#a93f65430500d003575c547eb667330b0">More...</a><br /></td></tr>
<tr class="separator:a93f65430500d003575c547eb667330b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b38987063bb127bb34761961d7f678"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a93b38987063bb127bb34761961d7f678">ColorText_has_args</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> ctext)</td></tr>
<tr class="memdesc:a93b38987063bb127bb34761961d7f678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> has any argument values set.  <a href="#a93b38987063bb127bb34761961d7f678">More...</a><br /></td></tr>
<tr class="separator:a93b38987063bb127bb34761961d7f678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac846e583415e832b9090270020320b9f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ac846e583415e832b9090270020320b9f">ColorText_is_empty</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> ctext)</td></tr>
<tr class="memdesc:ac846e583415e832b9090270020320b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> has no usable values.  <a href="#ac846e583415e832b9090270020320b9f">More...</a><br /></td></tr>
<tr class="separator:ac846e583415e832b9090270020320b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6eb8832110b943c3a3a17627a50288"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a1d6eb8832110b943c3a3a17627a50288">ColorText_is_ptr</a> (void *p)</td></tr>
<tr class="memdesc:a1d6eb8832110b943c3a3a17627a50288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a void pointer to see if it contains a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> struct.  <a href="#a1d6eb8832110b943c3a3a17627a50288">More...</a><br /></td></tr>
<tr class="separator:a1d6eb8832110b943c3a3a17627a50288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412833a097b050c8ee99874c733bd030"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a412833a097b050c8ee99874c733bd030">ColorText_length</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> ctext)</td></tr>
<tr class="memdesc:a412833a097b050c8ee99874c733bd030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length in bytes needed to allocate a string (<code>char*</code>) built with <a class="el" href="colr_8c.html#ae305b33e0a44b956ccf4123aa4f1a033" title="Stringifies a ColorText struct, creating a mix of escape codes and text. ">ColorText_to_str()</a> with the current <code>text</code>, <code>fore</code>, <code>back</code>, and <code>style</code> members.  <a href="#a412833a097b050c8ee99874c733bd030">More...</a><br /></td></tr>
<tr class="separator:a412833a097b050c8ee99874c733bd030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575a6cdc2f65cf1cd25227f847ae8d76"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a575a6cdc2f65cf1cd25227f847ae8d76">ColorText_repr</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a>)</td></tr>
<tr class="memdesc:a575a6cdc2f65cf1cd25227f847ae8d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a string (<code>char*</code>) representation for a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.  <a href="#a575a6cdc2f65cf1cd25227f847ae8d76">More...</a><br /></td></tr>
<tr class="separator:a575a6cdc2f65cf1cd25227f847ae8d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab408d87cce896acccb75357acca8ade4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab408d87cce896acccb75357acca8ade4">ColorText_set_just</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> *ctext, <a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a> cjust)</td></tr>
<tr class="memdesc:ab408d87cce896acccb75357acca8ade4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> method for a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, and return the <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.  <a href="#ab408d87cce896acccb75357acca8ade4">More...</a><br /></td></tr>
<tr class="separator:ab408d87cce896acccb75357acca8ade4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880b39cd2ce9b622dbe7790a162d88f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a880b39cd2ce9b622dbe7790a162d88f7">ColorText_set_values</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> *ctext, char *text,...)</td></tr>
<tr class="memdesc:a880b39cd2ce9b622dbe7790a162d88f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an existing <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> from 1 mandatory string (<code>char*</code>), and optional fore, back, and style args (pointers to ColorArgs).  <a href="#a880b39cd2ce9b622dbe7790a162d88f7">More...</a><br /></td></tr>
<tr class="separator:a880b39cd2ce9b622dbe7790a162d88f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e04de932a4cf712ac91e794bdc3f8db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a8e04de932a4cf712ac91e794bdc3f8db">ColorText_to_ptr</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> ctext)</td></tr>
<tr class="memdesc:a8e04de932a4cf712ac91e794bdc3f8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> into allocated memory and returns the pointer.  <a href="#a8e04de932a4cf712ac91e794bdc3f8db">More...</a><br /></td></tr>
<tr class="separator:a8e04de932a4cf712ac91e794bdc3f8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae305b33e0a44b956ccf4123aa4f1a033"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ae305b33e0a44b956ccf4123aa4f1a033">ColorText_to_str</a> (<a class="el" href="colr_8h.html#structColorText">ColorText</a> ctext)</td></tr>
<tr class="memdesc:ae305b33e0a44b956ccf4123aa4f1a033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stringifies a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> struct, creating a mix of escape codes and text.  <a href="#ae305b33e0a44b956ccf4123aa4f1a033">More...</a><br /></td></tr>
<tr class="separator:ae305b33e0a44b956ccf4123aa4f1a033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e3483ae4add048424177fdc2b97b71"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a29e3483ae4add048424177fdc2b97b71">ColorType_eq</a> (<a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> a, <a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> b)</td></tr>
<tr class="memdesc:a29e3483ae4add048424177fdc2b97b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ColorTypes.  <a href="#a29e3483ae4add048424177fdc2b97b71">More...</a><br /></td></tr>
<tr class="separator:a29e3483ae4add048424177fdc2b97b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa75deef059c002134a88dbbdc18fd49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#afa75deef059c002134a88dbbdc18fd49">ColorType_from_str</a> (const char *arg)</td></tr>
<tr class="memdesc:afa75deef059c002134a88dbbdc18fd49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine which type of color value is desired by name.  <a href="#afa75deef059c002134a88dbbdc18fd49">More...</a><br /></td></tr>
<tr class="separator:afa75deef059c002134a88dbbdc18fd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc223f6fda6296396e9ecddcc68d4aec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#adc223f6fda6296396e9ecddcc68d4aec">ColorType_is_invalid</a> (<a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> type)</td></tr>
<tr class="memdesc:adc223f6fda6296396e9ecddcc68d4aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if a ColorType value is considered invalid.  <a href="#adc223f6fda6296396e9ecddcc68d4aec">More...</a><br /></td></tr>
<tr class="separator:adc223f6fda6296396e9ecddcc68d4aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5883d43e3206584ad048908720afb2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a5a5883d43e3206584ad048908720afb2">ColorType_is_valid</a> (<a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> type)</td></tr>
<tr class="memdesc:a5a5883d43e3206584ad048908720afb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if a ColorType value is considered valid.  <a href="#a5a5883d43e3206584ad048908720afb2">More...</a><br /></td></tr>
<tr class="separator:a5a5883d43e3206584ad048908720afb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a291ca6d28f9f430794413b76b7b094ed"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a291ca6d28f9f430794413b76b7b094ed">ColorType_repr</a> (<a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> type)</td></tr>
<tr class="memdesc:a291ca6d28f9f430794413b76b7b094ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation of a ColorType.  <a href="#a291ca6d28f9f430794413b76b7b094ed">More...</a><br /></td></tr>
<tr class="separator:a291ca6d28f9f430794413b76b7b094ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce7c54ad0e31ecf6d790c5770c2b66b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a5ce7c54ad0e31ecf6d790c5770c2b66b">ColorValue_empty</a> (void)</td></tr>
<tr class="memdesc:a5ce7c54ad0e31ecf6d790c5770c2b66b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an "empty" <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>.  <a href="#a5ce7c54ad0e31ecf6d790c5770c2b66b">More...</a><br /></td></tr>
<tr class="separator:a5ce7c54ad0e31ecf6d790c5770c2b66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf57e195301864cec80739e7e0f3000c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#adf57e195301864cec80739e7e0f3000c">ColorValue_eq</a> (<a class="el" href="colr_8h.html#structColorValue">ColorValue</a> a, <a class="el" href="colr_8h.html#structColorValue">ColorValue</a> b)</td></tr>
<tr class="memdesc:adf57e195301864cec80739e7e0f3000c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> structs.  <a href="#adf57e195301864cec80739e7e0f3000c">More...</a><br /></td></tr>
<tr class="separator:adf57e195301864cec80739e7e0f3000c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0cd3dca0ff796d69c1d6d02362079a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a4d0cd3dca0ff796d69c1d6d02362079a">ColorValue_from_str</a> (char *s)</td></tr>
<tr class="memdesc:a4d0cd3dca0ff796d69c1d6d02362079a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> from a known color name, or <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> string (<code>char*</code>).  <a href="#a4d0cd3dca0ff796d69c1d6d02362079a">More...</a><br /></td></tr>
<tr class="separator:a4d0cd3dca0ff796d69c1d6d02362079a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7fedbceb4f751d0d30034c0ef1dca8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aca7fedbceb4f751d0d30034c0ef1dca8">ColorValue_from_value</a> (<a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> type, void *p)</td></tr>
<tr class="memdesc:aca7fedbceb4f751d0d30034c0ef1dca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used with the color_val macro to dynamically create a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> based on it's argument type.  <a href="#aca7fedbceb4f751d0d30034c0ef1dca8">More...</a><br /></td></tr>
<tr class="separator:aca7fedbceb4f751d0d30034c0ef1dca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711a955406cde9716797bf61ab43a7a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a711a955406cde9716797bf61ab43a7a7">ColorValue_has_BasicValue</a> (<a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval, <a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> bval)</td></tr>
<tr class="memdesc:a711a955406cde9716797bf61ab43a7a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has a BasicValue set.  <a href="#a711a955406cde9716797bf61ab43a7a7">More...</a><br /></td></tr>
<tr class="separator:a711a955406cde9716797bf61ab43a7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11dc047d1defc4de2239a45667b45f85"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a11dc047d1defc4de2239a45667b45f85">ColorValue_has_ExtendedValue</a> (<a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval, <a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a> eval)</td></tr>
<tr class="memdesc:a11dc047d1defc4de2239a45667b45f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has a ExtendedValue set.  <a href="#a11dc047d1defc4de2239a45667b45f85">More...</a><br /></td></tr>
<tr class="separator:a11dc047d1defc4de2239a45667b45f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fbfa502deb1f2bb920b74b9f4867fcf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a3fbfa502deb1f2bb920b74b9f4867fcf">ColorValue_has_StyleValue</a> (<a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval, <a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a> sval)</td></tr>
<tr class="memdesc:a3fbfa502deb1f2bb920b74b9f4867fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has a StyleValue set.  <a href="#a3fbfa502deb1f2bb920b74b9f4867fcf">More...</a><br /></td></tr>
<tr class="separator:a3fbfa502deb1f2bb920b74b9f4867fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8188a8a68463d6de08bf9ed2a4debad5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a8188a8a68463d6de08bf9ed2a4debad5">ColorValue_has_RGB</a> (<a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval, <a class="el" href="colr_8h.html#structRGB">RGB</a> rgbval)</td></tr>
<tr class="memdesc:a8188a8a68463d6de08bf9ed2a4debad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has a <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value set.  <a href="#a8188a8a68463d6de08bf9ed2a4debad5">More...</a><br /></td></tr>
<tr class="separator:a8188a8a68463d6de08bf9ed2a4debad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48005bb1589a7ebeef413ccee2a7c2a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a48005bb1589a7ebeef413ccee2a7c2a1">ColorValue_is_empty</a> (<a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval)</td></tr>
<tr class="memdesc:a48005bb1589a7ebeef413ccee2a7c2a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> is an empty placeholder.  <a href="#a48005bb1589a7ebeef413ccee2a7c2a1">More...</a><br /></td></tr>
<tr class="separator:a48005bb1589a7ebeef413ccee2a7c2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22fcf30338eb777592421543885f74e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a22fcf30338eb777592421543885f74e0">ColorValue_is_invalid</a> (<a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval)</td></tr>
<tr class="memdesc:a22fcf30338eb777592421543885f74e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> holds an invalid value.  <a href="#a22fcf30338eb777592421543885f74e0">More...</a><br /></td></tr>
<tr class="separator:a22fcf30338eb777592421543885f74e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7183410b61d12a99dda3f76c2705497"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ac7183410b61d12a99dda3f76c2705497">ColorValue_is_valid</a> (<a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval)</td></tr>
<tr class="memdesc:ac7183410b61d12a99dda3f76c2705497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> holds a valid value.  <a href="#ac7183410b61d12a99dda3f76c2705497">More...</a><br /></td></tr>
<tr class="separator:ac7183410b61d12a99dda3f76c2705497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af891527249f068cfcef057313c522a42"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#af891527249f068cfcef057313c522a42">ColorValue_length</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type, <a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval)</td></tr>
<tr class="memdesc:af891527249f068cfcef057313c522a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length in bytes needed to allocate a string (<code>char*</code>) built with <a class="el" href="colr_8c.html#a3d9ca6bef0b8e7eac4812349ab5562cb" title="Converts a ColorValue into an escape code string (char*). ">ColorValue_to_str()</a> with the specified ArgType and <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>.  <a href="#af891527249f068cfcef057313c522a42">More...</a><br /></td></tr>
<tr class="separator:af891527249f068cfcef057313c522a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95cf6ab7c565726eeb7c276d734193f6"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a95cf6ab7c565726eeb7c276d734193f6">ColorValue_repr</a> (<a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval)</td></tr>
<tr class="memdesc:a95cf6ab7c565726eeb7c276d734193f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation of a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>.  <a href="#a95cf6ab7c565726eeb7c276d734193f6">More...</a><br /></td></tr>
<tr class="separator:a95cf6ab7c565726eeb7c276d734193f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9ca6bef0b8e7eac4812349ab5562cb"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a3d9ca6bef0b8e7eac4812349ab5562cb">ColorValue_to_str</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type, <a class="el" href="colr_8h.html#structColorValue">ColorValue</a> cval)</td></tr>
<tr class="memdesc:a3d9ca6bef0b8e7eac4812349ab5562cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> into an escape code string (<code>char*</code>).  <a href="#a3d9ca6bef0b8e7eac4812349ab5562cb">More...</a><br /></td></tr>
<tr class="separator:a3d9ca6bef0b8e7eac4812349ab5562cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17bf46ac385e41b729d07a65dd506cba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a17bf46ac385e41b729d07a65dd506cba">BasicValue_eq</a> (<a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> a, <a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> b)</td></tr>
<tr class="memdesc:a17bf46ac385e41b729d07a65dd506cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two BasicValues.  <a href="#a17bf46ac385e41b729d07a65dd506cba">More...</a><br /></td></tr>
<tr class="separator:a17bf46ac385e41b729d07a65dd506cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4163ac65dca3e222525808b80a40b733"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a4163ac65dca3e222525808b80a40b733">BasicValue_from_str</a> (const char *arg)</td></tr>
<tr class="memdesc:a4163ac65dca3e222525808b80a40b733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert named argument to an actual BasicValue enum value.  <a href="#a4163ac65dca3e222525808b80a40b733">More...</a><br /></td></tr>
<tr class="separator:a4163ac65dca3e222525808b80a40b733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a78ebb45cb53792d4c658bade99a70"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a71a78ebb45cb53792d4c658bade99a70">BasicValue_to_ansi</a> (<a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a> type, <a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> bval)</td></tr>
<tr class="memdesc:a71a78ebb45cb53792d4c658bade99a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a fore/back BasicValue to the actual 4bit ansi code number.  <a href="#a71a78ebb45cb53792d4c658bade99a70">More...</a><br /></td></tr>
<tr class="separator:a71a78ebb45cb53792d4c658bade99a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc0d9917621cab5b3efd162b7dc5a8c"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a1bc0d9917621cab5b3efd162b7dc5a8c">BasicValue_repr</a> (<a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> bval)</td></tr>
<tr class="memdesc:a1bc0d9917621cab5b3efd162b7dc5a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation of a BasicValue.  <a href="#a1bc0d9917621cab5b3efd162b7dc5a8c">More...</a><br /></td></tr>
<tr class="separator:a1bc0d9917621cab5b3efd162b7dc5a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac847d91a396ae6babc0bd46e6386a701"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ac847d91a396ae6babc0bd46e6386a701">ExtendedValue_eq</a> (<a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a> a, <a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a> b)</td></tr>
<tr class="memdesc:ac847d91a396ae6babc0bd46e6386a701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ExtendedValues.  <a href="#ac847d91a396ae6babc0bd46e6386a701">More...</a><br /></td></tr>
<tr class="separator:ac847d91a396ae6babc0bd46e6386a701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0632d78965000b1e50068a64e335133b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a0632d78965000b1e50068a64e335133b">ExtendedValue_from_hex</a> (const char *hexstr)</td></tr>
<tr class="memdesc:a0632d78965000b1e50068a64e335133b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an ExtendedValue from a hex string (<code>char*</code>).  <a href="#a0632d78965000b1e50068a64e335133b">More...</a><br /></td></tr>
<tr class="separator:a0632d78965000b1e50068a64e335133b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757be189530b4925c84df25742374485"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a757be189530b4925c84df25742374485">ExtendedValue_from_hex_default</a> (const char *hexstr, <a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a> default_value)</td></tr>
<tr class="memdesc:a757be189530b4925c84df25742374485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an ExtendedValue from a hex string (<code>char*</code>), but return a default value if the hex string is invalid.  <a href="#a757be189530b4925c84df25742374485">More...</a><br /></td></tr>
<tr class="separator:a757be189530b4925c84df25742374485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1548d9fc5f3e00a7b5d834eb1e12ff93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a1548d9fc5f3e00a7b5d834eb1e12ff93">ExtendedValue_from_RGB</a> (<a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:a1548d9fc5f3e00a7b5d834eb1e12ff93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value into the closest matching ExtendedValue.  <a href="#a1548d9fc5f3e00a7b5d834eb1e12ff93">More...</a><br /></td></tr>
<tr class="separator:a1548d9fc5f3e00a7b5d834eb1e12ff93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e859d542a8aa0939e4f76b1f33cb5f8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a2e859d542a8aa0939e4f76b1f33cb5f8">ExtendedValue_from_str</a> (const char *arg)</td></tr>
<tr class="memdesc:a2e859d542a8aa0939e4f76b1f33cb5f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a known name, integer string (0-255), or a hex string (<code>char*</code>), into an ExtendedValue suitable for the extended-value-based functions.  <a href="#a2e859d542a8aa0939e4f76b1f33cb5f8">More...</a><br /></td></tr>
<tr class="separator:a2e859d542a8aa0939e4f76b1f33cb5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa45baebc38756a40e7084f8198999902"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#aa45baebc38756a40e7084f8198999902">ExtendedValue_repr</a> (int eval)</td></tr>
<tr class="memdesc:aa45baebc38756a40e7084f8198999902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation of a ExtendedValue.  <a href="#aa45baebc38756a40e7084f8198999902">More...</a><br /></td></tr>
<tr class="separator:aa45baebc38756a40e7084f8198999902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e334d6b9145fca9717fe5a2aeb542fe"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a4e334d6b9145fca9717fe5a2aeb542fe">ExtendedValue_to_str</a> (<a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a> eval)</td></tr>
<tr class="memdesc:a4e334d6b9145fca9717fe5a2aeb542fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) from an ExtendedValue's actual value, suitable for use with <a class="el" href="colr_8c.html#a2e859d542a8aa0939e4f76b1f33cb5f8" title="Converts a known name, integer string (0-255), or a hex string (char*), into an ExtendedValue suitabl...">ExtendedValue_from_str()</a>.  <a href="#a4e334d6b9145fca9717fe5a2aeb542fe">More...</a><br /></td></tr>
<tr class="separator:a4e334d6b9145fca9717fe5a2aeb542fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32bf31475b0f6264b45438bd5c09ee7d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a32bf31475b0f6264b45438bd5c09ee7d">StyleValue_eq</a> (<a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a> a, <a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a> b)</td></tr>
<tr class="memdesc:a32bf31475b0f6264b45438bd5c09ee7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two StyleValues.  <a href="#a32bf31475b0f6264b45438bd5c09ee7d">More...</a><br /></td></tr>
<tr class="separator:a32bf31475b0f6264b45438bd5c09ee7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca63735ad2cbc6475d4af83dc7c1a9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a4ca63735ad2cbc6475d4af83dc7c1a9b">StyleValue_from_str</a> (const char *arg)</td></tr>
<tr class="memdesc:a4ca63735ad2cbc6475d4af83dc7c1a9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a named argument to actual StyleValue enum value.  <a href="#a4ca63735ad2cbc6475d4af83dc7c1a9b">More...</a><br /></td></tr>
<tr class="separator:a4ca63735ad2cbc6475d4af83dc7c1a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b74664587dd3c0e981603ee75c331b"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a24b74664587dd3c0e981603ee75c331b">StyleValue_repr</a> (<a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a> sval)</td></tr>
<tr class="memdesc:a24b74664587dd3c0e981603ee75c331b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation of a StyleValue.  <a href="#a24b74664587dd3c0e981603ee75c331b">More...</a><br /></td></tr>
<tr class="separator:a24b74664587dd3c0e981603ee75c331b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b5f73b8aa9d72216d7386221418ae1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ad4b5f73b8aa9d72216d7386221418ae1">RGB_eq</a> (<a class="el" href="colr_8h.html#structRGB">RGB</a> a, <a class="el" href="colr_8h.html#structRGB">RGB</a> b)</td></tr>
<tr class="memdesc:ad4b5f73b8aa9d72216d7386221418ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> structs.  <a href="#ad4b5f73b8aa9d72216d7386221418ae1">More...</a><br /></td></tr>
<tr class="separator:ad4b5f73b8aa9d72216d7386221418ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33884dcde034819c5e6749667247194"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ad33884dcde034819c5e6749667247194">RGB_from_hex</a> (const char *hexstr, <a class="el" href="colr_8h.html#structRGB">RGB</a> *<a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:ad33884dcde034819c5e6749667247194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a hex color into an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.  <a href="#ad33884dcde034819c5e6749667247194">More...</a><br /></td></tr>
<tr class="separator:ad33884dcde034819c5e6749667247194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6133112d9c73a8b56995e16e1af62d3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a6133112d9c73a8b56995e16e1af62d3b">RGB_from_hex_default</a> (const char *hexstr, <a class="el" href="colr_8h.html#structRGB">RGB</a> default_value)</td></tr>
<tr class="memdesc:a6133112d9c73a8b56995e16e1af62d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a hex color into an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value, but use a default value when errors occur.  <a href="#a6133112d9c73a8b56995e16e1af62d3b">More...</a><br /></td></tr>
<tr class="separator:a6133112d9c73a8b56995e16e1af62d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c9e50fe14ad0c82bcf1a62699c05de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a98c9e50fe14ad0c82bcf1a62699c05de">RGB_from_str</a> (const char *arg, <a class="el" href="colr_8h.html#structRGB">RGB</a> *<a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:a98c9e50fe14ad0c82bcf1a62699c05de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> string (<code>char*</code>) into an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.  <a href="#a98c9e50fe14ad0c82bcf1a62699c05de">More...</a><br /></td></tr>
<tr class="separator:a98c9e50fe14ad0c82bcf1a62699c05de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e4feb89e009f00cfe7e74a55fab56f"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a95e4feb89e009f00cfe7e74a55fab56f">RGB_to_hex</a> (<a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:a95e4feb89e009f00cfe7e74a55fab56f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value into a hex string (<code>char*</code>).  <a href="#a95e4feb89e009f00cfe7e74a55fab56f">More...</a><br /></td></tr>
<tr class="separator:a95e4feb89e009f00cfe7e74a55fab56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d2f9a1133c8a955f0a551870d7ebe8"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a16d2f9a1133c8a955f0a551870d7ebe8">RGB_to_str</a> (<a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:a16d2f9a1133c8a955f0a551870d7ebe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value into an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> string (<code>char*</code>) suitable for input to <a class="el" href="colr_8c.html#a0943a956bc1491d6a6996ddc99a4d2dd" title="Convert an RGB string (char*) into an RGB value. ">RGB_from_str()</a>.  <a href="#a16d2f9a1133c8a955f0a551870d7ebe8">More...</a><br /></td></tr>
<tr class="separator:a16d2f9a1133c8a955f0a551870d7ebe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4576c531151e398b7ecede2e30df70d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#ab4576c531151e398b7ecede2e30df70d">RGB_to_term_RGB</a> (<a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:ab4576c531151e398b7ecede2e30df70d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value into it's nearest terminal-friendly <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.  <a href="#ab4576c531151e398b7ecede2e30df70d">More...</a><br /></td></tr>
<tr class="separator:ab4576c531151e398b7ecede2e30df70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd28864afbcfa4a344e4596130645177"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#afd28864afbcfa4a344e4596130645177">RGB_repr</a> (<a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td></tr>
<tr class="memdesc:afd28864afbcfa4a344e4596130645177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string (<code>char*</code>) representation for an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.  <a href="#afd28864afbcfa4a344e4596130645177">More...</a><br /></td></tr>
<tr class="separator:afd28864afbcfa4a344e4596130645177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b4ed49acc5d806f161a3b31f5bf023"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colr_8h.html#a41b4ed49acc5d806f161a3b31f5bf023">TermSize_repr</a> (<a class="el" href="colr_8h.html#structTermSize">TermSize</a> ts)</td></tr>
<tr class="memdesc:a41b4ed49acc5d806f161a3b31f5bf023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a string (<code>char*</code>) representation for a <a class="el" href="colr_8h.html#structTermSize" title="Holds a terminal size, usually retrieved with colr_term_size(). ">TermSize</a>.  <a href="#a41b4ed49acc5d806f161a3b31f5bf023">More...</a><br /></td></tr>
<tr class="separator:a41b4ed49acc5d806f161a3b31f5bf023"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Declarations for ColrC functions, enums, structs, etc. </p>
<p>Common macros and definitions are found here in <a class="el" href="colr_8h.html" title="Declarations for ColrC functions, enums, structs, etc. ">colr.h</a>, however the functions are documented in <a class="el" href="colr_8c.html" title="Implements everything in the colr.h header. ">colr.c</a>.</p>
</div><hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structRGB" id="structRGB"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structRGB">&#9670;&nbsp;</a></span>RGB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct RGB</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Container for <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> values. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a233b293e05afb1f665bccf5e755a1015"></a>unsigned char</td>
<td class="fieldname">
blue</td>
<td class="fielddoc">
Blue value for a color. </td></tr>
<tr><td class="fieldtype">
<a id="aa79ef354ee37a3d4009f88c6df3ff89c"></a>unsigned char</td>
<td class="fieldname">
green</td>
<td class="fielddoc">
Green value for a color. </td></tr>
<tr><td class="fieldtype">
<a id="a27a7ad87f1e966cb05761741e57b06d2"></a>unsigned char</td>
<td class="fieldname">
red</td>
<td class="fielddoc">
Red value for a color. </td></tr>
</table>

</div>
</div>
<a name="structBasicInfo" id="structBasicInfo"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structBasicInfo">&#9670;&nbsp;</a></span>BasicInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct BasicInfo</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Holds a known color name and it's <code>BasicValue</code>. </p>
<p>This is used for the <code>basic_names</code> array in <a class="el" href="colr_8c.html" title="Implements everything in the colr.h header. ">colr.c</a>. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ad02167bf204991552d918c44c3b82482"></a>char *</td>
<td class="fieldname">
name</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a184c878a0f9fe130891970d15e3238d0"></a><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a></td>
<td class="fieldname">
value</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structExtendedInfo" id="structExtendedInfo"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structExtendedInfo">&#9670;&nbsp;</a></span>ExtendedInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ExtendedInfo</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Holds a known color name and it's <code>ExtendedValue</code>. </p>
<p>This is used for the <code>basic_names</code> array in <a class="el" href="colr_8c.html" title="Implements everything in the colr.h header. ">colr.c</a>. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ac61ae9cfb3398cfa8c71ea0a010bcf8c"></a>char *</td>
<td class="fieldname">
name</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a9e3a963de5460df97e31452dc0da39e9"></a><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a></td>
<td class="fieldname">
value</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structStyleInfo" id="structStyleInfo"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structStyleInfo">&#9670;&nbsp;</a></span>StyleInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct StyleInfo</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Holds a known style name and it's <code>StyleValue</code>. </p>
<p>This is used for the <code>style_names</code> array in <a class="el" href="colr_8c.html" title="Implements everything in the colr.h header. ">colr.c</a>. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a722b87ccd4114d29b1f3fda3667de2d0"></a>char *</td>
<td class="fieldname">
name</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a976533eec4bc1529dd6e29541dbb9aaf"></a><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a></td>
<td class="fieldname">
value</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="unionColorStructMarker" id="unionColorStructMarker"></a>
<h2 class="memtitle"><span class="permalink"><a href="#unionColorStructMarker">&#9670;&nbsp;</a></span>ColorStructMarker</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union ColorStructMarker</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Breaks down Colr struct markers, such as COLORARG_MARKER, into individual bytes. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a2d22f09822b1b05b93d38e966e970682"></a>struct <a class="el" href="colr_8h.html#structColorStructMarker_8bytes">ColorStructMarker</a></td>
<td class="fieldname">
bytes</td>
<td class="fielddoc">
Individual bytes that make up the marker. </td></tr>
<tr><td class="fieldtype">
<a id="ad7d6d68fd813c55819065388649b0cd9"></a>unsigned int</td>
<td class="fieldname">
marker</td>
<td class="fielddoc">
The actual unsigned int marker value. </td></tr>
</table>

</div>
</div>
<a name="structColorValue" id="structColorValue"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structColorValue">&#9670;&nbsp;</a></span>ColorValue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ColorValue</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Holds a color type and it's value. </p>
<p>The <code>.type</code> member must always match the type of color value it is holding.</p>
<p>This is internal. It's used to make the final interface easier to use. You probably shouldn't be using it. </p>
</div><div class="dynheader">
Collaboration diagram for ColorValue:</div>
<div class="dyncontent">
<div class="center"><img src="structColorValue__coll__graph.png" border="0" usemap="#ColorValue_coll__map" alt="Collaboration graph"/></div>
<map name="ColorValue_coll__map" id="ColorValue_coll__map">
<area shape="rect" id="node2" href="colr_8h.html#structRGB" title="Container for RGB values. " alt="" coords="22,5,73,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="abc2bf486addb5900c648b2dc3b2c472f"></a><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a></td>
<td class="fieldname">
basic</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a01592c0494ac1323caa73fd1cd21b3e3"></a><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a></td>
<td class="fieldname">
ext</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a6a5f2a470e1db3e0f6ebb340eeed183c"></a><a class="el" href="colr_8h.html#structRGB">RGB</a></td>
<td class="fieldname">
rgb</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a901e7250a4768f40407d758a9b40766e"></a><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a></td>
<td class="fieldname">
style</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="aaa27aca3ef590be3930e4ff16ad7775d"></a><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structColorJustify" id="structColorJustify"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structColorJustify">&#9670;&nbsp;</a></span>ColorJustify</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ColorJustify</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Holds a string justification method, width, and padding character for ColorTexts. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a6b0eef965341a39f0ce479448389b977"></a>unsigned int</td>
<td class="fieldname">
marker</td>
<td class="fielddoc">
A marker used to inspect void pointers and determine if they are ColorJustifys. </td></tr>
<tr><td class="fieldtype">
<a id="a0d0ae3eed868d6fe94c60e4f757a7412"></a><a class="el" href="colr_8h.html#af1a3fe0b966f944fd659a98be170045f">ColorJustifyMethod</a></td>
<td class="fieldname">
method</td>
<td class="fielddoc">
The justification method, can be JUST_NONE. </td></tr>
<tr><td class="fieldtype">
<a id="a7972e067cc39f0cc113993a7dfd2b6df"></a>char</td>
<td class="fieldname">
padchar</td>
<td class="fielddoc">
The desired padding character, or <code>0</code> to use the default (`' '`). </td></tr>
<tr><td class="fieldtype">
<a id="a74010f20f8a60fe77dc5c62e13f0c3fb"></a>int</td>
<td class="fieldname">
width</td>
<td class="fielddoc">
The desired width for the final string, or <code>0</code> to use <a class="el" href="colr_8c.html#ae4c11bb5b3b1bb2848bb16aee39763b2" title="Attempts to retrieve the row/column size of the terminal and returns a TermSize. ">colr_term_size()</a>. </td></tr>
</table>

</div>
</div>
<a name="structColorNameData" id="structColorNameData"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structColorNameData">&#9670;&nbsp;</a></span>ColorNameData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ColorNameData</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Holds info about a known color name, like it's ExtendedValue and it's <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value. </p>
<p>Some of the names have the same ExtendedValue, and not all ExtendedValues have names.</p>
<p>This is used in the colr_name_data array. </p>
</div><div class="dynheader">
Collaboration diagram for ColorNameData:</div>
<div class="dyncontent">
<div class="center"><img src="structColorNameData__coll__graph.png" border="0" usemap="#ColorNameData_coll__map" alt="Collaboration graph"/></div>
<map name="ColorNameData_coll__map" id="ColorNameData_coll__map">
<area shape="rect" id="node2" href="colr_8h.html#structRGB" title="Container for RGB values. " alt="" coords="37,5,87,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a784696b7478fb97d410f78ea092f453f"></a><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a></td>
<td class="fieldname">
ext</td>
<td class="fielddoc">
ExtendedValue (256-colors) for the color. </td></tr>
<tr><td class="fieldtype">
<a id="a9155ebcbb6235c8a7c00398c1d69242a"></a>char *</td>
<td class="fieldname">
name</td>
<td class="fielddoc">
The known name of the color. </td></tr>
<tr><td class="fieldtype">
<a id="a64702b0ae877daffb159a3a1c0d1512e"></a><a class="el" href="colr_8h.html#structRGB">RGB</a></td>
<td class="fieldname">
rgb</td>
<td class="fielddoc">
<a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> (TrueColor) for the color. </td></tr>
</table>

</div>
</div>
<a name="structColorArg" id="structColorArg"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structColorArg">&#9670;&nbsp;</a></span>ColorArg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ColorArg</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Holds an ArgType, and a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>. </p>
</div><div class="dynheader">
Collaboration diagram for ColorArg:</div>
<div class="dyncontent">
<div class="center"><img src="structColorArg__coll__graph.png" border="0" usemap="#ColorArg_coll__map" alt="Collaboration graph"/></div>
<map name="ColorArg_coll__map" id="ColorArg_coll__map">
<area shape="rect" id="node2" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. " alt="" coords="5,95,89,121"/>
<area shape="rect" id="node3" href="colr_8h.html#structRGB" title="Container for RGB values. " alt="" coords="22,5,73,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a931c021b053e2504582c4994c9259d75"></a>unsigned int</td>
<td class="fieldname">
marker</td>
<td class="fielddoc">
A marker used to inspect void pointers and determine if they are ColorArgs. </td></tr>
<tr><td class="fieldtype">
<a id="a4d1de8b30570b3f8de977e2530382c49"></a><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
Fore, back, style, invalid. </td></tr>
<tr><td class="fieldtype">
<a id="ad947d9d54ef7ab11b84a36b6cd3a3426"></a><a class="el" href="colr_8h.html#structColorValue">ColorValue</a></td>
<td class="fieldname">
value</td>
<td class="fielddoc">
Color type and value. </td></tr>
</table>

</div>
</div>
<a name="structColorText" id="structColorText"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structColorText">&#9670;&nbsp;</a></span>ColorText</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ColorText</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Holds a string of text, and optional fore, back, and style ColorArgs. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="colr_join_example_8c-example.html#_a6">colr_join_example.c</a>.</dd>
</dl></div><div class="dynheader">
Collaboration diagram for ColorText:</div>
<div class="dyncontent">
<div class="center"><img src="structColorText__coll__graph.png" border="0" usemap="#ColorText_coll__map" alt="Collaboration graph"/></div>
<map name="ColorText_coll__map" id="ColorText_coll__map">
<area shape="rect" id="node2" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. " alt="" coords="11,184,83,211"/>
<area shape="rect" id="node3" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. " alt="" coords="5,95,89,121"/>
<area shape="rect" id="node4" href="colr_8h.html#structRGB" title="Container for RGB values. " alt="" coords="22,5,73,32"/>
<area shape="rect" id="node5" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ..." alt="" coords="107,184,198,211"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ae9b8a112de055f9d7826a50b4cdf4e4a"></a><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *</td>
<td class="fieldname">
back</td>
<td class="fielddoc">
<a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> for back color. Can be <code>NULL</code>. </td></tr>
<tr><td class="fieldtype">
<a id="a788a3311c550c543c8ef345a5e90e757"></a><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *</td>
<td class="fieldname">
fore</td>
<td class="fielddoc">
<a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> for fore color. Can be <code>NULL</code>. </td></tr>
<tr><td class="fieldtype">
<a id="a36047003e9e4322bf432db68b39d0663"></a><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a></td>
<td class="fieldname">
just</td>
<td class="fielddoc">
<a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> info, set to JUST_NONE by default. </td></tr>
<tr><td class="fieldtype">
<a id="a6a6feb8503bdc29ca093828bc1dc18f1"></a>unsigned int</td>
<td class="fieldname">
marker</td>
<td class="fielddoc">
A marker used to inspect void pointers and determine if they are ColorTexts. </td></tr>
<tr><td class="fieldtype">
<a id="aa9f47920503d771d3bd80435b3ef2d6f"></a><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *</td>
<td class="fieldname">
style</td>
<td class="fielddoc">
<a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> for style value. Can be <code>NULL</code>. </td></tr>
<tr><td class="fieldtype">
<a id="aad9a63ccc1c0361fb44ef27b932b2765"></a>char *</td>
<td class="fieldname">
text</td>
<td class="fielddoc">
Text to colorize. </td></tr>
</table>

</div>
</div>
<a name="structTermSize" id="structTermSize"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structTermSize">&#9670;&nbsp;</a></span>TermSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct TermSize</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Holds a terminal size, usually retrieved with <a class="el" href="colr_8c.html#ae4c11bb5b3b1bb2848bb16aee39763b2" title="Attempts to retrieve the row/column size of the terminal and returns a TermSize. ">colr_term_size()</a>. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a9a5b60ff7d19d434ea08ee742e3d6711"></a>unsigned short</td>
<td class="fieldname">
columns</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a65143bf24ee18a8aabbf71e9f854d405"></a>unsigned short</td>
<td class="fieldname">
rows</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structColorStructMarker_8bytes" id="structColorStructMarker_8bytes"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structColorStructMarker_8bytes">&#9670;&nbsp;</a></span>ColorStructMarker.bytes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ColorStructMarker.bytes</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Individual bytes that make up the marker. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="aedbab45572c72a5d9440b40bcc0500c0"></a>unsigned char</td>
<td class="fieldname">
b1</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="afbfba2e45c2045dc5cab22a5afe83d9d"></a>unsigned char</td>
<td class="fieldname">
b2</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a7a6f150b83091ce20c89368641f9a137"></a>unsigned char</td>
<td class="fieldname">
b3</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a3dfe563103ab11bec75bb5081e7a1dbe"></a>unsigned char</td>
<td class="fieldname">
b4</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ab7f29d345901a016f81f020ca4326c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f29d345901a016f81f020ca4326c61">&#9670;&nbsp;</a></span>alloc_basic</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define alloc_basic</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;calloc(<a class="el" href="colr_8h.html#a4ef6ad74c493fe40e199341072fabefe">CODE_LEN</a>, sizeof(char))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate enough for a basic code. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the allocated string, or NULL on error.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> </dd></dl>

</div>
</div>
<a id="a27c2b2b2835220a22a3b02e18febda40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27c2b2b2835220a22a3b02e18febda40">&#9670;&nbsp;</a></span>alloc_extended</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define alloc_extended</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;calloc(<a class="el" href="colr_8h.html#af77ec93393736fa98be724385d61614d">CODEX_LEN</a>, sizeof(char))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate enough for a extended code. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the allocated string, or NULL on error.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> </dd></dl>

</div>
</div>
<a id="ade4f7e3d0a7c1d9b991b0a33a995d6e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade4f7e3d0a7c1d9b991b0a33a995d6e5">&#9670;&nbsp;</a></span>alloc_rgb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define alloc_rgb</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;calloc(<a class="el" href="colr_8h.html#ad50e6b68284102d5270834e02652af37">CODE_RGB_LEN</a>, sizeof(char))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate enough for an rgb code. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the allocated string, or NULL on error.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> </dd></dl>

</div>
</div>
<a id="a6af1a91e97e7aed226ab0cdc6ce205f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6af1a91e97e7aed226ab0cdc6ce205f8">&#9670;&nbsp;</a></span>alloc_style</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define alloc_style</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;calloc(<a class="el" href="colr_8h.html#ac83d14a355d35b7af90deb99ad3b7601">STYLE_LEN</a>, sizeof(char))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate enough for a style code. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the allocated string, or NULL on error.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> </dd></dl>

</div>
</div>
<a id="a63464899e77699c41410c7ed566342a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63464899e77699c41410c7ed566342a7">&#9670;&nbsp;</a></span>argeq</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define argeq</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">arg, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s2&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(!strcmp(arg, s1)) || (!strcmp(arg, s2))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro for <code>!strcmp(arg, s1) || !strcmp(arg, s2)</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>String to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s1</td><td>First string to compare against. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s2</td><td>Second string to compare against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if <code>arg</code> matches either <code>s1</code> or <code>s2</code>, otherwise <code>0</code>. </dd></dl>

</div>
</div>
<a id="a6e247a378d2359d2d6efa4af5e3cd03b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e247a378d2359d2d6efa4af5e3cd03b">&#9670;&nbsp;</a></span>asprintf_or_return</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define asprintf_or_return</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">retval, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#a80a08fc1383c7260a31698864d52fee2">if_not_asprintf</a>(__VA_ARGS__) return retval</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro for bailing out of a function when asprintf fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">retval</td><td>Value to return if the asprintf fails. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Arguments for asprintf. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a5af692f2357d46b9cee45bb114f2a4a2">ColorArg_repr()</a>, <a class="el" href="colr_8h.html#a6c35f6b47cc737744487d14d20241656">ColorJustify_repr()</a>, <a class="el" href="colr_8h.html#a575a6cdc2f65cf1cd25227f847ae8d76">ColorText_repr()</a>, <a class="el" href="colr_8h.html#aa4d7418d0f38aa5d42c9cc2f7a06cdd5">colr_char_repr()</a>, <a class="el" href="colr_8h.html#ad32382336586dbda9a7e205403de8a14">colr_str_center()</a>, <a class="el" href="colr_8h.html#ac8be0d81828f73816a447b7440987d91">colr_str_ljust()</a>, <a class="el" href="colr_8h.html#a196ad91a69cfbeb27a5266ffc93ed353">colr_str_repr()</a>, <a class="el" href="colr_8h.html#a8fbaa15923af761c5eb99224ef8089b4">colr_str_rjust()</a>, <a class="el" href="colr_8h.html#aa45baebc38756a40e7084f8198999902">ExtendedValue_repr()</a>, <a class="el" href="colr_8h.html#a4e334d6b9145fca9717fe5a2aeb542fe">ExtendedValue_to_str()</a>, <a class="el" href="colr_8h.html#afd28864afbcfa4a344e4596130645177">RGB_repr()</a>, <a class="el" href="colr_8h.html#a95e4feb89e009f00cfe7e74a55fab56f">RGB_to_hex()</a>, <a class="el" href="colr_8h.html#a16d2f9a1133c8a955f0a551870d7ebe8">RGB_to_str()</a>, and <a class="el" href="colr_8h.html#a41b4ed49acc5d806f161a3b31f5bf023">TermSize_repr()</a>.</p>

</div>
</div>
<a id="a947915cd251af5099f6a9232836b12d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947915cd251af5099f6a9232836b12d8">&#9670;&nbsp;</a></span>back</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define back</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#afb5ac0bd012b8162cea125ad0d9e8bf0">ColorArg_to_ptr</a>(<a class="el" href="colr_8h.html#aeba419af1d4c23615eb844db37e46ee6">back_arg</a>(x))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a back color suitable for use with the <a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2" title="Join ColorArg pointers, ColorText pointers, and strings into one long string. ">colr()</a> and <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr() macro...">Colr()</a> macros. </p>
<p>Technically, this macro accepts BasicValues, ExtendedValues, or <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> structs. However, for some of these you should be using the macros that create those things.</p>
<p>BasicValues can be used by their names (RED, YELLOW, etc.).</p>
<p>ExtendedValues can be created on the fly with <a class="el" href="colr_8h.html#a37ff4fc6d17b53b60202be55bd0732c5" title="Casts to ExtendedValue (unsigned char). ">ext()</a>.</p>
<p><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> structs can be easily created with <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57" title="Creates an anonymous RGB struct for use in function calls. ">rgb()</a>.</p>
<p>Color names (<code>char*</code>) can be passed to generate the appropriate color value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A BasicValue, ExtendedValue, or <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct to use for the color value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a heap-allocated <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct.<br />
 If used inside of the <a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2" title="Join ColorArg pointers, ColorText pointers, and strings into one long string. ">colr()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, and <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr() macro...">Colr()</a> macros, <em>they will <code>free()</code> the result</em>.<br />
Otherwise, <em>you are responsible for calling <code>free()</code></em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#aeba419af1d4c23615eb844db37e46ee6" title="Uses ColorArg_from_&lt;type&gt; to build a ColorArg with the appropriate color type, based on the type of i...">back_arg</a> <a class="el" href="colr_8h.html#a5f85c3a1434551be3846414be3d1bdb9" title="Retrieve just the escape code string for a back color. ">back_str</a> <a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2" title="Join ColorArg pointers, ColorText pointers, and strings into one long string. ">colr</a> <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr() macro...">Colr</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="back_example_8c-example.html#a2">back_example.c</a>, <a class="el" href="Colr_example_8c-example.html#a9">Colr_example.c</a>, and <a class="el" href="fore_example_8c-example.html#a5">fore_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="aeba419af1d4c23615eb844db37e46ee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba419af1d4c23615eb844db37e46ee6">&#9670;&nbsp;</a></span>back_arg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define back_arg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_Generic( \</div><div class="line">        (x), \</div><div class="line">        <span class="keywordtype">char</span>* : <a class="code" href="colr_8h.html#ae8d897499fca87d7902159f4ed7dbba3">ColorArg_from_str</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structRGB">RGB</a>: <a class="code" href="colr_8h.html#aaa24bba74e99aa66ed41839576e57856">ColorArg_from_RGB</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>: <a class="code" href="colr_8h.html#aad49f4597388e6bdb896ff28334cd5e6">ColorArg_from_BasicValue</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>: <a class="code" href="colr_8h.html#aed30e2a4b30ab5e3cf49608a3c410cc5">ColorArg_from_ExtendedValue</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>: <a class="code" href="colr_8h.html#acf63bcee395dca3ca29dc324e3d7c8f2">ColorArg_from_StyleValue</a> \</div><div class="line">    )(BACK, x)</div><div class="ttc" id="colr_8h_html_aed30e2a4b30ab5e3cf49608a3c410cc5"><div class="ttname"><a href="colr_8h.html#aed30e2a4b30ab5e3cf49608a3c410cc5">ColorArg_from_ExtendedValue</a></div><div class="ttdeci">ColorArg ColorArg_from_ExtendedValue(ArgType type, ExtendedValue value)</div><div class="ttdoc">Explicit version of ColorArg_from_value that only handles ExtendedValues. </div><div class="ttdef"><b>Definition:</b> colr.c:2666</div></div>
<div class="ttc" id="colr_8h_html_a0c061fbfddd43dfe324486dc86cb92ee"><div class="ttname"><a href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a></div><div class="ttdeci">BasicValue</div><div class="ttdoc">Basic color values, with a few convenience values for extended colors. </div><div class="ttdef"><b>Definition:</b> colr.h:1117</div></div>
<div class="ttc" id="colr_8h_html_aaa24bba74e99aa66ed41839576e57856"><div class="ttname"><a href="colr_8h.html#aaa24bba74e99aa66ed41839576e57856">ColorArg_from_RGB</a></div><div class="ttdeci">ColorArg ColorArg_from_RGB(ArgType type, RGB value)</div><div class="ttdoc">Explicit version of ColorArg_from_value that only handles RGB structs. </div><div class="ttdef"><b>Definition:</b> colr.c:2689</div></div>
<div class="ttc" id="colr_8h_html_acf63bcee395dca3ca29dc324e3d7c8f2"><div class="ttname"><a href="colr_8h.html#acf63bcee395dca3ca29dc324e3d7c8f2">ColorArg_from_StyleValue</a></div><div class="ttdeci">ColorArg ColorArg_from_StyleValue(ArgType type, StyleValue value)</div><div class="ttdoc">Explicit version of ColorArg_from_value that only handles StyleValues. </div><div class="ttdef"><b>Definition:</b> colr.c:2735</div></div>
<div class="ttc" id="colr_8h_html_structRGB"><div class="ttname"><a href="colr_8h.html#structRGB">RGB</a></div><div class="ttdoc">Container for RGB values. </div><div class="ttdef"><b>Definition:</b> colr.h:1200</div></div>
<div class="ttc" id="colr_8h_html_aad49f4597388e6bdb896ff28334cd5e6"><div class="ttname"><a href="colr_8h.html#aad49f4597388e6bdb896ff28334cd5e6">ColorArg_from_BasicValue</a></div><div class="ttdeci">ColorArg ColorArg_from_BasicValue(ArgType type, BasicValue value)</div><div class="ttdoc">Explicit version of ColorArg_from_value that only handles BasicValues. </div><div class="ttdef"><b>Definition:</b> colr.c:2643</div></div>
<div class="ttc" id="colr_8h_html_a6dda29f582a062546ef8733d8b7d8a94"><div class="ttname"><a href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a></div><div class="ttdeci">unsigned char ExtendedValue</div><div class="ttdoc">Convenience typedef for clarity when dealing with extended (256) colors. </div><div class="ttdef"><b>Definition:</b> colr.h:1189</div></div>
<div class="ttc" id="colr_8h_html_ae8d897499fca87d7902159f4ed7dbba3"><div class="ttname"><a href="colr_8h.html#ae8d897499fca87d7902159f4ed7dbba3">ColorArg_from_str</a></div><div class="ttdeci">ColorArg ColorArg_from_str(ArgType type, char *colorname)</div><div class="ttdoc">Build a ColorArg (fore, back, or style value) from a known color name/style. </div><div class="ttdef"><b>Definition:</b> colr.c:2713</div></div>
<div class="ttc" id="colr_8h_html_a85224ec2507f33b1985f4cdd0adfe0e6"><div class="ttname"><a href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a></div><div class="ttdeci">StyleValue</div><div class="ttdoc">Style values. </div><div class="ttdef"><b>Definition:</b> colr.h:1214</div></div>
</div><!-- fragment -->
<p>Uses ColorArg_from_&lt;type&gt; to build a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> with the appropriate color type, based on the type of it's argument. </p>
<p>Uses <code>_Generic</code> (C11 standard) to dynamically create a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>. This is used by the <a class="el" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8" title="Create a back color suitable for use with the colr() and Colr() macros. ">back()</a> macro.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td><code>BasicValue</code>, <code>Extended</code> (<code>unsigned char</code>), <code><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a></code> struct, or string (color name) for back color. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> with the BACK type set, and it's <code>.value.type</code> set for the appropriate color type/value.<br />
 For invalid values the <code>.value.type</code> may be set to TYPE_INVALID.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8" title="Create a back color suitable for use with the colr() and Colr() macros. ">back</a> <a class="el" href="colr_8h.html#a5f85c3a1434551be3846414be3d1bdb9" title="Retrieve just the escape code string for a back color. ">back_str</a> </dd></dl>

</div>
</div>
<a id="a5f85c3a1434551be3846414be3d1bdb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f85c3a1434551be3846414be3d1bdb9">&#9670;&nbsp;</a></span>back_str</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define back_str</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#a91fb398f6463553e576fc067f5a0a854">ColorArg_to_str</a>(<a class="el" href="colr_8h.html#aeba419af1d4c23615eb844db37e46ee6">back_arg</a>(x))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve just the escape code string for a back color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A BasicValue, ExtendedValue, or <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8" title="Create a back color suitable for use with the colr() and Colr() macros. ">back</a> <a class="el" href="colr_8h.html#aeba419af1d4c23615eb844db37e46ee6" title="Uses ColorArg_from_&lt;type&gt; to build a ColorArg with the appropriate color type, based on the type of i...">back_arg</a> </dd></dl>

</div>
</div>
<a id="a653c1408c1d132a05a5648ffd53ca2c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a653c1408c1d132a05a5648ffd53ca2c6">&#9670;&nbsp;</a></span>basic</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define basic</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;((enum BasicValue_t)(x))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts to BasicValue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Value to case to <code>BasicValue</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A BasicValue.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f" title="Create a fore color suitable for use with the colr() and Colr() macros. ">fore</a> <a class="el" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8" title="Create a back color suitable for use with the colr() and Colr() macros. ">back</a> <a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2" title="Join ColorArg pointers, ColorText pointers, and strings into one long string. ">colr</a> <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr() macro...">Colr</a> </dd></dl>

</div>
</div>
<a id="a7dbd4f0825e46d22010c39d92a5f6e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dbd4f0825e46d22010c39d92a5f6e60">&#9670;&nbsp;</a></span>bool_colr_enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bool_colr_enum</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(x &lt; 0 ? false: true)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the "truthiness" of the enums used in ColrC (BasicValue, ExtendedValue, StyleValue, ColorType, ArgType). </p>
<p>Any value less than <code>0</code> is considered false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>An enum to convert to boolean. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the value is considered valid, or non-empty. </td></tr>
    <tr><td class="paramname">false</td><td>if the value is considered invalid, or empty. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a66b4906cfb08588005536db1250dc899">ColorArg_is_invalid()</a>, <a class="el" href="colr_8h.html#a1e446f65d6987d52522a1755c909d421">ColorArg_is_valid()</a>, <a class="el" href="colr_8h.html#adc223f6fda6296396e9ecddcc68d4aec">ColorType_is_invalid()</a>, <a class="el" href="colr_8h.html#a5a5883d43e3206584ad048908720afb2">ColorType_is_valid()</a>, <a class="el" href="colr_8h.html#a22fcf30338eb777592421543885f74e0">ColorValue_is_invalid()</a>, and <a class="el" href="colr_8h.html#ac7183410b61d12a99dda3f76c2705497">ColorValue_is_valid()</a>.</p>

</div>
</div>
<a id="ab0e75d15b6f6536e745f66563c4ba6c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0e75d15b6f6536e745f66563c4ba6c3">&#9670;&nbsp;</a></span>CODE_ANY_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CODE_ANY_LEN&#160;&#160;&#160;46</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum length in chars for any possible escape code mixture. </p>
<p>(basically <code>(CODE_RGB_LEN * 2) + STYLE_LEN</code> since rgb codes are the longest). </p>

</div>
</div>
<a id="a4ef6ad74c493fe40e199341072fabefe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef6ad74c493fe40e199341072fabefe">&#9670;&nbsp;</a></span>CODE_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CODE_LEN&#160;&#160;&#160;14</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum length for a basic fore/back escape code, including `'\0'`. </p>
<p>Keep in mind that BasicValue actually has some "light" colors (104). </p>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ae29032483aea8cb25d6b90750767ffc1">format_bg()</a>, and <a class="el" href="colr_8h.html#a6027d93e8768f3c152edafd92e757801">format_fg()</a>.</p>

</div>
</div>
<a id="a9837a2915a770865032578914efb8621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9837a2915a770865032578914efb8621">&#9670;&nbsp;</a></span>CODE_LEN_MIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CODE_LEN_MIN&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum length for the shortest basic fore/back escape code, including `'\0'`. </p>
<p>Use CODE_LEN for allocation. </p>

</div>
</div>
<a id="a3ffdc16cef9af954c4d62d29ba8d7961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ffdc16cef9af954c4d62d29ba8d7961">&#9670;&nbsp;</a></span>CODE_RGB_LEN_MIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CODE_RGB_LEN_MIN&#160;&#160;&#160;14</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum length for the shortest <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> fore/back escape code, including `'\0'`. </p>
<p>Use CODE_RGB_LEN for allocation. </p>

</div>
</div>
<a id="a37730bc0c16d2d698f3d539add30483b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37730bc0c16d2d698f3d539add30483b">&#9670;&nbsp;</a></span>CODEX_LEN_MIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CODEX_LEN_MIN&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum length for the shortest extended fore/back escape code, including `'\0'`. </p>
<p>Use CODEX_LEN for allocation. </p>

</div>
</div>
<a id="aa8903c150d5b0912b2f797f9235978f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8903c150d5b0912b2f797f9235978f8">&#9670;&nbsp;</a></span>color_arg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define color_arg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_Generic( \</div><div class="line">        (x), \</div><div class="line">        <a class="code" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>: <a class="code" href="colr_8h.html#a89a5aa762bd5802872faf571aa32ea35">ColorArg_from_value</a>(type, TYPE_BASIC, &amp;x), \</div><div class="line">        <a class="code" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>: <a class="code" href="colr_8h.html#a89a5aa762bd5802872faf571aa32ea35">ColorArg_from_value</a>(type, TYPE_EXTENDED, &amp;x), \</div><div class="line">        <a class="code" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>: <a class="code" href="colr_8h.html#a89a5aa762bd5802872faf571aa32ea35">ColorArg_from_value</a>(type, TYPE_STYLE, &amp;x), \</div><div class="line">        <a class="code" href="colr_8h.html#structRGB">RGB</a>: <a class="code" href="colr_8h.html#a89a5aa762bd5802872faf571aa32ea35">ColorArg_from_value</a>(type, TYPE_RGB, &amp;x) \</div><div class="line">    )</div><div class="ttc" id="colr_8h_html_a0c061fbfddd43dfe324486dc86cb92ee"><div class="ttname"><a href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a></div><div class="ttdeci">BasicValue</div><div class="ttdoc">Basic color values, with a few convenience values for extended colors. </div><div class="ttdef"><b>Definition:</b> colr.h:1117</div></div>
<div class="ttc" id="colr_8h_html_a89a5aa762bd5802872faf571aa32ea35"><div class="ttname"><a href="colr_8h.html#a89a5aa762bd5802872faf571aa32ea35">ColorArg_from_value</a></div><div class="ttdeci">ColorArg ColorArg_from_value(ArgType type, ColorType colrtype, void *p)</div><div class="ttdoc">Used with the color_arg macro to dynamically create a ColorArg based on it&amp;#39;s argument type...</div><div class="ttdef"><b>Definition:</b> colr.c:2762</div></div>
<div class="ttc" id="colr_8h_html_structRGB"><div class="ttname"><a href="colr_8h.html#structRGB">RGB</a></div><div class="ttdoc">Container for RGB values. </div><div class="ttdef"><b>Definition:</b> colr.h:1200</div></div>
<div class="ttc" id="colr_8h_html_a6dda29f582a062546ef8733d8b7d8a94"><div class="ttname"><a href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a></div><div class="ttdeci">unsigned char ExtendedValue</div><div class="ttdoc">Convenience typedef for clarity when dealing with extended (256) colors. </div><div class="ttdef"><b>Definition:</b> colr.h:1189</div></div>
<div class="ttc" id="colr_8h_html_a85224ec2507f33b1985f4cdd0adfe0e6"><div class="ttname"><a href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a></div><div class="ttdeci">StyleValue</div><div class="ttdoc">Style values. </div><div class="ttdef"><b>Definition:</b> colr.h:1214</div></div>
</div><!-- fragment -->
<p>Builds a correct <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct according to the type of it's second argument. </p>
<p>Uses <code>_Generic</code> (C11 standard) to dynamically create a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td><code>ArgType</code> (<code>FORE</code>, <code>BACK</code>, <code>STYLE</code>) to build the <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td><code>BasicValue</code>, <code>Extended</code> (<code>unsigned char</code>). or <code><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a></code> value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ColorArg_from_value(type, [appropriate type], x) </dd></dl>

</div>
</div>
<a id="ab5557ed18d83facb69dd68b30629c37e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5557ed18d83facb69dd68b30629c37e">&#9670;&nbsp;</a></span>COLOR_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define COLOR_LEN&#160;&#160;&#160;30</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum length in chars for any combination of basic/extended escape codes. </p>
<p>Should be <code>(CODEX_LEN * 2) + STYLE_LEN</code>. Allocating for a string that will be colorized must account for this. </p>

</div>
</div>
<a id="a4a74a4af461e4aeacf99533a91c3fa0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a74a4af461e4aeacf99533a91c3fa0d">&#9670;&nbsp;</a></span>color_name_is_basic</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define color_name_is_basic</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(<a class="el" href="colr_8h.html#afa75deef059c002134a88dbbdc18fd49">ColorType_from_str</a>(x) == TYPE_BASIC)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro for checking if a color name is valid, and maps to a BasicValue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Color name (<code>char*</code>) to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the name is a valid BasicValue name, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#ad8da162275a03adc210cd90c0e2b923d" title="Convenience macro for checking if a color name is valid. ">color_name_is_valid</a> <a class="el" href="colr_8h.html#a631e5b639fc75363670dbd912c42abb3" title="Convenience macro for checking if a color name is invalid. ">color_name_is_invalid</a> </dd></dl>

</div>
</div>
<a id="a631e5b639fc75363670dbd912c42abb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a631e5b639fc75363670dbd912c42abb3">&#9670;&nbsp;</a></span>color_name_is_invalid</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define color_name_is_invalid</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#adc223f6fda6296396e9ecddcc68d4aec">ColorType_is_invalid</a>(<a class="el" href="colr_8h.html#afa75deef059c002134a88dbbdc18fd49">ColorType_from_str</a>(x))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro for checking if a color name is invalid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Color name (<code>char*</code>) to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the name is an invalid color name, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#ad8da162275a03adc210cd90c0e2b923d" title="Convenience macro for checking if a color name is valid. ">color_name_is_valid</a> <a class="el" href="colr_8h.html#a4a74a4af461e4aeacf99533a91c3fa0d" title="Convenience macro for checking if a color name is valid, and maps to a BasicValue. ">color_name_is_basic</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#color_name_is_invalid-example" id="color_name_is_invalid-example" class="diamond-bullet">◆&#160;</a> color_name_is_invalid example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* names[] = {</div><div class="line">    <span class="stringliteral">&quot;red&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;lightblue&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;127&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;123,54,67&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;NOTACOLOR&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;345&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;1;&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;1;2;&quot;</span></div><div class="line">};</div><div class="line"><span class="keywordtype">size_t</span> names_len = <span class="keyword">sizeof</span>(names) / <span class="keyword">sizeof</span>(names[0]);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; names_len; i++) {</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="colr_8h.html#a631e5b639fc75363670dbd912c42abb3">color_name_is_invalid</a>(names[i])) {</div><div class="line">        printf(<span class="stringliteral">&quot;Invalid name: %s\n&quot;</span>, names[i]);</div><div class="line">    } <span class="keywordflow">else</span>  {</div><div class="line">        printf(<span class="stringliteral">&quot;  Valid name: %s\n&quot;</span>, names[i]);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> </div> 
</div>
</div>
<a id="ad8da162275a03adc210cd90c0e2b923d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8da162275a03adc210cd90c0e2b923d">&#9670;&nbsp;</a></span>color_name_is_valid</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define color_name_is_valid</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#a5a5883d43e3206584ad048908720afb2">ColorType_is_valid</a>(<a class="el" href="colr_8h.html#afa75deef059c002134a88dbbdc18fd49">ColorType_from_str</a>(x))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro for checking if a color name is valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Color name (<code>char*</code>) to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the name is a valid color name, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a631e5b639fc75363670dbd912c42abb3" title="Convenience macro for checking if a color name is invalid. ">color_name_is_invalid</a> <a class="el" href="colr_8h.html#a4a74a4af461e4aeacf99533a91c3fa0d" title="Convenience macro for checking if a color name is valid, and maps to a BasicValue. ">color_name_is_basic</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#color_name_is_valid-example" id="color_name_is_valid-example" class="diamond-bullet">◆&#160;</a> color_name_is_valid example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* names[] = {</div><div class="line">    <span class="stringliteral">&quot;red&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;lightblue&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;127&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;123,54,67&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;NOTACOLOR&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;345&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;1;&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;1;2;&quot;</span></div><div class="line">};</div><div class="line"><span class="keywordtype">size_t</span> names_len = <span class="keyword">sizeof</span>(names) / <span class="keyword">sizeof</span>(names[0]);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; names_len; i++) {</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="colr_8h.html#ad8da162275a03adc210cd90c0e2b923d">color_name_is_valid</a>(names[i])) {</div><div class="line">        printf(<span class="stringliteral">&quot;  Valid name: %s\n&quot;</span>, names[i]);</div><div class="line">    } <span class="keywordflow">else</span>  {</div><div class="line">        printf(<span class="stringliteral">&quot;Invalid name: %s\n&quot;</span>, names[i]);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> </div> 
</div>
</div>
<a id="a9dbb9166f2a4d79e48dd5b11c3eb258b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dbb9166f2a4d79e48dd5b11c3eb258b">&#9670;&nbsp;</a></span>COLOR_RGB_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define COLOR_RGB_LEN&#160;&#160;&#160;26</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum length in chars added to a rgb colorized string. </p>
<p>Should be <code>CODE_RGB_LEN + STYLE_LEN</code> Allocating for a string that will be colorized with rgb values must account for this. </p>

</div>
</div>
<a id="a4eb7445c534661e32283d2119beb45d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eb7445c534661e32283d2119beb45d6">&#9670;&nbsp;</a></span>color_val</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define color_val</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_Generic( \</div><div class="line">        (x), \</div><div class="line">        <a class="code" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>: <a class="code" href="colr_8h.html#aca7fedbceb4f751d0d30034c0ef1dca8">ColorValue_from_value</a>(TYPE_BASIC, &amp;x), \</div><div class="line">        <a class="code" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>: <a class="code" href="colr_8h.html#aca7fedbceb4f751d0d30034c0ef1dca8">ColorValue_from_value</a>(TYPE_EXTENDED, &amp;x), \</div><div class="line">        <a class="code" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>: <a class="code" href="colr_8h.html#aca7fedbceb4f751d0d30034c0ef1dca8">ColorValue_from_value</a>(TYPE_STYLE, &amp;x), \</div><div class="line">        <a class="code" href="colr_8h.html#structRGB">RGB</a>: <a class="code" href="colr_8h.html#aca7fedbceb4f751d0d30034c0ef1dca8">ColorValue_from_value</a>(TYPE_RGB, &amp;x) \</div><div class="line">    )</div><div class="ttc" id="colr_8h_html_a0c061fbfddd43dfe324486dc86cb92ee"><div class="ttname"><a href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a></div><div class="ttdeci">BasicValue</div><div class="ttdoc">Basic color values, with a few convenience values for extended colors. </div><div class="ttdef"><b>Definition:</b> colr.h:1117</div></div>
<div class="ttc" id="colr_8h_html_structRGB"><div class="ttname"><a href="colr_8h.html#structRGB">RGB</a></div><div class="ttdoc">Container for RGB values. </div><div class="ttdef"><b>Definition:</b> colr.h:1200</div></div>
<div class="ttc" id="colr_8h_html_a6dda29f582a062546ef8733d8b7d8a94"><div class="ttname"><a href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a></div><div class="ttdeci">unsigned char ExtendedValue</div><div class="ttdoc">Convenience typedef for clarity when dealing with extended (256) colors. </div><div class="ttdef"><b>Definition:</b> colr.h:1189</div></div>
<div class="ttc" id="colr_8h_html_a85224ec2507f33b1985f4cdd0adfe0e6"><div class="ttname"><a href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a></div><div class="ttdeci">StyleValue</div><div class="ttdoc">Style values. </div><div class="ttdef"><b>Definition:</b> colr.h:1214</div></div>
<div class="ttc" id="colr_8h_html_aca7fedbceb4f751d0d30034c0ef1dca8"><div class="ttname"><a href="colr_8h.html#aca7fedbceb4f751d0d30034c0ef1dca8">ColorValue_from_value</a></div><div class="ttdeci">ColorValue ColorValue_from_value(ColorType type, void *p)</div><div class="ttdoc">Used with the color_val macro to dynamically create a ColorValue based on it&amp;#39;s argument type...</div><div class="ttdef"><b>Definition:</b> colr.c:3645</div></div>
</div><!-- fragment -->
<p>Builds a correct <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> struct according to the type of it's first argument. </p>
<p>Uses <code>_Generic</code> (C11 standard) to dynamically create a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td><code>BasicValue</code>, <code>Extended</code> (<code>unsigned char</code>). or <code><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a></code> value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ColorValue_from_value([appropriate type], x) </dd></dl>

</div>
</div>
<a id="ade1c77f81a0fd49f7895598cbd9ac76c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade1c77f81a0fd49f7895598cbd9ac76c">&#9670;&nbsp;</a></span>Colr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Colr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">text, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#a8e04de932a4cf712ac91e794bdc3f8db">ColorText_to_ptr</a>(<a class="el" href="colr_8h.html#ad4702d6ddc409a93a0b42c8f6141d2f2">ColorText_from_values</a>(text, __VA_ARGS__, _ColrLastArg))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a heap-allocated <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> struct that can be used by itself, or with the <a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2" title="Join ColorArg pointers, ColorText pointers, and strings into one long string. ">colr()</a> macro. </p>
<p>You must <code>free()</code> the resulting <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> struct using <a class="el" href="colr_8h.html#a901e5738358a739629cc3aaccab3e73f" title="Frees a ColorText and it&#39;s ColorArgs. ">ColorText_free()</a>, unless you pass it to <a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2" title="Join ColorArg pointers, ColorText pointers, and strings into one long string. ">colr()</a>, which will <code>free()</code> it for you.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>String to colorize/style. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>No more than 3 <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointers for fore, back, and style in any order.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.<br />
 If used inside of the <a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2" title="Join ColorArg pointers, ColorText pointers, and strings into one long string. ">colr()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, and <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr() macro...">Colr()</a> macros, <em>they will <code>free()</code> the result</em>.<br />
Otherwise, <em>you are responsible for calling <code>free()</code></em>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="back_example_8c-example.html#a9">back_example.c</a>, <a class="el" href="Colr_example_8c-example.html#a1">Colr_example.c</a>, <a class="el" href="colr_example_8c-example.html#a1">colr_example.c</a>, <a class="el" href="colr_join_example_8c-example.html#a1">colr_join_example.c</a>, <a class="el" href="fore_example_8c-example.html#a4">fore_example.c</a>, and <a class="el" href="style_example_8c-example.html#a2">style_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="a429998ab7c120490f34921c35e1d76d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a429998ab7c120490f34921c35e1d76d2">&#9670;&nbsp;</a></span>colr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#a25670add558019fdb66a60d51f0ffbda">_colr</a>(__VA_ARGS__, _ColrLastArg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointers, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointers, and strings into one long string. </p>
<p>To build the <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointers, it is better to use the <a class="el" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f" title="Create a fore color suitable for use with the colr() and Colr() macros. ">fore()</a>, <a class="el" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8" title="Create a back color suitable for use with the colr() and Colr() macros. ">back()</a>, and <a class="el" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662" title="Create a style suitable for use with the colr() and Colr() macros. ">style()</a> macros. The ColorArgs are heap allocated, but <a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2" title="Join ColorArg pointers, ColorText pointers, and strings into one long string. ">colr()</a> will free() them for you.</p>
<p>To build the <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointers, it is better to use the <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr() macro...">Colr()</a> macro, along with the <a class="el" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f" title="Create a fore color suitable for use with the colr() and Colr() macros. ">fore()</a>, <a class="el" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8" title="Create a back color suitable for use with the colr() and Colr() macros. ">back()</a>, and <a class="el" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662" title="Create a style suitable for use with the colr() and Colr() macros. ">style()</a> macros. The ColorTexts are heap allocated, but <a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2" title="Join ColorArg pointers, ColorText pointers, and strings into one long string. ">colr()</a> will free() them for you.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>One or more <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointers, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointers, or strings to join. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string result.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr() macro...">Colr</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="back_example_8c-example.html#a0">back_example.c</a>, <a class="el" href="Colr_example_8c-example.html#a0">Colr_example.c</a>, <a class="el" href="colr_example_8c-example.html#a0">colr_example.c</a>, <a class="el" href="fore_example_8c-example.html#a0">fore_example.c</a>, and <a class="el" href="style_example_8c-example.html#a0">style_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="aac52a4a5dbfd4f87ffd84e538eab9c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac52a4a5dbfd4f87ffd84e538eab9c29">&#9670;&nbsp;</a></span>Colr_center</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Colr_center</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">text, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">justwidth, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="colr_8h.html#ab408d87cce896acccb75357acca8ade4">ColorText_set_just</a>( \</div><div class="line">        <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(text, __VA_ARGS__), \</div><div class="line">        (<a class="code" href="colr_8h.html#structColorJustify">ColorJustify</a>){.method=JUST_CENTER, .width=justwidth, .padchar=<span class="charliteral">&#39; &#39;</span>} \</div><div class="line">    )</div><div class="ttc" id="colr_8h_html_ab408d87cce896acccb75357acca8ade4"><div class="ttname"><a href="colr_8h.html#ab408d87cce896acccb75357acca8ade4">ColorText_set_just</a></div><div class="ttdeci">ColorText * ColorText_set_just(ColorText *ctext, ColorJustify cjust)</div><div class="ttdoc">Set the ColorJustify method for a ColorText, and return the ColorText. </div><div class="ttdef"><b>Definition:</b> colr.c:3271</div></div>
<div class="ttc" id="colr_8h_html_structColorJustify"><div class="ttname"><a href="colr_8h.html#structColorJustify">ColorJustify</a></div><div class="ttdoc">Holds a string justification method, width, and padding character for ColorTexts. ...</div><div class="ttdef"><b>Definition:</b> colr.h:1345</div></div>
<div class="ttc" id="colr_8h_html_ade1c77f81a0fd49f7895598cbd9ac76c"><div class="ttname"><a href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a></div><div class="ttdeci">#define Colr(text,...)</div><div class="ttdoc">Returns a heap-allocated ColorText struct that can be used by itself, or with the colr() macro...</div><div class="ttdef"><b>Definition:</b> colr.h:467</div></div>
</div><!-- fragment -->
<p>Sets the JustifyMethod for a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> while allocating it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>Text to colorize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">justwidth</td><td>Width for justification. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Fore, back, or style ColorArgs for <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr() macro...">Colr()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.<br />
 If used inside of the <a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2" title="Join ColorArg pointers, ColorText pointers, and strings into one long string. ">colr()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, and <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr() macro...">Colr()</a> macros, <em>they will <code>free()</code> the result</em>.<br />
Otherwise, <em>you are responsible for calling <code>free()</code></em>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="Colr_example_8c-example.html#a3">Colr_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="a36af8aa0f01eaa780da182e856923faa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36af8aa0f01eaa780da182e856923faa">&#9670;&nbsp;</a></span>colr_eq</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_eq</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_Generic( \</div><div class="line">        (a), \</div><div class="line">        <a class="code" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>: <a class="code" href="colr_8h.html#a17bf46ac385e41b729d07a65dd506cba">BasicValue_eq</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorArg">ColorArg</a>: <a class="code" href="colr_8h.html#acb62efc0182d6f6107055eeda961a628">ColorArg_eq</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorJustify">ColorJustify</a>: <a class="code" href="colr_8h.html#ab71656e616aef4bbb3c278d43c4a326e">ColorJustify_eq</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>: <a class="code" href="colr_8h.html#a29e3483ae4add048424177fdc2b97b71">ColorType_eq</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorValue">ColorValue</a>: <a class="code" href="colr_8h.html#adf57e195301864cec80739e7e0f3000c">ColorValue_eq</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>: <a class="code" href="colr_8h.html#ac847d91a396ae6babc0bd46e6386a701">ExtendedValue_eq</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structRGB">RGB</a>: <a class="code" href="colr_8h.html#ad4b5f73b8aa9d72216d7386221418ae1">RGB_eq</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>: <a class="code" href="colr_8h.html#a32bf31475b0f6264b45438bd5c09ee7d">StyleValue_eq</a> \</div><div class="line">    )(a, b)</div><div class="ttc" id="colr_8h_html_acb62efc0182d6f6107055eeda961a628"><div class="ttname"><a href="colr_8h.html#acb62efc0182d6f6107055eeda961a628">ColorArg_eq</a></div><div class="ttdeci">bool ColorArg_eq(ColorArg a, ColorArg b)</div><div class="ttdoc">Compares two ColorArg structs. </div><div class="ttdef"><b>Definition:</b> colr.c:2612</div></div>
<div class="ttc" id="colr_8h_html_structColorValue"><div class="ttname"><a href="colr_8h.html#structColorValue">ColorValue</a></div><div class="ttdoc">Holds a color type and it&amp;#39;s value. </div><div class="ttdef"><b>Definition:</b> colr.h:1335</div></div>
<div class="ttc" id="colr_8h_html_structColorJustify"><div class="ttname"><a href="colr_8h.html#structColorJustify">ColorJustify</a></div><div class="ttdoc">Holds a string justification method, width, and padding character for ColorTexts. ...</div><div class="ttdef"><b>Definition:</b> colr.h:1345</div></div>
<div class="ttc" id="colr_8h_html_a0c061fbfddd43dfe324486dc86cb92ee"><div class="ttname"><a href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a></div><div class="ttdeci">BasicValue</div><div class="ttdoc">Basic color values, with a few convenience values for extended colors. </div><div class="ttdef"><b>Definition:</b> colr.h:1117</div></div>
<div class="ttc" id="colr_8h_html_a29e3483ae4add048424177fdc2b97b71"><div class="ttname"><a href="colr_8h.html#a29e3483ae4add048424177fdc2b97b71">ColorType_eq</a></div><div class="ttdeci">bool ColorType_eq(ColorType a, ColorType b)</div><div class="ttdoc">Compares two ColorTypes. </div><div class="ttdef"><b>Definition:</b> colr.c:3402</div></div>
<div class="ttc" id="colr_8h_html_ab71656e616aef4bbb3c278d43c4a326e"><div class="ttname"><a href="colr_8h.html#ab71656e616aef4bbb3c278d43c4a326e">ColorJustify_eq</a></div><div class="ttdeci">bool ColorJustify_eq(ColorJustify a, ColorJustify b)</div><div class="ttdoc">Compares two ColorJustify structs. </div><div class="ttdef"><b>Definition:</b> colr.c:2943</div></div>
<div class="ttc" id="colr_8h_html_adf57e195301864cec80739e7e0f3000c"><div class="ttname"><a href="colr_8h.html#adf57e195301864cec80739e7e0f3000c">ColorValue_eq</a></div><div class="ttdeci">bool ColorValue_eq(ColorValue a, ColorValue b)</div><div class="ttdoc">Compares two ColorValue structs. </div><div class="ttdef"><b>Definition:</b> colr.c:3570</div></div>
<div class="ttc" id="colr_8h_html_a32bf31475b0f6264b45438bd5c09ee7d"><div class="ttname"><a href="colr_8h.html#a32bf31475b0f6264b45438bd5c09ee7d">StyleValue_eq</a></div><div class="ttdeci">bool StyleValue_eq(StyleValue a, StyleValue b)</div><div class="ttdoc">Compares two StyleValues. </div><div class="ttdef"><b>Definition:</b> colr.c:4561</div></div>
<div class="ttc" id="colr_8h_html_ac847d91a396ae6babc0bd46e6386a701"><div class="ttname"><a href="colr_8h.html#ac847d91a396ae6babc0bd46e6386a701">ExtendedValue_eq</a></div><div class="ttdeci">bool ExtendedValue_eq(ExtendedValue a, ExtendedValue b)</div><div class="ttdoc">Compares two ExtendedValues. </div><div class="ttdef"><b>Definition:</b> colr.c:4098</div></div>
<div class="ttc" id="colr_8h_html_structColorArg"><div class="ttname"><a href="colr_8h.html#structColorArg">ColorArg</a></div><div class="ttdoc">Holds an ArgType, and a ColorValue. </div><div class="ttdef"><b>Definition:</b> colr.h:1373</div></div>
<div class="ttc" id="colr_8h_html_ad4b5f73b8aa9d72216d7386221418ae1"><div class="ttname"><a href="colr_8h.html#ad4b5f73b8aa9d72216d7386221418ae1">RGB_eq</a></div><div class="ttdeci">bool RGB_eq(RGB a, RGB b)</div><div class="ttdoc">Compare two RGB structs. </div><div class="ttdef"><b>Definition:</b> colr.c:4300</div></div>
<div class="ttc" id="colr_8h_html_structRGB"><div class="ttname"><a href="colr_8h.html#structRGB">RGB</a></div><div class="ttdoc">Container for RGB values. </div><div class="ttdef"><b>Definition:</b> colr.h:1200</div></div>
<div class="ttc" id="colr_8h_html_a5e133660cf9d4bcd1cb6a49e3ec16f83"><div class="ttname"><a href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a></div><div class="ttdeci">ColorType</div><div class="ttdoc">Color/Style code types. Used with ColorType_from_str() and ColorValue. </div><div class="ttdef"><b>Definition:</b> colr.h:1269</div></div>
<div class="ttc" id="colr_8h_html_a6dda29f582a062546ef8733d8b7d8a94"><div class="ttname"><a href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a></div><div class="ttdeci">unsigned char ExtendedValue</div><div class="ttdoc">Convenience typedef for clarity when dealing with extended (256) colors. </div><div class="ttdef"><b>Definition:</b> colr.h:1189</div></div>
<div class="ttc" id="colr_8h_html_a85224ec2507f33b1985f4cdd0adfe0e6"><div class="ttname"><a href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a></div><div class="ttdeci">StyleValue</div><div class="ttdoc">Style values. </div><div class="ttdef"><b>Definition:</b> colr.h:1214</div></div>
<div class="ttc" id="colr_8h_html_a17bf46ac385e41b729d07a65dd506cba"><div class="ttname"><a href="colr_8h.html#a17bf46ac385e41b729d07a65dd506cba">BasicValue_eq</a></div><div class="ttdeci">bool BasicValue_eq(BasicValue a, BasicValue b)</div><div class="ttdoc">Compares two BasicValues. </div><div class="ttdef"><b>Definition:</b> colr.c:3961</div></div>
</div><!-- fragment -->
<p>Calls the &lt;type&gt;_eq functions for the supported types. </p>
<p>The types for <code>a</code> and <code>b</code> must be the same.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First supported type to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second supported type to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the values are equal, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a76eae619668e01987653932a7492fd94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76eae619668e01987653932a7492fd94">&#9670;&nbsp;</a></span>colr_free</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_free</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_Generic( \</div><div class="line">        (x), \</div><div class="line">        <a class="code" href="colr_8h.html#structColorArg">ColorArg</a>*: <a class="code" href="colr_8h.html#aa1163a9c866767fb7fcb734d3c0d9b7c">ColorArg_free</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorText">ColorText</a>*: <a class="code" href="colr_8h.html#a901e5738358a739629cc3aaccab3e73f">ColorText_free</a>, \</div><div class="line">        <span class="keywordflow">default</span>: free \</div><div class="line">    )(x)</div><div class="ttc" id="colr_8h_html_aa1163a9c866767fb7fcb734d3c0d9b7c"><div class="ttname"><a href="colr_8h.html#aa1163a9c866767fb7fcb734d3c0d9b7c">ColorArg_free</a></div><div class="ttdeci">void ColorArg_free(ColorArg *p)</div><div class="ttdoc">Free allocated memory for a ColorArg. </div><div class="ttdef"><b>Definition:</b> colr.c:2626</div></div>
<div class="ttc" id="colr_8h_html_a901e5738358a739629cc3aaccab3e73f"><div class="ttname"><a href="colr_8h.html#a901e5738358a739629cc3aaccab3e73f">ColorText_free</a></div><div class="ttdeci">void ColorText_free(ColorText *p)</div><div class="ttdoc">Frees a ColorText and it&amp;#39;s ColorArgs. </div><div class="ttdef"><b>Definition:</b> colr.c:3071</div></div>
<div class="ttc" id="colr_8h_html_structColorArg"><div class="ttname"><a href="colr_8h.html#structColorArg">ColorArg</a></div><div class="ttdoc">Holds an ArgType, and a ColorValue. </div><div class="ttdef"><b>Definition:</b> colr.h:1373</div></div>
<div class="ttc" id="colr_8h_html_structColorText"><div class="ttname"><a href="colr_8h.html#structColorText">ColorText</a></div><div class="ttdoc">Holds a string of text, and optional fore, back, and style ColorArgs. </div><div class="ttdef"><b>Definition:</b> colr.h:1383</div></div>
</div><!-- fragment -->
<p>Calls the &lt;type&gt;_free functions for the supported types. </p>
<p>If the type is not supported, a plain <code>free(x)</code> is used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A pointer to a supported type to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0819ea3109493d7fe1656a7cadaca7d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0819ea3109493d7fe1656a7cadaca7d5">&#9670;&nbsp;</a></span>colr_is_empty</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_is_empty</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_Generic( \</div><div class="line">        (x), \</div><div class="line">        <a class="code" href="colr_8h.html#structColorArg">ColorArg</a>: <a class="code" href="colr_8h.html#a752355c2d96d35688d3756558f8421ba">ColorArg_is_empty</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorJustify">ColorJustify</a>: <a class="code" href="colr_8h.html#a34f193b6e6a20c63caecc1d9b53c89fb">ColorJustify_is_empty</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorText">ColorText</a>: <a class="code" href="colr_8h.html#ac846e583415e832b9090270020320b9f">ColorText_is_empty</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorValue">ColorValue</a>: <a class="code" href="colr_8h.html#a48005bb1589a7ebeef413ccee2a7c2a1">ColorValue_is_empty</a> \</div><div class="line">    )(x)</div><div class="ttc" id="colr_8h_html_structColorValue"><div class="ttname"><a href="colr_8h.html#structColorValue">ColorValue</a></div><div class="ttdoc">Holds a color type and it&amp;#39;s value. </div><div class="ttdef"><b>Definition:</b> colr.h:1335</div></div>
<div class="ttc" id="colr_8h_html_a752355c2d96d35688d3756558f8421ba"><div class="ttname"><a href="colr_8h.html#a752355c2d96d35688d3756558f8421ba">ColorArg_is_empty</a></div><div class="ttdeci">bool ColorArg_is_empty(ColorArg carg)</div><div class="ttdoc">Checks to see if a ColorArg is an empty placeholder. </div><div class="ttdef"><b>Definition:</b> colr.c:2787</div></div>
<div class="ttc" id="colr_8h_html_structColorJustify"><div class="ttname"><a href="colr_8h.html#structColorJustify">ColorJustify</a></div><div class="ttdoc">Holds a string justification method, width, and padding character for ColorTexts. ...</div><div class="ttdef"><b>Definition:</b> colr.h:1345</div></div>
<div class="ttc" id="colr_8h_html_ac846e583415e832b9090270020320b9f"><div class="ttname"><a href="colr_8h.html#ac846e583415e832b9090270020320b9f">ColorText_is_empty</a></div><div class="ttdeci">bool ColorText_is_empty(ColorText ctext)</div><div class="ttdoc">Checks to see if a ColorText has no usable values. </div><div class="ttdef"><b>Definition:</b> colr.c:3165</div></div>
<div class="ttc" id="colr_8h_html_structColorArg"><div class="ttname"><a href="colr_8h.html#structColorArg">ColorArg</a></div><div class="ttdoc">Holds an ArgType, and a ColorValue. </div><div class="ttdef"><b>Definition:</b> colr.h:1373</div></div>
<div class="ttc" id="colr_8h_html_structColorText"><div class="ttname"><a href="colr_8h.html#structColorText">ColorText</a></div><div class="ttdoc">Holds a string of text, and optional fore, back, and style ColorArgs. </div><div class="ttdef"><b>Definition:</b> colr.h:1383</div></div>
<div class="ttc" id="colr_8h_html_a34f193b6e6a20c63caecc1d9b53c89fb"><div class="ttname"><a href="colr_8h.html#a34f193b6e6a20c63caecc1d9b53c89fb">ColorJustify_is_empty</a></div><div class="ttdeci">bool ColorJustify_is_empty(ColorJustify cjust)</div><div class="ttdoc">Checks to see if a ColorJustify is &quot;empty&quot;. </div><div class="ttdef"><b>Definition:</b> colr.c:2962</div></div>
<div class="ttc" id="colr_8h_html_a48005bb1589a7ebeef413ccee2a7c2a1"><div class="ttname"><a href="colr_8h.html#a48005bb1589a7ebeef413ccee2a7c2a1">ColorValue_is_empty</a></div><div class="ttdeci">bool ColorValue_is_empty(ColorValue cval)</div><div class="ttdoc">Checks to see if a ColorValue is an empty placeholder. </div><div class="ttdef"><b>Definition:</b> colr.c:3741</div></div>
</div><!-- fragment -->
<p>Calls the &lt;type&gt;is_empty functions for the supported types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A supported type to build a string from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2982e773789d3f819036212694afed5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2982e773789d3f819036212694afed5e">&#9670;&nbsp;</a></span>colr_is_invalid</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_is_invalid</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_Generic( \</div><div class="line">        (x), \</div><div class="line">        <a class="code" href="colr_8h.html#structColorArg">ColorArg</a>: <a class="code" href="colr_8h.html#a66b4906cfb08588005536db1250dc899">ColorArg_is_invalid</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>: <a class="code" href="colr_8h.html#adc223f6fda6296396e9ecddcc68d4aec">ColorType_is_invalid</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorValue">ColorValue</a>: <a class="code" href="colr_8h.html#a22fcf30338eb777592421543885f74e0">ColorValue_is_invalid</a> \</div><div class="line">    )(x)</div><div class="ttc" id="colr_8h_html_structColorValue"><div class="ttname"><a href="colr_8h.html#structColorValue">ColorValue</a></div><div class="ttdoc">Holds a color type and it&amp;#39;s value. </div><div class="ttdef"><b>Definition:</b> colr.h:1335</div></div>
<div class="ttc" id="colr_8h_html_a22fcf30338eb777592421543885f74e0"><div class="ttname"><a href="colr_8h.html#a22fcf30338eb777592421543885f74e0">ColorValue_is_invalid</a></div><div class="ttdeci">bool ColorValue_is_invalid(ColorValue cval)</div><div class="ttdoc">Checks to see if a ColorValue holds an invalid value. </div><div class="ttdef"><b>Definition:</b> colr.c:3757</div></div>
<div class="ttc" id="colr_8h_html_a66b4906cfb08588005536db1250dc899"><div class="ttname"><a href="colr_8h.html#a66b4906cfb08588005536db1250dc899">ColorArg_is_invalid</a></div><div class="ttdeci">bool ColorArg_is_invalid(ColorArg carg)</div><div class="ttdoc">Checks to see if a ColorArg holds an invalid value. </div><div class="ttdef"><b>Definition:</b> colr.c:2798</div></div>
<div class="ttc" id="colr_8h_html_structColorArg"><div class="ttname"><a href="colr_8h.html#structColorArg">ColorArg</a></div><div class="ttdoc">Holds an ArgType, and a ColorValue. </div><div class="ttdef"><b>Definition:</b> colr.h:1373</div></div>
<div class="ttc" id="colr_8h_html_adc223f6fda6296396e9ecddcc68d4aec"><div class="ttname"><a href="colr_8h.html#adc223f6fda6296396e9ecddcc68d4aec">ColorType_is_invalid</a></div><div class="ttdeci">bool ColorType_is_invalid(ColorType type)</div><div class="ttdoc">Check to see if a ColorType value is considered invalid. </div><div class="ttdef"><b>Definition:</b> colr.c:3481</div></div>
<div class="ttc" id="colr_8h_html_a5e133660cf9d4bcd1cb6a49e3ec16f83"><div class="ttname"><a href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a></div><div class="ttdeci">ColorType</div><div class="ttdoc">Color/Style code types. Used with ColorType_from_str() and ColorValue. </div><div class="ttdef"><b>Definition:</b> colr.h:1269</div></div>
</div><!-- fragment -->
<p>Calls the &lt;type&gt;is_invalid functions for the supported types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A supported type to build a string from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8909ecf2f0be1bbc70ab33667578134e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8909ecf2f0be1bbc70ab33667578134e">&#9670;&nbsp;</a></span>colr_is_valid</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_is_valid</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_Generic( \</div><div class="line">        (x), \</div><div class="line">        <a class="code" href="colr_8h.html#structColorArg">ColorArg</a>: <a class="code" href="colr_8h.html#a1e446f65d6987d52522a1755c909d421">ColorArg_is_valid</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>: <a class="code" href="colr_8h.html#a5a5883d43e3206584ad048908720afb2">ColorType_is_valid</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorValue">ColorValue</a>: <a class="code" href="colr_8h.html#ac7183410b61d12a99dda3f76c2705497">ColorValue_is_valid</a> \</div><div class="line">    )(x)</div><div class="ttc" id="colr_8h_html_a1e446f65d6987d52522a1755c909d421"><div class="ttname"><a href="colr_8h.html#a1e446f65d6987d52522a1755c909d421">ColorArg_is_valid</a></div><div class="ttdeci">bool ColorArg_is_valid(ColorArg carg)</div><div class="ttdoc">Checks to see if a ColorArg holds a valid value. </div><div class="ttdef"><b>Definition:</b> colr.c:2827</div></div>
<div class="ttc" id="colr_8h_html_structColorValue"><div class="ttname"><a href="colr_8h.html#structColorValue">ColorValue</a></div><div class="ttdoc">Holds a color type and it&amp;#39;s value. </div><div class="ttdef"><b>Definition:</b> colr.h:1335</div></div>
<div class="ttc" id="colr_8h_html_ac7183410b61d12a99dda3f76c2705497"><div class="ttname"><a href="colr_8h.html#ac7183410b61d12a99dda3f76c2705497">ColorValue_is_valid</a></div><div class="ttdeci">bool ColorValue_is_valid(ColorValue cval)</div><div class="ttdoc">Checks to see if a ColorValue holds a valid value. </div><div class="ttdef"><b>Definition:</b> colr.c:3768</div></div>
<div class="ttc" id="colr_8h_html_structColorArg"><div class="ttname"><a href="colr_8h.html#structColorArg">ColorArg</a></div><div class="ttdoc">Holds an ArgType, and a ColorValue. </div><div class="ttdef"><b>Definition:</b> colr.h:1373</div></div>
<div class="ttc" id="colr_8h_html_a5a5883d43e3206584ad048908720afb2"><div class="ttname"><a href="colr_8h.html#a5a5883d43e3206584ad048908720afb2">ColorType_is_valid</a></div><div class="ttdeci">bool ColorType_is_valid(ColorType type)</div><div class="ttdoc">Check to see if a ColorType value is considered valid. </div><div class="ttdef"><b>Definition:</b> colr.c:3492</div></div>
<div class="ttc" id="colr_8h_html_a5e133660cf9d4bcd1cb6a49e3ec16f83"><div class="ttname"><a href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a></div><div class="ttdeci">ColorType</div><div class="ttdoc">Color/Style code types. Used with ColorType_from_str() and ColorValue. </div><div class="ttdef"><b>Definition:</b> colr.h:1269</div></div>
</div><!-- fragment -->
<p>Calls the &lt;type&gt;is_valid functions for the supported types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A supported type to build a string from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b56172c3a4f77092b0b476359a2a746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b56172c3a4f77092b0b476359a2a746">&#9670;&nbsp;</a></span>colr_istr_either</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_istr_either</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s3&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((s1 &amp;&amp; s2 &amp;&amp; s3) ? (<a class="el" href="colr_8h.html#a2e6c31c3ae1ebaec998e526d0cc38abb">colr_istreq</a>(s1, s2) || <a class="el" href="colr_8h.html#a2e6c31c3ae1ebaec998e526d0cc38abb">colr_istreq</a>(s1, s3)) : 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro for <code>!strcasecmp(s1, s2) || !strcasecmp(s1, s3)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s1</td><td>The string to compare against the other two strings. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s2</td><td>The first string to compare with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s3</td><td>The second string to compare with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if <code>s1</code> is equal to <code>s2</code> or <code>s3</code>, otherwise <code>0</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ab2ebdcd3c6e598a244292c7605452e9d">colr_supports_rgb()</a>.</p>

</div>
</div>
<a id="a2e6c31c3ae1ebaec998e526d0cc38abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e6c31c3ae1ebaec998e526d0cc38abb">&#9670;&nbsp;</a></span>colr_istreq</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_istreq</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s2&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((s1 &amp;&amp; s2) ? !strcasecmp(s1, s2) : 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro for <code>!strcasecmp(s1, s2)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s1</td><td>The first string to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s2</td><td>The second string to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if <code>s1</code> and <code>s2</code> are equal, otherwise <code>0</code>. </dd></dl>

</div>
</div>
<a id="ae8cc35d2d3a15c9c22ebb0a0835c92f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8cc35d2d3a15c9c22ebb0a0835c92f0">&#9670;&nbsp;</a></span>colr_join</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_join</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">joiner, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join</a>(joiner, __VA_ARGS__, _ColrLastArg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointers, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointers, and strings by another <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointer, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointer, or string. </p>
<p>To build the <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointers, it is better to use the <a class="el" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f" title="Create a fore color suitable for use with the colr() and Colr() macros. ">fore()</a>, <a class="el" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8" title="Create a back color suitable for use with the colr() and Colr() macros. ">back()</a>, and <a class="el" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662" title="Create a style suitable for use with the colr() and Colr() macros. ">style()</a> macros. The ColorArgs are heap allocated, but <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a> will free() them for you.</p>
<p>To build the <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointers, it is better to use the <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr() macro...">Colr()</a> macro, along with the <a class="el" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f" title="Create a fore color suitable for use with the colr() and Colr() macros. ">fore()</a>, <a class="el" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8" title="Create a back color suitable for use with the colr() and Colr() macros. ">back()</a>, and <a class="el" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662" title="Create a style suitable for use with the colr() and Colr() macros. ">style()</a> macros. The ColorTexts are heap allocated, but <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a> will free() them for you.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">joiner</td><td>What to put between the other arguments. <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointer, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointer, or string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Other arguments to join, with <code>joiner</code> between them. <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointers, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointers, or strings, in any order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2" title="Join ColorArg pointers, ColorText pointers, and strings into one long string. ">colr</a> <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr() macro...">Colr</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="colr_join_example_8c-example.html#a0">colr_join_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="a373daeb0be048e4631ab04c445414362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a373daeb0be048e4631ab04c445414362">&#9670;&nbsp;</a></span>Colr_ljust</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Colr_ljust</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">text, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">justwidth, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="colr_8h.html#ab408d87cce896acccb75357acca8ade4">ColorText_set_just</a>( \</div><div class="line">        <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(text, __VA_ARGS__), \</div><div class="line">        (<a class="code" href="colr_8h.html#structColorJustify">ColorJustify</a>){.method=JUST_LEFT, .width=justwidth, .padchar=<span class="charliteral">&#39; &#39;</span>} \</div><div class="line">    )</div><div class="ttc" id="colr_8h_html_ab408d87cce896acccb75357acca8ade4"><div class="ttname"><a href="colr_8h.html#ab408d87cce896acccb75357acca8ade4">ColorText_set_just</a></div><div class="ttdeci">ColorText * ColorText_set_just(ColorText *ctext, ColorJustify cjust)</div><div class="ttdoc">Set the ColorJustify method for a ColorText, and return the ColorText. </div><div class="ttdef"><b>Definition:</b> colr.c:3271</div></div>
<div class="ttc" id="colr_8h_html_structColorJustify"><div class="ttname"><a href="colr_8h.html#structColorJustify">ColorJustify</a></div><div class="ttdoc">Holds a string justification method, width, and padding character for ColorTexts. ...</div><div class="ttdef"><b>Definition:</b> colr.h:1345</div></div>
<div class="ttc" id="colr_8h_html_ade1c77f81a0fd49f7895598cbd9ac76c"><div class="ttname"><a href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a></div><div class="ttdeci">#define Colr(text,...)</div><div class="ttdoc">Returns a heap-allocated ColorText struct that can be used by itself, or with the colr() macro...</div><div class="ttdef"><b>Definition:</b> colr.h:467</div></div>
</div><!-- fragment -->
<p>Sets the JustifyMethod for a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> while allocating it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>Text to colorize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">justwidth</td><td>Width for justification. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Fore, back, or style ColorArgs for <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr() macro...">Colr()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.<br />
 If used inside of the <a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2" title="Join ColorArg pointers, ColorText pointers, and strings into one long string. ">colr()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, and <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr() macro...">Colr()</a> macros, <em>they will <code>free()</code> the result</em>.<br />
Otherwise, <em>you are responsible for calling <code>free()</code></em>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="Colr_example_8c-example.html#a4">Colr_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="af2011f1f6c35bc63ca0cb23b9b893f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2011f1f6c35bc63ca0cb23b9b893f61">&#9670;&nbsp;</a></span>colr_max</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_max</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(a &gt; b ? a : b)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro for <code>(a &gt; b ? a : b)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First value to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second value to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>a</code> if <code>a &gt; b</code>, otherwise <code>b</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a412833a097b050c8ee99874c733bd030">ColorText_length()</a>.</p>

</div>
</div>
<a id="a4559cb7ed508a538687727ccd4586ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4559cb7ed508a538687727ccd4586ccb">&#9670;&nbsp;</a></span>colr_replace</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_replace</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">target, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">repl&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_Generic( \</div><div class="line">        (repl), \</div><div class="line">        <span class="keywordtype">char</span>*: <a class="code" href="colr_8h.html#a29047496628c944048314c83f9415a5b">colr_str_replace</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorArg">ColorArg</a>*: <a class="code" href="colr_8h.html#a44d236bca80dbce495c0f282c3a7d192">colr_str_replace_ColorArg</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorText">ColorText</a>*: <a class="code" href="colr_8h.html#a7ec6d96305890148b019602f2301f989">colr_str_replace_ColorText</a> \</div><div class="line">    )(s, target, repl)</div><div class="ttc" id="colr_8h_html_a7ec6d96305890148b019602f2301f989"><div class="ttname"><a href="colr_8h.html#a7ec6d96305890148b019602f2301f989">colr_str_replace_ColorText</a></div><div class="ttdeci">char * colr_str_replace_ColorText(char *s, const char *target, const ColorText *repl)</div><div class="ttdoc">Replace substrings in a string (char*) with a ColorText&amp;#39;s string result. </div><div class="ttdef"><b>Definition:</b> colr.c:1557</div></div>
<div class="ttc" id="colr_8h_html_a29047496628c944048314c83f9415a5b"><div class="ttname"><a href="colr_8h.html#a29047496628c944048314c83f9415a5b">colr_str_replace</a></div><div class="ttdeci">char * colr_str_replace(char *s, const char *target, const char *repl)</div><div class="ttdoc">Replaces substrings in a string (char*). </div><div class="ttdef"><b>Definition:</b> colr.c:1480</div></div>
<div class="ttc" id="colr_8h_html_structColorArg"><div class="ttname"><a href="colr_8h.html#structColorArg">ColorArg</a></div><div class="ttdoc">Holds an ArgType, and a ColorValue. </div><div class="ttdef"><b>Definition:</b> colr.h:1373</div></div>
<div class="ttc" id="colr_8h_html_structColorText"><div class="ttname"><a href="colr_8h.html#structColorText">ColorText</a></div><div class="ttdoc">Holds a string of text, and optional fore, back, and style ColorArgs. </div><div class="ttdef"><b>Definition:</b> colr.h:1383</div></div>
<div class="ttc" id="colr_8h_html_a44d236bca80dbce495c0f282c3a7d192"><div class="ttname"><a href="colr_8h.html#a44d236bca80dbce495c0f282c3a7d192">colr_str_replace_ColorArg</a></div><div class="ttdeci">char * colr_str_replace_ColorArg(char *s, const char *target, const ColorArg *repl)</div><div class="ttdoc">Replace substrings in a string (char*) with a ColorArg&amp;#39;s string result. </div><div class="ttdef"><b>Definition:</b> colr.c:1536</div></div>
</div><!-- fragment -->
<p>Replace a substring in <code>s</code> with another string, <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> string, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> string. </p>
<p>If a string (<code>char*</code>) is used as <code>repl</code>, this is just a wrapper around <a class="el" href="colr_8h.html#a29047496628c944048314c83f9415a5b" title="Replaces substrings in a string (char*). ">colr_str_replace()</a>.</p>
<p>If a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> is used as <code>repl</code>, the appropriate colr_str_replace_&lt;type&gt; function is called. The function will create a string of escape-codes/text to be used as a replacement.</p>
<p>If <code>repl</code> is <code>NULL</code>, then an empty string (<code>""</code>) is used as the replacement, which causes the <code>target</code> string to be removed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. <em>must be <code>null</code>-terminated</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>A target string to replace in <code>s</code>. <em>must be <code>null</code>-terminated</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>A string, <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to replace the target string with. If this is <code>NULL</code>, then an empty string is used (<code>""</code>) as the replacement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string with the result.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> </dd></dl>

</div>
</div>
<a id="ac1ef824dd213274fb239526269315543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ef824dd213274fb239526269315543">&#9670;&nbsp;</a></span>colr_repr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_repr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_Generic( \</div><div class="line">        (x), \</div><div class="line">        <a class="code" href="colr_8h.html#structColorArg">ColorArg</a>: <a class="code" href="colr_8h.html#a5af692f2357d46b9cee45bb114f2a4a2">ColorArg_repr</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorJustify">ColorJustify</a>: <a class="code" href="colr_8h.html#a6c35f6b47cc737744487d14d20241656">ColorJustify_repr</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#af1a3fe0b966f944fd659a98be170045f">ColorJustifyMethod</a>: <a class="code" href="colr_8h.html#adf78eeb364553d130055d93e9892cd9c">ColorJustifyMethod_repr</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorText">ColorText</a>: <a class="code" href="colr_8h.html#a575a6cdc2f65cf1cd25227f847ae8d76">ColorText_repr</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorValue">ColorValue</a>: <a class="code" href="colr_8h.html#a95cf6ab7c565726eeb7c276d734193f6">ColorValue_repr</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>: <a class="code" href="colr_8h.html#ad01ccaf04c71fc2474da94b050236572">ArgType_repr</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>: <a class="code" href="colr_8h.html#a291ca6d28f9f430794413b76b7b094ed">ColorType_repr</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>: <a class="code" href="colr_8h.html#a1bc0d9917621cab5b3efd162b7dc5a8c">BasicValue_repr</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>: <a class="code" href="colr_8h.html#aa45baebc38756a40e7084f8198999902">ExtendedValue_repr</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structRGB">RGB</a>: <a class="code" href="colr_8h.html#afd28864afbcfa4a344e4596130645177">RGB_repr</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>: <a class="code" href="colr_8h.html#a24b74664587dd3c0e981603ee75c331b">StyleValue_repr</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structTermSize">TermSize</a>: <a class="code" href="colr_8h.html#a41b4ed49acc5d806f161a3b31f5bf023">TermSize_repr</a>, \</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>*: <a class="code" href="colr_8h.html#a196ad91a69cfbeb27a5266ffc93ed353">colr_str_repr</a>, \</div><div class="line">        <span class="keywordtype">char</span>*: colr_str_repr, \</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>: <a class="code" href="colr_8h.html#aa4d7418d0f38aa5d42c9cc2f7a06cdd5">colr_char_repr</a>, \</div><div class="line">        <span class="keywordtype">char</span>: colr_char_repr \</div><div class="line">    )(x)</div><div class="ttc" id="colr_8h_html_a5af692f2357d46b9cee45bb114f2a4a2"><div class="ttname"><a href="colr_8h.html#a5af692f2357d46b9cee45bb114f2a4a2">ColorArg_repr</a></div><div class="ttdeci">char * ColorArg_repr(ColorArg carg)</div><div class="ttdoc">Creates a string (char*) representation for a ColorArg. </div><div class="ttdef"><b>Definition:</b> colr.c:2859</div></div>
<div class="ttc" id="colr_8h_html_aa45baebc38756a40e7084f8198999902"><div class="ttname"><a href="colr_8h.html#aa45baebc38756a40e7084f8198999902">ExtendedValue_repr</a></div><div class="ttdeci">char * ExtendedValue_repr(int eval)</div><div class="ttdoc">Creates a string (char*) representation of a ExtendedValue. </div><div class="ttdef"><b>Definition:</b> colr.c:4261</div></div>
<div class="ttc" id="colr_8h_html_structColorValue"><div class="ttname"><a href="colr_8h.html#structColorValue">ColorValue</a></div><div class="ttdoc">Holds a color type and it&amp;#39;s value. </div><div class="ttdef"><b>Definition:</b> colr.h:1335</div></div>
<div class="ttc" id="colr_8h_html_a24b74664587dd3c0e981603ee75c331b"><div class="ttname"><a href="colr_8h.html#a24b74664587dd3c0e981603ee75c331b">StyleValue_repr</a></div><div class="ttdeci">char * StyleValue_repr(StyleValue sval)</div><div class="ttdoc">Creates a string (char*) representation of a StyleValue. </div><div class="ttdef"><b>Definition:</b> colr.c:4597</div></div>
<div class="ttc" id="colr_8h_html_a291ca6d28f9f430794413b76b7b094ed"><div class="ttname"><a href="colr_8h.html#a291ca6d28f9f430794413b76b7b094ed">ColorType_repr</a></div><div class="ttdeci">char * ColorType_repr(ColorType type)</div><div class="ttdoc">Creates a string (char*) representation of a ColorType. </div><div class="ttdef"><b>Definition:</b> colr.c:3505</div></div>
<div class="ttc" id="colr_8h_html_adf78eeb364553d130055d93e9892cd9c"><div class="ttname"><a href="colr_8h.html#adf78eeb364553d130055d93e9892cd9c">ColorJustifyMethod_repr</a></div><div class="ttdeci">char * ColorJustifyMethod_repr(ColorJustifyMethod meth)</div><div class="ttdoc">Creates a string (char*) representation for a ColorJustifyMethod. </div><div class="ttdef"><b>Definition:</b> colr.c:3028</div></div>
<div class="ttc" id="colr_8h_html_a0c061fbfddd43dfe324486dc86cb92ee"><div class="ttname"><a href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a></div><div class="ttdeci">BasicValue</div><div class="ttdoc">Basic color values, with a few convenience values for extended colors. </div><div class="ttdef"><b>Definition:</b> colr.h:1117</div></div>
<div class="ttc" id="colr_8h_html_structColorJustify"><div class="ttname"><a href="colr_8h.html#structColorJustify">ColorJustify</a></div><div class="ttdoc">Holds a string justification method, width, and padding character for ColorTexts. ...</div><div class="ttdef"><b>Definition:</b> colr.h:1345</div></div>
<div class="ttc" id="colr_8h_html_afd28864afbcfa4a344e4596130645177"><div class="ttname"><a href="colr_8h.html#afd28864afbcfa4a344e4596130645177">RGB_repr</a></div><div class="ttdeci">char * RGB_repr(RGB rgb)</div><div class="ttdoc">Creates a string (char*) representation for an RGB value. </div><div class="ttdef"><b>Definition:</b> colr.c:4540</div></div>
<div class="ttc" id="colr_8h_html_a58d8da4a4f5529031f00c7a6b9eeb5e1"><div class="ttname"><a href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a></div><div class="ttdeci">ArgType</div><div class="ttdoc">Argument types (fore, back, style). </div><div class="ttdef"><b>Definition:</b> colr.h:1253</div></div>
<div class="ttc" id="colr_8h_html_a95cf6ab7c565726eeb7c276d734193f6"><div class="ttname"><a href="colr_8h.html#a95cf6ab7c565726eeb7c276d734193f6">ColorValue_repr</a></div><div class="ttdeci">char * ColorValue_repr(ColorValue cval)</div><div class="ttdoc">Creates a string (char*) representation of a ColorValue. </div><div class="ttdef"><b>Definition:</b> colr.c:3849</div></div>
<div class="ttc" id="colr_8h_html_a6c35f6b47cc737744487d14d20241656"><div class="ttname"><a href="colr_8h.html#a6c35f6b47cc737744487d14d20241656">ColorJustify_repr</a></div><div class="ttdeci">char * ColorJustify_repr(ColorJustify cjust)</div><div class="ttdoc">Creates a string (char*) representation for a ColorJustify. </div><div class="ttdef"><b>Definition:</b> colr.c:3000</div></div>
<div class="ttc" id="colr_8h_html_a575a6cdc2f65cf1cd25227f847ae8d76"><div class="ttname"><a href="colr_8h.html#a575a6cdc2f65cf1cd25227f847ae8d76">ColorText_repr</a></div><div class="ttdeci">char * ColorText_repr(ColorText)</div><div class="ttdoc">Allocate a string (char*) representation for a ColorText. </div><div class="ttdef"><b>Definition:</b> colr.c:3234</div></div>
<div class="ttc" id="colr_8h_html_ad01ccaf04c71fc2474da94b050236572"><div class="ttname"><a href="colr_8h.html#ad01ccaf04c71fc2474da94b050236572">ArgType_repr</a></div><div class="ttdeci">char * ArgType_repr(ArgType type)</div><div class="ttdoc">Creates a string (char*) representation of a ArgType. </div><div class="ttdef"><b>Definition:</b> colr.c:2537</div></div>
<div class="ttc" id="colr_8h_html_aa4d7418d0f38aa5d42c9cc2f7a06cdd5"><div class="ttname"><a href="colr_8h.html#aa4d7418d0f38aa5d42c9cc2f7a06cdd5">colr_char_repr</a></div><div class="ttdeci">char * colr_char_repr(char x)</div><div class="ttdoc">Creates a string (char*) representation for a char. </div><div class="ttdef"><b>Definition:</b> colr.c:906</div></div>
<div class="ttc" id="colr_8h_html_a41b4ed49acc5d806f161a3b31f5bf023"><div class="ttname"><a href="colr_8h.html#a41b4ed49acc5d806f161a3b31f5bf023">TermSize_repr</a></div><div class="ttdeci">char * TermSize_repr(TermSize ts)</div><div class="ttdoc">Create a string (char*) representation for a TermSize. </div><div class="ttdef"><b>Definition:</b> colr.c:4657</div></div>
<div class="ttc" id="colr_8h_html_structTermSize"><div class="ttname"><a href="colr_8h.html#structTermSize">TermSize</a></div><div class="ttdoc">Holds a terminal size, usually retrieved with colr_term_size(). </div><div class="ttdef"><b>Definition:</b> colr.h:1400</div></div>
<div class="ttc" id="colr_8h_html_a1bc0d9917621cab5b3efd162b7dc5a8c"><div class="ttname"><a href="colr_8h.html#a1bc0d9917621cab5b3efd162b7dc5a8c">BasicValue_repr</a></div><div class="ttdeci">char * BasicValue_repr(BasicValue bval)</div><div class="ttdoc">Creates a string (char*) representation of a BasicValue. </div><div class="ttdef"><b>Definition:</b> colr.c:3997</div></div>
<div class="ttc" id="colr_8h_html_structColorArg"><div class="ttname"><a href="colr_8h.html#structColorArg">ColorArg</a></div><div class="ttdoc">Holds an ArgType, and a ColorValue. </div><div class="ttdef"><b>Definition:</b> colr.h:1373</div></div>
<div class="ttc" id="colr_8h_html_a196ad91a69cfbeb27a5266ffc93ed353"><div class="ttname"><a href="colr_8h.html#a196ad91a69cfbeb27a5266ffc93ed353">colr_str_repr</a></div><div class="ttdeci">char * colr_str_repr(const char *s)</div><div class="ttdoc">Convert a string (char*) into a representation of a string, by wrapping it in quotes and escaping cha...</div><div class="ttdef"><b>Definition:</b> colr.c:1592</div></div>
<div class="ttc" id="colr_8h_html_structColorText"><div class="ttname"><a href="colr_8h.html#structColorText">ColorText</a></div><div class="ttdoc">Holds a string of text, and optional fore, back, and style ColorArgs. </div><div class="ttdef"><b>Definition:</b> colr.h:1383</div></div>
<div class="ttc" id="colr_8h_html_structRGB"><div class="ttname"><a href="colr_8h.html#structRGB">RGB</a></div><div class="ttdoc">Container for RGB values. </div><div class="ttdef"><b>Definition:</b> colr.h:1200</div></div>
<div class="ttc" id="colr_8h_html_a5e133660cf9d4bcd1cb6a49e3ec16f83"><div class="ttname"><a href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a></div><div class="ttdeci">ColorType</div><div class="ttdoc">Color/Style code types. Used with ColorType_from_str() and ColorValue. </div><div class="ttdef"><b>Definition:</b> colr.h:1269</div></div>
<div class="ttc" id="colr_8h_html_a6dda29f582a062546ef8733d8b7d8a94"><div class="ttname"><a href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a></div><div class="ttdeci">unsigned char ExtendedValue</div><div class="ttdoc">Convenience typedef for clarity when dealing with extended (256) colors. </div><div class="ttdef"><b>Definition:</b> colr.h:1189</div></div>
<div class="ttc" id="colr_8h_html_a85224ec2507f33b1985f4cdd0adfe0e6"><div class="ttname"><a href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a></div><div class="ttdeci">StyleValue</div><div class="ttdoc">Style values. </div><div class="ttdef"><b>Definition:</b> colr.h:1214</div></div>
<div class="ttc" id="colr_8h_html_af1a3fe0b966f944fd659a98be170045f"><div class="ttname"><a href="colr_8h.html#af1a3fe0b966f944fd659a98be170045f">ColorJustifyMethod</a></div><div class="ttdeci">ColorJustifyMethod</div><div class="ttdoc">Justification style for ColorTexts. </div><div class="ttdef"><b>Definition:</b> colr.h:1261</div></div>
</div><!-- fragment -->
<p>Transforms several ColrC objects into their string representations. </p>
<p>Uses _Generic (C11 standard) to dynamically dispatch to the proper <code>*_repr</code> functions.</p>
<p>If a regular string is passed in, it will be escaped and you must still <code>free()</code> the result.</p>
<p>Supported Types:</p><ul>
<li><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a></li>
<li><a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a></li>
<li>ColorJustifyMethod</li>
<li><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a></li>
<li><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a></li>
<li>ArgType</li>
<li>ColorType</li>
<li>BasicValue</li>
<li>ExtendedValue</li>
<li><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a></li>
<li>StyleValue</li>
<li><a class="el" href="colr_8h.html#structTermSize" title="Holds a terminal size, usually retrieved with colr_term_size(). ">TermSize</a></li>
<li>char*</li>
<li>char</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A value with one of the supported types to transform into a string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Stringified representation of what was passed in.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> </dd></dl>

</div>
</div>
<a id="aba613f3915a178c3eb981e072d53ef72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba613f3915a178c3eb981e072d53ef72">&#9670;&nbsp;</a></span>Colr_rjust</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Colr_rjust</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">text, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">justwidth, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="colr_8h.html#ab408d87cce896acccb75357acca8ade4">ColorText_set_just</a>( \</div><div class="line">        <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(text, __VA_ARGS__), \</div><div class="line">        (<a class="code" href="colr_8h.html#structColorJustify">ColorJustify</a>){.method=JUST_RIGHT, .width=justwidth, .padchar=<span class="charliteral">&#39; &#39;</span>} \</div><div class="line">    )</div><div class="ttc" id="colr_8h_html_ab408d87cce896acccb75357acca8ade4"><div class="ttname"><a href="colr_8h.html#ab408d87cce896acccb75357acca8ade4">ColorText_set_just</a></div><div class="ttdeci">ColorText * ColorText_set_just(ColorText *ctext, ColorJustify cjust)</div><div class="ttdoc">Set the ColorJustify method for a ColorText, and return the ColorText. </div><div class="ttdef"><b>Definition:</b> colr.c:3271</div></div>
<div class="ttc" id="colr_8h_html_structColorJustify"><div class="ttname"><a href="colr_8h.html#structColorJustify">ColorJustify</a></div><div class="ttdoc">Holds a string justification method, width, and padding character for ColorTexts. ...</div><div class="ttdef"><b>Definition:</b> colr.h:1345</div></div>
<div class="ttc" id="colr_8h_html_ade1c77f81a0fd49f7895598cbd9ac76c"><div class="ttname"><a href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a></div><div class="ttdeci">#define Colr(text,...)</div><div class="ttdoc">Returns a heap-allocated ColorText struct that can be used by itself, or with the colr() macro...</div><div class="ttdef"><b>Definition:</b> colr.h:467</div></div>
</div><!-- fragment -->
<p>Sets the JustifyMethod for a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> while allocating it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>Text to colorize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">justwidth</td><td>Width for justification. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Fore, back, or style ColorArgs for <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr() macro...">Colr()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.<br />
 If used inside of the <a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2" title="Join ColorArg pointers, ColorText pointers, and strings into one long string. ">colr()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, and <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr() macro...">Colr()</a> macros, <em>they will <code>free()</code> the result</em>.<br />
Otherwise, <em>you are responsible for calling <code>free()</code></em>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="Colr_example_8c-example.html#a6">Colr_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="aaa52f88d230028534c63d4255ec4426c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa52f88d230028534c63d4255ec4426c">&#9670;&nbsp;</a></span>Colr_str</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Colr_str</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">text, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2">colr</a>(<a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(text, __VA_ARGS__))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an allocated string directly from <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr() macro...">Colr()</a> arguments. </p>
<p>This is a wrapper around <code>colr(Colr(text, ...))</code>, which will automatically <code>free()</code> the <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, and return a string that you are responsible for.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>String to colorize/style. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>No more than 3 <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointers for fore, back, and style in any order.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string with the result.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="Colr_example_8c-example.html#a8">Colr_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="afeaf33a4617bbd5de036a160d784fb83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeaf33a4617bbd5de036a160d784fb83">&#9670;&nbsp;</a></span>colr_str_either</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_str_either</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s3&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(<a class="el" href="colr_8h.html#aa3efb8eb9314481b0692a75079e4a3f4">colr_str_eq</a>(s1, s2) || <a class="el" href="colr_8h.html#aa3efb8eb9314481b0692a75079e4a3f4">colr_str_eq</a>(s1, s3))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro for <code>!strcmp(s1, s2) || !strcmp(s1, s3)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s1</td><td>The string to compare against the other two strings. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s2</td><td>The first string to compare with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s3</td><td>The second string to compare with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if <code>s1</code> is equal to <code>s2</code> or <code>s3</code>, otherwise <code>0</code>. </dd></dl>

</div>
</div>
<a id="aa3efb8eb9314481b0692a75079e4a3f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3efb8eb9314481b0692a75079e4a3f4">&#9670;&nbsp;</a></span>colr_str_eq</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_str_eq</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s2&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((s1 &amp;&amp; s2) ? !strcmp(s1, s2) : 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro for <code>!strcmp(s1, s2)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s1</td><td>The first string to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s2</td><td>The second string to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if <code>s1</code> and <code>s2</code> are equal, otherwise <code>0</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a98c9e50fe14ad0c82bcf1a62699c05de">RGB_from_str()</a>.</p>

</div>
</div>
<a id="a790e5a9bd0b3ca7cd7d428007f6a21b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a790e5a9bd0b3ca7cd7d428007f6a21b9">&#9670;&nbsp;</a></span>colr_to_str</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define colr_to_str</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_Generic( \</div><div class="line">        (x), \</div><div class="line">        <a class="code" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>: <a class="code" href="colr_8h.html#a2b270bebb1a01212b7e44e52f61f94be">ArgType_to_str</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorArg">ColorArg</a>: <a class="code" href="colr_8h.html#a91fb398f6463553e576fc067f5a0a854">ColorArg_to_str</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorText">ColorText</a>: <a class="code" href="colr_8h.html#ae305b33e0a44b956ccf4123aa4f1a033">ColorText_to_str</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structColorValue">ColorValue</a>: <a class="code" href="colr_8h.html#a3d9ca6bef0b8e7eac4812349ab5562cb">ColorValue_to_str</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>: <a class="code" href="colr_8h.html#a4e334d6b9145fca9717fe5a2aeb542fe">ExtendedValue_to_str</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structRGB">RGB</a>: <a class="code" href="colr_8h.html#a16d2f9a1133c8a955f0a551870d7ebe8">RGB_to_str</a> \</div><div class="line">    )(x)</div><div class="ttc" id="colr_8h_html_structColorValue"><div class="ttname"><a href="colr_8h.html#structColorValue">ColorValue</a></div><div class="ttdoc">Holds a color type and it&amp;#39;s value. </div><div class="ttdef"><b>Definition:</b> colr.h:1335</div></div>
<div class="ttc" id="colr_8h_html_a91fb398f6463553e576fc067f5a0a854"><div class="ttname"><a href="colr_8h.html#a91fb398f6463553e576fc067f5a0a854">ColorArg_to_str</a></div><div class="ttdeci">char * ColorArg_to_str(ColorArg carg)</div><div class="ttdoc">Converts a ColorArg into an escape code string (char*). </div><div class="ttdef"><b>Definition:</b> colr.c:2912</div></div>
<div class="ttc" id="colr_8h_html_a58d8da4a4f5529031f00c7a6b9eeb5e1"><div class="ttname"><a href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a></div><div class="ttdeci">ArgType</div><div class="ttdoc">Argument types (fore, back, style). </div><div class="ttdef"><b>Definition:</b> colr.h:1253</div></div>
<div class="ttc" id="colr_8h_html_a16d2f9a1133c8a955f0a551870d7ebe8"><div class="ttname"><a href="colr_8h.html#a16d2f9a1133c8a955f0a551870d7ebe8">RGB_to_str</a></div><div class="ttdeci">char * RGB_to_str(RGB rgb)</div><div class="ttdoc">Convert an RGB value into an RGB string (char*) suitable for input to RGB_from_str(). </div><div class="ttdef"><b>Definition:</b> colr.c:4486</div></div>
<div class="ttc" id="colr_8h_html_a3d9ca6bef0b8e7eac4812349ab5562cb"><div class="ttname"><a href="colr_8h.html#a3d9ca6bef0b8e7eac4812349ab5562cb">ColorValue_to_str</a></div><div class="ttdeci">char * ColorValue_to_str(ArgType type, ColorValue cval)</div><div class="ttdoc">Converts a ColorValue into an escape code string (char*). </div><div class="ttdef"><b>Definition:</b> colr.c:3876</div></div>
<div class="ttc" id="colr_8h_html_a4e334d6b9145fca9717fe5a2aeb542fe"><div class="ttname"><a href="colr_8h.html#a4e334d6b9145fca9717fe5a2aeb542fe">ExtendedValue_to_str</a></div><div class="ttdeci">char * ExtendedValue_to_str(ExtendedValue eval)</div><div class="ttdoc">Creates a string (char*) from an ExtendedValue&amp;#39;s actual value, suitable for use with ExtendedValue_fr...</div><div class="ttdef"><b>Definition:</b> colr.c:4286</div></div>
<div class="ttc" id="colr_8h_html_structColorArg"><div class="ttname"><a href="colr_8h.html#structColorArg">ColorArg</a></div><div class="ttdoc">Holds an ArgType, and a ColorValue. </div><div class="ttdef"><b>Definition:</b> colr.h:1373</div></div>
<div class="ttc" id="colr_8h_html_structColorText"><div class="ttname"><a href="colr_8h.html#structColorText">ColorText</a></div><div class="ttdoc">Holds a string of text, and optional fore, back, and style ColorArgs. </div><div class="ttdef"><b>Definition:</b> colr.h:1383</div></div>
<div class="ttc" id="colr_8h_html_structRGB"><div class="ttname"><a href="colr_8h.html#structRGB">RGB</a></div><div class="ttdoc">Container for RGB values. </div><div class="ttdef"><b>Definition:</b> colr.h:1200</div></div>
<div class="ttc" id="colr_8h_html_ae305b33e0a44b956ccf4123aa4f1a033"><div class="ttname"><a href="colr_8h.html#ae305b33e0a44b956ccf4123aa4f1a033">ColorText_to_str</a></div><div class="ttdeci">char * ColorText_to_str(ColorText ctext)</div><div class="ttdoc">Stringifies a ColorText struct, creating a mix of escape codes and text. </div><div class="ttdef"><b>Definition:</b> colr.c:3349</div></div>
<div class="ttc" id="colr_8h_html_a6dda29f582a062546ef8733d8b7d8a94"><div class="ttname"><a href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a></div><div class="ttdeci">unsigned char ExtendedValue</div><div class="ttdoc">Convenience typedef for clarity when dealing with extended (256) colors. </div><div class="ttdef"><b>Definition:</b> colr.h:1189</div></div>
<div class="ttc" id="colr_8h_html_a2b270bebb1a01212b7e44e52f61f94be"><div class="ttname"><a href="colr_8h.html#a2b270bebb1a01212b7e44e52f61f94be">ArgType_to_str</a></div><div class="ttdeci">char * ArgType_to_str(ArgType type)</div><div class="ttdoc">Creates a string (char*) from an ArgType. </div><div class="ttdef"><b>Definition:</b> colr.c:2565</div></div>
</div><!-- fragment -->
<p>Calls the &lt;type&gt;to_str functions for the supported types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A supported type to build a string from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac69ec39944a786ba43206120851fa856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac69ec39944a786ba43206120851fa856">&#9670;&nbsp;</a></span>dbug_repr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define dbug_repr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">lbl, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> { \</div><div class="line">            char* _dbug_repr_s = <a class="code" href="colr_8h.html#ac1ef824dd213274fb239526269315543">colr_repr</a>(x); \</div><div class="line">            dbug(<span class="stringliteral">&quot;%s: %s\n&quot;</span>, lbl, _dbug_repr_s); \</div><div class="line">            free(_dbug_repr_s); \</div><div class="line">        } <span class="keywordflow">while</span>(0)</div><div class="ttc" id="colr_8h_html_ac1ef824dd213274fb239526269315543"><div class="ttname"><a href="colr_8h.html#ac1ef824dd213274fb239526269315543">colr_repr</a></div><div class="ttdeci">#define colr_repr(x)</div><div class="ttdoc">Transforms several ColrC objects into their string representations. </div><div class="ttdef"><b>Definition:</b> colr.h:758</div></div>
</div><!-- fragment -->
<p>Uses <a class="el" href="colr_8h.html#ac1ef824dd213274fb239526269315543" title="Transforms several ColrC objects into their string representations. ">colr_repr()</a> to build a string representation of a ColrC object, dbug prints it, and calls free() when it's done. </p>
<p>This is for dbugging purposes, and is a no-op when DEBUG is not defined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lbl</td><td>Label text for the dbug print. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Any object supported by <a class="el" href="colr_8h.html#ac1ef824dd213274fb239526269315543" title="Transforms several ColrC objects into their string representations. ">colr_repr()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37ff4fc6d17b53b60202be55bd0732c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ff4fc6d17b53b60202be55bd0732c5">&#9670;&nbsp;</a></span>ext</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ext</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;((<a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>)x)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts to ExtendedValue (unsigned char). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Value to cast to <code>unsigned char</code>/<code>ExtendedValue</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ExtendedValue.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f" title="Create a fore color suitable for use with the colr() and Colr() macros. ">fore</a> <a class="el" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8" title="Create a back color suitable for use with the colr() and Colr() macros. ">back</a> <a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2" title="Join ColorArg pointers, ColorText pointers, and strings into one long string. ">colr</a> <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr() macro...">Colr</a> <a class="el" href="colr_8h.html#aa3c79297600d8ab15a495843d63db54d" title="Like hex(), but force a conversion to the closest ExtendedValue (256-colors). ">ext_hex</a> <a class="el" href="colr_8h.html#affaeebdd3dad2cf0d5e14a7870c1e4f6" title="Like hex_or(), but force a conversion to the closest ExtendedValue (256-colors). ">ext_hex_or</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="back_example_8c-example.html#a3">back_example.c</a>, <a class="el" href="colr_example_8c-example.html#a5">colr_example.c</a>, and <a class="el" href="fore_example_8c-example.html#a2">fore_example.c</a>.</dd>
</dl>
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a1548d9fc5f3e00a7b5d834eb1e12ff93">ExtendedValue_from_RGB()</a>.</p>

</div>
</div>
<a id="aa3c79297600d8ab15a495843d63db54d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3c79297600d8ab15a495843d63db54d">&#9670;&nbsp;</a></span>ext_hex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ext_hex</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#affaeebdd3dad2cf0d5e14a7870c1e4f6">ext_hex_or</a>(s, <a class="el" href="colr_8h.html#a37ff4fc6d17b53b60202be55bd0732c5">ext</a>(0))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <a class="el" href="colr_8h.html#a8fe812f8e76e4baed394ee9adf46b3df" title="Use RGB_from_hex_default() to create an RGB value. ">hex()</a>, but force a conversion to the closest ExtendedValue (256-colors). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>A hex string to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The closest matching ExtendedValue, or 0 for bad hex strings.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a37ff4fc6d17b53b60202be55bd0732c5" title="Casts to ExtendedValue (unsigned char). ">ext</a> <a class="el" href="colr_8h.html#affaeebdd3dad2cf0d5e14a7870c1e4f6" title="Like hex_or(), but force a conversion to the closest ExtendedValue (256-colors). ">ext_hex_or</a> <a class="el" href="colr_8h.html#a8fe812f8e76e4baed394ee9adf46b3df" title="Use RGB_from_hex_default() to create an RGB value. ">hex</a> <a class="el" href="colr_8h.html#ab55724d1f9877f698cf8591df92b8887" title="Use RGB_from_hex_default() to create an RGB value. ">hex_or</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="back_example_8c-example.html#a7">back_example.c</a>, <a class="el" href="Colr_example_8c-example.html#a5">Colr_example.c</a>, and <a class="el" href="colr_join_example_8c-example.html#a5">colr_join_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="affaeebdd3dad2cf0d5e14a7870c1e4f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affaeebdd3dad2cf0d5e14a7870c1e4f6">&#9670;&nbsp;</a></span>ext_hex_or</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ext_hex_or</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">default_value&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#a757be189530b4925c84df25742374485">ExtendedValue_from_hex_default</a>(s, default_value)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <a class="el" href="colr_8h.html#ab55724d1f9877f698cf8591df92b8887" title="Use RGB_from_hex_default() to create an RGB value. ">hex_or()</a>, but force a conversion to the closest ExtendedValue (256-colors). </p>
<p>This is a convenience macro for <a class="el" href="colr_8h.html#a757be189530b4925c84df25742374485" title="Create an ExtendedValue from a hex string (char*), but return a default value if the hex string is in...">ExtendedValue_from_hex_default()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>A hex string to convert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_value</td><td>ExtendedValue to use if the hex string is not valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The closest matching ExtendedValue, or <code>default_value</code> for bad hex strings.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a37ff4fc6d17b53b60202be55bd0732c5" title="Casts to ExtendedValue (unsigned char). ">ext</a> <a class="el" href="colr_8h.html#aa3c79297600d8ab15a495843d63db54d" title="Like hex(), but force a conversion to the closest ExtendedValue (256-colors). ">ext_hex</a> <a class="el" href="colr_8h.html#a8fe812f8e76e4baed394ee9adf46b3df" title="Use RGB_from_hex_default() to create an RGB value. ">hex</a> <a class="el" href="colr_8h.html#ab55724d1f9877f698cf8591df92b8887" title="Use RGB_from_hex_default() to create an RGB value. ">hex_or</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="back_example_8c-example.html#a8">back_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="add3d47951e17cbf856902e11e4efa2e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add3d47951e17cbf856902e11e4efa2e6">&#9670;&nbsp;</a></span>ext_rgb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ext_rgb</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">r, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">g, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#a1548d9fc5f3e00a7b5d834eb1e12ff93">ExtendedValue_from_RGB</a>((<a class="el" href="colr_8h.html#structRGB">RGB</a>){.red=r, .green=g, .blue=b})</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the closest matching ExtendedValue from an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value. </p>
<p>This is short-hand for <a class="el" href="colr_8h.html#a1548d9fc5f3e00a7b5d834eb1e12ff93" title="Convert an RGB value into the closest matching ExtendedValue. ">ExtendedValue_from_RGB()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>The red value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>The green value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The blue value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ExtendedValue that closely matches the <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a1548d9fc5f3e00a7b5d834eb1e12ff93" title="Convert an RGB value into the closest matching ExtendedValue. ">ExtendedValue_from_RGB</a> <a class="el" href="colr_8h.html#ab4576c531151e398b7ecede2e30df70d" title="Convert an RGB value into it&#39;s nearest terminal-friendly RGB value. ">RGB_to_term_RGB</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="Colr_example_8c-example.html#a7">Colr_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="afeb79141345fded0a55ee9aba354f567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeb79141345fded0a55ee9aba354f567">&#9670;&nbsp;</a></span>EXTENDED_INVALID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EXTENDED_INVALID&#160;&#160;&#160;<a class="el" href="colr_8h.html#aaaddb0f34c1374c29a8b7629ac40ca8b">COLOR_INVALID</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for COLOR_INVALID. </p>
<p>All color values share an _INVALID member with the same value, so: </p><div class="fragment"><div class="line"><a class="code" href="colr_8h.html#aaaddb0f34c1374c29a8b7629ac40ca8b">COLOR_INVALID</a> == BASIC_INVALID == <a class="code" href="colr_8h.html#afeb79141345fded0a55ee9aba354f567">EXTENDED_INVALID</a> == STYLE_INVALID</div></div><!-- fragment --> 
</div>
</div>
<a id="a19d8b61303404007a3224be0f8296c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19d8b61303404007a3224be0f8296c3f">&#9670;&nbsp;</a></span>fore</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define fore</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#afb5ac0bd012b8162cea125ad0d9e8bf0">ColorArg_to_ptr</a>(<a class="el" href="colr_8h.html#a3cc38de52ea52344113083ba4d90088e">fore_arg</a>(x))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a fore color suitable for use with the <a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2" title="Join ColorArg pointers, ColorText pointers, and strings into one long string. ">colr()</a> and <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr() macro...">Colr()</a> macros. </p>
<p>Technically, this macro accepts BasicValues, ExtendedValues, or <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> structs. However, for some of these you should be using the macros that create those things.</p>
<p>BasicValues can be used by their names (RED, YELLOW, etc.).</p>
<p>ExtendedValues can be created on the fly with <a class="el" href="colr_8h.html#a37ff4fc6d17b53b60202be55bd0732c5" title="Casts to ExtendedValue (unsigned char). ">ext()</a>.</p>
<p><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> structs can be easily created with <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57" title="Creates an anonymous RGB struct for use in function calls. ">rgb()</a>.</p>
<p>Color names (<code>char*</code>) can be passed to generate the appropriate color value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A BasicValue, ExtendedValue, or <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct to use for the color value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a heap-allocated <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct.<br />
 If used inside of the <a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2" title="Join ColorArg pointers, ColorText pointers, and strings into one long string. ">colr()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, and <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr() macro...">Colr()</a> macros, <em>they will <code>free()</code> the result</em>.<br />
Otherwise, <em>you are responsible for calling <code>free()</code></em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a3cc38de52ea52344113083ba4d90088e" title="Uses ColorArg_from_&lt;type&gt; to build a ColorArg with the appropriate color type, based on the type of i...">fore_arg</a> <a class="el" href="colr_8h.html#a0e27cd8b78fc357be02c4dbf6a6c9096" title="Retrieve just the escape code string for a fore color. ">fore_str</a> <a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2" title="Join ColorArg pointers, ColorText pointers, and strings into one long string. ">colr</a> <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr() macro...">Colr</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="back_example_8c-example.html#a1">back_example.c</a>, <a class="el" href="Colr_example_8c-example.html#a2">Colr_example.c</a>, <a class="el" href="colr_example_8c-example.html#a2">colr_example.c</a>, <a class="el" href="colr_join_example_8c-example.html#a2">colr_join_example.c</a>, and <a class="el" href="fore_example_8c-example.html#a1">fore_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="a3cc38de52ea52344113083ba4d90088e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cc38de52ea52344113083ba4d90088e">&#9670;&nbsp;</a></span>fore_arg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define fore_arg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_Generic( \</div><div class="line">        (x), \</div><div class="line">        <span class="keywordtype">char</span>* : <a class="code" href="colr_8h.html#ae8d897499fca87d7902159f4ed7dbba3">ColorArg_from_str</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#structRGB">RGB</a>: <a class="code" href="colr_8h.html#aaa24bba74e99aa66ed41839576e57856">ColorArg_from_RGB</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>: <a class="code" href="colr_8h.html#aad49f4597388e6bdb896ff28334cd5e6">ColorArg_from_BasicValue</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>: <a class="code" href="colr_8h.html#aed30e2a4b30ab5e3cf49608a3c410cc5">ColorArg_from_ExtendedValue</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>: <a class="code" href="colr_8h.html#acf63bcee395dca3ca29dc324e3d7c8f2">ColorArg_from_StyleValue</a> \</div><div class="line">    )(FORE, x)</div><div class="ttc" id="colr_8h_html_aed30e2a4b30ab5e3cf49608a3c410cc5"><div class="ttname"><a href="colr_8h.html#aed30e2a4b30ab5e3cf49608a3c410cc5">ColorArg_from_ExtendedValue</a></div><div class="ttdeci">ColorArg ColorArg_from_ExtendedValue(ArgType type, ExtendedValue value)</div><div class="ttdoc">Explicit version of ColorArg_from_value that only handles ExtendedValues. </div><div class="ttdef"><b>Definition:</b> colr.c:2666</div></div>
<div class="ttc" id="colr_8h_html_a0c061fbfddd43dfe324486dc86cb92ee"><div class="ttname"><a href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a></div><div class="ttdeci">BasicValue</div><div class="ttdoc">Basic color values, with a few convenience values for extended colors. </div><div class="ttdef"><b>Definition:</b> colr.h:1117</div></div>
<div class="ttc" id="colr_8h_html_aaa24bba74e99aa66ed41839576e57856"><div class="ttname"><a href="colr_8h.html#aaa24bba74e99aa66ed41839576e57856">ColorArg_from_RGB</a></div><div class="ttdeci">ColorArg ColorArg_from_RGB(ArgType type, RGB value)</div><div class="ttdoc">Explicit version of ColorArg_from_value that only handles RGB structs. </div><div class="ttdef"><b>Definition:</b> colr.c:2689</div></div>
<div class="ttc" id="colr_8h_html_acf63bcee395dca3ca29dc324e3d7c8f2"><div class="ttname"><a href="colr_8h.html#acf63bcee395dca3ca29dc324e3d7c8f2">ColorArg_from_StyleValue</a></div><div class="ttdeci">ColorArg ColorArg_from_StyleValue(ArgType type, StyleValue value)</div><div class="ttdoc">Explicit version of ColorArg_from_value that only handles StyleValues. </div><div class="ttdef"><b>Definition:</b> colr.c:2735</div></div>
<div class="ttc" id="colr_8h_html_structRGB"><div class="ttname"><a href="colr_8h.html#structRGB">RGB</a></div><div class="ttdoc">Container for RGB values. </div><div class="ttdef"><b>Definition:</b> colr.h:1200</div></div>
<div class="ttc" id="colr_8h_html_aad49f4597388e6bdb896ff28334cd5e6"><div class="ttname"><a href="colr_8h.html#aad49f4597388e6bdb896ff28334cd5e6">ColorArg_from_BasicValue</a></div><div class="ttdeci">ColorArg ColorArg_from_BasicValue(ArgType type, BasicValue value)</div><div class="ttdoc">Explicit version of ColorArg_from_value that only handles BasicValues. </div><div class="ttdef"><b>Definition:</b> colr.c:2643</div></div>
<div class="ttc" id="colr_8h_html_a6dda29f582a062546ef8733d8b7d8a94"><div class="ttname"><a href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a></div><div class="ttdeci">unsigned char ExtendedValue</div><div class="ttdoc">Convenience typedef for clarity when dealing with extended (256) colors. </div><div class="ttdef"><b>Definition:</b> colr.h:1189</div></div>
<div class="ttc" id="colr_8h_html_ae8d897499fca87d7902159f4ed7dbba3"><div class="ttname"><a href="colr_8h.html#ae8d897499fca87d7902159f4ed7dbba3">ColorArg_from_str</a></div><div class="ttdeci">ColorArg ColorArg_from_str(ArgType type, char *colorname)</div><div class="ttdoc">Build a ColorArg (fore, back, or style value) from a known color name/style. </div><div class="ttdef"><b>Definition:</b> colr.c:2713</div></div>
<div class="ttc" id="colr_8h_html_a85224ec2507f33b1985f4cdd0adfe0e6"><div class="ttname"><a href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a></div><div class="ttdeci">StyleValue</div><div class="ttdoc">Style values. </div><div class="ttdef"><b>Definition:</b> colr.h:1214</div></div>
</div><!-- fragment -->
<p>Uses ColorArg_from_&lt;type&gt; to build a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> with the appropriate color type, based on the type of it's argument. </p>
<p>Uses <code>_Generic</code> (C11 standard) to dynamically create a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>. This is used by the <a class="el" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f" title="Create a fore color suitable for use with the colr() and Colr() macros. ">fore()</a> macro.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td><code>BasicValue</code>, <code>Extended</code> (<code>unsigned char</code>), <code><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a></code> struct, or string (color name) for fore color. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> with the FORE type set, and it's <code>.value.type</code> set for the appropriate color type/value. For invalid values the <code>.value.type</code> may be set to TYPE_INVALID.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f" title="Create a fore color suitable for use with the colr() and Colr() macros. ">fore</a> <a class="el" href="colr_8h.html#a0e27cd8b78fc357be02c4dbf6a6c9096" title="Retrieve just the escape code string for a fore color. ">fore_str</a> </dd></dl>

</div>
</div>
<a id="a0e27cd8b78fc357be02c4dbf6a6c9096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e27cd8b78fc357be02c4dbf6a6c9096">&#9670;&nbsp;</a></span>fore_str</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define fore_str</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#a91fb398f6463553e576fc067f5a0a854">ColorArg_to_str</a>(<a class="el" href="colr_8h.html#a3cc38de52ea52344113083ba4d90088e">fore_arg</a>(x))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve just the escape code string for a fore color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A BasicValue, ExtendedValue, or <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f" title="Create a fore color suitable for use with the colr() and Colr() macros. ">fore</a> <a class="el" href="colr_8h.html#a3cc38de52ea52344113083ba4d90088e" title="Uses ColorArg_from_&lt;type&gt; to build a ColorArg with the appropriate color type, based on the type of i...">fore_arg</a> </dd></dl>

</div>
</div>
<a id="a8fe812f8e76e4baed394ee9adf46b3df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe812f8e76e4baed394ee9adf46b3df">&#9670;&nbsp;</a></span>hex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hex</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#ab55724d1f9877f698cf8591df92b8887">hex_or</a>(s, <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>(0, 0, 0))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use <a class="el" href="colr_8h.html#a6133112d9c73a8b56995e16e1af62d3b" title="Convert a hex color into an RGB value, but use a default value when errors occur. ...">RGB_from_hex_default()</a> to create an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>A hex string to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A valid <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value, or <code><a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57" title="Creates an anonymous RGB struct for use in function calls. ">rgb(0, 0, 0)</a></code> for bad hex strings.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#ab55724d1f9877f698cf8591df92b8887" title="Use RGB_from_hex_default() to create an RGB value. ">hex_or</a> <a class="el" href="colr_8h.html#aa3c79297600d8ab15a495843d63db54d" title="Like hex(), but force a conversion to the closest ExtendedValue (256-colors). ">ext_hex</a> <a class="el" href="colr_8h.html#affaeebdd3dad2cf0d5e14a7870c1e4f6" title="Like hex_or(), but force a conversion to the closest ExtendedValue (256-colors). ">ext_hex_or</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="back_example_8c-example.html#a5">back_example.c</a>, and <a class="el" href="colr_join_example_8c-example.html#a7">colr_join_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="ab55724d1f9877f698cf8591df92b8887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55724d1f9877f698cf8591df92b8887">&#9670;&nbsp;</a></span>hex_or</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hex_or</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">default_rgb&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#a6133112d9c73a8b56995e16e1af62d3b">RGB_from_hex_default</a>(s, default_rgb)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use <a class="el" href="colr_8h.html#a6133112d9c73a8b56995e16e1af62d3b" title="Convert a hex color into an RGB value, but use a default value when errors occur. ...">RGB_from_hex_default()</a> to create an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>A hex string to convert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_rgb</td><td>Default <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value to use if the hex string is not valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A valid <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value, or <code>default_rgb</code> for bad hex strings.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a8fe812f8e76e4baed394ee9adf46b3df" title="Use RGB_from_hex_default() to create an RGB value. ">hex</a> <a class="el" href="colr_8h.html#aa3c79297600d8ab15a495843d63db54d" title="Like hex(), but force a conversion to the closest ExtendedValue (256-colors). ">ext_hex</a> <a class="el" href="colr_8h.html#affaeebdd3dad2cf0d5e14a7870c1e4f6" title="Like hex_or(), but force a conversion to the closest ExtendedValue (256-colors). ">ext_hex_or</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="back_example_8c-example.html#a6">back_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="a80a08fc1383c7260a31698864d52fee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a08fc1383c7260a31698864d52fee2">&#9670;&nbsp;</a></span>if_not_asprintf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define if_not_asprintf</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;if (asprintf(__VA_ARGS__) &lt; 1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro for checking asprintf's return value. </p>
<p>Should be followed by a block of code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Arguments for asprintf. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1adf75633b342417b6a2dda3d9e8dcd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1adf75633b342417b6a2dda3d9e8dcd3">&#9670;&nbsp;</a></span>inline_str_lstrip_char</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define inline_str_lstrip_char</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dest, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">length, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> { \</div><div class="line">        size_t _st_l_c_dest_i = 0; \</div><div class="line">        for (<span class="keywordtype">size_t</span> _st_l_c_i = 0; _st_l_c_i &lt; length; _st_l_c_i++) { \</div><div class="line">            if (s[_st_l_c_i] == c) <span class="keywordflow">continue</span>; \</div><div class="line">            dest[_st_l_c_dest_i] = s[_st_l_c_i]; \</div><div class="line">            _st_l_c_dest_i++; \</div><div class="line">        } \</div><div class="line">    } <span class="keywordflow">while</span> (0);</div></div><!-- fragment -->
<p>Strip a leading character from a string, filling a <code>char</code> array with the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>Destination <code>char</code> array. Must have room for <code>strlen(s) + 1</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>String to strip the character from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of <code>s</code>, the input string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Character to strip. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ad33884dcde034819c5e6749667247194">RGB_from_hex()</a>.</p>

</div>
</div>
<a id="a6fa7a1b0351d0bdbdf9fd5f882673d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fa7a1b0351d0bdbdf9fd5f882673d57">&#9670;&nbsp;</a></span>rgb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rgb</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">r, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">g, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((<a class="el" href="colr_8h.html#structRGB">RGB</a>){.red=r, .green=g, .blue=b})</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an anonymous <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct for use in function calls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td><code>unsigned char</code> Red value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td><code>unsigned char</code> Blue value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td><code>unsigned char</code> Green value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f" title="Create a fore color suitable for use with the colr() and Colr() macros. ">fore</a> <a class="el" href="colr_8h.html#a947915cd251af5099f6a9232836b12d8" title="Create a back color suitable for use with the colr() and Colr() macros. ">back</a> <a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2" title="Join ColorArg pointers, ColorText pointers, and strings into one long string. ">colr</a> <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr() macro...">Colr</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="back_example_8c-example.html#a4">back_example.c</a>, <a class="el" href="colr_example_8c-example.html#a3">colr_example.c</a>, <a class="el" href="colr_join_example_8c-example.html#a3">colr_join_example.c</a>, and <a class="el" href="fore_example_8c-example.html#a3">fore_example.c</a>.</dd>
</dl>
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a0632d78965000b1e50068a64e335133b">ExtendedValue_from_hex()</a>, <a class="el" href="colr_8h.html#a15a88e36717ca1e6a4892d2ffda1f4f3">format_bg_rgb()</a>, <a class="el" href="colr_8h.html#aca1991134c0d649bdc57b86140b6c2b0">format_fg_rgb()</a>, <a class="el" href="colr_8h.html#a3580f33d058571dffd8e5ff789c49296">rainbow_step()</a>, and <a class="el" href="colr_8h.html#a6133112d9c73a8b56995e16e1af62d3b">RGB_from_hex_default()</a>.</p>

</div>
</div>
<a id="a7592d374ee178fd8ac19d8dabbb83662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7592d374ee178fd8ac19d8dabbb83662">&#9670;&nbsp;</a></span>style</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define style</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#afb5ac0bd012b8162cea125ad0d9e8bf0">ColorArg_to_ptr</a>(<a class="el" href="colr_8h.html#a53683a9e279942578e46768be25587d0">style_arg</a>(x))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a style suitable for use with the <a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2" title="Join ColorArg pointers, ColorText pointers, and strings into one long string. ">colr()</a> and <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr() macro...">Colr()</a> macros. </p>
<p>This macro accepts strings (style names) and StyleValues.</p>
<p>Style names (<code>char*</code>) can be passed to generate the appropriate style value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A StyleValue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a heap-allocated <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct.<br />
 If used inside of the <a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2" title="Join ColorArg pointers, ColorText pointers, and strings into one long string. ">colr()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, and <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr() macro...">Colr()</a> macros, <em>they will <code>free()</code> the result</em>.<br />
Otherwise, <em>you are responsible for calling <code>free()</code></em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a53683a9e279942578e46768be25587d0" title="Uses ColorArg_from_StyleValue to build a ColorArg with the appropriate color type/value. ">style_arg</a> <a class="el" href="colr_8h.html#ab307d323b317da4b6f4d24ee1929b354" title="Retrieve just the escape code string for a style. ">style_str</a> <a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2" title="Join ColorArg pointers, ColorText pointers, and strings into one long string. ">colr</a> <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr() macro...">Colr</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="Colr_example_8c-example.html#a10">Colr_example.c</a>, <a class="el" href="colr_example_8c-example.html#a6">colr_example.c</a>, <a class="el" href="colr_join_example_8c-example.html#a4">colr_join_example.c</a>, and <a class="el" href="style_example_8c-example.html#a1">style_example.c</a>.</dd>
</dl>
</div>
</div>
<a id="a53683a9e279942578e46768be25587d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53683a9e279942578e46768be25587d0">&#9670;&nbsp;</a></span>style_arg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define style_arg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_Generic( \</div><div class="line">        (x), \</div><div class="line">        <span class="keywordtype">char</span>* : <a class="code" href="colr_8h.html#ae8d897499fca87d7902159f4ed7dbba3">ColorArg_from_str</a>, \</div><div class="line">        <a class="code" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>: <a class="code" href="colr_8h.html#acf63bcee395dca3ca29dc324e3d7c8f2">ColorArg_from_StyleValue</a> \</div><div class="line">    )(STYLE, x)</div><div class="ttc" id="colr_8h_html_acf63bcee395dca3ca29dc324e3d7c8f2"><div class="ttname"><a href="colr_8h.html#acf63bcee395dca3ca29dc324e3d7c8f2">ColorArg_from_StyleValue</a></div><div class="ttdeci">ColorArg ColorArg_from_StyleValue(ArgType type, StyleValue value)</div><div class="ttdoc">Explicit version of ColorArg_from_value that only handles StyleValues. </div><div class="ttdef"><b>Definition:</b> colr.c:2735</div></div>
<div class="ttc" id="colr_8h_html_ae8d897499fca87d7902159f4ed7dbba3"><div class="ttname"><a href="colr_8h.html#ae8d897499fca87d7902159f4ed7dbba3">ColorArg_from_str</a></div><div class="ttdeci">ColorArg ColorArg_from_str(ArgType type, char *colorname)</div><div class="ttdoc">Build a ColorArg (fore, back, or style value) from a known color name/style. </div><div class="ttdef"><b>Definition:</b> colr.c:2713</div></div>
<div class="ttc" id="colr_8h_html_a85224ec2507f33b1985f4cdd0adfe0e6"><div class="ttname"><a href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a></div><div class="ttdeci">StyleValue</div><div class="ttdoc">Style values. </div><div class="ttdef"><b>Definition:</b> colr.h:1214</div></div>
</div><!-- fragment -->
<p>Uses ColorArg_from_StyleValue to build a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> with the appropriate color type/value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td><code>StyleValue</code> for the style. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> with the STYLE type set, and it's <code>.value.type</code> set for the appropriate color type/value. For invalid values the <code>.value.type</code> may be set to TYPE_INVALID.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662" title="Create a style suitable for use with the colr() and Colr() macros. ">style</a> <a class="el" href="colr_8h.html#ab307d323b317da4b6f4d24ee1929b354" title="Retrieve just the escape code string for a style. ">style_str</a> </dd></dl>

</div>
</div>
<a id="a5fd8134cf00ddafc463dbce4010439af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd8134cf00ddafc463dbce4010439af">&#9670;&nbsp;</a></span>STYLE_LEN_MIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STYLE_LEN_MIN&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum length for the shortest style escape code, including `'\0'`. </p>
<p>Use STYLE_LEN for allocation. </p>

</div>
</div>
<a id="ab307d323b317da4b6f4d24ee1929b354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab307d323b317da4b6f4d24ee1929b354">&#9670;&nbsp;</a></span>style_str</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define style_str</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="colr_8h.html#a91fb398f6463553e576fc067f5a0a854">ColorArg_to_str</a>(<a class="el" href="colr_8h.html#a53683a9e279942578e46768be25587d0">style_arg</a>(x))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve just the escape code string for a style. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>StyleValue to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662" title="Create a style suitable for use with the colr() and Colr() macros. ">style</a> <a class="el" href="colr_8h.html#a53683a9e279942578e46768be25587d0" title="Uses ColorArg_from_StyleValue to build a ColorArg with the appropriate color type/value. ">style_arg</a> </dd></dl>

</div>
</div>
<a id="ad1d2ceec58f8075f06e09f277c8893ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d2ceec58f8075f06e09f277c8893ae">&#9670;&nbsp;</a></span>while_colr_va_arg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define while_colr_va_arg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ap, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">vartype, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;while (x = va_arg(ap, vartype), !<a class="el" href="colr_8h.html#af64af11f4992c8143cb722772df98c98">_colr_is_last_arg</a>(x))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a while-loop over a <code>va_list</code>, where the last argument is expected to be _ColrLastArg, or a pointer to a _ColrLastArg_s with the same values as _ColrLastArg. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ap</td><td>The <code>va_list</code> to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vartype</td><td>Expected type of the argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The variable to assign to (usually <code>arg</code>). </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a25670add558019fdb66a60d51f0ffbda">_colr()</a>, <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>, <a class="el" href="colr_8h.html#a91a051ef4cd2e7200a31f9de48766b4c">_colr_join_size()</a>, <a class="el" href="colr_8h.html#ad70e1c4f6da5a46e6fcf838aed07885b">_colr_size()</a>, <a class="el" href="colr_8h.html#ad4702d6ddc409a93a0b42c8f6141d2f2">ColorText_from_values()</a>, and <a class="el" href="colr_8h.html#a880b39cd2ce9b622dbe7790a162d88f7">ColorText_set_values()</a>.</p>

</div>
</div>
<a id="aab60aea9412ba6fb6859bf0db474e366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab60aea9412ba6fb6859bf0db474e366">&#9670;&nbsp;</a></span>with_rgbs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define with_rgbs</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = 0; r &lt; 256; r++) \</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> g = 0; g &lt; 256; g++) \</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> b = 0; b &lt; 256; b++) \</div></div><!-- fragment -->
<p>Iterate over every possible rgb combination, 0-255 for red, green, and blue. </p>
<p>This macro expects a block of code after it, where the values <code>r</code>, <code>g</code>, and <code>b</code> are declared as <code>int</code> in the range <code>0</code>-<code>255</code>.</p>
<div class="examplecode"> <div class="examplecode-header"> <a href="#with_rgbs-example" id="with_rgbs-example" class="diamond-bullet">◆&#160;</a> with_rgbs example: </div><div class="fragment"><div class="line"><a class="code" href="colr_8h.html#aab60aea9412ba6fb6859bf0db474e366">with_rgbs</a>() {</div><div class="line">    <span class="comment">// You can do whatever you want with r, g, and b.</span></div><div class="line">    <span class="keywordflow">if</span> ((r % 100 == 0) &amp;&amp; (g % 100 == 0) &amp;&amp; (b % 100 == 0)) {</div><div class="line">        <a class="code" href="colr_8h.html#structRGB">RGB</a> val = <a class="code" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>(r, g, b);</div><div class="line">        <span class="keywordtype">char</span>* repr = <a class="code" href="colr_8h.html#ac1ef824dd213274fb239526269315543">colr_repr</a>(val);</div><div class="line">        <span class="keywordtype">char</span>* s = <a class="code" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2">colr</a>(<a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(val), repr);</div><div class="line">        printf(<span class="stringliteral">&quot;Found RGB: %s\n&quot;</span>, s);</div><div class="line">        free(repr);</div><div class="line">        free(s);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> </div> 
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="adc966460db21ff6c35f23fcf6abe541e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc966460db21ff6c35f23fcf6abe541e">&#9670;&nbsp;</a></span>RGB_fmter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* RGB_fmter) (char *out, <a class="el" href="colr_8h.html#structRGB">RGB</a> <a class="el" href="colr_8h.html#a6fa7a1b0351d0bdbdf9fd5f882673d57">rgb</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function type that knows how to fill a string with an rgb escape code. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a0c061fbfddd43dfe324486dc86cb92ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c061fbfddd43dfe324486dc86cb92ee">&#9670;&nbsp;</a></span>BasicValue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Basic color values, with a few convenience values for extended colors. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a25670add558019fdb66a60d51f0ffbda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25670add558019fdb66a60d51f0ffbda">&#9670;&nbsp;</a></span>_colr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* _colr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Joins ColorArgs, ColorTexts, and strings (<code>char*</code>) into one long string. </p>
<p>This will free() any ColorArgs and ColorTexts that are passed in. It is backing the <a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2" title="Join ColorArg pointers, ColorText pointers, and strings into one long string. ">colr()</a> macro, and enables easy throwaway color values.</p>
<p>Any plain strings that are passed in are left alone. It is up to the caller to free those. ColrC only manages the temporary Colr-based objects needed to build up these strings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The first of any ColorArgs, ColorTexts, or strings to join. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Zero or more ColorArgs, ColorTexts, or strings to join. The last argument must be a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointer that is equal to _ColrLastArgValue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string with mixed escape codes/strings.<br />
 CODE_RESET_ALL is appended to all the pieces that aren't plain strings. This allows easy part-colored messages, so there's no need to use CODE_RESET_ALL directly.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>. </dd></dl>

</div>
</div>
<a id="af64af11f4992c8143cb722772df98c98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af64af11f4992c8143cb722772df98c98">&#9670;&nbsp;</a></span>_colr_is_last_arg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool _colr_is_last_arg </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a void pointer is _ColrLastArg (the last-arg-marker). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The pointer to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the pointer is _ColrLastArg, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a4227a65824fdd699a25d3200706c9e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4227a65824fdd699a25d3200706c9e9e">&#9670;&nbsp;</a></span>_colr_join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* _colr_join </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>joinerp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Joins ColorArgs, ColorTexts, and strings (<code>char*</code>) into one long string separated by it's first argument. </p>
<p>This will free() any ColorArgs and ColorTexts that are passed in. It is backing the <a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2" title="Join ColorArg pointers, ColorText pointers, and strings into one long string. ">colr()</a> macro, and enables easy throwaway color values.</p>
<p>Any plain strings that are passed in are left alone. It is up to the caller to free those. ColrC only manages the temporary Colr-based objects needed to build up these strings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">joinerp</td><td>The joiner (any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, or string). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Zero or more ColorArgs, ColorTexts, or strings to join by the joiner. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string with mixed escape codes/strings.<br />
 CODE_RESET_ALL is appended to all <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> arguments. This allows easy part-colored messages.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>. </dd></dl>

</div>
</div>
<a id="a6d47ac6ee2a59e1c976cf2838545aa25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d47ac6ee2a59e1c976cf2838545aa25">&#9670;&nbsp;</a></span>_colr_join_array_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t _colr_join_array_length </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the length of a <code>NULL</code>-terminated array of strings (<code>char*</code>), ColorArgs, or ColorTexts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ps</td><td>A <code>NULL</code>-terminated array of ColorArgs, ColorTexts, or strings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of items (before <code>NULL</code>) in the array. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a701126bd27c90fafa46152d9f9327b2f">colr_join_array()</a>.</p>

</div>
</div>
<a id="ac49c3a33d328ebaf2b0564d5a9b1d4ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac49c3a33d328ebaf2b0564d5a9b1d4ec">&#9670;&nbsp;</a></span>_colr_join_arrayn_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t _colr_join_arrayn_size </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>joinerp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size in bytes needed to join an array of strings (<code>char*</code>), ColorArgs, or ColorTexts by another string (<code>char*</code>), <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>. </p>
<p>This is used to allocate memory in the _colr_join_array() function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">joinerp</td><td>The joiner (any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, or string). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ps</td><td>An array of pointers to ColorArgs, ColorTexts, or strings. The array must have <code>NULL</code> as the last item if <code>count</code> is greater than the total number of items. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Total number of items in the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string with the result.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2" title="Join ColorArg pointers, ColorText pointers, and strings into one long string. ">colr</a> <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join</a> <a class="el" href="colr_8c.html#a701126bd27c90fafa46152d9f9327b2f" title="Join an array of strings (char*), ColorArgs, or ColorTexts by another string (char*), ColorArg, or ColorText. ">colr_join_array</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a71fcf08ad36d4424790e275d973445fc">colr_join_arrayn()</a>.</p>

</div>
</div>
<a id="a91a051ef4cd2e7200a31f9de48766b4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a051ef4cd2e7200a31f9de48766b4c">&#9670;&nbsp;</a></span>_colr_join_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t _colr_join_size </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>joinerp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse arguments, just as in <a class="el" href="colr_8c.html#a4227a65824fdd699a25d3200706c9e9e" title="Joins ColorArgs, ColorTexts, and strings (char*) into one long string separated by it&#39;s first argumen...">_colr_join()</a>, but only return the size needed to allocate the resulting string. </p>
<p>This allows <a class="el" href="colr_8c.html#a4227a65824fdd699a25d3200706c9e9e" title="Joins ColorArgs, ColorTexts, and strings (char*) into one long string separated by it&#39;s first argumen...">_colr_join()</a> to allocate once, instead of reallocating for each argument that is passed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">joinerp</td><td>The joiner (any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, or string). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>A <code>va_list</code> with zero or more ColorArgs, ColorTexts, or strings to join.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length (in bytes) needed to allocate a string built with <a class="el" href="colr_8c.html#a25670add558019fdb66a60d51f0ffbda" title="Joins ColorArgs, ColorTexts, and strings (char*) into one long string. ">_colr()</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#a25670add558019fdb66a60d51f0ffbda" title="Joins ColorArgs, ColorTexts, and strings (char*) into one long string. ">_colr</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>.</p>

</div>
</div>
<a id="ab0be451277fc7e39aee0aa409c9d3f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0be451277fc7e39aee0aa409c9d3f0c">&#9670;&nbsp;</a></span>_colr_ptr_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t _colr_ptr_length </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size, in bytes, needed to convert a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, or string (<code>char*</code>) into a string. </p>
<p>This is used in the variadic _colr* functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> pointer, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> pointer, or string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length needed to convert the object into a string (<code>strlen() + 1</code> for strings). </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ac49c3a33d328ebaf2b0564d5a9b1d4ec">_colr_join_arrayn_size()</a>, <a class="el" href="colr_8h.html#a91a051ef4cd2e7200a31f9de48766b4c">_colr_join_size()</a>, and <a class="el" href="colr_8h.html#ad70e1c4f6da5a46e6fcf838aed07885b">_colr_size()</a>.</p>

</div>
</div>
<a id="ad70e1c4f6da5a46e6fcf838aed07885b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad70e1c4f6da5a46e6fcf838aed07885b">&#9670;&nbsp;</a></span>_colr_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t _colr_size </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse arguments, just as in <a class="el" href="colr_8c.html#a25670add558019fdb66a60d51f0ffbda" title="Joins ColorArgs, ColorTexts, and strings (char*) into one long string. ">_colr()</a>, but only return the length needed to allocate the resulting string. </p>
<p>This allows <a class="el" href="colr_8c.html#a25670add558019fdb66a60d51f0ffbda" title="Joins ColorArgs, ColorTexts, and strings (char*) into one long string. ">_colr()</a> to allocate once, instead of reallocating for each argument that is passed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The first of any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, or strings to join. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>A <code>va_list</code> with zero or more ColorArgs, ColorTexts, or strings to join.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length (in bytes) needed to allocate a string built with <a class="el" href="colr_8c.html#a25670add558019fdb66a60d51f0ffbda" title="Joins ColorArgs, ColorTexts, and strings (char*) into one long string. ">_colr()</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#a25670add558019fdb66a60d51f0ffbda" title="Joins ColorArgs, ColorTexts, and strings (char*) into one long string. ">_colr</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a25670add558019fdb66a60d51f0ffbda">_colr()</a>.</p>

</div>
</div>
<a id="a7d16a274fbb779576396457264453873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d16a274fbb779576396457264453873">&#9670;&nbsp;</a></span>_rainbow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* _rainbow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#adc966460db21ff6c35f23fcf6abe541e">RGB_fmter</a>&#160;</td>
          <td class="paramname"><em>fmter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles multi-byte character string (<code>char*</code>) conversion and character iteration for all of the rainbow_ functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fmter</td><td>A formatter function (RGB_fmter) that can create escape codes from <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to "rainbowize". Input <em>must be <code>null</code>-terminated</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freq</td><td>The "tightness" for colors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting offset into the rainbow.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string (<code>char*</code>) with the result.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a69dd994da51a57fc3cedb5ade591d5c1">rainbow_bg()</a>, <a class="el" href="colr_8h.html#ab261b60d6d790f5a3c91883a1b6646a7">rainbow_bg_term()</a>, <a class="el" href="colr_8h.html#a7aed06cce3570d914738ce3f517e7ee9">rainbow_fg()</a>, and <a class="el" href="colr_8h.html#aa740f000c6d3ebe24734411e83125e37">rainbow_fg_term()</a>.</p>

</div>
</div>
<a id="ad01ccaf04c71fc2474da94b050236572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01ccaf04c71fc2474da94b050236572">&#9670;&nbsp;</a></span>ArgType_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ArgType_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation of a ArgType. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>An ArgType to get the type from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an allocated string.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1" title="Argument types (fore, back, style). ">ArgType</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a5af692f2357d46b9cee45bb114f2a4a2">ColorArg_repr()</a>.</p>

</div>
</div>
<a id="a2b270bebb1a01212b7e44e52f61f94be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b270bebb1a01212b7e44e52f61f94be">&#9670;&nbsp;</a></span>ArgType_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ArgType_to_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) from an ArgType. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>An ArgType to get the type from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an allocated string.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1" title="Argument types (fore, back, style). ">ArgType</a> </dd></dl>

</div>
</div>
<a id="a17bf46ac385e41b729d07a65dd506cba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17bf46ac385e41b729d07a65dd506cba">&#9670;&nbsp;</a></span>BasicValue_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BasicValue_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two BasicValues. </p>
<p>This is used to implement <a class="el" href="colr_8h.html#a36af8aa0f01eaa780da182e856923faa" title="Calls the &lt;type&gt;_eq functions for the supported types. ">colr_eq()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first BasicValue to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second BasicValue to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if they are equal, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a4163ac65dca3e222525808b80a40b733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4163ac65dca3e222525808b80a40b733">&#9670;&nbsp;</a></span>BasicValue_from_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a> BasicValue_from_str </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert named argument to an actual BasicValue enum value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Color name to find the BasicValue for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BasicValue value on success, or BASIC_INVALID on error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee" title="Basic color values, with a few convenience values for extended colors. ">BasicValue</a> </dd></dl>

</div>
</div>
<a id="a1bc0d9917621cab5b3efd162b7dc5a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc0d9917621cab5b3efd162b7dc5a8c">&#9670;&nbsp;</a></span>BasicValue_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* BasicValue_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>bval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation of a BasicValue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bval</td><td>A BasicValue to get the value from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an allocated string.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee" title="Basic color values, with a few convenience values for extended colors. ">BasicValue</a> </dd></dl>

</div>
</div>
<a id="a71a78ebb45cb53792d4c658bade99a70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71a78ebb45cb53792d4c658bade99a70">&#9670;&nbsp;</a></span>BasicValue_to_ansi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BasicValue_to_ansi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>bval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a fore/back BasicValue to the actual 4bit ansi code number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ArgType (FORE/BACK). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bval</td><td>BasicValue to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer usable with basic escape code fore/back colors.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee" title="Basic color values, with a few convenience values for extended colors. ">BasicValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ae29032483aea8cb25d6b90750767ffc1">format_bg()</a>, and <a class="el" href="colr_8h.html#a6027d93e8768f3c152edafd92e757801">format_fg()</a>.</p>

</div>
</div>
<a id="af838f8479681d809beb868b2e1b547e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af838f8479681d809beb868b2e1b547e7">&#9670;&nbsp;</a></span>ColorArg_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> ColorArg_empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> with ARGTYPE_NONE and ColorValue.type.TYPE_NONE. </p>
<p>This is used to pass "empty" fore/back/style args to the <a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2" title="Join ColorArg pointers, ColorText pointers, and strings into one long string. ">colr()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, and <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr() macro...">Colr()</a> macros, where <code>NULL</code> has a different meaning (end of argument list).</p>
<dl class="section return"><dt>Returns</dt><dd><code>(<a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>){.type=ARGTYPE_NONE, .value.type=TYPE_NONE}</code></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#a752355c2d96d35688d3756558f8421ba" title="Checks to see if a ColorArg is an empty placeholder. ">ColorArg_is_empty</a> <a class="el" href="colr_8c.html#a5ce7c54ad0e31ecf6d790c5770c2b66b" title="Create an &quot;empty&quot; ColorValue. ">ColorValue_empty</a> </dd></dl>

</div>
</div>
<a id="acb62efc0182d6f6107055eeda961a628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb62efc0182d6f6107055eeda961a628">&#9670;&nbsp;</a></span>ColorArg_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorArg_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> structs. </p>
<p>They are considered "equal" if their <code>.type</code> and <code>.value</code> match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if they are equal, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a93f65430500d003575c547eb667330b0">ColorText_has_arg()</a>.</p>

</div>
</div>
<a id="aa1163a9c866767fb7fcb734d3c0d9b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1163a9c866767fb7fcb734d3c0d9b7c">&#9670;&nbsp;</a></span>ColorArg_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ColorArg_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free allocated memory for a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>. </p>
<p>This has no advantage over <code>free(colorarg)</code> right now, it is used in debugging, and may be extended in the future. It's better just to use it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to free.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a25670add558019fdb66a60d51f0ffbda">_colr()</a>, <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>, and <a class="el" href="colr_8h.html#a901e5738358a739629cc3aaccab3e73f">ColorText_free()</a>.</p>

</div>
</div>
<a id="aad49f4597388e6bdb896ff28334cd5e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad49f4597388e6bdb896ff28334cd5e6">&#9670;&nbsp;</a></span>ColorArg_from_BasicValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> ColorArg_from_BasicValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicit version of ColorArg_from_value that only handles BasicValues. </p>
<p>This is used in some macros to aid in dynamic escape code creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ArgType (FORE, BACK, STYLE). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>BasicValue to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, with the <code>.value.type</code> member possibly set to <code>TYPE_INVALID</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

</div>
</div>
<a id="aed30e2a4b30ab5e3cf49608a3c410cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed30e2a4b30ab5e3cf49608a3c410cc5">&#9670;&nbsp;</a></span>ColorArg_from_ExtendedValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> ColorArg_from_ExtendedValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicit version of ColorArg_from_value that only handles ExtendedValues. </p>
<p>This is used in some macros to aid in dynamic escape code creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ArgType (FORE, BACK, STYLE). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>ExtendedValue to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, with the <code>.value.type</code> member possibly set to <code>TYPE_INVALID</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

</div>
</div>
<a id="aaa24bba74e99aa66ed41839576e57856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa24bba74e99aa66ed41839576e57856">&#9670;&nbsp;</a></span>ColorArg_from_RGB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> ColorArg_from_RGB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicit version of ColorArg_from_value that only handles <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> structs. </p>
<p>This is used in some macros to aid in dynamic escape code creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ArgType (FORE, BACK, STYLE). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, with the <code>.value.type</code> member possibly set to <code>TYPE_INVALID</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

</div>
</div>
<a id="ae8d897499fca87d7902159f4ed7dbba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8d897499fca87d7902159f4ed7dbba3">&#9670;&nbsp;</a></span>ColorArg_from_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> ColorArg_from_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>colorname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> (fore, back, or style value) from a known color name/style. </p>
<p>The <code>.value.type</code> attribute can be checked for an invalid type, or you can call ColorArg_is_invalid(x).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ArgType (FORE, BACK, STYLE). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">colorname</td><td>A known color name/style.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct with usable values.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

</div>
</div>
<a id="acf63bcee395dca3ca29dc324e3d7c8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf63bcee395dca3ca29dc324e3d7c8f2">&#9670;&nbsp;</a></span>ColorArg_from_StyleValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> ColorArg_from_StyleValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicit version of ColorArg_from_value that only handles StyleValues. </p>
<p>This is used in some macros to aid in dynamic escape code creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ArgType (FORE, BACK, STYLE). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>StyleValue to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, with the <code>.value.type</code> member possibly set to <code>TYPE_INVALID</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

</div>
</div>
<a id="a89a5aa762bd5802872faf571aa32ea35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a5aa762bd5802872faf571aa32ea35">&#9670;&nbsp;</a></span>ColorArg_from_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a> ColorArg_from_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>&#160;</td>
          <td class="paramname"><em>colrtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used with the color_arg macro to dynamically create a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> based on it's argument type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ArgType value, to mark the type of <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">colrtype</td><td>ColorType value, to mark the type of <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A pointer to either a BasicValue, ExtendedValue, or a <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct with the appropriate <code>.value.type</code> member set for the value that was passed. For invalid types the <code>.value.type</code> member may be set to one of:<ul>
<li>TYPE_INVALID</li>
<li>TYPE_INVALID_EXTENDED_RANGE</li>
<li>TYPE_INVALID_RGB_RANGE</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

</div>
</div>
<a id="a752355c2d96d35688d3756558f8421ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a752355c2d96d35688d3756558f8421ba">&#9670;&nbsp;</a></span>ColorArg_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorArg_is_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>carg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> is an empty placeholder. </p>
<p>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> is empty if it's <code>.type</code> is set to <code>ARGTYPE_NONE</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">carg</td><td>A <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> is considered "empty", otherwise <code>false</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#adaff727006f4c057aab75e55bfb473c4">ColorArg_length()</a>, <a class="el" href="colr_8h.html#a91fb398f6463553e576fc067f5a0a854">ColorArg_to_str()</a>, <a class="el" href="colr_8h.html#a93b38987063bb127bb34761961d7f678">ColorText_has_args()</a>, and <a class="el" href="colr_8h.html#ae305b33e0a44b956ccf4123aa4f1a033">ColorText_to_str()</a>.</p>

</div>
</div>
<a id="a66b4906cfb08588005536db1250dc899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b4906cfb08588005536db1250dc899">&#9670;&nbsp;</a></span>ColorArg_is_invalid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorArg_is_invalid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>carg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> holds an invalid value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">carg</td><td><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is invalid, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

</div>
</div>
<a id="ad15f3a714a6383123d3fb24ade173e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad15f3a714a6383123d3fb24ade173e29">&#9670;&nbsp;</a></span>ColorArg_is_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorArg_is_ptr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks a void pointer to see if it contains a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct. </p>
<p>The first member of a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> is a marker.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A void pointer to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the pointer is a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a25670add558019fdb66a60d51f0ffbda">_colr()</a>, <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>, <a class="el" href="colr_8h.html#a6d47ac6ee2a59e1c976cf2838545aa25">_colr_join_array_length()</a>, <a class="el" href="colr_8h.html#ac49c3a33d328ebaf2b0564d5a9b1d4ec">_colr_join_arrayn_size()</a>, <a class="el" href="colr_8h.html#ab0be451277fc7e39aee0aa409c9d3f0c">_colr_ptr_length()</a>, <a class="el" href="colr_8h.html#ad70e1c4f6da5a46e6fcf838aed07885b">_colr_size()</a>, <a class="el" href="colr_8h.html#ad4702d6ddc409a93a0b42c8f6141d2f2">ColorText_from_values()</a>, <a class="el" href="colr_8h.html#a880b39cd2ce9b622dbe7790a162d88f7">ColorText_set_values()</a>, and <a class="el" href="colr_8h.html#a71fcf08ad36d4424790e275d973445fc">colr_join_arrayn()</a>.</p>

</div>
</div>
<a id="a1e446f65d6987d52522a1755c909d421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e446f65d6987d52522a1755c909d421">&#9670;&nbsp;</a></span>ColorArg_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorArg_is_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>carg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> holds a valid value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">carg</td><td><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is valid, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

</div>
</div>
<a id="adaff727006f4c057aab75e55bfb473c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaff727006f4c057aab75e55bfb473c4">&#9670;&nbsp;</a></span>ColorArg_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ColorArg_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>carg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length in bytes needed to allocate a string (<code>char*</code>) built with <a class="el" href="colr_8c.html#a91fb398f6463553e576fc067f5a0a854" title="Converts a ColorArg into an escape code string (char*). ">ColorArg_to_str()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">carg</td><td><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length (<code>size_t</code>) needed to allocate a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string, or <code>1</code> (size of an empty string) for invalid/empty arg types/values.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ac49c3a33d328ebaf2b0564d5a9b1d4ec">_colr_join_arrayn_size()</a>, <a class="el" href="colr_8h.html#ab0be451277fc7e39aee0aa409c9d3f0c">_colr_ptr_length()</a>, <a class="el" href="colr_8h.html#ad70e1c4f6da5a46e6fcf838aed07885b">_colr_size()</a>, and <a class="el" href="colr_8h.html#a412833a097b050c8ee99874c733bd030">ColorText_length()</a>.</p>

</div>
</div>
<a id="a5af692f2357d46b9cee45bb114f2a4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af692f2357d46b9cee45bb114f2a4a2">&#9670;&nbsp;</a></span>ColorArg_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorArg_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>carg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation for a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>. </p>
<p>Allocates memory for the string representation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">carg</td><td><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> struct to get the representation for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Allocated string for the representation.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a575a6cdc2f65cf1cd25227f847ae8d76">ColorText_repr()</a>.</p>

</div>
</div>
<a id="afb5ac0bd012b8162cea125ad0d9e8bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb5ac0bd012b8162cea125ad0d9e8bf0">&#9670;&nbsp;</a></span>ColorArg_to_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>* ColorArg_to_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>carg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> into memory and returns the pointer. </p>
<p>You must free() the memory if you call this directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">carg</td><td><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to copy/allocate for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a heap-allocated <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

</div>
</div>
<a id="a91fb398f6463553e576fc067f5a0a854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91fb398f6463553e576fc067f5a0a854">&#9670;&nbsp;</a></span>ColorArg_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorArg_to_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>carg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> into an escape code string (<code>char*</code>). </p>
<p>Allocates memory for the string.</p>
<p>If the <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> is empty (<code>ARGTYPE_NONE</code>), an empty string is returned.</p>
<p>If the <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> is invalid, an empty string is returned. You must still free the empty string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">carg</td><td><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to get the ArgType and <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Allocated string for the escape code.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a25670add558019fdb66a60d51f0ffbda">_colr()</a>, <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>, <a class="el" href="colr_8h.html#ae305b33e0a44b956ccf4123aa4f1a033">ColorText_to_str()</a>, <a class="el" href="colr_8h.html#a71fcf08ad36d4424790e275d973445fc">colr_join_arrayn()</a>, and <a class="el" href="colr_8h.html#a44d236bca80dbce495c0f282c3a7d192">colr_str_replace_ColorArg()</a>.</p>

</div>
</div>
<a id="ae11e9457ca4e8f5be0e29351b49b6844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae11e9457ca4e8f5be0e29351b49b6844">&#9670;&nbsp;</a></span>ColorJustify_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a> ColorJustify_empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an "empty" <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a>, with JUST_NONE set. </p>
<dl class="section return"><dt>Returns</dt><dd>An initialized <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a>, with no justification method set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a341b4033c31c58e412ff15280185c6bd">ColorText_empty()</a>.</p>

</div>
</div>
<a id="ab71656e616aef4bbb3c278d43c4a326e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab71656e616aef4bbb3c278d43c4a326e">&#9670;&nbsp;</a></span>ColorJustify_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorJustify_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> structs. </p>
<p>They are considered "equal" if their member values match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if they are equal, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> </dd></dl>

</div>
</div>
<a id="a34f193b6e6a20c63caecc1d9b53c89fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f193b6e6a20c63caecc1d9b53c89fb">&#9670;&nbsp;</a></span>ColorJustify_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorJustify_is_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a>&#160;</td>
          <td class="paramname"><em>cjust</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> is "empty". </p>
<p>A <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> is considered "empty" if the <code>.method</code> member is set to <code>JUST_NONE</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cjust</td><td>The <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> is empty, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> <a class="el" href="colr_8c.html#ae11e9457ca4e8f5be0e29351b49b6844" title="Creates an &quot;empty&quot; ColorJustify, with JUST_NONE set. ">ColorJustify_empty</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ac846e583415e832b9090270020320b9f">ColorText_is_empty()</a>, and <a class="el" href="colr_8h.html#a412833a097b050c8ee99874c733bd030">ColorText_length()</a>.</p>

</div>
</div>
<a id="a7d4a7a21151993343ef96a068c6d5018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4a7a21151993343ef96a068c6d5018">&#9670;&nbsp;</a></span>ColorJustify_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a> ColorJustify_new </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#af1a3fe0b966f944fd659a98be170045f">ColorJustifyMethod</a>&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>padchar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a>. </p>
<p>This is used to ensure every <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> has it's <code>.marker</code> member set correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>ColorJustifyMethod to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>Width for justification. If <code>0</code> is given, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> will use the width from colr_terminal_size(). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">padchar</td><td>Padding character to use. If <code>0</code> is given, the default, space (`' '`), is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An initialized <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a>. </dd></dl>

</div>
</div>
<a id="a6c35f6b47cc737744487d14d20241656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c35f6b47cc737744487d14d20241656">&#9670;&nbsp;</a></span>ColorJustify_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorJustify_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a>&#160;</td>
          <td class="paramname"><em>cjust</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation for a <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a>. </p>
<p>Allocates memory for the string representation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cjust</td><td><a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> struct to get the representation for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Allocated string for the representation.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a575a6cdc2f65cf1cd25227f847ae8d76">ColorText_repr()</a>.</p>

</div>
</div>
<a id="adf78eeb364553d130055d93e9892cd9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf78eeb364553d130055d93e9892cd9c">&#9670;&nbsp;</a></span>ColorJustifyMethod_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorJustifyMethod_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#af1a3fe0b966f944fd659a98be170045f">ColorJustifyMethod</a>&#160;</td>
          <td class="paramname"><em>meth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation for a ColorJustifyMethod. </p>
<p>Allocates memory for the string representation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meth</td><td>ColorJustifyMethod to get the representation for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Allocated string for the representation.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#af1a3fe0b966f944fd659a98be170045f" title="Justification style for ColorTexts. ">ColorJustifyMethod</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a6c35f6b47cc737744487d14d20241656">ColorJustify_repr()</a>.</p>

</div>
</div>
<a id="a341b4033c31c58e412ff15280185c6bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a341b4033c31c58e412ff15280185c6bd">&#9670;&nbsp;</a></span>ColorText_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorText">ColorText</a> ColorText_empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an "empty" <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> with pointers set to <code>NULL</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>An initialized <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ad4702d6ddc409a93a0b42c8f6141d2f2">ColorText_from_values()</a>, and <a class="el" href="colr_8h.html#a880b39cd2ce9b622dbe7790a162d88f7">ColorText_set_values()</a>.</p>

</div>
</div>
<a id="a901e5738358a739629cc3aaccab3e73f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a901e5738358a739629cc3aaccab3e73f">&#9670;&nbsp;</a></span>ColorText_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ColorText_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> and it's ColorArgs. </p>
<p>The text member is left alone, because it wasn't created by ColrC.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Pointer to <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to free, along with it's Colr-based members.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a25670add558019fdb66a60d51f0ffbda">_colr()</a>, and <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>.</p>

</div>
</div>
<a id="ad4702d6ddc409a93a0b42c8f6141d2f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4702d6ddc409a93a0b42c8f6141d2f2">&#9670;&nbsp;</a></span>ColorText_from_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorText">ColorText</a> ColorText_from_values </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> from 1 mandatory string (<code>char*</code>), and optional fore, back, and style args (pointers to ColorArgs). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>Text to colorize (a regular string). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>ColorArgs for fore, back, and style, in any order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An initialized <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> struct.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

</div>
</div>
<a id="a93f65430500d003575c547eb667330b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f65430500d003575c547eb667330b0">&#9670;&nbsp;</a></span>ColorText_has_arg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorText_has_arg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a>&#160;</td>
          <td class="paramname"><em>ctext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorArg">ColorArg</a>&#160;</td>
          <td class="paramname"><em>carg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> has a certain <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> value set. </p>
<p>Uses <a class="el" href="colr_8c.html#acb62efc0182d6f6107055eeda961a628" title="Compares two ColorArg structs. ">ColorArg_eq()</a> to inspect the <code>fore</code>, <code>back</code>, and <code>style</code> members.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctext</td><td>The <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to inspect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">carg</td><td>The <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <code>fore</code>, <code>back</code>, or <code>style</code> arg matches <code>carg</code>, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a93b38987063bb127bb34761961d7f678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93b38987063bb127bb34761961d7f678">&#9670;&nbsp;</a></span>ColorText_has_args()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorText_has_args </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a>&#160;</td>
          <td class="paramname"><em>ctext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> has any argument values set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctext</td><td>A <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>.fore</code>, <code>.back</code>, or .<code>style</code> is set to a non-empty <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, otherwise <code>false</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a25670add558019fdb66a60d51f0ffbda">_colr()</a>, <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>, and <a class="el" href="colr_8h.html#ad70e1c4f6da5a46e6fcf838aed07885b">_colr_size()</a>.</p>

</div>
</div>
<a id="ac846e583415e832b9090270020320b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac846e583415e832b9090270020320b9f">&#9670;&nbsp;</a></span>ColorText_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorText_is_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a>&#160;</td>
          <td class="paramname"><em>ctext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> has no usable values. </p>
<p>A <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> is considered "empty" if the <code>.text</code>, <code>.fore</code>, <code>.back</code>, and <code>.style</code> pointers are <code>NULL</code>, and the <code>.just</code> member is set to an "empty" <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctext</td><td>The <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> is empty, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> <a class="el" href="colr_8c.html#a341b4033c31c58e412ff15280185c6bd" title="Creates an &quot;empty&quot; ColorText with pointers set to NULL. ">ColorText_empty</a> </dd></dl>

</div>
</div>
<a id="a1d6eb8832110b943c3a3a17627a50288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6eb8832110b943c3a3a17627a50288">&#9670;&nbsp;</a></span>ColorText_is_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorText_is_ptr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks a void pointer to see if it contains a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> struct. </p>
<p>The first member of a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> is a marker.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A void pointer to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the pointer is a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a25670add558019fdb66a60d51f0ffbda">_colr()</a>, <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>, <a class="el" href="colr_8h.html#a6d47ac6ee2a59e1c976cf2838545aa25">_colr_join_array_length()</a>, <a class="el" href="colr_8h.html#ac49c3a33d328ebaf2b0564d5a9b1d4ec">_colr_join_arrayn_size()</a>, <a class="el" href="colr_8h.html#ab0be451277fc7e39aee0aa409c9d3f0c">_colr_ptr_length()</a>, <a class="el" href="colr_8h.html#ad70e1c4f6da5a46e6fcf838aed07885b">_colr_size()</a>, and <a class="el" href="colr_8h.html#a71fcf08ad36d4424790e275d973445fc">colr_join_arrayn()</a>.</p>

</div>
</div>
<a id="a412833a097b050c8ee99874c733bd030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a412833a097b050c8ee99874c733bd030">&#9670;&nbsp;</a></span>ColorText_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ColorText_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a>&#160;</td>
          <td class="paramname"><em>ctext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length in bytes needed to allocate a string (<code>char*</code>) built with <a class="el" href="colr_8c.html#ae305b33e0a44b956ccf4123aa4f1a033" title="Stringifies a ColorText struct, creating a mix of escape codes and text. ">ColorText_to_str()</a> with the current <code>text</code>, <code>fore</code>, <code>back</code>, and <code>style</code> members. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctext</td><td><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length (<code>size_t</code>) needed to allocate a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string, or <code>1</code> (size of an empty string) for invalid/empty arg types/values.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ac49c3a33d328ebaf2b0564d5a9b1d4ec">_colr_join_arrayn_size()</a>, <a class="el" href="colr_8h.html#ab0be451277fc7e39aee0aa409c9d3f0c">_colr_ptr_length()</a>, <a class="el" href="colr_8h.html#ad70e1c4f6da5a46e6fcf838aed07885b">_colr_size()</a>, and <a class="el" href="colr_8h.html#ae305b33e0a44b956ccf4123aa4f1a033">ColorText_to_str()</a>.</p>

</div>
</div>
<a id="a575a6cdc2f65cf1cd25227f847ae8d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a575a6cdc2f65cf1cd25227f847ae8d76">&#9670;&nbsp;</a></span>ColorText_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorText_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a>&#160;</td>
          <td class="paramname"><em>ctext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a string (<code>char*</code>) representation for a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctext</td><td><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to get the string representation for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Allocated string for the <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

</div>
</div>
<a id="ab408d87cce896acccb75357acca8ade4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab408d87cce896acccb75357acca8ade4">&#9670;&nbsp;</a></span>ColorText_set_just()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorText">ColorText</a>* ColorText_set_just </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td>
          <td class="paramname"><em>ctext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorJustify">ColorJustify</a>&#160;</td>
          <td class="paramname"><em>cjust</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> method for a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, and return the <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>. </p>
<p>This is to facilitate the justification macros. If you already have a pointer to a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, you can just do <code>ctext-&gt;just = just;</code>. The purpose of this is to allow <code>ColorText_set_just(ColorText_to_ptr(...), ...)</code> to work.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ctext</td><td>The <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to set the justification method for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cjust</td><td>The <a class="el" href="colr_8h.html#structColorJustify" title="Holds a string justification method, width, and padding character for ColorTexts. ...">ColorJustify</a> struct to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The same pointer that was given as <code>ctext</code>. </dd></dl>

</div>
</div>
<a id="a880b39cd2ce9b622dbe7790a162d88f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a880b39cd2ce9b622dbe7790a162d88f7">&#9670;&nbsp;</a></span>ColorText_set_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ColorText_set_values </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td>
          <td class="paramname"><em>ctext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an existing <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> from 1 mandatory string (<code>char*</code>), and optional fore, back, and style args (pointers to ColorArgs). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ctext</td><td>A <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to initialize with values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>Text to colorize (a regular string). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>A <code>va_list</code> with ColorArgs pointers for fore, back, and style, in any order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An initialized <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> struct.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

</div>
</div>
<a id="a8e04de932a4cf712ac91e794bdc3f8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e04de932a4cf712ac91e794bdc3f8db">&#9670;&nbsp;</a></span>ColorText_to_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorText">ColorText</a>* ColorText_to_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a>&#160;</td>
          <td class="paramname"><em>ctext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> into allocated memory and returns the pointer. </p>
<p>You must free() the memory if you call this directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctext</td><td><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to copy/allocate for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a heap-allocated <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

</div>
</div>
<a id="ae305b33e0a44b956ccf4123aa4f1a033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae305b33e0a44b956ccf4123aa4f1a033">&#9670;&nbsp;</a></span>ColorText_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorText_to_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorText">ColorText</a>&#160;</td>
          <td class="paramname"><em>ctext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stringifies a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> struct, creating a mix of escape codes and text. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctext</td><td><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to stringify. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string with text/escape-codes.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a25670add558019fdb66a60d51f0ffbda">_colr()</a>, <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>, <a class="el" href="colr_8h.html#a71fcf08ad36d4424790e275d973445fc">colr_join_arrayn()</a>, and <a class="el" href="colr_8h.html#a7ec6d96305890148b019602f2301f989">colr_str_replace_ColorText()</a>.</p>

</div>
</div>
<a id="a29e3483ae4add048424177fdc2b97b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29e3483ae4add048424177fdc2b97b71">&#9670;&nbsp;</a></span>ColorType_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorType_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two ColorTypes. </p>
<p>This is used to implement <a class="el" href="colr_8h.html#a36af8aa0f01eaa780da182e856923faa" title="Calls the &lt;type&gt;_eq functions for the supported types. ">colr_eq()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first ColorType to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second ColorType to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if they are equal, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="afa75deef059c002134a88dbbdc18fd49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa75deef059c002134a88dbbdc18fd49">&#9670;&nbsp;</a></span>ColorType_from_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> ColorType_from_str </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine which type of color value is desired by name. </p>
<p>Example:</p><ul>
<li>"red" == TYPE_BASIC</li>
<li>"253" == TYPE_EXTENDED</li>
<li>"123,55,67" == TYPE_RGB</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Color name to get the ColorType for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ColorType</td><td>value on success. </td></tr>
    <tr><td class="paramname">TYPE_INVALID</td><td>for invalid color names/strings. </td></tr>
    <tr><td class="paramname">TYPE_INVALID_EXTENDED_RANGE</td><td>for ExtendedValues outside of 0-255. </td></tr>
    <tr><td class="paramname">TYPE_INVALID_RGB_RANGE</td><td>for rgb values outside of 0-255.</td></tr>
  </table>
  </dd>
</dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#ColorType_from_str-example" id="ColorType_from_str-example" class="diamond-bullet">◆&#160;</a> ColorType_from_str example: </div><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="colr_8h.html">colr.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div><div class="line">    <span class="keywordtype">char</span>* userarg;</div><div class="line">    <span class="keywordflow">if</span> (argc == 1) {</div><div class="line">        <span class="keywordflow">if</span> (asprintf(&amp;userarg, <span class="stringliteral">&quot;%s&quot;</span>, <span class="stringliteral">&quot;123,54,25&quot;</span>) &lt; 1) <span class="keywordflow">return</span> 1;</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">        <span class="keywordflow">if</span> (asprintf(&amp;userarg, <span class="stringliteral">&quot;%s&quot;</span>,  argv[1]) &lt; 1) <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">    <a class="code" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a> type = <a class="code" href="colr_8c.html#afa75deef059c002134a88dbbdc18fd49">ColorType_from_str</a>(userarg);</div><div class="line">    <span class="keywordflow">if</span> (!<a class="code" href="colr_8c.html#adc223f6fda6296396e9ecddcc68d4aec">ColorType_is_invalid</a>(type)) {</div><div class="line">        <span class="keywordtype">char</span>* repr = <a class="code" href="colr_8h.html#ac1ef824dd213274fb239526269315543">colr_repr</a>(type);</div><div class="line">        printf(<span class="stringliteral">&quot;User passed in a %s, %s\n&quot;</span>, repr, userarg);</div><div class="line">        free(repr);</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">        printf(<span class="stringliteral">&quot;User passed in an invalid color name: %s\n&quot;</span>, userarg);</div><div class="line">    }</div><div class="line">    free(userarg);</div><div class="line">}</div></div><!-- fragment --> </div> <dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83" title="Color/Style code types. Used with ColorType_from_str() and ColorValue. ">ColorType</a> </dd></dl>

</div>
</div>
<a id="adc223f6fda6296396e9ecddcc68d4aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc223f6fda6296396e9ecddcc68d4aec">&#9670;&nbsp;</a></span>ColorType_is_invalid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorType_is_invalid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check to see if a ColorType value is considered invalid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ColorType value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is considered invalid, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83" title="Color/Style code types. Used with ColorType_from_str() and ColorValue. ">ColorType</a> </dd></dl>

</div>
</div>
<a id="a5a5883d43e3206584ad048908720afb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a5883d43e3206584ad048908720afb2">&#9670;&nbsp;</a></span>ColorType_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorType_is_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check to see if a ColorType value is considered valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ColorType value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is considered valid, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83" title="Color/Style code types. Used with ColorType_from_str() and ColorValue. ">ColorType</a> </dd></dl>

</div>
</div>
<a id="a291ca6d28f9f430794413b76b7b094ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a291ca6d28f9f430794413b76b7b094ed">&#9670;&nbsp;</a></span>ColorType_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorType_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation of a ColorType. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>A ColorType to get the type from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an allocated string. <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83" title="Color/Style code types. Used with ColorType_from_str() and ColorValue. ">ColorType</a> </dd></dl>

</div>
</div>
<a id="a5ce7c54ad0e31ecf6d790c5770c2b66b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce7c54ad0e31ecf6d790c5770c2b66b">&#9670;&nbsp;</a></span>ColorValue_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a> ColorValue_empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an "empty" <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>. </p>
<p>This is used with <a class="el" href="colr_8c.html#af838f8479681d809beb868b2e1b547e7" title="Create a ColorArg with ARGTYPE_NONE and ColorValue.type.TYPE_NONE. ">ColorArg_empty()</a> to build ColorArgs that don't do anything, where using <code>NULL</code> has a different meaning inside the <a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2" title="Join ColorArg pointers, ColorText pointers, and strings into one long string. ">colr()</a>, <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join()</a>, and <a class="el" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c" title="Returns a heap-allocated ColorText struct that can be used by itself, or with the colr() macro...">Colr()</a> macros.</p>
<dl class="section return"><dt>Returns</dt><dd><code>(<a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>){.type=TYPE_NONE, .basic=0, .ext=0, .rgb=(<a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a>){0, 0, 0}}</code></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> <a class="el" href="colr_8c.html#af838f8479681d809beb868b2e1b547e7" title="Create a ColorArg with ARGTYPE_NONE and ColorValue.type.TYPE_NONE. ">ColorArg_empty</a> <a class="el" href="colr_8c.html#a752355c2d96d35688d3756558f8421ba" title="Checks to see if a ColorArg is an empty placeholder. ">ColorArg_is_empty</a> <a class="el" href="colr_8c.html#a48005bb1589a7ebeef413ccee2a7c2a1" title="Checks to see if a ColorValue is an empty placeholder. ">ColorValue_is_empty</a> </dd></dl>

</div>
</div>
<a id="adf57e195301864cec80739e7e0f3000c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf57e195301864cec80739e7e0f3000c">&#9670;&nbsp;</a></span>ColorValue_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorValue_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> structs. </p>
<p>They are considered "equal" if all of their members match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if they are equal, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#acb62efc0182d6f6107055eeda961a628">ColorArg_eq()</a>.</p>

</div>
</div>
<a id="a4d0cd3dca0ff796d69c1d6d02362079a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d0cd3dca0ff796d69c1d6d02362079a">&#9670;&nbsp;</a></span>ColorValue_from_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a> ColorValue_from_str </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> from a known color name, or <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> string (<code>char*</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>A string to parse the color name from (can be an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> string). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> (with no fore/back information, only the color type and value).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ae8d897499fca87d7902159f4ed7dbba3">ColorArg_from_str()</a>.</p>

</div>
</div>
<a id="aca7fedbceb4f751d0d30034c0ef1dca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca7fedbceb4f751d0d30034c0ef1dca8">&#9670;&nbsp;</a></span>ColorValue_from_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a> ColorValue_from_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a5e133660cf9d4bcd1cb6a49e3ec16f83">ColorType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used with the color_val macro to dynamically create a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> based on it's argument type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>A ColorType value, to mark the type of <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A pointer to either a BasicValue, ExtendedValue, or a <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> struct with the appropriate <code>.type</code> member set for the value that was passed. For invalid types the <code>.type</code> member may be set to one of:<ul>
<li>TYPE_INVALID</li>
<li>TYPE_INVALID_EXTENDED_RANGE</li>
<li>TYPE_INVALID_RGB_RANGE</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#aad49f4597388e6bdb896ff28334cd5e6">ColorArg_from_BasicValue()</a>, <a class="el" href="colr_8h.html#aed30e2a4b30ab5e3cf49608a3c410cc5">ColorArg_from_ExtendedValue()</a>, <a class="el" href="colr_8h.html#aaa24bba74e99aa66ed41839576e57856">ColorArg_from_RGB()</a>, <a class="el" href="colr_8h.html#acf63bcee395dca3ca29dc324e3d7c8f2">ColorArg_from_StyleValue()</a>, and <a class="el" href="colr_8h.html#a4d0cd3dca0ff796d69c1d6d02362079a">ColorValue_from_str()</a>.</p>

</div>
</div>
<a id="a711a955406cde9716797bf61ab43a7a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a711a955406cde9716797bf61ab43a7a7">&#9670;&nbsp;</a></span>ColorValue_has_BasicValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorValue_has_BasicValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>bval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has a BasicValue set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bval</td><td>BasicValue to look for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has the exact BasicValue set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

</div>
</div>
<a id="a11dc047d1defc4de2239a45667b45f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11dc047d1defc4de2239a45667b45f85">&#9670;&nbsp;</a></span>ColorValue_has_ExtendedValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorValue_has_ExtendedValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>&#160;</td>
          <td class="paramname"><em>eval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has a ExtendedValue set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eval</td><td>ExtendedValue to look for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has the exact ExtendedValue set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

</div>
</div>
<a id="a8188a8a68463d6de08bf9ed2a4debad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8188a8a68463d6de08bf9ed2a4debad5">&#9670;&nbsp;</a></span>ColorValue_has_RGB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorValue_has_RGB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgbval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has a <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rgbval</td><td><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value to look for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has the exact <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

</div>
</div>
<a id="a3fbfa502deb1f2bb920b74b9f4867fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fbfa502deb1f2bb920b74b9f4867fcf">&#9670;&nbsp;</a></span>ColorValue_has_StyleValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorValue_has_StyleValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>&#160;</td>
          <td class="paramname"><em>sval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has a StyleValue set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sval</td><td>StyleValue to look for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> has the exact StyleValue set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

</div>
</div>
<a id="a48005bb1589a7ebeef413ccee2a7c2a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48005bb1589a7ebeef413ccee2a7c2a1">&#9670;&nbsp;</a></span>ColorValue_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorValue_is_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> is an empty placeholder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> is "empty", otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> <a class="el" href="colr_8c.html#a5ce7c54ad0e31ecf6d790c5770c2b66b" title="Create an &quot;empty&quot; ColorValue. ">ColorValue_empty</a> <a class="el" href="colr_8c.html#af838f8479681d809beb868b2e1b547e7" title="Create a ColorArg with ARGTYPE_NONE and ColorValue.type.TYPE_NONE. ">ColorArg_empty</a> <a class="el" href="colr_8c.html#a752355c2d96d35688d3756558f8421ba" title="Checks to see if a ColorArg is an empty placeholder. ">ColorArg_is_empty</a> </dd></dl>

</div>
</div>
<a id="a22fcf30338eb777592421543885f74e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22fcf30338eb777592421543885f74e0">&#9670;&nbsp;</a></span>ColorValue_is_invalid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorValue_is_invalid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> holds an invalid value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> struct to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is invalid, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

</div>
</div>
<a id="ac7183410b61d12a99dda3f76c2705497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7183410b61d12a99dda3f76c2705497">&#9670;&nbsp;</a></span>ColorValue_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ColorValue_is_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> holds a valid value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> struct to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is valid, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

</div>
</div>
<a id="af891527249f068cfcef057313c522a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af891527249f068cfcef057313c522a42">&#9670;&nbsp;</a></span>ColorValue_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ColorValue_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length in bytes needed to allocate a string (<code>char*</code>) built with <a class="el" href="colr_8c.html#a3d9ca6bef0b8e7eac4812349ab5562cb" title="Converts a ColorValue into an escape code string (char*). ">ColorValue_to_str()</a> with the specified ArgType and <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ArgType (<code>FORE</code>, <code>BACK</code>, <code>STYLE</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length (<code>size_t</code>) needed to allocate a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>'s string, or <code>1</code> (size of an empty string) for invalid/empty arg types/values.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#adaff727006f4c057aab75e55bfb473c4">ColorArg_length()</a>.</p>

</div>
</div>
<a id="a95cf6ab7c565726eeb7c276d734193f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95cf6ab7c565726eeb7c276d734193f6">&#9670;&nbsp;</a></span>ColorValue_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorValue_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation of a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td>A <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to get the type and value from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an allocated string.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a5af692f2357d46b9cee45bb114f2a4a2">ColorArg_repr()</a>.</p>

</div>
</div>
<a id="a3d9ca6bef0b8e7eac4812349ab5562cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d9ca6bef0b8e7eac4812349ab5562cb">&#9670;&nbsp;</a></span>ColorValue_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ColorValue_to_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a58d8da4a4f5529031f00c7a6b9eeb5e1">ArgType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structColorValue">ColorValue</a>&#160;</td>
          <td class="paramname"><em>cval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a <a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> into an escape code string (<code>char*</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ArgType (FORE, BACK, STYLE) to build the escape code for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cval</td><td><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> to get the color value from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string with the appropriate escape code. For invalid values, an empty string is returned.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structColorValue" title="Holds a color type and it&#39;s value. ">ColorValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a91fb398f6463553e576fc067f5a0a854">ColorArg_to_str()</a>.</p>

</div>
</div>
<a id="a10030070daafdee7124638adfc5469d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10030070daafdee7124638adfc5469d8">&#9670;&nbsp;</a></span>colr_append_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void colr_append_reset </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends CODE_RESET_ALL to a string (<code>char*</code>), but makes sure to do it before any newlines. </p>
<p>Input <em>must be <code>null</code>-terminated</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to append to. <em>Must have extra room for CODE_RESET_ALL</em>. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a25670add558019fdb66a60d51f0ffbda">_colr()</a>, <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>, <a class="el" href="colr_8h.html#ae305b33e0a44b956ccf4123aa4f1a033">ColorText_to_str()</a>, and <a class="el" href="colr_8h.html#a71fcf08ad36d4424790e275d973445fc">colr_join_arrayn()</a>.</p>

</div>
</div>
<a id="a7f1ea562310969b7efa8711a843f103c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f1ea562310969b7efa8711a843f103c">&#9670;&nbsp;</a></span>colr_char_escape_char()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char colr_char_escape_char </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the char needed to represent an escape sequence in C. </p>
<p>The following characters are supported: </p><table class="doxtable">
<tr>
<th align="right">Escape Sequence </th><th align="left">Description Representation  </th></tr>
<tr>
<td align="right">\ ' </td><td align="left">single quote </td></tr>
<tr>
<td align="right">\ " </td><td align="left">double quote </td></tr>
<tr>
<td align="right">\ ? </td><td align="left">question mark </td></tr>
<tr>
<td align="right">\ \ </td><td align="left">backslash </td></tr>
<tr>
<td align="right">\ a </td><td align="left">audible bell </td></tr>
<tr>
<td align="right">\ b </td><td align="left">backspace </td></tr>
<tr>
<td align="right">\ f </td><td align="left">form feed - new page </td></tr>
<tr>
<td align="right">\ n </td><td align="left">line feed - new line </td></tr>
<tr>
<td align="right">\ r </td><td align="left">carriage return </td></tr>
<tr>
<td align="right">\ t </td><td align="left">horizontal tab </td></tr>
<tr>
<td align="right">\ v </td><td align="left">vertical tab </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The character to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The letter, without a backslash, needed to create an escape sequence. If the char doesn't need an escape sequence, it is simply returned.</dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_char_escape_char-example" id="colr_char_escape_char-example" class="diamond-bullet">◆&#160;</a> colr_char_escape_char example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span> constantchar = <a class="code" href="colr_8c.html#a7f1ea562310969b7efa8711a843f103c">colr_char_escape_char</a>(<span class="charliteral">&#39;\n&#39;</span>);</div><div class="line">assert(constantchar == <span class="charliteral">&#39;n&#39;</span>);</div><div class="line"></div><div class="line"><span class="keywordtype">char</span> constantquote = <a class="code" href="colr_8c.html#a7f1ea562310969b7efa8711a843f103c">colr_char_escape_char</a>(<span class="charliteral">&#39;&quot;&#39;</span>);</div><div class="line">assert(constantquote == <span class="charliteral">&#39;&quot;&#39;</span>);</div><div class="line"></div><div class="line"><span class="comment">// The actual escape sequence would need the backslash added to it:</span></div><div class="line"><span class="keywordtype">char</span>* escaped;</div><div class="line">asprintf(&amp;escaped, <span class="stringliteral">&quot;\\%c&quot;</span>, <a class="code" href="colr_8c.html#a7f1ea562310969b7efa8711a843f103c">colr_char_escape_char</a>(<span class="charliteral">&#39;\t&#39;</span>));</div><div class="line">free(escaped);</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a196ad91a69cfbeb27a5266ffc93ed353">colr_str_repr()</a>.</p>

</div>
</div>
<a id="a7c2bef208b24ea5962b8e1af154772c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c2bef208b24ea5962b8e1af154772c1">&#9670;&nbsp;</a></span>colr_char_in_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_char_in_str </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a character exists in the given string (<code>char*</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Character to search for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>String to check. Input <em>must be <code>null</code>-terminated</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>c</code> is found in <code>s</code>, otherwise <code>false</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ab00c551514ec181b50628b8cc80e5527">colr_str_lstrip_chars()</a>.</p>

</div>
</div>
<a id="ab4fed7123927027262875834964b0a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4fed7123927027262875834964b0a94">&#9670;&nbsp;</a></span>colr_char_is_code_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_char_is_code_end </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a character is suitable for an escape code ending. </p>
<p><code>m</code> is used as the last character in color codes, but other characters can be used for escape sequences (such as "\x1b[2A", cursor up). Actual escape code endings can be in the range (<code>char</code>) 64-126 (inclusive).</p>
<p>Since ColrC only deals with color codes and maybe some cursor/erase codes, this function tests if the character is either <code>A-Z</code> or <code>a-z</code>.</p>
<p>For more information, see: <a href="https://en.wikipedia.org/wiki/ANSI_escape_code">https://en.wikipedia.org/wiki/ANSI_escape_code</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Character to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the character is a possible escape code ending, otherwise <code>false</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a85b2971301b5247769b08f5ed08564fb">colr_str_is_codes()</a>, <a class="el" href="colr_8h.html#a037a0245a39d7ff5cfba5f779d0eb251">colr_str_noncode_len()</a>, and <a class="el" href="colr_8h.html#ab0b13b04dc178d0990ab2ae403ee64e0">colr_str_strip_codes()</a>.</p>

</div>
</div>
<a id="aa4d7418d0f38aa5d42c9cc2f7a06cdd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d7418d0f38aa5d42c9cc2f7a06cdd5">&#9670;&nbsp;</a></span>colr_char_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_char_repr </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation for a char. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Value to create the representation for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a6c35f6b47cc737744487d14d20241656">ColorJustify_repr()</a>.</p>

</div>
</div>
<a id="a67ef4700a46e78c2bed1132428a610fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ef4700a46e78c2bed1132428a610fb">&#9670;&nbsp;</a></span>colr_char_should_escape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_char_should_escape </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if an ascii character has an escape sequence in C. </p>
<p>The following characters are supported: </p><table class="doxtable">
<tr>
<th align="right">Escape Sequence </th><th align="left">Description Representation  </th></tr>
<tr>
<td align="right">\ ' </td><td align="left">single quote </td></tr>
<tr>
<td align="right">\ " </td><td align="left">double quote </td></tr>
<tr>
<td align="right">\ ? </td><td align="left">question mark </td></tr>
<tr>
<td align="right">\ \ </td><td align="left">backslash </td></tr>
<tr>
<td align="right">\ a </td><td align="left">audible bell </td></tr>
<tr>
<td align="right">\ b </td><td align="left">backspace </td></tr>
<tr>
<td align="right">\ f </td><td align="left">form feed - new page </td></tr>
<tr>
<td align="right">\ n </td><td align="left">line feed - new line </td></tr>
<tr>
<td align="right">\ r </td><td align="left">carriage return </td></tr>
<tr>
<td align="right">\ t </td><td align="left">horizontal tab </td></tr>
<tr>
<td align="right">\ v </td><td align="left">vertical tab </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The character to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the character needs an escape sequence, otherwise <code>false</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a196ad91a69cfbeb27a5266ffc93ed353">colr_str_repr()</a>.</p>

</div>
</div>
<a id="a330b20c743df488e74e70e6b0daef62a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a330b20c743df488e74e70e6b0daef62a">&#9670;&nbsp;</a></span>colr_check_marker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_check_marker </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>marker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks an unsigned int against the individual bytes behind a pointer's value. </p>
<p>This helps to guard against overflows, because only a single byte is checked at a time. If any byte doesn't match the marker, <code>false</code> is immediately returned, instead of continuing past the pointer's bounds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">marker</td><td>A colr marker, like COLORARG_MARKER, COLORTEXT_MARKER, etc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A pointer to check, to see if it starts with the marker. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all bytes match the marker, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#ad15f3a714a6383123d3fb24ade173e29" title="Checks a void pointer to see if it contains a ColorArg struct. ">ColorArg_is_ptr</a> <a class="el" href="colr_8c.html#a1d6eb8832110b943c3a3a17627a50288" title="Checks a void pointer to see if it contains a ColorText struct. ">ColorText_is_ptr</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_check_marker-example" id="colr_check_marker-example" class="diamond-bullet">◆&#160;</a> colr_check_marker example: </div><div class="fragment"><div class="line"><span class="comment">// This is actually used with void pointer, where the type is not known.</span></div><div class="line"><span class="comment">// It&#39;s only known that the pointer will be 1 of 3 types.</span></div><div class="line"><a class="code" href="colr_8h.html#structColorArg">ColorArg</a>* cargp = <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(GREEN);</div><div class="line">assert(<a class="code" href="colr_8c.html#a330b20c743df488e74e70e6b0daef62a">colr_check_marker</a>(<a class="code" href="colr_8h.html#a22fa09afcaf087080075551d293a72fd">COLORARG_MARKER</a>, cargp));</div><div class="line"><a class="code" href="colr_8h.html#a76eae619668e01987653932a7492fd94">colr_free</a>(cargp);</div><div class="line"></div><div class="line"><span class="keywordtype">char</span>* s = <span class="stringliteral">&quot;Not a ColorText at all.&quot;</span>;</div><div class="line">assert(!<a class="code" href="colr_8c.html#a330b20c743df488e74e70e6b0daef62a">colr_check_marker</a>(<a class="code" href="colr_8h.html#afc3756a551f1f8e5dfb56f6ab41d9e07">COLORTEXT_MARKER</a>, s));</div><div class="line"></div><div class="line"><a class="code" href="colr_8h.html#structColorText">ColorText</a>* ctextp = <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;But this is a ColorText.&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(GREEN));</div><div class="line">assert(<a class="code" href="colr_8c.html#a330b20c743df488e74e70e6b0daef62a">colr_check_marker</a>(<a class="code" href="colr_8h.html#afc3756a551f1f8e5dfb56f6ab41d9e07">COLORTEXT_MARKER</a>, ctextp));</div><div class="line"><a class="code" href="colr_8h.html#a76eae619668e01987653932a7492fd94">colr_free</a>(ctextp);</div><div class="line"></div><div class="line">printf(<span class="stringliteral">&quot;colr_check_marker() assertions held up.\n&quot;</span>);</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#ad15f3a714a6383123d3fb24ade173e29">ColorArg_is_ptr()</a>, and <a class="el" href="colr_8h.html#a1d6eb8832110b943c3a3a17627a50288">ColorText_is_ptr()</a>.</p>

</div>
</div>
<a id="a8963c87ccb1c39bdd4481bb81810ba78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8963c87ccb1c39bdd4481bb81810ba78">&#9670;&nbsp;</a></span>colr_empty_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_empty_str </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates an empty string (<code>char*</code>). </p>
<p>This is for keeping the interface simple, so the return values from color functions with invalid values can be consistent.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to an allocated string consisting of '\0'. <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a25670add558019fdb66a60d51f0ffbda">_colr()</a>, <a class="el" href="colr_8h.html#a4227a65824fdd699a25d3200706c9e9e">_colr_join()</a>, <a class="el" href="colr_8h.html#a91fb398f6463553e576fc067f5a0a854">ColorArg_to_str()</a>, <a class="el" href="colr_8h.html#ae305b33e0a44b956ccf4123aa4f1a033">ColorText_to_str()</a>, <a class="el" href="colr_8h.html#a71fcf08ad36d4424790e275d973445fc">colr_join_arrayn()</a>, <a class="el" href="colr_8h.html#ad32382336586dbda9a7e205403de8a14">colr_str_center()</a>, <a class="el" href="colr_8h.html#ac8be0d81828f73816a447b7440987d91">colr_str_ljust()</a>, <a class="el" href="colr_8h.html#a8fbaa15923af761c5eb99224ef8089b4">colr_str_rjust()</a>, and <a class="el" href="colr_8h.html#ab0b13b04dc178d0990ab2ae403ee64e0">colr_str_strip_codes()</a>.</p>

</div>
</div>
<a id="a701126bd27c90fafa46152d9f9327b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a701126bd27c90fafa46152d9f9327b2f">&#9670;&nbsp;</a></span>colr_join_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_join_array </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>joinerp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join an array of strings (<code>char*</code>), ColorArgs, or ColorTexts by another string (<code>char*</code>), <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">joinerp</td><td>The joiner (any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, or string). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ps</td><td>An array of pointers to ColorArgs, ColorTexts, or strings. The array must have <code>NULL</code> as the last item. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string with the result.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_join_array-example" id="colr_join_array-example" class="diamond-bullet">◆&#160;</a> colr_join_array example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* joiner = <span class="stringliteral">&quot; [and] &quot;</span>;</div><div class="line"><a class="code" href="colr_8h.html#structColorText">ColorText</a>* words[] = {</div><div class="line">    <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;this&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED)),</div><div class="line">    <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;that&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(<a class="code" href="colr_8h.html#a8fe812f8e76e4baed394ee9adf46b3df">hex</a>(<span class="stringliteral">&quot;ff3599&quot;</span>))),</div><div class="line">    <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;the other&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(BLUE), <a class="code" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662">style</a>(UNDERLINE)),</div><div class="line">    NULL</div><div class="line">};</div><div class="line"><span class="keywordtype">char</span>* s = <a class="code" href="colr_8c.html#a701126bd27c90fafa46152d9f9327b2f">colr_join_array</a>(joiner, words);</div><div class="line">printf(<span class="stringliteral">&quot;%s\n&quot;</span>, s);</div><div class="line">free(s);</div><div class="line"></div><div class="line"><span class="comment">// Don&#39;t forget to free the ColorTexts/ColorArgs.</span></div><div class="line"><span class="keywordtype">size_t</span> i = 0;</div><div class="line"><span class="keywordflow">while</span> (words[i]) <a class="code" href="colr_8c.html#a901e5738358a739629cc3aaccab3e73f">ColorText_free</a>(words[i++]);</div></div><!-- fragment --> </div> <dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2" title="Join ColorArg pointers, ColorText pointers, and strings into one long string. ">colr</a> <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join</a> <a class="el" href="colr_8c.html#a71fcf08ad36d4424790e275d973445fc" title="Join an array of strings (char*), ColorArgs, or ColorTexts by another string (char*), ColorArg, or ColorText. ">colr_join_arrayn</a> </dd></dl>

</div>
</div>
<a id="a71fcf08ad36d4424790e275d973445fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71fcf08ad36d4424790e275d973445fc">&#9670;&nbsp;</a></span>colr_join_arrayn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_join_arrayn </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>joinerp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join an array of strings (<code>char*</code>), ColorArgs, or ColorTexts by another string (<code>char*</code>), <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, or <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">joinerp</td><td>The joiner (any <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>, <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>, or string). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ps</td><td>An array of pointers to ColorArgs, ColorTexts, or strings. The array must have at least a length of <code>count</code>, unless a <code>NULL</code> element is placed at the end. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The total number of items in the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string with the result.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_join_arrayn-example" id="colr_join_arrayn-example" class="diamond-bullet">◆&#160;</a> colr_join_arrayn example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* joiner = <span class="stringliteral">&quot; [and] &quot;</span>;</div><div class="line"><a class="code" href="colr_8h.html#structColorText">ColorText</a>* words[] = {</div><div class="line">    <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;this&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(RED)),</div><div class="line">    <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;that&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(<a class="code" href="colr_8h.html#a8fe812f8e76e4baed394ee9adf46b3df">hex</a>(<span class="stringliteral">&quot;ff3599&quot;</span>))),</div><div class="line">    <a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;the other&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(BLUE), <a class="code" href="colr_8h.html#a7592d374ee178fd8ac19d8dabbb83662">style</a>(UNDERLINE))</div><div class="line">};</div><div class="line"><span class="comment">// This only works for actual arrays, not malloc&#39;d stuff.</span></div><div class="line"><span class="keywordtype">size_t</span> arr_length = <span class="keyword">sizeof</span>(words) / <span class="keyword">sizeof</span>(words[0]);</div><div class="line"><span class="keywordtype">char</span>* s = <a class="code" href="colr_8c.html#a71fcf08ad36d4424790e275d973445fc">colr_join_arrayn</a>(joiner, words, arr_length);</div><div class="line">printf(<span class="stringliteral">&quot;%s\n&quot;</span>, s);</div><div class="line">free(s);</div><div class="line"></div><div class="line"><span class="comment">// Don&#39;t forget to free the ColorTexts/ColorArgs.</span></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; arr_length; i++) <a class="code" href="colr_8c.html#a901e5738358a739629cc3aaccab3e73f">ColorText_free</a>(words[i]);</div></div><!-- fragment --> </div> <dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2" title="Join ColorArg pointers, ColorText pointers, and strings into one long string. ">colr</a> <a class="el" href="colr_8h.html#ae8cc35d2d3a15c9c22ebb0a0835c92f0" title="Join ColorArg pointers, ColorText pointers, and strings by another ColorArg pointer, ColorText pointer, or string. ">colr_join</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a701126bd27c90fafa46152d9f9327b2f">colr_join_array()</a>.</p>

</div>
</div>
<a id="ad32382336586dbda9a7e205403de8a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad32382336586dbda9a7e205403de8a14">&#9670;&nbsp;</a></span>colr_str_center()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_center </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>padchar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Center-justifies a string (<code>char*</code>), ignoring escape codes when measuring the width. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to justify.<br />
 Input <em>must be <code>null</code>-terminated</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">padchar</td><td>The character to pad with. If '0', then `' '` is used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The overall width for the resulting string.<br />
 If set to '0', the terminal width will be used from <a class="el" href="colr_8c.html#ae4c11bb5b3b1bb2848bb16aee39763b2" title="Attempts to retrieve the row/column size of the terminal and returns a TermSize. ">colr_term_size()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string with the result.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#ac8be0d81828f73816a447b7440987d91" title="Left-justifies a string (char*), ignoring escape codes when measuring the width. ">colr_str_ljust</a> <a class="el" href="colr_8c.html#a8fbaa15923af761c5eb99224ef8089b4" title="Right-justifies a string (char*), ignoring escape codes when measuring the width. ...">colr_str_rjust</a> <a class="el" href="colr_8c.html#ae4c11bb5b3b1bb2848bb16aee39763b2" title="Attempts to retrieve the row/column size of the terminal and returns a TermSize. ">colr_term_size</a> </dd></dl>

</div>
</div>
<a id="ad5e3ecc4a6c4bcaad1217df9200d271e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e3ecc4a6c4bcaad1217df9200d271e">&#9670;&nbsp;</a></span>colr_str_char_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t colr_str_char_count </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of characters (<code>c</code>) that are found in a string (<code>char*</code>) (<code>s</code>). </p>
<p>Returns <code>0</code> if <code>s</code> is <code>NULL</code>, or <code>c</code> is `'\0'`.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to examine. Input <em>must be <code>null</code>-terminated</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The character to count. <em>must not be <code>0</code></em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of times <code>c</code> occurs in <code>s</code>. </dd></dl>

</div>
</div>
<a id="a578b0f213d7b24b3f3c00ff4d3f6e292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a578b0f213d7b24b3f3c00ff4d3f6e292">&#9670;&nbsp;</a></span>colr_str_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_copy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like strncopy, but ensures null-termination. </p>
<p>If src is NULL, or dest is NULL, NULL is returned.</p>
<p>If src does not contain a null-terminator, <em>this function will truncate at <code>length</code> characters</em>.</p>
<p>A null-terminator is always appended to dest.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>Memory allocated for new string. <em>Must have room for <code>strlen(src)</code>.</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source string to copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Maximum characters to copy. <em>This does not include the null-terminator</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a pointer to dest is returned.</dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_copy-example" id="colr_str_copy-example" class="diamond-bullet">◆&#160;</a> colr_str_copy example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* s = <span class="stringliteral">&quot;testing&quot;</span>;</div><div class="line"><span class="keywordtype">size_t</span> length = strlen(s);</div><div class="line"><span class="keywordtype">char</span>* dest = malloc(length + 1);</div><div class="line"></div><div class="line"><span class="comment">// Copy the entire string:</span></div><div class="line"><a class="code" href="colr_8c.html#a578b0f213d7b24b3f3c00ff4d3f6e292">colr_str_copy</a>(dest, s, length);</div><div class="line">assert(strcmp(dest, <span class="stringliteral">&quot;testing&quot;</span>) == 0);</div><div class="line">printf(<span class="stringliteral">&quot;Copied: %s\n&quot;</span>, dest);</div><div class="line"></div><div class="line"><span class="comment">// Copy only 4 bytes:</span></div><div class="line"><a class="code" href="colr_8c.html#a578b0f213d7b24b3f3c00ff4d3f6e292">colr_str_copy</a>(dest, s, 4);</div><div class="line">assert(strcmp(dest, <span class="stringliteral">&quot;test&quot;</span>) == 0);</div><div class="line">printf(<span class="stringliteral">&quot;Truncated: %s\n&quot;</span>, dest);</div><div class="line">free(dest);</div></div><!-- fragment --> </div> 
</div>
</div>
<a id="a1471df42416f87bb2d9c30655a19f3a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1471df42416f87bb2d9c30655a19f3a0">&#9670;&nbsp;</a></span>colr_str_ends_with()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_str_ends_with </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>suf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if one string (<code>char*</code>) ends with another. </p>
<p><code>str</code> and <code>suf</code> <em>must be <code>null</code>-terminated</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>String to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">suf</td><td>Suffix to check for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <code>str</code> ends with <code>suf</code>. </dd>
<dd>
False if either is NULL, or the string doesn't end with the suffix. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a10030070daafdee7124638adfc5469d8">colr_append_reset()</a>.</p>

</div>
</div>
<a id="a8b9f4cbe1e806316e063206dfb610476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b9f4cbe1e806316e063206dfb610476">&#9670;&nbsp;</a></span>colr_str_has_codes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_str_has_codes </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a string (<code>char*</code>) has ANSI escape codes in it. </p>
<p>This will detect any ansi escape code, not just colors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to check. Can be <code>NULL</code>. Input <em>must be <code>null</code>-terminated</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the string has at least one escape code, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#a85b2971301b5247769b08f5ed08564fb" title="Determines if a string (char*) is composed entirely of escape codes. ">colr_str_is_codes</a> </dd></dl>

</div>
</div>
<a id="a3dc3f370843b64e92fb7d79e7989b5c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc3f370843b64e92fb7d79e7989b5c3">&#9670;&nbsp;</a></span>colr_str_is_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_str_is_all </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a string (<code>char*</code>) consists of only one character, possibly repeated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>String to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Character to test for. Must not be <code>0</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>s</code> contains only the character <code>c</code>, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a85b2971301b5247769b08f5ed08564fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b2971301b5247769b08f5ed08564fb">&#9670;&nbsp;</a></span>colr_str_is_codes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_str_is_codes </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a string (<code>char*</code>) is composed entirely of escape codes. </p>
<p>Returns <code>false</code> if the string is <code>NULL</code>, or empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to check. Input <em>must be <code>null</code>-terminated</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the string is escape-codes only, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#a8b9f4cbe1e806316e063206dfb610476" title="Determines if a string (char*) has ANSI escape codes in it. ">colr_str_has_codes</a> </dd></dl>

</div>
</div>
<a id="af5492da225ade4fd8fe71989826348b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5492da225ade4fd8fe71989826348b4">&#9670;&nbsp;</a></span>colr_str_is_digits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_str_is_digits </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether all characters in a string (<code>char*</code>) are digits. </p>
<p>If <code>s</code> is NULL or an empty string (<code>""</code>), <code>false</code> is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>String to check. Input <em>must be <code>null</code>-terminated</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all characters are digits (0-9), otherwise <code>false</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a2e859d542a8aa0939e4f76b1f33cb5f8">ExtendedValue_from_str()</a>.</p>

</div>
</div>
<a id="ac8be0d81828f73816a447b7440987d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8be0d81828f73816a447b7440987d91">&#9670;&nbsp;</a></span>colr_str_ljust()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_ljust </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>padchar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left-justifies a string (<code>char*</code>), ignoring escape codes when measuring the width. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to justify.<br />
 Input <em>must be <code>null</code>-terminated</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">padchar</td><td>The character to pad with. If '0', then `' '` is used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The overall width for the resulting string.<br />
 If set to '0', the terminal width will be used from <a class="el" href="colr_8c.html#ae4c11bb5b3b1bb2848bb16aee39763b2" title="Attempts to retrieve the row/column size of the terminal and returns a TermSize. ">colr_term_size()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#ad32382336586dbda9a7e205403de8a14" title="Center-justifies a string (char*), ignoring escape codes when measuring the width. ">colr_str_center</a> <a class="el" href="colr_8c.html#a8fbaa15923af761c5eb99224ef8089b4" title="Right-justifies a string (char*), ignoring escape codes when measuring the width. ...">colr_str_rjust</a> <a class="el" href="colr_8c.html#ae4c11bb5b3b1bb2848bb16aee39763b2" title="Attempts to retrieve the row/column size of the terminal and returns a TermSize. ">colr_term_size</a> </dd></dl>

</div>
</div>
<a id="a116ec26960e79456dbf9cf7f40ffe0d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116ec26960e79456dbf9cf7f40ffe0d7">&#9670;&nbsp;</a></span>colr_str_lower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void colr_str_lower </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a string (<code>char*</code>) into lower case in place. </p>
<p>Input <em>must be <code>null</code>-terminated</em>.</p>
<p>If <code>s</code> is <code>NULL</code>, nothing is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The input string to convert to lower case. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab00c551514ec181b50628b8cc80e5527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab00c551514ec181b50628b8cc80e5527">&#9670;&nbsp;</a></span>colr_str_lstrip_chars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_lstrip_chars </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>chars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes certain characters from the start of a string (<code>char*</code>). </p>
<p>The order of the characters in <code>chars</code> does not matter. If any of them are found at the start of a string, they will be removed.</p>
<p><code>colr_str_lstrip_chars("aabbccTEST", "bca") == "TEST"</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to strip. <code>s</code> <em>must be <code>null</code>-terminated</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">chars</td><td>A string of characters to remove. Each will be removed from the start of the string. <code>chars</code> <em>must be <code>null</code>-terminated</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string with the result. May return NULL if <code>s</code> or <code>chars</code> is NULL. <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>. </dd></dl>

</div>
</div>
<a id="ab473f70278850994e1b7b9c8008353fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab473f70278850994e1b7b9c8008353fa">&#9670;&nbsp;</a></span>colr_str_mb_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t colr_str_mb_len </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of characters in a string (<code>char*</code>), taking into account possibly multi-byte characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to get the length of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters, single and multi-byte, or <code>0</code> if <code>s</code> is <code>NULL</code>, empty, or has invalid multibyte sequences. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a7d16a274fbb779576396457264453873">_rainbow()</a>.</p>

</div>
</div>
<a id="a037a0245a39d7ff5cfba5f779d0eb251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037a0245a39d7ff5cfba5f779d0eb251">&#9670;&nbsp;</a></span>colr_str_noncode_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t colr_str_noncode_len </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length of string (<code>char*</code>), ignoring escape codes and the the null-terminator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>String to get the length for. Input <em>must be <code>null</code>-terminated</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the string, as if it didn't contain escape codes.<br />
 For non-escape-code strings, this is like <code>strlen()</code>.<br />
 For <code>NULL</code> or "empty" strings, <code>0</code> is returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#ab0b13b04dc178d0990ab2ae403ee64e0" title="Strips escape codes from a string (char*), resulting in a new allocated string. ">colr_str_strip_codes</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a412833a097b050c8ee99874c733bd030">ColorText_length()</a>, <a class="el" href="colr_8h.html#ad32382336586dbda9a7e205403de8a14">colr_str_center()</a>, <a class="el" href="colr_8h.html#ac8be0d81828f73816a447b7440987d91">colr_str_ljust()</a>, and <a class="el" href="colr_8h.html#a8fbaa15923af761c5eb99224ef8089b4">colr_str_rjust()</a>.</p>

</div>
</div>
<a id="a29047496628c944048314c83f9415a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29047496628c944048314c83f9415a5b">&#9670;&nbsp;</a></span>colr_str_replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces substrings in a string (<code>char*</code>). </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>The string to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The string to replace with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>target</code> is <code>NULL</code>/empty.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a44d236bca80dbce495c0f282c3a7d192">colr_str_replace_ColorArg()</a>, and <a class="el" href="colr_8h.html#a7ec6d96305890148b019602f2301f989">colr_str_replace_ColorText()</a>.</p>

</div>
</div>
<a id="a44d236bca80dbce495c0f282c3a7d192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d236bca80dbce495c0f282c3a7d192">&#9670;&nbsp;</a></span>colr_str_replace_ColorArg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_ColorArg </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="colr_8h.html#structColorArg">ColorArg</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace substrings in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>The string to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorArg" title="Holds an ArgType, and a ColorValue. ">ColorArg</a> to produce escape-codes to replace with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>target</code> is <code>NULL</code>/empty.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>. </dd></dl>

</div>
</div>
<a id="a7ec6d96305890148b019602f2301f989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ec6d96305890148b019602f2301f989">&#9670;&nbsp;</a></span>colr_str_replace_ColorText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_replace_ColorText </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="colr_8h.html#structColorText">ColorText</a> *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace substrings in a string (<code>char*</code>) with a <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a>'s string result. </p>
<p>Using <code>NULL</code> as a replacement is like using an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>The string to replace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>The <a class="el" href="colr_8h.html#structColorText" title="Holds a string of text, and optional fore, back, and style ColorArgs. ">ColorText</a> to produce text/escape-codes to replace with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>/empty, <code>target</code> is <code>NULL</code>/empty.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>. </dd></dl>

</div>
</div>
<a id="a196ad91a69cfbeb27a5266ffc93ed353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a196ad91a69cfbeb27a5266ffc93ed353">&#9670;&nbsp;</a></span>colr_str_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_repr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string (<code>char*</code>) into a representation of a string, by wrapping it in quotes and escaping characters that need escaping. </p>
<p>If <code>s</code> is NULL, then an allocated string containing the string "NULL" is returned (without quotes).</p>
<p>Escape codes will be escaped, so the terminal will ignore them if the result is printed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to represent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string with the representation.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#a67ef4700a46e78c2bed1132428a610fb" title="Determines if an ascii character has an escape sequence in C. ">colr_char_should_escape</a> <a class="el" href="colr_8c.html#a7f1ea562310969b7efa8711a843f103c" title="Returns the char needed to represent an escape sequence in C. ">colr_char_escape_char</a></dd></dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#colr_str_repr-example" id="colr_str_repr-example" class="diamond-bullet">◆&#160;</a> colr_str_repr example: </div><div class="fragment"><div class="line"><span class="keywordtype">char</span>* s = <a class="code" href="colr_8c.html#a196ad91a69cfbeb27a5266ffc93ed353">colr_str_repr</a>(<span class="stringliteral">&quot;This\nhas \bspecial\tchars.&quot;</span>);</div><div class="line"><span class="comment">// The string `s` contains an escaped string, it *looks like* the definition,</span></div><div class="line"><span class="comment">// but no real newlines, backspaces, or tabs are in it.</span></div><div class="line">assert(strcmp(s, <span class="stringliteral">&quot;\&quot;This\\nhas \\bspecial\\tchars.\&quot;&quot;</span>) == 0);</div><div class="line">free(s);</div></div><!-- fragment --> </div> 
<p class="reference">Referenced by <a class="el" href="colr_8h.html#a575a6cdc2f65cf1cd25227f847ae8d76">ColorText_repr()</a>.</p>

</div>
</div>
<a id="a8fbaa15923af761c5eb99224ef8089b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fbaa15923af761c5eb99224ef8089b4">&#9670;&nbsp;</a></span>colr_str_rjust()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_rjust </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>padchar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Right-justifies a string (<code>char*</code>), ignoring escape codes when measuring the width. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to justify.<br />
 Input <em>must be <code>null</code>-terminated</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">padchar</td><td>The character to pad with. If '0', then `' '` is used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The overall width for the resulting string.<br />
 If set to '0', the terminal width will be used from <a class="el" href="colr_8c.html#ae4c11bb5b3b1bb2848bb16aee39763b2" title="Attempts to retrieve the row/column size of the terminal and returns a TermSize. ">colr_term_size()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string with the result, or <code>NULL</code> if <code>s</code> is <code>NULL</code>.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#ad32382336586dbda9a7e205403de8a14" title="Center-justifies a string (char*), ignoring escape codes when measuring the width. ">colr_str_center</a> <a class="el" href="colr_8c.html#ac8be0d81828f73816a447b7440987d91" title="Left-justifies a string (char*), ignoring escape codes when measuring the width. ">colr_str_ljust</a> <a class="el" href="colr_8c.html#ae4c11bb5b3b1bb2848bb16aee39763b2" title="Attempts to retrieve the row/column size of the terminal and returns a TermSize. ">colr_term_size</a> </dd></dl>

</div>
</div>
<a id="a7f001f49e15a8c38e0dc3c6c6c1bb06c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f001f49e15a8c38e0dc3c6c6c1bb06c">&#9670;&nbsp;</a></span>colr_str_starts_with()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_str_starts_with </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks a string (<code>char*</code>) for a certain prefix substring. </p>
<p><code>prefix</code> <em>must be <code>null</code>-terminated</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>The prefix string to look for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the string <code>s</code> starts with prefix. </dd>
<dd>
False if one of the strings is null, or the prefix isn't found. </dd></dl>

</div>
</div>
<a id="ab0b13b04dc178d0990ab2ae403ee64e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b13b04dc178d0990ab2ae403ee64e0">&#9670;&nbsp;</a></span>colr_str_strip_codes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_strip_codes </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Strips escape codes from a string (<code>char*</code>), resulting in a new allocated string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to strip escape codes from. Input <em>must be <code>null</code>-terminated</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string with the result.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8c.html#a037a0245a39d7ff5cfba5f779d0eb251" title="Returns the length of string (char*), ignoring escape codes and the the null-terminator. ">colr_str_noncode_len</a> </dd></dl>

</div>
</div>
<a id="ae9b847e10db135f7ebc89031b3a7ad56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b847e10db135f7ebc89031b3a7ad56">&#9670;&nbsp;</a></span>colr_str_to_lower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* colr_str_to_lower </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new lowercase version of a string (<code>char*</code>). </p>
<p><em>You must <code>free()</code> the memory allocated by this function.</em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The input string to convert to lower case.<br />
 <em>must be <code>null</code>-terminated</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The allocated string, or <code>NULL</code> if <code>s</code> is <code>NULL</code>.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a2e859d542a8aa0939e4f76b1f33cb5f8">ExtendedValue_from_str()</a>, and <a class="el" href="colr_8h.html#a98c9e50fe14ad0c82bcf1a62699c05de">RGB_from_str()</a>.</p>

</div>
</div>
<a id="ab2ebdcd3c6e598a244292c7605452e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ebdcd3c6e598a244292c7605452e9d">&#9670;&nbsp;</a></span>colr_supports_rgb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool colr_supports_rgb </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether the current environment support <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> (True Colors). </p>
<p>This checks <code>$COLORTERM</code> for the appropriate value (<code>'truecolor'</code> or <code>'24bit'</code>). On "dumber" terminals, <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> codes are probably ignored or mistaken for a 256-color or even 8-color value.</p>
<p>For instance, <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> is supported in <code>konsole</code>, but not in <code>xterm</code> or <code>linux</code> ttys. Using <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> codes in <code>xterm</code> makes the colors appear as though a 256-color value was used (closest matching value, like <a class="el" href="colr_8c.html#ab4576c531151e398b7ecede2e30df70d" title="Convert an RGB value into it&#39;s nearest terminal-friendly RGB value. ">RGB_to_term_RGB()</a>). Using <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> codes in a simpler <code>linux</code> tty makes them appear as though an 8-color value was used. Very ugly, but not a disaster.</p>
<p>I haven't seen a <em>modern</em> linux terminal spew garbage across the screen from using <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> codes when they are not supported, but I could be wrong. I would like to see that terminal if you know of one.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if 24-bit (true color, or "rgb") support is detected, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="ae4c11bb5b3b1bb2848bb16aee39763b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c11bb5b3b1bb2848bb16aee39763b2">&#9670;&nbsp;</a></span>colr_term_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structTermSize">TermSize</a> colr_term_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to retrieve the row/column size of the terminal and returns a <a class="el" href="colr_8h.html#structTermSize" title="Holds a terminal size, usually retrieved with colr_term_size(). ">TermSize</a>. </p>
<p>If the call to <code>ioctl()</code> fails, a default <a class="el" href="colr_8h.html#structTermSize" title="Holds a terminal size, usually retrieved with colr_term_size(). ">TermSize</a> struct is returned: </p><div class="fragment"><div class="line">(<a class="code" href="colr_8h.html#structTermSize">TermSize</a>){.rows=35, .columns=80}</div></div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="colr_8h.html#structTermSize" title="Holds a terminal size, usually retrieved with colr_term_size(). ">TermSize</a> struct with terminal size information. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a412833a097b050c8ee99874c733bd030">ColorText_length()</a>, <a class="el" href="colr_8h.html#ad32382336586dbda9a7e205403de8a14">colr_str_center()</a>, <a class="el" href="colr_8h.html#ac8be0d81828f73816a447b7440987d91">colr_str_ljust()</a>, and <a class="el" href="colr_8h.html#a8fbaa15923af761c5eb99224ef8089b4">colr_str_rjust()</a>.</p>

</div>
</div>
<a id="ae7d7b7bf1080742eeb588ba70ce9ea77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d7b7bf1080742eeb588ba70ce9ea77">&#9670;&nbsp;</a></span>colr_win_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct winsize colr_win_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to retrieve a <code>winsize</code> struct from an <code>ioctl</code> call. </p>
<p>If the call fails, the environment variables <code>LINES</code> and <code>COLUMNS</code> are checked. If that fails, a default <code>winsize</code> struct is returned: </p><div class="fragment"><div class="line">(<span class="keyword">struct </span>winsize){.ws_row=35, .ws_col=80, .ws_xpixel=0, .ws_ypixel=0}</div></div><!-- fragment --><p><code>man ioctl_tty</code> says that <code>.ws_xpixel</code> and <code>.ws_ypixel</code> are unused.</p>
<dl class="section return"><dt>Returns</dt><dd>A <code>winsize</code> struct (<code>sys/ioctl.h</code>) with window size information. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ae4c11bb5b3b1bb2848bb16aee39763b2">colr_term_size()</a>.</p>

</div>
</div>
<a id="afc2c53ebede7f97645f671401bfe356d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc2c53ebede7f97645f671401bfe356d">&#9670;&nbsp;</a></span>colr_win_size_env()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct winsize colr_win_size_env </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get window/terminal size using the environment variables <code>LINES</code>, <code>COLUMNS</code>, or <code>COLS</code>. </p>
<p>This is used as a fallback if the <code>ioctl()</code> call fails in <a class="el" href="colr_8c.html#ae7d7b7bf1080742eeb588ba70ce9ea77" title="Attempts to retrieve a winsize struct from an ioctl call. ">colr_win_size()</a>. If environment variables are not available, a default <code>winsize</code> struct is returned: </p><div class="fragment"><div class="line">(<span class="keyword">struct </span>winsize){.ws_row=35, .ws_col=80, .ws_xpixel=0, .ws_ypixel=0}</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>A <code>winsize</code> struct (<code>sys/ioctl.h</code>) with window size information. </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ae7d7b7bf1080742eeb588ba70ce9ea77">colr_win_size()</a>.</p>

</div>
</div>
<a id="ac847d91a396ae6babc0bd46e6386a701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac847d91a396ae6babc0bd46e6386a701">&#9670;&nbsp;</a></span>ExtendedValue_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ExtendedValue_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two ExtendedValues. </p>
<p>This is used to implement <a class="el" href="colr_8h.html#a36af8aa0f01eaa780da182e856923faa" title="Calls the &lt;type&gt;_eq functions for the supported types. ">colr_eq()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first ExtendedValue to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second ExtendedValue to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if they are equal, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a0632d78965000b1e50068a64e335133b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0632d78965000b1e50068a64e335133b">&#9670;&nbsp;</a></span>ExtendedValue_from_hex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ExtendedValue_from_hex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hexstr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an ExtendedValue from a hex string (<code>char*</code>). </p>
<p>This is not a 1:1 translation of hex to rgb. Use <a class="el" href="colr_8c.html#a5e0c7cd639abdb4aafd4c592a3d79263" title="Convert a hex color into an RGB value. ">RGB_from_hex()</a> for that. This will convert the hex string to the closest matching ExtendedValue value.</p>
<p>The format for hex strings can be one of:</p><ul>
<li>"[#]ffffff" (Leading hash symbol is optional)</li>
<li>"[#]fff" (short-form)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hexstr</td><td>Hex string to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value between 0 and 255 on success. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">COLOR_INVALID</td><td>on error or bad values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94" title="Convenience typedef for clarity when dealing with extended (256) colors. ">ExtendedValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a757be189530b4925c84df25742374485">ExtendedValue_from_hex_default()</a>, and <a class="el" href="colr_8h.html#a2e859d542a8aa0939e4f76b1f33cb5f8">ExtendedValue_from_str()</a>.</p>

</div>
</div>
<a id="a757be189530b4925c84df25742374485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a757be189530b4925c84df25742374485">&#9670;&nbsp;</a></span>ExtendedValue_from_hex_default()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a> ExtendedValue_from_hex_default </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hexstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an ExtendedValue from a hex string (<code>char*</code>), but return a default value if the hex string is invalid. </p>
<p>This is not a 1:1 translation of hex to rgb. Use <a class="el" href="colr_8c.html#a6133112d9c73a8b56995e16e1af62d3b" title="Convert a hex color into an RGB value, but use a default value when errors occur. ...">RGB_from_hex_default()</a> for that. This will convert the hex string to the closest matching ExtendedValue value.</p>
<p>The format for hex strings can be one of:</p><ul>
<li>"[#]ffffff" (Leading hash symbol is optional)</li>
<li>"[#]fff" (short-form)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hexstr</td><td>Hex string to convert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_value</td><td>ExtendedValue to use for bad hex strings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ExtendedValue on success, or <code>default_value</code> on error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94" title="Convenience typedef for clarity when dealing with extended (256) colors. ">ExtendedValue</a> </dd>
<dd>
<a class="el" href="colr_8c.html#a0632d78965000b1e50068a64e335133b" title="Create an ExtendedValue from a hex string (char*). ">ExtendedValue_from_hex</a> </dd></dl>

</div>
</div>
<a id="a1548d9fc5f3e00a7b5d834eb1e12ff93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1548d9fc5f3e00a7b5d834eb1e12ff93">&#9670;&nbsp;</a></span>ExtendedValue_from_RGB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a> ExtendedValue_from_RGB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value into the closest matching ExtendedValue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ExtendedValue that closely matches the original <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94" title="Convenience typedef for clarity when dealing with extended (256) colors. ">ExtendedValue</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a0632d78965000b1e50068a64e335133b">ExtendedValue_from_hex()</a>, <a class="el" href="colr_8h.html#a185cec167afe41b6401206659d2d406c">format_bg_RGB_term()</a>, and <a class="el" href="colr_8h.html#a4661c576a4da879b8d4a2c525a42ad78">format_fg_RGB_term()</a>.</p>

</div>
</div>
<a id="a2e859d542a8aa0939e4f76b1f33cb5f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e859d542a8aa0939e4f76b1f33cb5f8">&#9670;&nbsp;</a></span>ExtendedValue_from_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ExtendedValue_from_str </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a known name, integer string (0-255), or a hex string (<code>char*</code>), into an ExtendedValue suitable for the extended-value-based functions. </p>
<p>Hex strings can be used:</p><ul>
<li>"#ffffff" (Leading hash symbol is <b>NOT</b> optional)</li>
<li>"#fff" (short-form)</li>
</ul>
<p>The `'#'` is not optional for hex strings because it is impossible to tell the difference between the hex value '111' and the extended value '111' without it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Color name to find the ExtendedValue for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value between 0 and 255 on success. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">COLOR_INVALID</td><td>on error or bad values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94" title="Convenience typedef for clarity when dealing with extended (256) colors. ">ExtendedValue</a> </dd></dl>

</div>
</div>
<a id="aa45baebc38756a40e7084f8198999902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa45baebc38756a40e7084f8198999902">&#9670;&nbsp;</a></span>ExtendedValue_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ExtendedValue_repr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation of a ExtendedValue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eval</td><td>A ExtendedValue to get the value from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an allocated string.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94" title="Convenience typedef for clarity when dealing with extended (256) colors. ">ExtendedValue</a> </dd></dl>

</div>
</div>
<a id="a4e334d6b9145fca9717fe5a2aeb542fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e334d6b9145fca9717fe5a2aeb542fe">&#9670;&nbsp;</a></span>ExtendedValue_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ExtendedValue_to_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94">ExtendedValue</a>&#160;</td>
          <td class="paramname"><em>eval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) from an ExtendedValue's actual value, suitable for use with <a class="el" href="colr_8c.html#a2e859d542a8aa0939e4f76b1f33cb5f8" title="Converts a known name, integer string (0-255), or a hex string (char*), into an ExtendedValue suitabl...">ExtendedValue_from_str()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eval</td><td>A ExtendedValue to get the value from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an allocated string<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a6dda29f582a062546ef8733d8b7d8a94" title="Convenience typedef for clarity when dealing with extended (256) colors. ">ExtendedValue</a> </dd></dl>

</div>
</div>
<a id="ae29032483aea8cb25d6b90750767ffc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae29032483aea8cb25d6b90750767ffc1">&#9670;&nbsp;</a></span>format_bg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_bg </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for a background color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. <em>Must have enough room for <code>CODEX_LEN</code>.</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>BasicValue value to use for background. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15a88e36717ca1e6a4892d2ffda1f4f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15a88e36717ca1e6a4892d2ffda1f4f3">&#9670;&nbsp;</a></span>format_bg_rgb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_bg_rgb </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>redval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>greenval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>blueval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for a true color (rgb) background color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. <em>Must have enough room for <code>CODE_RGB_LEN</code>.</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">redval</td><td>Value for red. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">greenval</td><td>Value for green. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blueval</td><td>Value for blue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97257ad40619df6a6c190890ff2873c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97257ad40619df6a6c190890ff2873c4">&#9670;&nbsp;</a></span>format_bg_RGB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_bg_RGB </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for a true color (rgb) background color using values from an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. <em>Must have enough room for <code>CODE_RGB_LEN</code>.</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct to get red, blue, and green values from. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a15a88e36717ca1e6a4892d2ffda1f4f3">format_bg_rgb()</a>, and <a class="el" href="colr_8h.html#a69dd994da51a57fc3cedb5ade591d5c1">rainbow_bg()</a>.</p>

</div>
</div>
<a id="a185cec167afe41b6401206659d2d406c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a185cec167afe41b6401206659d2d406c">&#9670;&nbsp;</a></span>format_bg_RGB_term()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_bg_RGB_term </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for a true color (rgb) fore color using an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct's values, approximating 256-color values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td>Pointer to an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#ab261b60d6d790f5a3c91883a1b6646a7">rainbow_bg_term()</a>.</p>

</div>
</div>
<a id="aa4853b53fa18d26741ab7178606e5724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4853b53fa18d26741ab7178606e5724">&#9670;&nbsp;</a></span>format_bgx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_bgx </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for an extended background color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. <em>Must have enough room for <code>CODEX_LEN</code>.</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>Value to use for background. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a185cec167afe41b6401206659d2d406c">format_bg_RGB_term()</a>.</p>

</div>
</div>
<a id="a6027d93e8768f3c152edafd92e757801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6027d93e8768f3c152edafd92e757801">&#9670;&nbsp;</a></span>format_fg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_fg </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a0c061fbfddd43dfe324486dc86cb92ee">BasicValue</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for a fore color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. <em>Must have enough room for <code>CODEX_LEN</code>.</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>BasicValue value to use for fore. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca1991134c0d649bdc57b86140b6c2b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca1991134c0d649bdc57b86140b6c2b0">&#9670;&nbsp;</a></span>format_fg_rgb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_fg_rgb </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>redval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>greenval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>blueval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for a true color (rgb) fore color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. <em>Must have enough room for <code>CODE_RGB_LEN</code>.</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">redval</td><td>Value for red. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">greenval</td><td>Value for green. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blueval</td><td>Value for blue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3391a0cd6b6f73d9d39f8179fc0eb0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3391a0cd6b6f73d9d39f8179fc0eb0b">&#9670;&nbsp;</a></span>format_fg_RGB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_fg_RGB </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for a true color (rgb) fore color using an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct's values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td>Pointer to an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#aca1991134c0d649bdc57b86140b6c2b0">format_fg_rgb()</a>, and <a class="el" href="colr_8h.html#a7aed06cce3570d914738ce3f517e7ee9">rainbow_fg()</a>.</p>

</div>
</div>
<a id="a4661c576a4da879b8d4a2c525a42ad78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4661c576a4da879b8d4a2c525a42ad78">&#9670;&nbsp;</a></span>format_fg_RGB_term()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_fg_RGB_term </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for a true color (rgb) fore color using an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct's values, approximating 256-color values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td>Pointer to an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#aa740f000c6d3ebe24734411e83125e37">rainbow_fg_term()</a>.</p>

</div>
</div>
<a id="acfd2cf68768c59fc3ed5c31b93590c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfd2cf68768c59fc3ed5c31b93590c53">&#9670;&nbsp;</a></span>format_fgx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_fgx </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for an extended fore color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. <em>Must have enough room for <code>CODEX_LEN</code>.</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>Value to use for fore. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a4661c576a4da879b8d4a2c525a42ad78">format_fg_RGB_term()</a>.</p>

</div>
</div>
<a id="a6aec8e6a80b4ca158df2ad20e3e6a59e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aec8e6a80b4ca158df2ad20e3e6a59e">&#9670;&nbsp;</a></span>format_style()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void format_style </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>&#160;</td>
          <td class="paramname"><em>style</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an escape code for a style. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Memory allocated for the escape code string. <em>Must have enough room for <code>STYLE_LEN</code>.</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">style</td><td>StyleValue value to use for style. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69dd994da51a57fc3cedb5ade591d5c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69dd994da51a57fc3cedb5ade591d5c1">&#9670;&nbsp;</a></span>rainbow_bg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* rainbow_bg </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rainbow-ize some text using rgb back colors, lolcat style. </p>
<p>This prepends a color code to every character in the string. Multi-byte characters are handled properly by checking <code>mblen()</code>, and copying the bytes to the resulting string without codes between the multi-byte characters.</p>
<p>The <code>CODE_RESET_ALL</code> code is appended to the result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to colorize. Input <em>must be <code>null</code>-terminated</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freq</td><td>Frequency ("tightness") for the colors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Starting offset in the rainbow. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The allocated/formatted string on success.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>. </dd></dl>

</div>
</div>
<a id="ab261b60d6d790f5a3c91883a1b6646a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab261b60d6d790f5a3c91883a1b6646a7">&#9670;&nbsp;</a></span>rainbow_bg_term()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* rainbow_bg_term </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is exactly like <a class="el" href="colr_8c.html#a69dd994da51a57fc3cedb5ade591d5c1" title="Rainbow-ize some text using rgb back colors, lolcat style. ">rainbow_bg()</a>, except it uses colors that are closer to the standard 256-color values. </p>
<p>This prepends a color code to every character in the string. Multi-byte characters are handled properly by checking <code>mblen()</code>, and copying the bytes to the resulting string without codes between the multi-byte characters.</p>
<p>The <code>CODE_RESET_ALL</code> code is appended to the result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to colorize. Input <em>must be <code>null</code>-terminated</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freq</td><td>Frequency ("tightness") for the colors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Starting offset in the rainbow. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The allocated/formatted string on success.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>. </dd></dl>

</div>
</div>
<a id="a7aed06cce3570d914738ce3f517e7ee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aed06cce3570d914738ce3f517e7ee9">&#9670;&nbsp;</a></span>rainbow_fg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* rainbow_fg </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rainbow-ize some text using rgb fore colors, lolcat style. </p>
<p>This prepends a color code to every character in the string. Multi-byte characters are handled properly by checking <code>mblen()</code>, and copying the bytes to the resulting string without codes between the multi-byte characters.</p>
<p>The <code>CODE_RESET_ALL</code> code is appended to the result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to colorize. Input <em>must be <code>null</code>-terminated</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freq</td><td>Frequency ("tightness") for the colors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Starting offset in the rainbow. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The allocated/formatted string on success.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>. </dd></dl>

</div>
</div>
<a id="aa740f000c6d3ebe24734411e83125e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa740f000c6d3ebe24734411e83125e37">&#9670;&nbsp;</a></span>rainbow_fg_term()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* rainbow_fg_term </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is exactly like <a class="el" href="colr_8c.html#a7aed06cce3570d914738ce3f517e7ee9" title="Rainbow-ize some text using rgb fore colors, lolcat style. ">rainbow_fg()</a>, except it uses colors that are closer to the standard 256-color values. </p>
<p>This prepends a color code to every character in the string. Multi-byte characters are handled properly by checking <code>mblen()</code>, and copying the bytes to the resulting string without codes between the multi-byte characters.</p>
<p>The <code>CODE_RESET_ALL</code> code is appended to the result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to colorize. Input <em>must be <code>null</code>-terminated</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freq</td><td>Frequency ("tightness") for the colors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Starting offset in the rainbow. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The allocated/formatted string on success.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>. </dd></dl>

</div>
</div>
<a id="a3580f33d058571dffd8e5ff789c49296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3580f33d058571dffd8e5ff789c49296">&#9670;&nbsp;</a></span>rainbow_step()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structRGB">RGB</a> rainbow_step </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A single step in rainbow-izing produces the next color in the "rainbow" as an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">freq</td><td>Frequency ("tightness") of the colors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Starting offset in the rainbow.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value with the next "step" in the "rainbow". </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a7d16a274fbb779576396457264453873">_rainbow()</a>.</p>

</div>
</div>
<a id="ad4b5f73b8aa9d72216d7386221418ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b5f73b8aa9d72216d7386221418ae1">&#9670;&nbsp;</a></span>RGB_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RGB_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> structs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>a</code> and <code>b</code> have the same <code>r</code>, <code>g</code>, and <code>b</code> values, otherwise <code>false</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#adf57e195301864cec80739e7e0f3000c">ColorValue_eq()</a>, and <a class="el" href="colr_8h.html#a1548d9fc5f3e00a7b5d834eb1e12ff93">ExtendedValue_from_RGB()</a>.</p>

</div>
</div>
<a id="ad33884dcde034819c5e6749667247194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad33884dcde034819c5e6749667247194">&#9670;&nbsp;</a></span>RGB_from_hex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RGB_from_hex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hexstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a> *&#160;</td>
          <td class="paramname"><em>rgbval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a hex color into an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value. </p>
<p>The format for hex strings can be one of:</p><ul>
<li>"[#]ffffff" (Leading hash symbol is optional)</li>
<li>"[#]fff" (short-form)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hexstr</td><td>String to check for hex values. Input <em>must be <code>null</code>-terminated</em>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rgbval</td><td>Pointer to an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct to fill in the values for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success, with <code>rgbval</code> filled with the values. </td></tr>
    <tr><td class="paramname">COLOR_INVALID</td><td>for non-hex strings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a0632d78965000b1e50068a64e335133b">ExtendedValue_from_hex()</a>, <a class="el" href="colr_8h.html#a6133112d9c73a8b56995e16e1af62d3b">RGB_from_hex_default()</a>, and <a class="el" href="colr_8h.html#a98c9e50fe14ad0c82bcf1a62699c05de">RGB_from_str()</a>.</p>

</div>
</div>
<a id="a6133112d9c73a8b56995e16e1af62d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6133112d9c73a8b56995e16e1af62d3b">&#9670;&nbsp;</a></span>RGB_from_hex_default()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structRGB">RGB</a> RGB_from_hex_default </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hexstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a hex color into an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value, but use a default value when errors occur. </p>
<p>The format for hex strings can be one of:</p><ul>
<li>"[#]ffffff" (Leading hash symbol is optional)</li>
<li>"[#]fff" (short-form)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hexstr</td><td>String to check for <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> values. Input <em>must be <code>null</code>-terminated</em>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">default_value</td><td>An <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value to use when errors occur.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A valid <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value on success, or <code>default_value</code> on error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd>
<dd>
<a class="el" href="colr_8h.html#a8fe812f8e76e4baed394ee9adf46b3df" title="Use RGB_from_hex_default() to create an RGB value. ">hex</a> </dd></dl>

</div>
</div>
<a id="a98c9e50fe14ad0c82bcf1a62699c05de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c9e50fe14ad0c82bcf1a62699c05de">&#9670;&nbsp;</a></span>RGB_from_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RGB_from_str </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a> *&#160;</td>
          <td class="paramname"><em>rgbval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> string (<code>char*</code>) into an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value. </p>
<p>The format for <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> strings can be one of:</p><ul>
<li>"RED,GREEN,BLUE"</li>
<li>"RED GREEN BLUE"</li>
<li>"RED:GREEN:BLUE"</li>
<li>"RED;GREEN;BLUE" Or hex strings can be used:</li>
<li>"#ffffff" (Leading hash symbol is <b>NOT</b> optional)</li>
<li>"#fff" (short-form)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>String to check for <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> values. Input <em>must be <code>null</code>-terminated</em>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rgbval</td><td>Pointer to an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct to fill in the values for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success, with <code>rgbval</code> filled with the values. </td></tr>
    <tr><td class="paramname">COLOR_INVALID</td><td>for non-rgb strings. </td></tr>
    <tr><td class="paramname">COLOR_INVALID_RANGE</td><td>for rgb values outside of 0-255.</td></tr>
  </table>
  </dd>
</dl>
<div class="examplecode"> <div class="examplecode-header"> <a href="#RGB_from_str-example" id="RGB_from_str-example" class="diamond-bullet">◆&#160;</a> RGB_from_str example: </div><div class="fragment"><div class="line"><a class="code" href="colr_8h.html#structRGB">RGB</a> rgbval;</div><div class="line"><span class="keywordtype">int</span> ret = <a class="code" href="colr_8c.html#a0943a956bc1491d6a6996ddc99a4d2dd">RGB_from_str</a>(<span class="stringliteral">&quot;123,0,234&quot;</span>, &amp;rgbval);</div><div class="line"><span class="keywordflow">if</span> (ret != <a class="code" href="colr_8h.html#aaaddb0f34c1374c29a8b7629ac40ca8b">COLOR_INVALID</a>) {</div><div class="line">    <span class="keywordtype">char</span>* s = <a class="code" href="colr_8h.html#a429998ab7c120490f34921c35e1d76d2">colr</a>(<a class="code" href="colr_8h.html#ade1c77f81a0fd49f7895598cbd9ac76c">Colr</a>(<span class="stringliteral">&quot;Test&quot;</span>, <a class="code" href="colr_8h.html#a19d8b61303404007a3224be0f8296c3f">fore</a>(rgbval)));</div><div class="line">    printf(<span class="stringliteral">&quot;%s\n&quot;</span>, s);</div><div class="line">    free(s);</div><div class="line">}</div></div><!-- fragment --> </div> <dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

</div>
</div>
<a id="afd28864afbcfa4a344e4596130645177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd28864afbcfa4a344e4596130645177">&#9670;&nbsp;</a></span>RGB_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* RGB_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation for an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value. </p>
<p>Allocates memory for the string representation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> struct to get the representation for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Allocated string for the representation.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

</div>
</div>
<a id="a95e4feb89e009f00cfe7e74a55fab56f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e4feb89e009f00cfe7e74a55fab56f">&#9670;&nbsp;</a></span>RGB_to_hex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* RGB_to_hex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value into a hex string (<code>char*</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

</div>
</div>
<a id="a16d2f9a1133c8a955f0a551870d7ebe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16d2f9a1133c8a955f0a551870d7ebe8">&#9670;&nbsp;</a></span>RGB_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* RGB_to_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value into an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> string (<code>char*</code>) suitable for input to <a class="el" href="colr_8c.html#a0943a956bc1491d6a6996ddc99a4d2dd" title="Convert an RGB string (char*) into an RGB value. ">RGB_from_str()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string in the form <code>"red;green;blue"</code>.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>. </dd></dl>

</div>
</div>
<a id="ab4576c531151e398b7ecede2e30df70d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4576c531151e398b7ecede2e30df70d">&#9670;&nbsp;</a></span>RGB_to_term_RGB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#structRGB">RGB</a> RGB_to_term_RGB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structRGB">RGB</a>&#160;</td>
          <td class="paramname"><em>rgb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value into it's nearest terminal-friendly <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> value. </p>
<p>This is a helper for the 'to_term' functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> with values close to a terminal code color.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#structRGB" title="Container for RGB values. ">RGB</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="colr_8h.html#a1548d9fc5f3e00a7b5d834eb1e12ff93">ExtendedValue_from_RGB()</a>.</p>

</div>
</div>
<a id="a32bf31475b0f6264b45438bd5c09ee7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32bf31475b0f6264b45438bd5c09ee7d">&#9670;&nbsp;</a></span>StyleValue_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool StyleValue_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two StyleValues. </p>
<p>This is used to implement <a class="el" href="colr_8h.html#a36af8aa0f01eaa780da182e856923faa" title="Calls the &lt;type&gt;_eq functions for the supported types. ">colr_eq()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first StyleValue to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second StyleValue to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if they are equal, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a4ca63735ad2cbc6475d4af83dc7c1a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ca63735ad2cbc6475d4af83dc7c1a9b">&#9670;&nbsp;</a></span>StyleValue_from_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a> StyleValue_from_str </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a named argument to actual StyleValue enum value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Style name to convert into a StyleValue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A usable StyleValue value on success, or STYLE_INVALID on error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6" title="Style values. ">StyleValue</a> </dd></dl>

</div>
</div>
<a id="a24b74664587dd3c0e981603ee75c331b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b74664587dd3c0e981603ee75c331b">&#9670;&nbsp;</a></span>StyleValue_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* StyleValue_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6">StyleValue</a>&#160;</td>
          <td class="paramname"><em>sval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string (<code>char*</code>) representation of a StyleValue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sval</td><td>A StyleValue to get the value from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an allocated string.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="colr_8h.html#a85224ec2507f33b1985f4cdd0adfe0e6" title="Style values. ">StyleValue</a> </dd></dl>

</div>
</div>
<a id="a41b4ed49acc5d806f161a3b31f5bf023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b4ed49acc5d806f161a3b31f5bf023">&#9670;&nbsp;</a></span>TermSize_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* TermSize_repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="colr_8h.html#structTermSize">TermSize</a>&#160;</td>
          <td class="paramname"><em>ts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a string (<code>char*</code>) representation for a <a class="el" href="colr_8h.html#structTermSize" title="Holds a terminal size, usually retrieved with colr_term_size(). ">TermSize</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td><a class="el" href="colr_8h.html#structTermSize" title="Holds a terminal size, usually retrieved with colr_term_size(). ">TermSize</a> to get the representation for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string with the result.<br />
 <em>You must <code>free()</code> the memory allocated by this function.</em> <em>If allocation fails, <code>NULL</code> is returned</em>. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="colr_8h.html">colr.h</a></li>
    <li class="footer">Generated by
        <a href="http://www.doxygen.org/index.html">
        Doxygen <!-- <img class="footer" src="doxygen.png" alt="doxygen"/> -->
        </a>
        1.8.13
    </li>
  </ul>
</div>
</body>
</html>
